require = function a(s, o, l) {
    function h(e, t) {
        if (!o[e]) {
            if (!s[e]) {
                var i = "function" == typeof require && require;
                if (!t && i) return i(e, !0);
                if (u) return u(e, !0);
                var n = new Error("Cannot find module '" + e + "'");
                throw n.code = "MODULE_NOT_FOUND", n
            }
            var r = o[e] = {
                exports: {}
            };
            s[e][0].call(r.exports, function(t) {
                return h(s[e][1][t] || t)
            }, r, r.exports, a, s, o, l)
        }
        return o[e].exports
    }
    for (var u = "function" == typeof require && require, t = 0; t < l.length; t++) h(l[t]);
    return h
}({
    "@bornfight/b-accordion": [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = void 0;
        var n, u = (n = t("gsap")) && n.__esModule ? n : {
            default: n
        };

        function r(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }
        var a = function() {
            function n() {
                var i = this,
                    t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : ".js-accordion",
                    e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, n);
                this.defaults = Object.assign({}, {
                    openingEase: "power4.out",
                    closingEase: "power4.in",
                    openDuration: .5,
                    closeDuration: .3,
                    openDelay: 0,
                    closeDelay: 0
                }, e), this.openingEase = this.defaults.openingEase, this.closingEase = this.defaults.closingEase, this.openDuration = this.defaults.openDuration, this.closeDuration = this.defaults.closeDuration, this.openDelay = this.defaults.openDelay, this.closeDelay = this.defaults.closeDelay, this.accordion = document.querySelectorAll(t), 0 < this.accordion.length && this.accordion.forEach(function(t) {
                    var e = !1;
                    t.classList.contains("is-mono") && (e = !0), i.initAccordion(t, e)
                })
            }
            var t, e, i;
            return t = n, (e = [{
                key: "initAccordion",
                value: function(e, i) {
                    var n = this;
                    e.querySelectorAll(".js-accordion-single").forEach(function(t) {
                        n.accordionController(t, e, i)
                    })
                }
            }, {
                key: "accordionController",
                value: function(t, e, i) {
                    var n = this,
                        r = t.querySelector(".js-accordion-header");
                    if (null == r && (r = t), null == r) throw new Error("'js-accordion-header' missing!");
                    var a = t.querySelector(".js-accordion-panel");
                    if (null == a) throw new Error("'js-accordion-panel' missing!");
                    u.default.set(a, {
                        height: 0
                    }), r.addEventListener("click", function(t) {
                        t.preventDefault(), t.currentTarget.classList.contains("is-opened") ? n.closeAccordion(t.currentTarget, a) : n.openAccordion(t.currentTarget, a, e, i)
                    })
                }
            }, {
                key: "closeAccordion",
                value: function(t, e) {
                    t.classList.remove("is-opened"), t.parentNode.classList.contains("js-accordion-single") && t.parentNode.classList.remove("is-opened"), u.default.to(e, {
                        duration: this.closeDuration,
                        height: 0,
                        delay: this.closeDelay,
                        ease: this.closingEase
                    })
                }
            }, {
                key: "openAccordion",
                value: function(t, e, i, n) {
                    var r = this;
                    if (n)
                        for (var a = i.querySelectorAll(".js-accordion-single"), s = 0; s < a.length; s++) {
                            var o = a[s].querySelector(".js-accordion-header"),
                                l = a[s].querySelector(".js-accordion-panel");
                            t !== o && (o.classList.remove("is-opened"), t.parentNode.classList.contains("js-accordion-single") && o.parentNode.classList.remove("is-opened"), u.default.to(l, {
                                duration: this.closeDuration,
                                height: 0,
                                delay: this.closeDelay,
                                ease: this.closingEase
                            }))
                        }
                    t.classList.add("is-opened"), t.parentNode.classList.contains("js-accordion-single") && t.parentNode.classList.add("is-opened");
                    var h = 0;
                    u.default.set(e, {
                        height: "auto",
                        onComplete: function() {
                            h = e.clientHeight, u.default.set(e, {
                                height: 0,
                                onComplete: function() {
                                    u.default.to(e, {
                                        duration: r.openDuration,
                                        height: h,
                                        ease: r.openingEase,
                                        delay: r.openDelay,
                                        onComplete: function() {
                                            e.style.height = "auto"
                                        }
                                    })
                                }
                            })
                        }
                    })
                }
            }]) && r(t.prototype, e), i && r(t, i), n
        }();
        i.default = a
    }, {
        gsap: "gsap"
    }],
    "@bornfight/b-scroll-lock": [function(t, e, i) {
        "use strict";

        function r(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = void 0;
        var n = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.body = document.querySelector("body")
            }
            var e, i, n;
            return e = t, (i = [{
                key: "lockScroll",
                value: function(t) {
                    var e = 0 < arguments.length && void 0 !== t ? t : 100;
                    this.offsetTop = document.documentElement.scrollTop, this.body.style.overflow = "hidden", this.body.style.top = "-".concat(this.offsetTop, "px"), this.body.style.position = "fixed", this.offsetTop >= e && this.body.classList.add("is-fixed-scrolled")
                }
            }, {
                key: "unlockScroll",
                value: function(t) {
                    var e = 0 < arguments.length && void 0 !== t ? t : this.offsetTop;
                    this.body.style.top = "0px", this.body.style.position = "", this.body.style.overflow = "", document.documentElement.scrollTop = e, this.body.classList.remove("is-fixed-scrolled")
                }
            }]) && r(e.prototype, i), n && r(e, n), t
        }();
        i.default = n
    }, {}],
    "@tarekraafat/autocomplete.js": [function(t, e, i) {
        "use strict";

        function n(t) {
            return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function r() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }

            function s(t) {
                return t.innerHTML = ""
            }

            function x(e, t, i, n, r, a) {
                n({
                    event: e,
                    query: t instanceof HTMLInputElement ? t.value : t.innerHTML,
                    matches: r.matches,
                    results: r.list.map(function(t) {
                        return t.value
                    }),
                    selection: r.list.find(function(t) {
                        return 13 === e.keyCode ? t.index === Number(a.getAttribute(_)) : "mousedown" === e.type ? t.index === Number(e.currentTarget.getAttribute(_)) : void 0
                    })
                }), s(i)
            }

            function e(t, e) {
                e = e || {
                    bubbles: !1,
                    cancelable: !1,
                    detail: void 0
                };
                var i = document.createEvent("CustomEvent");
                return i.initCustomEvent(t, e.bubbles, e.cancelable, e.detail), i
            }

            function o(t) {
                return "<span class=".concat("autoComplete_highlighted", ">").concat(t, "</span>")
            }
            var _ = "data-id",
                w = "autoComplete_selected",
                X = function(t) {
                    return "string" == typeof t ? document.querySelector(t) : t()
                },
                Y = function(t) {
                    var e = document.createElement(t.element);
                    return e.setAttribute("id", "autoComplete_list"), t.container && t.container(e), t.destination.insertAdjacentElement(t.position, e), e
                },
                l = s;
            e.prototype = window.Event.prototype;
            var h = {
                CustomEventWrapper: "function" == typeof window.CustomEvent && window.CustomEvent || e,
                initElementClosestPolyfill: function() {
                    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function(t) {
                        var e = this;
                        do {
                            if (e.matches(t)) return e;
                            e = e.parentElement || e.parentNode
                        } while (null !== e && 1 === e.nodeType);
                        return null
                    })
                }
            };
            return t(J.prototype, [{
                key: "search",
                value: function(t, e) {
                    var i = e.toLowerCase();
                    if ("loose" === this.searchEngine) {
                        t = t.replace(/ /g, "");
                        for (var n = [], r = 0, a = 0; a < i.length; a++) {
                            var s = e[a];
                            r < t.length && i[a] === t[r] && (s = this.highlight ? o(s) : s, r++), n.push(s)
                        }
                        return r === t.length && n.join("")
                    }
                    if (i.includes(t)) return t = new RegExp("".concat(t), "i").exec(e), this.highlight ? e.replace(t, o(t)) : e
                }
            }, {
                key: "listMatchedResults",
                value: function(i) {
                    var h = this;
                    return new Promise(function(t) {
                        var l = [];
                        i.filter(function(n, r) {
                            function t(t) {
                                var e, i = t ? n[t] : n;
                                i && ((e = "function" == typeof h.searchEngine ? h.searchEngine(h.queryValue, i) : h.search(h.queryValue, i)) && t ? l.push({
                                    key: t,
                                    index: r,
                                    match: e,
                                    value: n
                                }) : e && !t && l.push({
                                    index: r,
                                    match: e,
                                    value: n
                                }))
                            }
                            if (h.data.key) {
                                var e = !0,
                                    i = !1,
                                    a = void 0;
                                try {
                                    for (var s, o = h.data.key[Symbol.iterator](); !(e = (s = o.next()).done); e = !0) t(s.value)
                                } catch (t) {
                                    i = !0, a = t
                                } finally {
                                    try {
                                        e || null == o.return || o.return()
                                    } finally {
                                        if (i) throw a
                                    }
                                }
                            } else t()
                        });
                        var e = h.sort ? l.sort(h.sort).slice(0, h.maxResults) : l.slice(0, h.maxResults);
                        return t({
                            matches: l.length,
                            list: e
                        })
                    })
                }
            }, {
                key: "ignite",
                value: function() {
                    var y = this,
                        b = X(this.selector);

                    function r(a) {
                        Promise.resolve(y.data.cache ? y.dataStream : y.data.src()).then(function(t) {
                            function m(t, e) {
                                b.dispatchEvent(new h.CustomEventWrapper("autoComplete", {
                                    bubbles: !0,
                                    detail: {
                                        event: t,
                                        input: i,
                                        query: n,
                                        matches: e ? e.matches : null,
                                        results: e ? e.list : null
                                    },
                                    cancelable: !0
                                }))
                            }
                            var g, v, i, n, e, r;
                            y.dataStream = t, g = a, i = b instanceof HTMLInputElement || b instanceof HTMLTextAreaElement ? b.value.toLowerCase() : b.innerHTML.toLowerCase(), n = y.queryValue = y.query && y.query.manipulate ? y.query.manipulate(i) : i, e = y.resultsList.render, r = y.trigger.condition ? y.trigger.condition(n) : n.length > y.threshold && n.replace(/ /g, "").length, e ? (v = y.resultsList.view, l(v), r ? y.listMatchedResults(y.dataStream, g).then(function(t) {
                                function e(t) {
                                    u.classList.remove(w), o = 1 === t ? u.nextSibling : u.previousSibling
                                }

                                function i(t) {
                                    (u = t).classList.add(w)
                                }
                                var n, r, a, s, o, l, h, u, c, p, d, f;
                                m(g, t), y.resultsList.render && (0 === t.list.length && y.noResults ? y.noResults() : (c = v, p = t.list, d = y.resultItem, f = document.createDocumentFragment(), p.forEach(function(t, e) {
                                    var i = document.createElement(d.element),
                                        n = p[e].index;
                                    i.setAttribute(_, n), i.setAttribute("class", "autoComplete_result"), d.content ? d.content(t, i) : i.innerHTML = t.match || t, f.appendChild(i)
                                }), c.appendChild(f), y.onSelection && (y.resultsList.navigation ? y.resultsList.navigation(g, b, v, y.onSelection, t) : (n = b, r = v, a = y.onSelection, s = t, l = r.childNodes, h = l.length - 1, u = void 0, n.onkeydown = function(t) {
                                    if (0 < l.length) switch (t.keyCode) {
                                        case 38:
                                            u ? (e(0), i(o || l[h])) : i(l[h]);
                                            break;
                                        case 40:
                                            u ? (e(1), i(o || l[0])) : i(l[0]);
                                            break;
                                        case 13:
                                            u && x(t, n, r, a, s, u)
                                    }
                                }, l.forEach(function(t) {
                                    t.onmousedown = function(t) {
                                        return x(t, n, r, a, s)
                                    }
                                })))))
                            }) : m(g)) : !e && r && y.listMatchedResults(y.dataStream, g).then(function(t) {
                                m(g, t)
                            })
                        })
                    }
                    this.placeHolder && b.setAttribute("placeholder", this.placeHolder), this.trigger.event.forEach(function(t) {
                        var i, n;
                        b.addEventListener(t, (i = y.debounce, function() {
                            var t = this,
                                e = arguments;
                            clearTimeout(n), n = setTimeout(function() {
                                return r.apply(t, e)
                            }, i)
                        }))
                    })
                }
            }, {
                key: "init",
                value: function() {
                    var e = this;
                    this.data.cache ? Promise.resolve(this.data.src()).then(function(t) {
                        e.dataStream = t, e.ignite()
                    }) : this.ignite(), h.initElementClosestPolyfill()
                }
            }]), J;

            function J(t) {
                ! function(t) {
                    if (!(t instanceof J)) throw new TypeError("Cannot call a class as a function")
                }(this);
                var e = t.selector,
                    i = void 0 === e ? "#autoComplete" : e,
                    n = t.data,
                    r = n.key,
                    a = n.src,
                    s = n.cache,
                    o = void 0 === s || s,
                    l = t.query,
                    h = t.trigger,
                    u = (h = void 0 === h ? {} : h).event,
                    c = void 0 === u ? ["input"] : u,
                    p = h.condition,
                    d = void 0 !== p && p,
                    f = t.searchEngine,
                    m = void 0 === f ? "strict" : f,
                    g = t.threshold,
                    v = void 0 === g ? 0 : g,
                    y = t.debounce,
                    b = void 0 === y ? 0 : y,
                    x = t.resultsList,
                    _ = (x = void 0 === x ? {} : x).render,
                    w = void 0 !== _ && _,
                    S = x.container,
                    M = void 0 !== S && S,
                    T = x.destination,
                    C = x.position,
                    A = void 0 === C ? "afterend" : C,
                    E = x.element,
                    D = void 0 === E ? "ul" : E,
                    P = x.navigation,
                    L = void 0 !== P && P,
                    k = t.sort,
                    O = void 0 !== k && k,
                    F = t.placeHolder,
                    I = t.maxResults,
                    N = void 0 === I ? 5 : I,
                    B = t.resultItem,
                    R = (B = void 0 === B ? {} : B).content,
                    z = void 0 !== R && R,
                    G = B.element,
                    V = void 0 === G ? "li" : G,
                    U = t.noResults,
                    j = t.highlight,
                    H = void 0 !== j && j,
                    W = t.onSelection,
                    q = w ? Y({
                        container: M,
                        destination: T || X(i),
                        position: A,
                        element: D
                    }) : null;
                this.selector = i, this.data = {
                    src: function() {
                        return "function" == typeof a ? a() : a
                    },
                    key: r,
                    cache: o
                }, this.query = l, this.trigger = {
                    event: c,
                    condition: d
                }, this.searchEngine = "loose" === m ? "loose" : "function" == typeof m ? m : "strict", this.threshold = v, this.debounce = b, this.resultsList = {
                    render: w,
                    view: q,
                    navigation: L
                }, this.sort = O, this.placeHolder = F, this.maxResults = N, this.resultItem = {
                    content: z,
                    element: V
                }, this.noResults = U, this.highlight = H, this.onSelection = W, this.init()
            }
        }
        "object" == (void 0 === i ? "undefined" : n(i)) && void 0 !== e ? e.exports = r() : "function" == typeof define && define.amd ? define(r) : (void 0).autoComplete = r()
    }, {}],
    1: [function(t, e, i) {
        "use strict";

        function n(t) {
            return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function C(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function a(t, e) {
            t.prototype = Object.create(e.prototype), (t.prototype.constructor = t).__proto__ = e
        }
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i._getCache = i._getSetter = i._missingPlugin = i._round = i._roundModifier = i._config = i._ticker = i._plugins = i._checkPlugin = i._replaceRandom = i._colorStringFilter = i._sortPropTweensByPriority = i._forEachName = i._removeLinkedListItem = i._setDefaults = i._relExp = i._renderComplexString = i._isUndefined = i._isString = i._numWithUnitExp = i._numExp = i._getProperty = i.shuffle = i.interpolate = i.unitize = i.pipe = i.mapRange = i.toArray = i.splitColor = i.clamp = i.getUnit = i.normalize = i.snap = i.random = i.distribute = i.wrapYoyo = i.wrap = i.Circ = i.Expo = i.Sine = i.Bounce = i.SteppedEase = i.Back = i.Elastic = i.Strong = i.Quint = i.Quart = i.Cubic = i.Quad = i.Linear = i.Power4 = i.Power3 = i.Power2 = i.Power1 = i.Power0 = i.default = i.gsap = i.PropTween = i.TweenLite = i.TweenMax = i.Tween = i.TimelineLite = i.TimelineMax = i.Timeline = i.Animation = i.GSCache = void 0;

        function S(t) {
            return "string" == typeof t
        }

        function d(t) {
            return "function" == typeof t
        }

        function A(t) {
            return "number" == typeof t
        }

        function r(t) {
            return void 0 === t
        }

        function E(t) {
            return "object" === n(t)
        }

        function I(t) {
            return !1 !== t
        }

        function s() {
            return "undefined" != typeof window
        }

        function D(t) {
            return d(t) || S(t)
        }

        function o(t) {
            return (de = we(t, pe)) && gi
        }

        function l() {}

        function P(t, e) {
            return !e && void 0
        }

        function h(t, e) {
            return t && (pe[t] = e) && de && (de[t] = e) || pe
        }

        function L() {
            return 0
        }

        function N(t) {
            var e, i, n = t[0];
            if (E(n) || d(n) || (t = [t]), !(e = (n._gsap || {}).harness)) {
                for (i = xe.length; i-- && !xe[i].targetTest(n););
                e = xe[i]
            }
            for (i = t.length; i--;) t[i] && (t[i]._gsap || (t[i]._gsap = new je(t[i], e))) || t.splice(i, 1);
            return t
        }

        function B(t) {
            return t._gsap || N(Ae(t))[0]._gsap
        }

        function u(t, e, i) {
            return (i = t[e]) && d(i) ? t[e]() : r(i) && t.getAttribute && t.getAttribute(e) || i
        }

        function f(t, e) {
            return (t = t.split(",")).forEach(e) || t
        }

        function k(t) {
            return Math.round(1e5 * t) / 1e5 || 0
        }

        function c(t, e, i) {
            var n, r = A(t[1]),
                a = (r ? 2 : 1) + (e < 2 ? 0 : 1),
                s = t[a];
            if (r && (s.duration = t[1]), s.parent = i, e) {
                for (n = s; i && !("immediateRender" in n);) n = i.vars.defaults || {}, i = I(i.vars.inherit) && i.parent;
                s.immediateRender = I(n.immediateRender), e < 2 ? s.runBackwards = 1 : s.startAt = t[a - 1]
            }
            return s
        }

        function R() {
            var t, e, i = me.length,
                n = me.slice(0);
            for (ge = {}, t = me.length = 0; t < i; t++)(e = n[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
        }

        function p(t, e, i, n) {
            me.length && R(), t.render(e, i, n), me.length && R()
        }

        function m(t) {
            var e = parseFloat(t);
            return (e || 0 === e) && (t + "").match(ce).length < 2 ? e : S(t) ? t.trim() : t
        }

        function g(t) {
            return t
        }

        function z(t, e) {
            for (var i in e) i in t || (t[i] = e[i]);
            return t
        }

        function v(t, e) {
            for (var i in e) i in t || "duration" === i || "ease" === i || (t[i] = e[i])
        }

        function y(t, e) {
            for (var i in e) t[i] = E(e[i]) ? y(t[i] || (t[i] = {}), e[i]) : e[i];
            return t
        }

        function G(t, e) {
            var i, n = {};
            for (i in t) i in e || (n[i] = t[i]);
            return n
        }

        function O(t) {
            var e = t.parent || Mt,
                i = t.keyframes ? v : z;
            if (I(t.inherit))
                for (; e;) i(t, e.vars.defaults), e = e.parent || e._dp;
            return t
        }

        function b(t, e, i, n) {
            void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
            var r = e._prev,
                a = e._next;
            r ? r._next = a : t[i] === e && (t[i] = a), a ? a._prev = r : t[n] === e && (t[n] = r), e._next = e._prev = e.parent = null
        }

        function V(t, e) {
            !t.parent || e && !t.parent.autoRemoveChildren || t.parent.remove(t), t._act = 0
        }

        function x(t, e) {
            if (t && (!e || e._end > t._dur || e._start < 0))
                for (var i = t; i;) i._dirty = 1, i = i.parent;
            return t
        }

        function _(t) {
            return t._repeat ? Se(t._tTime, t = t.duration() + t._rDelay) * t : 0
        }

        function w(t, e) {
            return (t - e._start) * e._ts + (0 <= e._ts ? 0 : e._dirty ? e.totalDuration() : e._tDur)
        }

        function M(t) {
            return t._end = k(t._start + (t._tDur / Math.abs(t._ts || t._rts || $t) || 0))
        }

        function T(t, e) {
            var i = t._dp;
            return i && i.smoothChildTiming && t._ts && (t._start = k(t._dp._time - (0 < t._ts ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), M(t), i._dirty || x(i, t)), t
        }

        function F(t, e) {
            var i;
            if ((e._time || e._initted && !e._dur) && (i = w(t.rawTime(), e), (!e._dur || Te(0, e.totalDuration(), i) - e._tTime > $t) && e.render(i, !0)), x(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                if (t._dur < t.duration())
                    for (i = t; i._dp;) 0 <= i.rawTime() && i.totalTime(i._tTime), i = i._dp;
                t._zTime = -$t
            }
        }

        function U(t, e, i, n) {
            return e.parent && V(e), e._start = k(i + e._delay), e._end = k(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
                function(t, e, i, n, r) {
                    void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
                    var a, s = t[n];
                    if (r)
                        for (a = e[r]; s && s[r] > a;) s = s._prev;
                    s ? (e._next = s._next, s._next = e) : (e._next = t[i], t[i] = e), e._next ? e._next._prev = e : t[n] = e, e._prev = s, e.parent = e._dp = t
                }(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, n || F(t, e), t
        }

        function j(t, e) {
            return pe.ScrollTrigger ? pe.ScrollTrigger.create(e, t) : void 0
        }

        function H(t, e, i, n) {
            return Je(t, e), t._initted ? !i && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && Dt !== Fe.frame ? (me.push(t), t._lazy = [e, n]) : void 0 : 1
        }

        function W(t, e, i, n) {
            var r = t._repeat,
                a = k(e) || 0,
                s = t._tTime / t._tDur;
            return s && !n && (t._time *= a / t._dur), t._dur = a, t._tDur = r ? r < 0 ? 1e10 : k(a * (r + 1) + t._rDelay * r) : a, s && !n ? T(t, t._tTime = t._tDur * s) : t.parent && M(t), i || x(t.parent, t), t
        }

        function q(t) {
            return t instanceof We ? x(t) : W(t, t._dur)
        }

        function X(t, e) {
            var i, n, r = t.labels,
                a = t._recent || Me,
                s = t.duration() >= Zt ? a.endTime(!1) : t._dur;
            return S(e) && (isNaN(e) || e in r) ? "<" === (i = e.charAt(0)) || ">" === i ? ("<" === i ? a._start : a.endTime(0 <= a._repeat)) + (parseFloat(e.substr(1)) || 0) : (i = e.indexOf("=")) < 0 ? (e in r || (r[e] = s), r[e]) : (n = +(e.charAt(i - 1) + e.substr(i + 1)), 1 < i ? X(t, e.substr(0, i - 1)) + n : s + n) : null == e ? s : +e
        }

        function Y(t, e) {
            return t || 0 === t ? e(t) : e
        }

        function J(t) {
            return (t = (t + "").substr((parseFloat(t) + "").length)) && isNaN(t) ? t : ""
        }

        function Z(e, i, t) {
            return Y(t, function(t) {
                return Te(e, i, t)
            })
        }

        function $(t, e) {
            return t && E(t) && "length" in t && (!e && !t.length || t.length - 1 in t && E(t[0])) && !t.nodeType && t !== Tt
        }

        function K(t) {
            return t.sort(function() {
                return .5 - Math.random()
            })
        }

        function Q(t) {
            if (d(t)) return t;
            var f = E(t) ? t : {
                    each: t
                },
                m = Ge(f.ease),
                g = f.from || 0,
                v = parseFloat(f.base) || 0,
                y = {},
                e = 0 < g && g < 1,
                b = isNaN(g) || e,
                x = f.axis,
                _ = g,
                w = g;
            return S(g) ? _ = w = {
                    center: .5,
                    edges: .5,
                    end: 1
                }[g] || 0 : !e && b && (_ = g[0], w = g[1]),
                function(t, e, i) {
                    var n, r, a, s, o, l, h, u, c, p = (i || f).length,
                        d = y[p];
                    if (!d) {
                        if (!(c = "auto" === f.grid ? 0 : (f.grid || [1, Zt])[1])) {
                            for (h = -Zt; h < (h = i[c++].getBoundingClientRect().left) && c < p;);
                            c--
                        }
                        for (d = y[p] = [], n = b ? Math.min(c, p) * _ - .5 : g % c, r = b ? p * w / c - .5 : g / c | 0, u = Zt, l = h = 0; l < p; l++) a = l % c - n, s = r - (l / c | 0), d[l] = o = x ? Math.abs("y" === x ? s : a) : ee(a * a + s * s), h < o && (h = o), o < u && (u = o);
                        "random" === g && K(d), d.max = h - u, d.min = u, d.v = p = (parseFloat(f.amount) || parseFloat(f.each) * (p < c ? p - 1 : x ? "y" === x ? p / c : c : Math.max(c, p / c)) || 0) * ("edges" === g ? -1 : 1), d.b = p < 0 ? v - p : v, d.u = J(f.amount || f.each) || 0, m = m && p < 0 ? ze(m) : m
                    }
                    return p = (d[t] - d.min) / d.max || 0, k(d.b + (m ? m(p) : p) * d.v) + d.u
                }
        }

        function tt(e) {
            var i = e < 1 ? Math.pow(10, (e + "").length - 2) : 1;
            return function(t) {
                return Math.floor(Math.round(parseFloat(t) / e) * e * i) / i + (A(t) ? 0 : J(t))
            }
        }

        function et(l, t) {
            var h, u, e = ae(l);
            return !e && E(l) && (h = e = l.radius || Zt, l.values ? (l = Ae(l.values), (u = !A(l[0])) && (h *= h)) : l = tt(l.increment)), Y(t, e ? d(l) ? function(t) {
                return u = l(t), Math.abs(u - t) <= h ? u : t
            } : function(t) {
                for (var e, i, n = parseFloat(u ? t.x : t), r = parseFloat(u ? t.y : 0), a = Zt, s = 0, o = l.length; o--;)(e = u ? (e = l[o].x - n) * e + (i = l[o].y - r) * i : Math.abs(l[o] - n)) < a && (a = e, s = o);
                return s = !h || a <= h ? l[s] : t, u || s === t || A(t) ? s : s + J(t)
            } : tt(l))
        }

        function it(t, e, i, n) {
            return Y(ae(t) ? !e : !0 === i ? !!(i = 0) : !n, function() {
                return ae(t) ? t[~~(Math.random() * t.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((t + Math.random() * (e - t)) / i) * i * n) / n
            })
        }

        function nt() {
            for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
            return function(t) {
                return e.reduce(function(t, e) {
                    return e(t)
                }, t)
            }
        }

        function rt(e, i) {
            return function(t) {
                return e(parseFloat(t)) + (i || J(t))
            }
        }

        function at(t, e, i) {
            return Ee(t, e, 0, 1, i)
        }

        function st(e, i, t) {
            return Y(t, function(t) {
                return e[~~i(t)]
            })
        }

        function ot(e, t, i) {
            var n = t - e;
            return ae(e) ? st(e, ot(0, e.length), t) : Y(i, function(t) {
                return (n + (t - e) % n) % n + e
            })
        }

        function lt(e, t, i) {
            var n = t - e,
                r = 2 * n;
            return ae(e) ? st(e, lt(0, e.length - 1), t) : Y(i, function(t) {
                return e + (n < (t = (r + (t - e) % r) % r || 0) ? r - t : t)
            })
        }

        function ht(t) {
            for (var e, i, n, r, a = 0, s = ""; ~(e = t.indexOf("random(", a));) n = t.indexOf(")", e), r = "[" === t.charAt(e + 7), i = t.substr(e + 7, n - e - 7).match(r ? ce : se), s += t.substr(a, e - a) + it(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5), a = n + 1;
            return s + t.substr(a, t.length - a)
        }

        function ut(e, i, t, n) {
            var r = isNaN(e + i) ? 0 : function(t) {
                return (1 - t) * e + t * i
            };
            if (!r) {
                var a, s, o, l, h, u = S(e),
                    c = {};
                if (!0 === t && (n = 1) && (t = null), u) e = {
                    p: e
                }, i = {
                    p: i
                };
                else if (ae(e) && !ae(i)) {
                    for (o = [], l = e.length, h = l - 2, s = 1; s < l; s++) o.push(ut(e[s - 1], e[s]));
                    l--, r = function(t) {
                        t *= l;
                        var e = Math.min(h, ~~t);
                        return o[e](t - e)
                    }, t = i
                } else n || (e = we(ae(e) ? [] : {}, e));
                if (!o) {
                    for (a in i) Ye.call(c, e, a, "get", i[a]);
                    r = function(t) {
                        return hi(t, c) || (u ? e.p : e)
                    }
                }
            }
            return Y(t, r)
        }

        function ct(t, e, i) {
            var n, r, a, s = t.labels,
                o = Zt;
            for (n in s)(r = s[n] - e) < 0 == !!i && r && o > (r = Math.abs(r)) && (a = n, o = r);
            return a
        }

        function pt(t) {
            return V(t), t.progress() < 1 && De(t, "onInterrupt"), t
        }

        function dt(t, e, i) {
            return (6 * (t = t < 0 ? t + 1 : 1 < t ? t - 1 : t) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) * Pe + .5 | 0
        }

        function ft(t, e, i) {
            var n, r, a, s, o, l, h, u, c, p, d = t ? A(t) ? [t >> 16, t >> 8 & Pe, t & Pe] : 0 : Le.black;
            if (!d) {
                if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Le[t]) d = Le[t];
                else if ("#" === t.charAt(0)) 4 === t.length && (t = "#" + (n = t.charAt(1)) + n + (r = t.charAt(2)) + r + (a = t.charAt(3)) + a), d = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & Pe, t & Pe];
                else if ("hsl" === t.substr(0, 3))
                    if (d = p = t.match(se), e) {
                        if (~t.indexOf("=")) return d = t.match(oe), i && d.length < 4 && (d[3] = 1), d
                    } else s = +d[0] % 360 / 360, o = d[1] / 100, n = 2 * (l = d[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), 3 < d.length && (d[3] *= 1), d[0] = dt(s + 1 / 3, n, r), d[1] = dt(s, n, r), d[2] = dt(s - 1 / 3, n, r);
                else d = t.match(se) || Le.transparent;
                d = d.map(Number)
            }
            return e && !p && (n = d[0] / Pe, r = d[1] / Pe, a = d[2] / Pe, l = ((h = Math.max(n, r, a)) + (u = Math.min(n, r, a))) / 2, h === u ? s = o = 0 : (c = h - u, o = .5 < l ? c / (2 - h - u) : c / (h + u), s = h === n ? (r - a) / c + (r < a ? 6 : 0) : h === r ? (a - n) / c + 2 : (n - r) / c + 4, s *= 60), d[0] = ~~(s + .5), d[1] = ~~(100 * o + .5), d[2] = ~~(100 * l + .5)), i && d.length < 4 && (d[3] = 1), d
        }

        function mt(t) {
            var i = [],
                n = [],
                r = -1;
            return t.split(ke).forEach(function(t) {
                var e = t.match(le) || [];
                i.push.apply(i, e), n.push(r += e.length + 1)
            }), i.c = n, i
        }

        function gt(t, e, i) {
            var n, r, a, s, o = "",
                l = (t + o).match(ke),
                h = e ? "hsla(" : "rgba(",
                u = 0;
            if (!l) return t;
            if (l = l.map(function(t) {
                    return (t = ft(t, e, 1)) && h + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                }), i && (a = mt(t), (n = i.c).join(o) !== a.c.join(o)))
                for (s = (r = t.replace(ke, "1").split(le)).length - 1; u < s; u++) o += r[u] + (~n.indexOf(u) ? l.shift() || h + "0,0,0,0)" : (a.length ? a : l.length ? l : i).shift());
            if (!r)
                for (s = (r = t.split(ke)).length - 1; u < s; u++) o += r[u] + l[u];
            return o + r[s]
        }

        function vt(t) {
            var e, i = t.join(" ");
            if (ke.lastIndex = 0, ke.test(i)) return e = Oe.test(i), t[1] = gt(t[1], e), t[0] = gt(t[0], e, mt(t[1])), !0
        }

        function yt(t) {
            var e, i, n, r, a = (t + "").split("("),
                s = Ne[a[0]];
            return s && 1 < a.length && s.config ? s.config.apply(null, ~t.indexOf("{") ? [function(t) {
                for (var e, i, n, r = {}, a = t.substr(1, t.length - 3).split(":"), s = a[0], o = 1, l = a.length; o < l; o++) i = a[o], e = o !== l - 1 ? i.lastIndexOf(",") : i.length, n = i.substr(0, e), r[s] = isNaN(n) ? n.replace(Re, "").trim() : +n, s = i.substr(e + 1).trim();
                return r
            }(a[1])] : (i = (e = t).indexOf("(") + 1, n = e.indexOf(")"), r = e.indexOf("(", i), e.substring(i, ~r && r < n ? e.indexOf(")", n + 1) : n).split(",").map(m))) : Ne._CE && Be.test(t) ? Ne._CE("", t) : s
        }

        function bt(t, e) {
            for (var i, n = t._first; n;) n instanceof We ? bt(n, e) : !n.vars.yoyoEase || n._yoyo && n._repeat || n._yoyo === e || (n.timeline ? bt(n.timeline, e) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = e)), n = n._next
        }

        function xt(t, e, i, n) {
            void 0 === i && (i = function(t) {
                return 1 - e(1 - t)
            }), void 0 === n && (n = function(t) {
                return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
            });
            var r, a = {
                easeIn: e,
                easeOut: i,
                easeInOut: n
            };
            return f(t, function(t) {
                for (var e in Ne[t] = pe[t] = a, Ne[r = t.toLowerCase()] = i, a) Ne[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Ne[t + "." + e] = a[e]
            }), 1
        }

        function _t(e) {
            return function(t) {
                return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
            }
        }

        function wt(i, t, e) {
            function n(t) {
                return 1 === t ? 1 : r * Math.pow(2, -10 * t) * ne((t - a) * o) + 1
            }
            var r = 1 <= t ? t : 1,
                a = (o = (e || (i ? .3 : .45)) / (t < 1 ? t : 1)) / Kt * (Math.asin(1 / r) || 0),
                s = "out" === i ? n : "in" === i ? function(t) {
                    return 1 - n(1 - t)
                } : _t(n),
                o = Kt / o;
            return s.config = function(t, e) {
                return wt(i, t, e)
            }, s
        }

        function St(e, i) {
            function n(t) {
                return t ? --t * t * ((i + 1) * t + i) + 1 : 0
            }
            void 0 === i && (i = 1.70158);
            var t = "out" === e ? n : "in" === e ? function(t) {
                return 1 - n(1 - t)
            } : _t(n);
            return t.config = function(t) {
                return St(e, t)
            }, t
        }
        var Mt, Tt, Ct, At, Et, Dt, Pt, Lt, kt, Ot, Ft, It, Nt, Bt, Rt, zt, Gt, Vt, Ut, jt, Ht, Wt, qt, Xt, Yt = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            },
            Jt = {
                duration: .5,
                overwrite: !1,
                delay: 0
            },
            Zt = 1e8,
            $t = 1e-8,
            Kt = 2 * Math.PI,
            Qt = Kt / 4,
            te = 0,
            ee = Math.sqrt,
            ie = Math.cos,
            ne = Math.sin,
            re = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
            ae = Array.isArray,
            se = /(?:-?\.?\d|\.)+/gi,
            oe = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
            le = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
            he = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
            ue = /[+-]=-?[\.\d]+/,
            ce = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
            pe = {},
            de = {},
            fe = {},
            me = [],
            ge = {},
            ve = {},
            ye = {},
            be = 30,
            xe = [],
            _e = "",
            we = function(t, e) {
                for (var i in e) t[i] = e[i];
                return t
            },
            Se = function(t, e) {
                return (t /= e) && ~~t === t ? ~~t - 1 : ~~t
            },
            Me = {
                _start: 0,
                endTime: L
            },
            Te = function(t, e, i) {
                return i < t ? t : e < i ? e : i
            },
            Ce = [].slice,
            Ae = function(t, e) {
                return !S(t) || e || !Ct && Ie() ? ae(t) ? (i = e, void 0 === n && (n = []), t.forEach(function(t) {
                    return S(t) && !i || $(t, 1) ? n.push.apply(n, Ae(t)) : n.push(t)
                }) || n) : $(t) ? Ce.call(t, 0) : t ? [t] : [] : Ce.call(At.querySelectorAll(t), 0);
                var i, n
            },
            Ee = function(e, t, i, n, r) {
                var a = t - e,
                    s = n - i;
                return Y(r, function(t) {
                    return i + ((t - e) / a * s || 0)
                })
            },
            De = function(t, e, i) {
                var n, r, a = t.vars,
                    s = a[e];
                if (s) return n = a[e + "Params"], r = a.callbackScope || t, i && me.length && R(), n ? s.apply(r, n) : s.call(r)
            },
            Pe = 255,
            Le = {
                aqua: [0, Pe, Pe],
                lime: [0, Pe, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, Pe],
                navy: [0, 0, 128],
                white: [Pe, Pe, Pe],
                olive: [128, 128, 0],
                yellow: [Pe, Pe, 0],
                orange: [Pe, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [Pe, 0, 0],
                pink: [Pe, 192, 203],
                cyan: [0, Pe, Pe],
                transparent: [Pe, Pe, Pe, 0]
            },
            ke = function() {
                var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                for (t in Le) e += "|" + t + "\\b";
                return new RegExp(e + ")", "gi")
            }(),
            Oe = /hsl[a]?\(/,
            Fe = (Bt = Date.now, Rt = 500, zt = 33, Gt = Bt(), Vt = Gt, jt = Ut = 1e3 / 240, Wt = {
                time: 0,
                frame: 0,
                tick: function() {
                    Ve(!0)
                },
                deltaRatio: function(t) {
                    return It / (1e3 / (t || 60))
                },
                wake: function() {
                    Et && (!Ct && s() && (Tt = Ct = window, At = Tt.document || {}, pe.gsap = gi, (Tt.gsapVersions || (Tt.gsapVersions = [])).push(gi.version), o(de || Tt.GreenSockGlobals || !Tt.gsap && Tt || {}), Ft = Tt.requestAnimationFrame), kt && Wt.sleep(), Ot = Ft || function(t) {
                        return setTimeout(t, jt - 1e3 * Wt.time + 1 | 0)
                    }, Lt = 1, Ve(2))
                },
                sleep: function() {
                    (Ft ? Tt.cancelAnimationFrame : clearTimeout)(kt), Lt = 0, Ot = L
                },
                lagSmoothing: function(t, e) {
                    Rt = t || 1e8, zt = Math.min(e, Rt, 0)
                },
                fps: function(t) {
                    Ut = 1e3 / (t || 240), jt = 1e3 * Wt.time + Ut
                },
                add: function(t) {
                    Ht.indexOf(t) < 0 && Ht.push(t), Ie()
                },
                remove: function(t) {
                    var e;
                    ~(e = Ht.indexOf(t)) && Ht.splice(e, 1) && e <= Nt && Nt--
                },
                _listeners: Ht = []
            }),
            Ie = function() {
                return !Lt && Fe.wake()
            },
            Ne = {},
            Be = /^[\d.\-M][\d.\-,\s]/,
            Re = /["']/g,
            ze = function(e) {
                return function(t) {
                    return 1 - e(1 - t)
                }
            },
            Ge = function(t, e) {
                return t && (d(t) ? t : Ne[t] || yt(t)) || e
            };

        function Ve(t) {
            var e, i, n, r, a = Bt() - Vt,
                s = !0 === t;
            if (Rt < a && (Gt += a - zt), (0 < (e = (n = (Vt += a) - Gt) - jt) || s) && (r = ++Wt.frame, It = n - 1e3 * Wt.time, Wt.time = n /= 1e3, jt += e + (Ut <= e ? 4 : Ut - e), i = 1), s || (kt = Ot(Ve)), i)
                for (Nt = 0; Nt < Ht.length; Nt++) Ht[Nt](n, It, r, t)
        }

        function Ue(t) {
            return t < Xt ? qt * t * t : t < .7272727272727273 ? qt * Math.pow(t - 1.5 / 2.75, 2) + .75 : t < .9090909090909092 ? qt * (t -= 2.25 / 2.75) * t + .9375 : qt * Math.pow(t - 2.625 / 2.75, 2) + .984375
        }
        i._ticker = Fe, i._colorStringFilter = vt, i.splitColor = ft, i.interpolate = ut, i.mapRange = Ee, i._replaceRandom = ht, i.wrapYoyo = lt, i.wrap = ot, i.normalize = at, i.unitize = rt, i.pipe = nt, i.random = it, i.snap = et, i._roundModifier = tt, i.distribute = Q, i.shuffle = K, i.toArray = Ae, i.clamp = Z, i.getUnit = J, i._removeLinkedListItem = b, i._setDefaults = z, i._round = k, i._forEachName = f, i._getProperty = u, i._getCache = B, i._plugins = ve, i._missingPlugin = l, i._relExp = ue, i._numWithUnitExp = le, i._numExp = oe, i._isUndefined = r, i._isString = S, i._config = Yt, f("Linear,Quad,Cubic,Quart,Quint,Strong", function(t, e) {
            var i = e < 5 ? e + 1 : e;
            xt(t + ",Power" + (i - 1), e ? function(t) {
                return Math.pow(t, i)
            } : function(t) {
                return t
            }, function(t) {
                return 1 - Math.pow(1 - t, i)
            }, function(t) {
                return t < .5 ? Math.pow(2 * t, i) / 2 : 1 - Math.pow(2 * (1 - t), i) / 2
            })
        }), Ne.Linear.easeNone = Ne.none = Ne.Linear.easeIn, xt("Elastic", wt("in"), wt("out"), wt()), qt = 7.5625, Xt = 1 / 2.75, xt("Bounce", function(t) {
            return 1 - Ue(1 - t)
        }, Ue), xt("Expo", function(t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0
        }), xt("Circ", function(t) {
            return -(ee(1 - t * t) - 1)
        }), xt("Sine", function(t) {
            return 1 === t ? 1 : 1 - ie(t * Qt)
        }), xt("Back", St("in"), St("out"), St()), Ne.SteppedEase = Ne.steps = pe.SteppedEase = {
            config: function(t, e) {
                void 0 === t && (t = 1);
                var i = 1 / t,
                    n = t + (e ? 0 : 1),
                    r = e ? 1 : 0;
                return function(t) {
                    return ((n * Te(0, .99999999, t) | 0) + r) * i
                }
            }
        }, Jt.ease = Ne["quad.out"], f("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(t) {
            return _e += t + "," + t + "Params,"
        });
        var je = function(t, e) {
            this.id = te++, (t._gsap = this).target = t, this.harness = e, this.get = e ? e.get : u, this.set = e ? e.getSetter : ai
        };
        i.GSCache = je;
        var He = function() {
            function t(t, e) {
                var i = t.parent || Mt;
                this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, W(this, +t.duration, 1, 1), this.data = t.data, Lt || Fe.wake(), i && U(i, this, e || 0 === e ? e : i._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0)
            }
            var e = t.prototype;
            return e.delay = function(t) {
                return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
            }, e.duration = function(t) {
                return arguments.length ? this.totalDuration(0 < this._repeat ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
            }, e.totalDuration = function(t) {
                return arguments.length ? (this._dirty = 0, W(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }, e.totalTime = function(t, e) {
                if (Ie(), !arguments.length) return this._tTime;
                var i = this._dp;
                if (i && i.smoothChildTiming && this._ts) {
                    for (T(this, t); i.parent;) i.parent._time !== i._start + (0 <= i._ts ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0), i = i.parent;
                    !this.parent && this._dp.autoRemoveChildren && (0 < this._ts && t < this._tDur || this._ts < 0 && 0 < t || !this._tDur && !t) && U(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === $t || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), p(this, t, e)), this
            }, e.time = function(t, e) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + _(this)) % this._dur || (t ? this._dur : 0), e) : this._time
            }, e.totalProgress = function(t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }, e.progress = function(t, e) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + _(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }, e.iteration = function(t, e) {
                var i = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (t - 1) * i, e) : this._repeat ? Se(this._tTime, i) + 1 : 1
            }, e.timeScale = function(t) {
                if (!arguments.length) return this._rts === -$t ? 0 : this._rts;
                if (this._rts === t) return this;
                var e = this.parent && this._ts ? w(this.parent._time, this) : this._tTime;
                return this._rts = +t || 0, this._ts = this._ps || t === -$t ? 0 : this._rts,
                    function(t) {
                        for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                        return t
                    }(this.totalTime(Te(-this._delay, this._tDur, e), !0))
            }, e.paused = function(t) {
                return arguments.length ? (this._ps !== t && ((this._ps = t) ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ie(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= $t) && Math.abs(this._zTime) !== $t))), this) : this._ps
            }, e.startTime = function(t) {
                if (arguments.length) {
                    this._start = t;
                    var e = this.parent || this._dp;
                    return !e || !e._sort && this.parent || U(e, this, t - this._delay), this
                }
                return this._start
            }, e.endTime = function(t) {
                return this._start + (I(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
            }, e.rawTime = function(t) {
                var e = this.parent || this._dp;
                return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? w(e.rawTime(t), this) : this._tTime : this._tTime
            }, e.globalTime = function(t) {
                for (var e = this, i = arguments.length ? t : e.rawTime(); e;) i = e._start + i / (e._ts || 1), e = e._dp;
                return i
            }, e.repeat = function(t) {
                return arguments.length ? (this._repeat = t, q(this)) : this._repeat
            }, e.repeatDelay = function(t) {
                return arguments.length ? (this._rDelay = t, q(this)) : this._rDelay
            }, e.yoyo = function(t) {
                return arguments.length ? (this._yoyo = t, this) : this._yoyo
            }, e.seek = function(t, e) {
                return this.totalTime(X(this, t), I(e))
            }, e.restart = function(t, e) {
                return this.play().totalTime(t ? -this._delay : 0, I(e))
            }, e.play = function(t, e) {
                return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
            }, e.reverse = function(t, e) {
                return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
            }, e.pause = function(t, e) {
                return null != t && this.seek(t, e), this.paused(!0)
            }, e.resume = function() {
                return this.paused(!1)
            }, e.reversed = function(t) {
                return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -$t : 0)), this) : this._rts < 0
            }, e.invalidate = function() {
                return this._initted = 0, this._zTime = -$t, this
            }, e.isActive = function() {
                var t, e = this.parent || this._dp,
                    i = this._start;
                return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= i && t < this.endTime(!0) - $t))
            }, e.eventCallback = function(t, e, i) {
                var n = this.vars;
                return 1 < arguments.length ? (e ? (n[t] = e, i && (n[t + "Params"] = i), "onUpdate" === t && (this._onUpdate = e)) : delete n[t], this) : n[t]
            }, e.then = function(n) {
                var r = this;
                return new Promise(function(e) {
                    function t() {
                        var t = r.then;
                        r.then = null, d(i) && (i = i(r)) && (i.then || i === r) && (r.then = t), e(i), r.then = t
                    }
                    var i = d(n) ? n : g;
                    r._initted && 1 === r.totalProgress() && 0 <= r._ts || !r._tTime && r._ts < 0 ? t() : r._prom = t
                })
            }, e.kill = function() {
                pt(this)
            }, t
        }();
        i.Animation = He, z(He.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -$t,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var We = function(n) {
            function t(t, e) {
                var i;
                return void 0 === t && (t = {}), (i = n.call(this, t, e) || this).labels = {}, i.smoothChildTiming = !!t.smoothChildTiming, i.autoRemoveChildren = !!t.autoRemoveChildren, i._sort = I(t.sortChildren), i.parent && F(i.parent, C(i)), t.scrollTrigger && j(C(i), t.scrollTrigger), i
            }
            a(t, n);
            var e = t.prototype;
            return e.to = function(t, e, i, n) {
                return new Qe(t, c(arguments, 0, this), X(this, A(e) ? n : i)), this
            }, e.from = function(t, e, i, n) {
                return new Qe(t, c(arguments, 1, this), X(this, A(e) ? n : i)), this
            }, e.fromTo = function(t, e, i, n, r) {
                return new Qe(t, c(arguments, 2, this), X(this, A(e) ? r : n)), this
            }, e.set = function(t, e, i) {
                return e.duration = 0, e.parent = this, O(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Qe(t, e, X(this, i), 1), this
            }, e.call = function(t, e, i) {
                return U(this, Qe.delayedCall(0, t, e), X(this, i))
            }, e.staggerTo = function(t, e, i, n, r, a, s) {
                return i.duration = e, i.stagger = i.stagger || n, i.onComplete = a, i.onCompleteParams = s, i.parent = this, new Qe(t, i, X(this, r)), this
            }, e.staggerFrom = function(t, e, i, n, r, a, s) {
                return i.runBackwards = 1, O(i).immediateRender = I(i.immediateRender), this.staggerTo(t, e, i, n, r, a, s)
            }, e.staggerFromTo = function(t, e, i, n, r, a, s, o) {
                return n.startAt = i, O(n).immediateRender = I(n.immediateRender), this.staggerTo(t, e, n, r, a, s, o)
            }, e.render = function(t, e, i) {
                var n, r, a, s, o, l, h, u, c, p, d, f, m = this._time,
                    g = this._dirty ? this.totalDuration() : this._tDur,
                    v = this._dur,
                    y = this !== Mt && g - $t < t && 0 <= t ? g : t < $t ? 0 : t,
                    b = this._zTime < 0 != t < 0 && (this._initted || !v);
                if (y !== this._tTime || i || b) {
                    if (m !== this._time && v && (y += this._time - m, t += this._time - m), n = y, c = this._start, l = !(u = this._ts), b && (v || (m = this._zTime), !t && e || (this._zTime = t)), this._repeat && (d = this._yoyo, o = v + this._rDelay, n = k(y % o), y === g ? (s = this._repeat, n = v) : ((s = ~~(y / o)) && s === y / o && (n = v, s--), v < n && (n = v)), p = Se(this._tTime, o), !m && this._tTime && p !== s && (p = s), d && 1 & s && (n = v - n, f = 1), s !== p && !this._lock)) {
                        var x = d && 1 & p,
                            _ = x === (d && 1 & s);
                        if (s < p && (x = !x), m = x ? 0 : v, this._lock = 1, this.render(m || (f ? 0 : k(s * o)), e, !v)._lock = 0, !e && this.parent && De(this, "onRepeat"), this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1), m !== this._time || l != !this._ts) return this;
                        if (v = this._dur, g = this._tDur, _ && (this._lock = 2, m = x ? v : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !f && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                        bt(this, f)
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (h = function(t, e, i) {
                            var n;
                            if (e < i)
                                for (n = t._first; n && n._start <= i;) {
                                    if (!n._dur && "isPause" === n.data && n._start > e) return n;
                                    n = n._next
                                } else
                                    for (n = t._last; n && n._start >= i;) {
                                        if (!n._dur && "isPause" === n.data && n._start < e) return n;
                                        n = n._prev
                                    }
                        }(this, k(m), k(n))) && (y -= n - (n = h._start)), this._tTime = y, this._time = n, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t), m || !n || e || De(this, "onStart"), m <= n && 0 <= t)
                        for (r = this._first; r;) {
                            if (a = r._next, (r._act || n >= r._start) && r._ts && h !== r) {
                                if (r.parent !== this) return this.render(t, e, i);
                                if (r.render(0 < r._ts ? (n - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (n - r._start) * r._ts, e, i), n !== this._time || !this._ts && !l) {
                                    h = 0, a && (y += this._zTime = -$t);
                                    break
                                }
                            }
                            r = a
                        } else {
                            r = this._last;
                            for (var w = t < 0 ? t : n; r;) {
                                if (a = r._prev, (r._act || w <= r._end) && r._ts && h !== r) {
                                    if (r.parent !== this) return this.render(t, e, i);
                                    if (r.render(0 < r._ts ? (w - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (w - r._start) * r._ts, e, i), n !== this._time || !this._ts && !l) {
                                        h = 0, a && (y += this._zTime = w ? -$t : $t);
                                        break
                                    }
                                }
                                r = a
                            }
                        }
                    if (h && !e && (this.pause(), h.render(m <= n ? 0 : -$t)._zTime = m <= n ? 1 : -1, this._ts)) return this._start = c, M(this), this.render(t, e, i);
                    this._onUpdate && !e && De(this, "onUpdate", !0), (y === g && g >= this.totalDuration() || !y && m) && (c !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || (!t && v || !(y === g && 0 < this._ts || !y && this._ts < 0) || V(this, 1), e || t < 0 && !m || !y && !m || (De(this, y === g ? "onComplete" : "onReverseComplete", !0), !this._prom || y < g && 0 < this.timeScale() || this._prom())))
                }
                return this
            }, e.add = function(t, e) {
                var i = this;
                if (A(e) || (e = X(this, e)), !(t instanceof He)) {
                    if (ae(t)) return t.forEach(function(t) {
                        return i.add(t, e)
                    }), this;
                    if (S(t)) return this.addLabel(t, e);
                    if (!d(t)) return this;
                    t = Qe.delayedCall(0, t)
                }
                return this !== t ? U(this, t, e) : this
            }, e.getChildren = function(t, e, i, n) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = -Zt);
                for (var r = [], a = this._first; a;) a._start >= n && (a instanceof Qe ? e && r.push(a) : (i && r.push(a), t && r.push.apply(r, a.getChildren(!0, e, i)))), a = a._next;
                return r
            }, e.getById = function(t) {
                for (var e = this.getChildren(1, 1, 1), i = e.length; i--;)
                    if (e[i].vars.id === t) return e[i]
            }, e.remove = function(t) {
                return S(t) ? this.removeLabel(t) : d(t) ? this.killTweensOf(t) : (b(this, t), t === this._recent && (this._recent = this._last), x(this))
            }, e.totalTime = function(t, e) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = k(Fe.time - (0 < this._ts ? t / this._ts : (this.totalDuration() - t) / -this._ts))), n.prototype.totalTime.call(this, t, e), this._forcing = 0, this) : this._tTime
            }, e.addLabel = function(t, e) {
                return this.labels[t] = X(this, e), this
            }, e.removeLabel = function(t) {
                return delete this.labels[t], this
            }, e.addPause = function(t, e, i) {
                var n = Qe.delayedCall(0, e || L, i);
                return n.data = "isPause", this._hasPause = 1, U(this, n, X(this, t))
            }, e.removePause = function(t) {
                var e = this._first;
                for (t = X(this, t); e;) e._start === t && "isPause" === e.data && V(e), e = e._next
            }, e.killTweensOf = function(t, e, i) {
                for (var n = this.getTweensOf(t, i), r = n.length; r--;) Xe !== n[r] && n[r].kill(t, e);
                return this
            }, e.getTweensOf = function(t, e) {
                for (var i, n = [], r = Ae(t), a = this._first, s = A(e); a;) a instanceof Qe ? function(t, e) {
                    for (var i = e.length, n = 0; t.indexOf(e[n]) < 0 && ++n < i;);
                    return n < i
                }(a._targets, r) && (s ? (!Xe || a._initted && a._ts) && a.globalTime(0) <= e && a.globalTime(a.totalDuration()) > e : !e || a.isActive()) && n.push(a) : (i = a.getTweensOf(r, e)).length && n.push.apply(n, i), a = a._next;
                return n
            }, e.tweenTo = function(t, e) {
                e = e || {};
                var i = this,
                    n = X(i, t),
                    r = e.startAt,
                    a = e.onStart,
                    s = e.onStartParams,
                    o = Qe.to(i, z(e, {
                        ease: "none",
                        lazy: !1,
                        time: n,
                        overwrite: "auto",
                        duration: e.duration || Math.abs((n - (r && "time" in r ? r.time : i._time)) / i.timeScale()) || $t,
                        onStart: function() {
                            i.pause();
                            var t = e.duration || Math.abs((n - i._time) / i.timeScale());
                            o._dur !== t && W(o, t, 0, 1).render(o._time, !0, !0), a && a.apply(o, s || [])
                        }
                    }));
                return o
            }, e.tweenFromTo = function(t, e, i) {
                return this.tweenTo(e, z({
                    startAt: {
                        time: X(this, t)
                    }
                }, i))
            }, e.recent = function() {
                return this._recent
            }, e.nextLabel = function(t) {
                return void 0 === t && (t = this._time), ct(this, X(this, t))
            }, e.previousLabel = function(t) {
                return void 0 === t && (t = this._time), ct(this, X(this, t), 1)
            }, e.currentLabel = function(t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + $t)
            }, e.shiftChildren = function(t, e, i) {
                void 0 === i && (i = 0);
                for (var n, r = this._first, a = this.labels; r;) r._start >= i && (r._start += t, r._end += t), r = r._next;
                if (e)
                    for (n in a) a[n] >= i && (a[n] += t);
                return x(this)
            }, e.invalidate = function() {
                var t = this._first;
                for (this._lock = 0; t;) t.invalidate(), t = t._next;
                return n.prototype.invalidate.call(this)
            }, e.clear = function(t) {
                void 0 === t && (t = !0);
                for (var e, i = this._first; i;) e = i._next, this.remove(i), i = e;
                return this._time = this._tTime = this._pTime = 0, t && (this.labels = {}), x(this)
            }, e.totalDuration = function(t) {
                var e, i, n, r = 0,
                    a = this,
                    s = a._last,
                    o = Zt;
                if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t));
                if (a._dirty) {
                    for (n = a.parent; s;) e = s._prev, s._dirty && s.totalDuration(), o < (i = s._start) && a._sort && s._ts && !a._lock ? (a._lock = 1, U(a, s, i - s._delay, 1)._lock = 0) : o = i, i < 0 && s._ts && (r -= i, (!n && !a._dp || n && n.smoothChildTiming) && (a._start += i / a._ts, a._time -= i, a._tTime -= i), a.shiftChildren(-i, !1, -Infinity), o = 0), s._end > r && s._ts && (r = s._end), s = e;
                    W(a, a === Mt && a._time > r ? a._time : r, 1, 1), a._dirty = 0
                }
                return a._tDur
            }, t.updateRoot = function(t) {
                if (Mt._ts && (p(Mt, w(t, Mt)), Dt = Fe.frame), Fe.frame >= be) {
                    be += Yt.autoSleep || 120;
                    var e = Mt._first;
                    if ((!e || !e._ts) && Yt.autoSleep && Fe._listeners.length < 2) {
                        for (; e && !e._ts;) e = e._next;
                        e || Fe.sleep()
                    }
                }
            }, t
        }(He);
        i.TimelineLite = i.TimelineMax = i.Timeline = We, z(We.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });

        function qe(t, e, i, n, r, a) {
            var s, o, l, h;
            if (ve[t] && !1 !== (s = new ve[t]).init(r, s.rawVars ? e[t] : function(t, e, i, n, r) {
                    if (d(t) && (t = Ze(t, r, e, i, n)), !E(t) || t.style && t.nodeType || ae(t) || re(t)) return S(t) ? Ze(t, r, e, i, n) : t;
                    var a, s = {};
                    for (a in t) s[a] = Ze(t[a], r, e, i, n);
                    return s
                }(e[t], n, r, a, i), i, n, a) && (i._pt = o = new di(i._pt, r, t, 0, 1, s.render, s, 0, s.priority), i !== Pt))
                for (l = i._ptLookup[i._targets.indexOf(r)], h = s._props.length; h--;) l[s._props[h]] = o;
            return s
        }
        var Xe, Ye = function(t, e, i, n, r, a, s, o, l) {
                d(n) && (n = n(r || 0, t, a));
                var h, u = t[e],
                    c = "get" !== i ? i : d(u) ? l ? t[e.indexOf("set") || !d(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u,
                    p = d(u) ? l ? ri : ni : ii;
                if (S(n) && (~n.indexOf("random(") && (n = ht(n)), "=" === n.charAt(1) && (n = parseFloat(c) + parseFloat(n.substr(2)) * ("-" === n.charAt(0) ? -1 : 1) + (J(c) || 0))), c !== n) return isNaN(c * n) ? function(t, e, i, n, r, a, s) {
                    var o, l, h, u, c, p, d, f, m = new di(this._pt, t, e, 0, 1, li, null, r),
                        g = 0,
                        v = 0;
                    for (m.b = i, m.e = n, i += "", (d = ~(n += "").indexOf("random(")) && (n = ht(n)), a && (a(f = [i, n], t, e), i = f[0], n = f[1]), l = i.match(he) || []; o = he.exec(n);) u = o[0], c = n.substring(g, o.index), h ? h = (h + 1) % 5 : "rgba(" === c.substr(-5) && (h = 1), u !== l[v++] && (p = parseFloat(l[v - 1]) || 0, m._pt = {
                        _next: m._pt,
                        p: c || 1 === v ? c : ",",
                        s: p,
                        c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - p,
                        m: h && h < 4 ? Math.round : 0
                    }, g = he.lastIndex);
                    return m.c = g < n.length ? n.substring(g, n.length) : "", m.fp = s, (ue.test(n) || d) && (m.e = 0), this._pt = m
                }.call(this, t, e, c, n, p, o || Yt.stringFilter, l) : (h = new di(this._pt, t, e, +c || 0, n - (c || 0), "boolean" == typeof u ? oi : si, 0, p), l && (h.fp = l), s && h.modifier(s, this, t), this._pt = h)
            },
            Je = function t(e, i) {
                var n, r, a, s, o, l, h, u, c, p, d, f, m, g = e.vars,
                    v = g.ease,
                    y = g.startAt,
                    b = g.immediateRender,
                    x = g.lazy,
                    _ = g.onUpdate,
                    w = g.onUpdateParams,
                    S = g.callbackScope,
                    M = g.runBackwards,
                    T = g.yoyoEase,
                    C = g.keyframes,
                    A = g.autoRevert,
                    E = e._dur,
                    D = e._startAt,
                    P = e._targets,
                    L = e.parent,
                    k = L && "nested" === L.data ? L.parent._targets : P,
                    O = "auto" === e._overwrite,
                    F = e.timeline;
                if (!F || C && v || (v = "none"), e._ease = Ge(v, Jt.ease), e._yEase = T ? ze(Ge(!0 === T ? v : T, Jt.ease)) : 0, T && e._yoyo && !e._repeat && (T = e._yEase, e._yEase = e._ease, e._ease = T), !F) {
                    if (f = (u = P[0] ? B(P[0]).harness : 0) && g[u.prop], n = G(g, fe), D && D.render(-1, !0).kill(), y) {
                        if (V(e._startAt = Qe.set(P, z({
                                data: "isStart",
                                overwrite: !1,
                                parent: L,
                                immediateRender: !0,
                                lazy: I(x),
                                startAt: null,
                                delay: 0,
                                onUpdate: _,
                                onUpdateParams: w,
                                callbackScope: S,
                                stagger: 0
                            }, y))), b)
                            if (0 < i) A || (e._startAt = 0);
                            else if (E && !(i < 0 && D)) return void(i && (e._zTime = i))
                    } else if (M && E)
                        if (D) A || (e._startAt = 0);
                        else if (i && (b = !1), a = z({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: b && I(x),
                            immediateRender: b,
                            stagger: 0,
                            parent: L
                        }, n), f && (a[u.prop] = f), V(e._startAt = Qe.set(P, a)), b) {
                        if (!i) return
                    } else t(e._startAt, $t);
                    for (e._pt = 0, x = E && I(x) || x && !E, r = 0; r < P.length; r++) {
                        if (h = (o = P[r])._gsap || N(P)[r]._gsap, e._ptLookup[r] = p = {}, ge[h.id] && me.length && R(), d = k === P ? r : k.indexOf(o), u && !1 !== (c = new u).init(o, f || n, e, d, k) && (e._pt = s = new di(e._pt, o, c.name, 0, 1, c.render, c, 0, c.priority), c._props.forEach(function(t) {
                                p[t] = s
                            }), c.priority && (l = 1)), !u || f)
                            for (a in n) ve[a] && (c = qe(a, n, e, d, o, k)) ? c.priority && (l = 1) : p[a] = s = Ye.call(e, o, a, "get", n[a], d, k, 0, g.stringFilter);
                        e._op && e._op[r] && e.kill(o, e._op[r]), O && e._pt && (Xe = e, Mt.killTweensOf(o, p, e.globalTime(0)), m = !e.parent, Xe = 0), e._pt && x && (ge[h.id] = 1)
                    }
                    l && pi(e), e._onInit && e._onInit(e)
                }
                e._from = !F && !!g.runBackwards, e._onUpdate = _, e._initted = (!e._op || e._pt) && !m
            },
            Ze = function(t, e, i, n, r) {
                return d(t) ? t.call(e, i, n, r) : S(t) && ~t.indexOf("random(") ? ht(t) : t
            },
            $e = _e + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
            Ke = ($e + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");
        i._checkPlugin = qe;
        var Qe = function(T) {
            function r(t, e, i, n) {
                var r;
                "number" == typeof e && (i.duration = e, e = i, i = null);
                var a, s, o, l, h, u, c, p, d = (r = T.call(this, n ? e : O(e), i) || this).vars,
                    f = d.duration,
                    m = d.delay,
                    g = d.immediateRender,
                    v = d.stagger,
                    y = d.overwrite,
                    b = d.keyframes,
                    x = d.defaults,
                    _ = d.scrollTrigger,
                    w = d.yoyoEase,
                    S = r.parent,
                    M = (ae(t) || re(t) ? A(t[0]) : "length" in e) ? [t] : Ae(t);
                if (r._targets = M.length ? N(M) : P(0, !Yt.nullTargetWarn) || [], r._ptLookup = [], r._overwrite = y, b || v || D(f) || D(m)) {
                    if (e = r.vars, (a = r.timeline = new We({
                            data: "nested",
                            defaults: x || {}
                        })).kill(), a.parent = C(r), b) z(a.vars.defaults, {
                        ease: "none"
                    }), b.forEach(function(t) {
                        return a.to(M, t, ">")
                    });
                    else {
                        if (l = M.length, c = v ? Q(v) : L, E(v))
                            for (h in v) ~$e.indexOf(h) && ((p = p || {})[h] = v[h]);
                        for (s = 0; s < l; s++) {
                            for (h in o = {}, e) Ke.indexOf(h) < 0 && (o[h] = e[h]);
                            o.stagger = 0, w && (o.yoyoEase = w), p && we(o, p), u = M[s], o.duration = +Ze(f, C(r), s, u, M), o.delay = (+Ze(m, C(r), s, u, M) || 0) - r._delay, !v && 1 === l && o.delay && (r._delay = m = o.delay, r._start += m, o.delay = 0), a.to(u, o, c(s, u, M))
                        }
                        a.duration() ? f = m = 0 : r.timeline = 0
                    }
                    f || r.duration(f = a.duration())
                } else r.timeline = 0;
                return !0 === y && (Xe = C(r), Mt.killTweensOf(M), Xe = 0), S && F(S, C(r)), (g || !f && !b && r._start === k(S._time) && I(g) && function t(e) {
                    return !e || e._ts && t(e.parent)
                }(C(r)) && "nested" !== S.data) && (r._tTime = -$t, r.render(Math.max(0, -m))), _ && j(C(r), _), r
            }
            a(r, T);
            var t = r.prototype;
            return t.render = function(t, e, i) {
                var n, r, a, s, o, l, h, u, c, p = this._time,
                    d = this._tDur,
                    f = this._dur,
                    m = d - $t < t && 0 <= t ? d : t < $t ? 0 : t;
                if (f) {
                    if (m !== this._tTime || !t || i || this._startAt && this._zTime < 0 != t < 0) {
                        if (n = m, u = this.timeline, this._repeat) {
                            if (s = f + this._rDelay, n = k(m % s), m === d ? (a = this._repeat, n = f) : ((a = ~~(m / s)) && a === m / s && (n = f, a--), f < n && (n = f)), (l = this._yoyo && 1 & a) && (c = this._yEase, n = f - n), o = Se(this._tTime, s), n === p && !i && this._initted) return this;
                            a !== o && (u && this._yEase && bt(u, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = i = 1, this.render(k(s * a), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (H(this, t < 0 ? t : n, i, e)) return this._tTime = 0, this;
                            if (f !== this._dur) return this.render(t, e, i)
                        }
                        for (this._tTime = m, this._time = n, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = h = (c || this._ease)(n / f), this._from && (this.ratio = h = 1 - h), !n || p || e || De(this, "onStart"), r = this._pt; r;) r.r(h, r.d), r = r._next;
                        u && u.render(t < 0 ? t : !n && l ? -$t : u._dur * h, e, i) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, i), De(this, "onUpdate")), this._repeat && a !== o && this.vars.onRepeat && !e && this.parent && De(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), !t && f || !(m === this._tDur && 0 < this._ts || !m && this._ts < 0) || V(this, 1), e || t < 0 && !p || !m && !p || (De(this, m === d ? "onComplete" : "onReverseComplete", !0), !this._prom || m < d && 0 < this.timeScale() || this._prom()))
                    }
                } else ! function(t, e, i, n) {
                    var r, a, s = t.ratio,
                        o = e < 0 || !e && s && !t._start && t._zTime > $t && !t._dp._lock || (t._ts < 0 || t._dp._ts < 0) && "isFromStart" !== t.data && "isStart" !== t.data ? 0 : 1,
                        l = t._rDelay,
                        h = 0;
                    if (l && t._repeat && (h = Te(0, t._tDur, e), Se(h, l) !== (a = Se(t._tTime, l)) && (s = 1 - o, t.vars.repeatRefresh && t._initted && t.invalidate())), o !== s || n || t._zTime === $t || !e && t._zTime) {
                        if (!t._initted && H(t, e, n, i)) return;
                        for (a = t._zTime, t._zTime = e || (i ? $t : 0), i = i || e && !a, t.ratio = o, t._from && (o = 1 - o), t._time = 0, t._tTime = h, i || De(t, "onStart"), r = t._pt; r;) r.r(o, r.d), r = r._next;
                        t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !i && De(t, "onUpdate"), h && t._repeat && !i && t.parent && De(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === o && (o && V(t, 1), i || (De(t, o ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                    } else t._zTime || (t._zTime = e)
                }(this, t, e, i);
                return this
            }, t.targets = function() {
                return this._targets
            }, t.invalidate = function() {
                return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), T.prototype.invalidate.call(this)
            }, t.kill = function(t, e) {
                if (void 0 === e && (e = "all"), !(t || e && "all" !== e) && (this._lazy = 0, this.parent)) return pt(this);
                if (this.timeline) {
                    var i = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(t, e, Xe && !0 !== Xe.vars.overwrite)._first || pt(this), this.parent && i !== this.timeline.totalDuration() && W(this, this._dur * this.timeline._tDur / i, 0, 1), this
                }
                var n, r, a, s, o, l, h, u = this._targets,
                    c = t ? Ae(t) : u,
                    p = this._ptLookup,
                    d = this._pt;
                if ((!e || "all" === e) && function(t, e) {
                        for (var i = t.length, n = i === e.length; n && i-- && t[i] === e[i];);
                        return i < 0
                    }(u, c)) return "all" === e && (this._pt = 0), pt(this);
                for (n = this._op = this._op || [], "all" !== e && (S(e) && (o = {}, f(e, function(t) {
                        return o[t] = 1
                    }), e = o), e = function(t, e) {
                        var i, n, r, a, s = t[0] ? B(t[0]).harness : 0,
                            o = s && s.aliases;
                        if (!o) return e;
                        for (n in i = we({}, e), o)
                            if (n in i)
                                for (r = (a = o[n].split(",")).length; r--;) i[a[r]] = i[n];
                        return i
                    }(u, e)), h = u.length; h--;)
                    if (~c.indexOf(u[h]))
                        for (o in r = p[h], "all" === e ? (n[h] = e, s = r, a = {}) : (a = n[h] = n[h] || {}, s = e), s)(l = r && r[o]) && ("kill" in l.d && !0 !== l.d.kill(o) || b(this, l, "_pt"), delete r[o]), "all" !== a && (a[o] = 1);
                return this._initted && !this._pt && d && pt(this), this
            }, r.to = function(t, e, i) {
                return new r(t, e, i)
            }, r.from = function(t, e) {
                return new r(t, c(arguments, 1))
            }, r.delayedCall = function(t, e, i, n) {
                return new r(e, 0, {
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: e,
                    onReverseComplete: e,
                    onCompleteParams: i,
                    onReverseCompleteParams: i,
                    callbackScope: n
                })
            }, r.fromTo = function(t, e, i) {
                return new r(t, c(arguments, 2))
            }, r.set = function(t, e) {
                return e.duration = 0, e.repeatDelay || (e.repeat = 0), new r(t, e)
            }, r.killTweensOf = function(t, e, i) {
                return Mt.killTweensOf(t, e, i)
            }, r
        }(He);
        i.TweenLite = i.TweenMax = i.Tween = Qe, z(Qe.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), f("staggerTo,staggerFrom,staggerFromTo", function(i) {
            Qe[i] = function() {
                var t = new We,
                    e = Ce.call(arguments, 0);
                return e.splice("staggerFromTo" === i ? 5 : 4, 0, 0), t[i].apply(t, e)
            }
        });

        function ti(t, e, i) {
            return t.setAttribute(e, i)
        }

        function ei(t, e, i, n) {
            n.mSet(t, e, n.m.call(n.tween, i, n.mt), n)
        }
        var ii = function(t, e, i) {
                return t[e] = i
            },
            ni = function(t, e, i) {
                return t[e](i)
            },
            ri = function(t, e, i, n) {
                return t[e](n.fp, i)
            },
            ai = function(t, e) {
                return d(t[e]) ? ni : r(t[e]) && t.setAttribute ? ti : ii
            },
            si = function(t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e)
            },
            oi = function(t, e) {
                return e.set(e.t, e.p, !!(e.s + e.c * t), e)
            },
            li = function(t, e) {
                var i = e._pt,
                    n = "";
                if (!t && e.b) n = e.b;
                else if (1 === t && e.e) n = e.e;
                else {
                    for (; i;) n = i.p + (i.m ? i.m(i.s + i.c * t) : Math.round(1e4 * (i.s + i.c * t)) / 1e4) + n, i = i._next;
                    n += e.c
                }
                e.set(e.t, e.p, n, e)
            },
            hi = function(t, e) {
                for (var i = e._pt; i;) i.r(t, i.d), i = i._next
            },
            ui = function(t, e, i, n) {
                for (var r, a = this._pt; a;) r = a._next, a.p === n && a.modifier(t, e, i), a = r
            },
            ci = function(t) {
                for (var e, i, n = this._pt; n;) i = n._next, n.p === t && !n.op || n.op === t ? b(this, n, "_pt") : n.dep || (e = 1), n = i;
                return !e
            },
            pi = function(t) {
                for (var e, i, n, r, a = t._pt; a;) {
                    for (e = a._next, i = n; i && i.pr > a.pr;) i = i._next;
                    (a._prev = i ? i._prev : r) ? a._prev._next = a: n = a, (a._next = i) ? i._prev = a : r = a, a = e
                }
                t._pt = n
            };
        i._sortPropTweensByPriority = pi, i._renderComplexString = li, i._getSetter = ai;
        var di = function() {
            function t(t, e, i, n, r, a, s, o, l) {
                this.t = e, this.s = n, this.c = r, this.p = i, this.r = a || si, this.d = s || this, this.set = o || ii, this.pr = l || 0, (this._next = t) && (t._prev = this)
            }
            return t.prototype.modifier = function(t, e, i) {
                this.mSet = this.mSet || this.set, this.set = ei, this.m = t, this.mt = i, this.tween = e
            }, t
        }();
        i.PropTween = di, f(_e + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(t) {
            return fe[t] = 1
        }), pe.TweenMax = pe.TweenLite = Qe, pe.TimelineLite = pe.TimelineMax = We, Mt = new We({
            sortChildren: !1,
            defaults: Jt,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), Yt.stringFilter = vt;
        var fi = {
            registerPlugin: function() {
                for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                e.forEach(function(t) {
                    var e = (t = !t.name && t.default || t).name,
                        i = d(t),
                        n = e && !i && t.init ? function() {
                            this._props = []
                        } : t,
                        r = {
                            init: L,
                            render: hi,
                            add: Ye,
                            kill: ci,
                            modifier: ui,
                            rawVars: 0
                        },
                        a = {
                            targetTest: 0,
                            get: 0,
                            getSetter: ai,
                            aliases: {},
                            register: 0
                        };
                    if (Ie(), t !== n) {
                        if (ve[e]) return;
                        z(n, z(G(t, r), a)), we(n.prototype, we(r, G(t, a))), ve[n.prop = e] = n, t.targetTest && (xe.push(n), fe[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                    }
                    h(e, n), t.register && t.register(gi, n, di)
                })
            },
            timeline: function(t) {
                return new We(t)
            },
            getTweensOf: function(t, e) {
                return Mt.getTweensOf(t, e)
            },
            getProperty: function(n, t, e, i) {
                S(n) && (n = Ae(n)[0]);
                var r = B(n || {}).get,
                    a = e ? g : m;
                return "native" === e && (e = ""), n ? t ? a((ve[t] && ve[t].get || r)(n, t, e, i)) : function(t, e, i) {
                    return a((ve[t] && ve[t].get || r)(n, t, e, i))
                } : n
            },
            quickSetter: function(i, e, n) {
                if (1 < (i = Ae(i)).length) {
                    var r = i.map(function(t) {
                            return gi.quickSetter(t, e, n)
                        }),
                        a = r.length;
                    return function(t) {
                        for (var e = a; e--;) r[e](t)
                    }
                }
                i = i[0] || {};
                var s = ve[e],
                    o = B(i),
                    l = o.harness && (o.harness.aliases || {})[e] || e,
                    h = s ? function(t) {
                        var e = new s;
                        Pt._pt = 0, e.init(i, n ? t + n : t, Pt, 0, [i]), e.render(1, e), Pt._pt && hi(1, Pt)
                    } : o.set(i, l);
                return s ? h : function(t) {
                    return h(i, l, n ? t + n : t, o, 1)
                }
            },
            isTweening: function(t) {
                return 0 < Mt.getTweensOf(t, !0).length
            },
            defaults: function(t) {
                return t && t.ease && (t.ease = Ge(t.ease, Jt.ease)), y(Jt, t || {})
            },
            config: function(t) {
                return y(Yt, t || {})
            },
            registerEffect: function(t) {
                var n = t.name,
                    r = t.effect,
                    e = t.plugins,
                    a = t.defaults,
                    i = t.extendTimeline;
                (e || "").split(",").forEach(function(t) {
                    return t && !ve[t] && !pe[t] && P()
                }), ye[n] = function(t, e, i) {
                    return r(Ae(t), z(e || {}, a), i)
                }, i && (We.prototype[n] = function(t, e, i) {
                    return this.add(ye[n](t, E(e) ? e : (i = e) && {}, this), i)
                })
            },
            registerEase: function(t, e) {
                Ne[t] = Ge(e)
            },
            parseEase: function(t, e) {
                return arguments.length ? Ge(t, e) : Ne
            },
            getById: function(t) {
                return Mt.getById(t)
            },
            exportRoot: function(t, e) {
                void 0 === t && (t = {});
                var i, n, r = new We(t);
                for (r.smoothChildTiming = I(t.smoothChildTiming), Mt.remove(r), r._dp = 0, r._time = r._tTime = Mt._time, i = Mt._first; i;) n = i._next, !e && !i._dur && i instanceof Qe && i.vars.onComplete === i._targets[0] || U(r, i, i._start - i._delay), i = n;
                return U(Mt, r, 0), r
            },
            utils: {
                wrap: ot,
                wrapYoyo: lt,
                distribute: Q,
                random: it,
                snap: et,
                normalize: at,
                getUnit: J,
                clamp: Z,
                splitColor: ft,
                toArray: Ae,
                mapRange: Ee,
                pipe: nt,
                unitize: rt,
                interpolate: ut,
                shuffle: K
            },
            install: o,
            effects: ye,
            ticker: Fe,
            updateRoot: We.updateRoot,
            plugins: ve,
            globalTimeline: Mt,
            core: {
                PropTween: di,
                globals: h,
                Tween: Qe,
                Timeline: We,
                Animation: He,
                getCache: B,
                _removeLinkedListItem: b
            }
        };
        f("to,from,fromTo,delayedCall,set,killTweensOf", function(t) {
            return fi[t] = Qe[t]
        }), Fe.add(We.updateRoot), Pt = fi.to({}, {
            duration: 0
        });

        function mi(t, r) {
            return {
                name: t,
                rawVars: 1,
                init: function(t, n, e) {
                    e._onInit = function(t) {
                        var e, i;
                        if (S(n) && (e = {}, f(n, function(t) {
                                return e[t] = 1
                            }), n = e), r) {
                            for (i in e = {}, n) e[i] = r(n[i]);
                            n = e
                        }! function(t, e) {
                            var i, n, r, a = t._targets;
                            for (i in e)
                                for (n = a.length; n--;)(r = (r = t._ptLookup[n][i]) && r.d) && (r._pt && (r = function(t, e) {
                                    for (var i = t._pt; i && i.p !== e && i.op !== e && i.fp !== e;) i = i._next;
                                    return i
                                }(r, i)), r && r.modifier && r.modifier(e[i], t, a[n], i))
                        }(t, n)
                    }
                }
            }
        }
        var gi = fi.registerPlugin({
            name: "attr",
            init: function(t, e, i, n, r) {
                var a, s;
                for (a in e)(s = this.add(t, "setAttribute", (t.getAttribute(a) || 0) + "", e[a], n, r, 0, 0, a)) && (s.op = a), this._props.push(a)
            }
        }, {
            name: "endArray",
            init: function(t, e) {
                for (var i = e.length; i--;) this.add(t, i, t[i] || 0, e[i])
            }
        }, mi("roundProps", tt), mi("modifiers"), mi("snap", et)) || fi;
        i.default = i.gsap = gi, Qe.version = We.version = gi.version = "3.5.1", Et = 1, s() && Ie();
        var vi = Ne.Power0,
            yi = Ne.Power1,
            bi = Ne.Power2,
            xi = Ne.Power3,
            _i = Ne.Power4,
            wi = Ne.Linear,
            Si = Ne.Quad,
            Mi = Ne.Cubic,
            Ti = Ne.Quart,
            Ci = Ne.Quint,
            Ai = Ne.Strong,
            Ei = Ne.Elastic,
            Di = Ne.Back,
            Pi = Ne.SteppedEase,
            Li = Ne.Bounce,
            ki = Ne.Sine,
            Oi = Ne.Expo,
            Fi = Ne.Circ;
        i.Circ = Fi, i.Expo = Oi, i.Sine = ki, i.Bounce = Li, i.SteppedEase = Pi, i.Back = Di, i.Elastic = Ei, i.Strong = Ai, i.Quint = Ci, i.Quart = Ti, i.Cubic = Mi, i.Quad = Si, i.Linear = wi, i.Power4 = _i, i.Power3 = xi, i.Power2 = bi, i.Power1 = yi, i.Power0 = vi
    }, {}],
    2: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.getText = function t(e) {
            var i = e.nodeType,
                n = "";
            if (1 === i || 9 === i || 11 === i) {
                if ("string" == typeof e.textContent) return e.textContent;
                for (e = e.firstChild; e; e = e.nextSibling) n += t(e)
            } else if (3 === i || 4 === i) return e.nodeValue;
            return n
        }, i.splitInnerHTML = function(t, e, i) {
            var n = t.firstChild,
                r = [];
            for (; n;) 3 === n.nodeType ? r.push.apply(r, a((n.nodeValue + "").replace(/^\n+/g, "").replace(/\s+/g, " "), e, i)) : "br" === (n.nodeName + "").toLowerCase() ? r[r.length - 1] += "<br>" : r.push(n.outerHTML), n = n.nextSibling;
            return r
        }, i.emojiSafeSplit = a, i.emojiExp = void 0;
        var l = /(^\s+|\s+$)/g,
            h = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

        function a(t, e, i) {
            if (t += "", i && (t = t.replace(l, "")), e && "" !== e) return t.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(e);
            for (var n, r, a = [], s = t.length, o = 0; o < s; o++)(55296 <= (r = t.charAt(o)).charCodeAt(0) && r.charCodeAt(0) <= 56319 || 65024 <= t.charCodeAt(o + 1) && t.charCodeAt(o + 1) <= 65039) && (n = ((t.substr(o, 12).split(h) || [])[1] || "").length || 2, r = t.substr(o, n), o += n - (a.emoji = 1)), a.push(">" === r ? "&gt;" : "<" === r ? "&lt;" : r);
            return a
        }
        i.emojiExp = h
    }, {}],
    3: [function(t, e, i) {
        "use strict";
        var n, r;
        n = function(t) {
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            var s = {
                getAttribute: function(t, e) {
                    return t[e]
                },
                setAttribute: function(t, e, i) {
                    t[e] = i
                },
                wrap: function(t, e) {
                    var i;
                    t && ((i = document.createElement("div")).className = e, t.parentNode.insertBefore(i, t), t.parentNode.removeChild(t), i.appendChild(t))
                },
                addClass: function(t, e) {
                    t && (t.classList ? t.classList.add(e) : t.className += " " + e)
                },
                removeClass: function(t, e) {
                    t && (t.classList ? t.classList.remove(e) : t.className = t.className.replace(new RegExp("(^|\\b)" + e.split(" ").join("|") + "(\\b|$)", "gi"), " "))
                },
                hasClass: function(t, e) {
                    return t.classList ? t.classList.contains(e) : new RegExp("(^| )" + e + "( |$)", "gi").test(t.className)
                },
                setVendor: function(t, e, i) {
                    t && (t.style[e.charAt(0).toLowerCase() + e.slice(1)] = i, t.style["webkit" + e] = i, t.style["moz" + e] = i, t.style["ms" + e] = i, t.style["o" + e] = i)
                },
                trigger: function(t, e, i) {
                    var n;
                    t && (n = new CustomEvent(e, {
                        detail: 2 < arguments.length && void 0 !== i ? i : null
                    }), t.dispatchEvent(n))
                },
                Listener: {
                    uid: 0
                },
                on: function(i, t, n) {
                    var r = this;
                    i && t.split(" ").forEach(function(t) {
                        var e = r.getAttribute(i, "lg-event-uid") || "";
                        s.Listener.uid++, e += "&" + s.Listener.uid, r.setAttribute(i, "lg-event-uid", e), s.Listener[t + s.Listener.uid] = n, i.addEventListener(t.split(".")[0], n, !1)
                    })
                },
                off: function(t, e) {
                    if (t) {
                        var i = this.getAttribute(t, "lg-event-uid");
                        if (i) {
                            i = i.split("&");
                            for (var n = 0; n < i.length; n++)
                                if (i[n]) {
                                    var r = e + i[n];
                                    if ("." === r.substring(0, 1))
                                        for (var a in s.Listener) s.Listener.hasOwnProperty(a) && -1 < a.split(".").indexOf(r.split(".")[1]) && (t.removeEventListener(a.split(".")[0], s.Listener[a]), this.setAttribute(t, "lg-event-uid", this.getAttribute(t, "lg-event-uid").replace("&" + i[n], "")), delete s.Listener[a]);
                                    else t.removeEventListener(r.split(".")[0], s.Listener[r]), this.setAttribute(t, "lg-event-uid", this.getAttribute(t, "lg-event-uid").replace("&" + i[n], "")), delete s.Listener[r]
                                }
                        }
                    }
                },
                param: function(e) {
                    return Object.keys(e).map(function(t) {
                        return encodeURIComponent(t) + "=" + encodeURIComponent(e[t])
                    }).join("&")
                }
            };
            t.default = s
        }, "function" == typeof define && define.amd ? define(["exports"], n) : void 0 !== i ? n(i) : (n(r = {}), (void 0).lgUtils = r)
    }, {}],
    4: [function(t, e, i) {
        "use strict";
        var n;

        function h(t, e, i) {
            return (h = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, i) {
                var n = function(t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t)););
                    return t
                }(t, e);
                if (n) {
                    var r = Object.getOwnPropertyDescriptor(n, e);
                    return r.get ? r.get.call(i) : r.value
                }
            })(t, e, i || t)
        }

        function W(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function a(t) {
            return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function d(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && r(t, e)
        }

        function r(t, e) {
            return (r = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function y(i) {
            var n = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var t, e = f(i);
                return o(this, n ? (t = f(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments))
            }
        }

        function o(t, e) {
            return !e || "object" !== a(e) && "function" != typeof e ? u(t) : e
        }

        function u(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function f(t) {
            return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }

        function V(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function s(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        function g(t, e, i) {
            return e && s(t.prototype, e), i && s(t, i), t
        }
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.AmbientLight = Ju, i.AmbientLightProbe = vc, i.AnimationClip = iu, i.AnimationLoader = uu, i.AnimationMixer = Jc, i.AnimationObjectGroup = Xc, i.ArcCurve = yu, i.ArrayCamera = lo, i.AudioLoader = mc, i.AxisHelper = function(t) {
            return new zp(t)
        }, i.BinaryTextureLoader = function(t) {
            return new fu(t)
        }, i.Bone = Zo, i.BooleanKeyframeTrack = Jh, i.BoundingBoxHelper = function(t, e) {
            return new kp(t, e)
        }, i.BufferAttribute = $n, i.BufferGeometry = gr, i.BufferGeometryLoader = nc, i.Camera = Zr, i.CanvasRenderer = function() {}, i.CanvasTexture = wl, i.CatmullRomCurve3 = Mu, i.ClosedSplineCurve3 = od, i.ColorKeyframeTrack = Zh, i.CompressedTexture = _l, i.CompressedTextureLoader = cu, i.CubeCamera = ta, i.CubeTexture = Aa, i.CubeTextureLoader = du, i.CubicBezierCurve = Eu, i.CubicBezierCurve3 = Du, i.CubicInterpolant = Wh, i.Curve = gu, i.CurvePath = Nu, i.DataTexture = ia, i.DataTexture2DArray = Ea, i.DataTexture3D = Da, i.DataTextureLoader = fu, i.DepthTexture = Sl, i.DirectionalLight = Yu, i.DiscreteInterpolant = Xh, i.DynamicBufferAttribute = function(t, e) {
            return new $n(t, e).setUsage(ai)
        }, i.EdgesHelper = function(t, e) {
            return new cl(new Mh(t.geometry), new il({
                color: void 0 !== e ? e : 16777215
            }))
        }, i.EllipseCurve = vu, i.EventDispatcher = oi, i.Face4 = function(t, e, i, n, r, a, s) {
            return new Wn(t, e, i, r, a, s)
        }, i.FileLoader = hu, i.Float32Attribute = function(t, e) {
            return new ar(t, e)
        }, i.Float32BufferAttribute = ar, i.Float64Attribute = function(t, e) {
            return new sr(t, e)
        }, i.Float64BufferAttribute = sr, i.Font = pc, i.FontLoader = dc, i.GLBufferAttribute = Kc, i.Geometry = Vr, i.Group = ho, i.HemisphereLight = Gu, i.HemisphereLightProbe = gc, i.ImageBitmapLoader = uc, i.ImageLoader = pu, i.ImmediateRenderObject = hp, i.InstancedBufferAttribute = ic, i.InstancedBufferGeometry = ec, i.InstancedInterleavedBuffer = $c, i.InstancedMesh = el, i.Int16Attribute = function(t, e) {
            return new er(t, e)
        }, i.Int16BufferAttribute = er, i.Int32Attribute = function(t, e) {
            return new nr(t, e)
        }, i.Int32BufferAttribute = nr, i.Int8Attribute = function(t, e) {
            return new Kn(t, e)
        }, i.Int8BufferAttribute = Kn, i.InterleavedBuffer = bo, i.InterleavedBufferAttribute = wo, i.Interpolant = Hh, i.JSONLoader = function() {}, i.KeyframeTrack = Yh, i.LOD = Wo, i.LensFlare = function() {}, i.Light = zu, i.LightProbe = Ku, i.LightShadow = Vu, i.Line = ll, i.LineBasicMaterial = il, i.LineCurve = Pu, i.LineCurve3 = Lu, i.LineDashedMaterial = Vh, i.LineLoop = pl, i.LineSegments = cl, i.LinearInterpolant = qh, i.Loader = ou, i.LoadingManager = au, i.Material = Xn, i.MaterialLoader = Qu, i.Mesh = Fr, i.MeshBasicMaterial = Yn, i.MeshDepthMaterial = to, i.MeshDistanceMaterial = eo, i.MeshFaceMaterial = function(t) {
            return t
        }, i.MeshLambertMaterial = zh, i.MeshMatcapMaterial = Gh, i.MeshNormalMaterial = Rh, i.MeshPhongMaterial = Nh, i.MeshPhysicalMaterial = Ih, i.MeshStandardMaterial = Fh, i.MeshToonMaterial = Bh, i.MultiMaterial = function(t) {
            void 0 === t && (t = []);
            return t.isMultiMaterial = !0, (t.materials = t).clone = function() {
                return t.slice()
            }, t
        }, i.NumberKeyframeTrack = $h, i.Object3D = wn, i.ObjectLoader = ac, i.OrthographicCamera = qu, i.ParametricBufferGeometry = Cl, i.ParametricGeometry = Tl, i.Particle = function(t) {
            return new No(t)
        }, i.ParticleBasicMaterial = function(t) {
            return new dl(t)
        }, i.ParticleSystem = function(t, e) {
            return new yl(t, e)
        }, i.ParticleSystemMaterial = function(t) {
            return new dl(t)
        }, i.Path = Bu, i.PerspectiveCamera = $r, i.PointCloud = function(t, e) {
            return new yl(t, e)
        }, i.PointCloudMaterial = function(t) {
            return new dl(t)
        }, i.PointLight = Wu, i.Points = yl, i.PointsMaterial = dl, i.PropertyBinding = qc, i.PropertyMixer = Fc, i.QuadraticBezierCurve = ku, i.QuadraticBezierCurve3 = Ou, i.QuaternionKeyframeTrack = Qh, i.QuaternionLinearInterpolant = Kh, i.RawShaderMaterial = Oh, i.Raycaster = Qc, i.RectAreaLight = Zu, i.ShaderMaterial = Jr, i.ShadowMaterial = kh, i.Shape = Ru, i.ShapePath = cc, i.Skeleton = Jo, i.SkinnedMesh = qo, i.Spline = hd, i.SplineCurve = Fu, i.SplineCurve3 = ld, i.SpotLight = ju, i.Sprite = No, i.SpriteMaterial = So, i.StereoCamera = xc, i.StringKeyframeTrack = tu, i.Texture = vi, i.TextureLoader = mu, i.Uint16Attribute = function(t, e) {
            return new ir(t, e)
        }, i.Uint16BufferAttribute = ir, i.Uint32Attribute = function(t, e) {
            return new rr(t, e)
        }, i.Uint32BufferAttribute = rr, i.Uint8Attribute = function(t, e) {
            return new Qn(t, e)
        }, i.Uint8BufferAttribute = Qn, i.Uint8ClampedAttribute = function(t, e) {
            return new tr(t, e)
        }, i.Uint8ClampedBufferAttribute = tr, i.VectorKeyframeTrack = eu, i.Vertex = function(t, e, i) {
            return new wi(t, e, i)
        }, i.VideoTexture = xl, i.WebGL1Renderer = mo, i.WebGLCubeRenderTarget = ea, i.WebGLMultisampleRenderTarget = xi, i.WebGLRenderTarget = bi, i.WebGLRenderTargetCube = function(t, e, i) {
            return new ea(t, i)
        }, i.WebGLRenderer = fo, i.WebGLUtils = oo, i.WireframeHelper = function(t, e) {
            return new cl(new Ml(t.geometry), new il({
                color: void 0 !== e ? e : 16777215
            }))
        }, i.XHRLoader = function(t) {
            return new hu(t)
        }, i.InvertStencilOp = i.InterpolateSmooth = i.InterpolateLinear = i.InterpolateDiscrete = i.IntType = i.IncrementWrapStencilOp = i.IncrementStencilOp = i.ImageUtils = i.IcosahedronGeometry = i.IcosahedronBufferGeometry = i.HemisphereLightHelper = i.HalfFloatType = i.GridHelper = i.GreaterStencilFunc = i.GreaterEqualStencilFunc = i.GreaterEqualDepth = i.GreaterDepth = i.GeometryUtils = i.GammaEncoding = i.GLSL3 = i.GLSL1 = i.Frustum = i.FrontSide = i.FogExp2 = i.Fog = i.FloatType = i.FlatShading = i.FaceColors = i.Face3 = i.ExtrudeGeometry = i.ExtrudeBufferGeometry = i.Euler = i.EquirectangularRefractionMapping = i.EquirectangularReflectionMapping = i.EqualStencilFunc = i.EqualDepth = i.EdgesGeometry = i.DynamicReadUsage = i.DynamicDrawUsage = i.DynamicCopyUsage = i.DstColorFactor = i.DstAlphaFactor = i.DoubleSide = i.DodecahedronGeometry = i.DodecahedronBufferGeometry = i.DirectionalLightHelper = i.DepthStencilFormat = i.DepthFormat = i.DefaultLoadingManager = i.DecrementWrapStencilOp = i.DecrementStencilOp = i.Cylindrical = i.CylinderGeometry = i.CylinderBufferGeometry = i.CustomToneMapping = i.CustomBlending = i.CullFaceNone = i.CullFaceFrontBack = i.CullFaceFront = i.CullFaceBack = i.CubeUVRefractionMapping = i.CubeUVReflectionMapping = i.CubeRefractionMapping = i.CubeReflectionMapping = i.ConeGeometry = i.ConeBufferGeometry = i.Color = i.Clock = i.ClampToEdgeWrapping = i.CircleGeometry = i.CircleBufferGeometry = i.CineonToneMapping = i.CameraHelper = i.Cache = i.ByteType = i.BoxHelper = i.CubeGeometry = i.BoxGeometry = i.BoxBufferGeometry = i.Box3Helper = i.Box3 = i.Box2 = i.BasicShadowMap = i.BasicDepthPacking = i.BackSide = i.AxesHelper = i.AudioListener = i.AudioContext = i.AudioAnalyser = i.Audio = i.ArrowHelper = i.AnimationUtils = i.AlwaysStencilFunc = i.AlwaysDepth = i.AlphaFormat = i.AdditiveBlending = i.AdditiveAnimationBlendMode = i.AddOperation = i.AddEquation = i.ACESFilmicToneMapping = void 0, i.RGBFormat = i.RGBEFormat = i.RGBEEncoding = i.RGBDEncoding = i.RGBA_S3TC_DXT5_Format = i.RGBA_S3TC_DXT3_Format = i.RGBA_S3TC_DXT1_Format = i.RGBA_PVRTC_4BPPV1_Format = i.RGBA_PVRTC_2BPPV1_Format = i.RGBA_ETC2_EAC_Format = i.RGBA_BPTC_Format = i.RGBA_ASTC_8x8_Format = i.RGBA_ASTC_8x6_Format = i.RGBA_ASTC_8x5_Format = i.RGBA_ASTC_6x6_Format = i.RGBA_ASTC_6x5_Format = i.RGBA_ASTC_5x5_Format = i.RGBA_ASTC_5x4_Format = i.RGBA_ASTC_4x4_Format = i.RGBA_ASTC_12x12_Format = i.RGBA_ASTC_12x10_Format = i.RGBA_ASTC_10x8_Format = i.RGBA_ASTC_10x6_Format = i.RGBA_ASTC_10x5_Format = i.RGBA_ASTC_10x10_Format = i.RGBAIntegerFormat = i.RGBAFormat = i.RGBADepthPacking = i.REVISION = i.Quaternion = i.PositionalAudio = i.PolyhedronGeometry = i.PolyhedronBufferGeometry = i.PolarGridHelper = i.PointLightHelper = i.PlaneHelper = i.PlaneGeometry = i.PlaneBufferGeometry = i.Plane = i.PMREMGenerator = i.PCFSoftShadowMap = i.PCFShadowMap = i.OneMinusSrcColorFactor = i.OneMinusSrcAlphaFactor = i.OneMinusDstColorFactor = i.OneMinusDstAlphaFactor = i.OneFactor = i.OctahedronGeometry = i.OctahedronBufferGeometry = i.ObjectSpaceNormalMap = i.NotEqualStencilFunc = i.NotEqualDepth = i.NormalBlending = i.NormalAnimationBlendMode = i.NoToneMapping = i.NoColors = i.NoBlending = i.NeverStencilFunc = i.NeverDepth = i.NearestMipmapNearestFilter = i.NearestMipmapLinearFilter = i.NearestMipMapNearestFilter = i.NearestMipMapLinearFilter = i.NearestFilter = i.MultiplyOperation = i.MultiplyBlending = i.MixOperation = i.MirroredRepeatWrapping = i.MinEquation = i.MaxEquation = i.Matrix4 = i.Matrix3 = i.MathUtils = i.Math = i.MOUSE = i.LuminanceFormat = i.LuminanceAlphaFormat = i.LoopRepeat = i.LoopPingPong = i.LoopOnce = i.LogLuvEncoding = i.LoaderUtils = i.LinearToneMapping = i.LinearMipmapNearestFilter = i.LinearMipmapLinearFilter = i.LinearMipMapNearestFilter = i.LinearMipMapLinearFilter = i.LinearFilter = i.LinearEncoding = i.LineStrip = i.LinePieces = i.Line3 = i.LessStencilFunc = i.LessEqualStencilFunc = i.LessEqualDepth = i.LessDepth = i.Layers = i.LatheGeometry = i.LatheBufferGeometry = i.KeepStencilOp = void 0, i.sRGBEncoding = i.ZeroStencilOp = i.ZeroSlopeEnding = i.ZeroFactor = i.ZeroCurvatureEnding = i.WrapAroundEnding = i.WireframeGeometry = i.VertexColors = i.Vector4 = i.Vector3 = i.Vector2 = i.VSMShadowMap = i.UnsignedShortType = i.UnsignedShort565Type = i.UnsignedShort5551Type = i.UnsignedShort4444Type = i.UnsignedIntType = i.UnsignedInt248Type = i.UnsignedByteType = i.UniformsUtils = i.UniformsLib = i.Uniform = i.UVMapping = i.TubeGeometry = i.TubeBufferGeometry = i.TrianglesDrawMode = i.TriangleStripDrawMode = i.TriangleFanDrawMode = i.Triangle = i.TorusKnotGeometry = i.TorusKnotBufferGeometry = i.TorusGeometry = i.TorusBufferGeometry = i.TextGeometry = i.TextBufferGeometry = i.TetrahedronGeometry = i.TetrahedronBufferGeometry = i.TangentSpaceNormalMap = i.TOUCH = i.SubtractiveBlending = i.SubtractEquation = i.StreamReadUsage = i.StreamDrawUsage = i.StreamCopyUsage = i.StaticReadUsage = i.StaticDrawUsage = i.StaticCopyUsage = i.SrcColorFactor = i.SrcAlphaSaturateFactor = i.SrcAlphaFactor = i.SpotLightHelper = i.SphericalHarmonics3 = i.Spherical = i.SphereGeometry = i.SphereBufferGeometry = i.Sphere = i.SmoothShading = i.SkeletonHelper = i.ShortType = i.ShapeUtils = i.ShapeGeometry = i.ShapeBufferGeometry = i.ShaderLib = i.ShaderChunk = i.SceneUtils = i.Scene = i.SRGB8_ALPHA8_ASTC_8x8_Format = i.SRGB8_ALPHA8_ASTC_8x6_Format = i.SRGB8_ALPHA8_ASTC_8x5_Format = i.SRGB8_ALPHA8_ASTC_6x6_Format = i.SRGB8_ALPHA8_ASTC_6x5_Format = i.SRGB8_ALPHA8_ASTC_5x5_Format = i.SRGB8_ALPHA8_ASTC_5x4_Format = i.SRGB8_ALPHA8_ASTC_4x4_Format = i.SRGB8_ALPHA8_ASTC_12x12_Format = i.SRGB8_ALPHA8_ASTC_12x10_Format = i.SRGB8_ALPHA8_ASTC_10x8_Format = i.SRGB8_ALPHA8_ASTC_10x6_Format = i.SRGB8_ALPHA8_ASTC_10x5_Format = i.SRGB8_ALPHA8_ASTC_10x10_Format = i.RingGeometry = i.RingBufferGeometry = i.ReverseSubtractEquation = i.ReplaceStencilOp = i.RepeatWrapping = i.ReinhardToneMapping = i.RedIntegerFormat = i.RedFormat = i.Ray = i.RGIntegerFormat = i.RGFormat = i.RGB_S3TC_DXT1_Format = i.RGB_PVRTC_4BPPV1_Format = i.RGB_PVRTC_2BPPV1_Format = i.RGB_ETC2_Format = i.RGB_ETC1_Format = i.RGBM7Encoding = i.RGBM16Encoding = i.RGBIntegerFormat = void 0, void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
            return "number" == typeof t && isFinite(t) && Math.floor(t) === t
        }), void 0 === Math.sign && (Math.sign = function(t) {
            return t < 0 ? -1 : 0 < t ? 1 : +t
        }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
            get: function() {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
            }
        }), void 0 === Object.assign && (Object.assign = function(t) {
            if (null == t) throw new TypeError("Cannot convert undefined or null to object");
            for (var e = Object(t), i = 1; i < arguments.length; i++) {
                var n = arguments[i];
                if (null != n)
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        });
        i.REVISION = "120";
        i.MOUSE = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        };
        i.TOUCH = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        };
        var q = 0;
        i.CullFaceNone = q;
        var X = 1;
        i.CullFaceBack = X;
        var Y = 2;
        i.CullFaceFront = Y;
        i.CullFaceFrontBack = 3;
        i.BasicShadowMap = 0;
        var I = 1;
        i.PCFShadowMap = I;
        var N = 2;
        i.PCFSoftShadowMap = N;
        var B = 3;
        i.VSMShadowMap = B;
        var k = 0;
        i.FrontSide = k;
        var J = 1;
        i.BackSide = J;
        var Z = 2;
        i.DoubleSide = Z;
        i.FlatShading = 1;
        i.SmoothShading = 2;
        var $ = 0;
        i.NoBlending = $;
        var K = 1;
        i.NormalBlending = K;
        var Q = 2;
        i.AdditiveBlending = Q;
        var tt = 3;
        i.SubtractiveBlending = tt;
        var et = 4;
        i.MultiplyBlending = et;
        var it = 5;
        i.CustomBlending = it;
        var nt = 100;
        i.AddEquation = nt;
        var rt = 101;
        i.SubtractEquation = rt;
        var at = 102;
        i.ReverseSubtractEquation = at;
        var st = 103;
        i.MinEquation = st;
        var ot = 104;
        i.MaxEquation = ot;
        var lt = 200;
        i.ZeroFactor = lt;
        var ht = 201;
        i.OneFactor = ht;
        var ut = 202;
        i.SrcColorFactor = ut;
        var ct = 203;
        i.OneMinusSrcColorFactor = ct;
        var pt = 204;
        i.SrcAlphaFactor = pt;
        var dt = 205;
        i.OneMinusSrcAlphaFactor = dt;
        var ft = 206;
        i.DstAlphaFactor = ft;
        var mt = 207;
        i.OneMinusDstAlphaFactor = mt;
        var gt = 208;
        i.DstColorFactor = gt;
        var vt = 209;
        i.OneMinusDstColorFactor = vt;
        var yt = 210;
        i.SrcAlphaSaturateFactor = yt;
        var bt = 0;
        i.NeverDepth = bt;
        var xt = 1;
        i.AlwaysDepth = xt;
        var _t = 2;
        i.LessDepth = _t;
        var wt = 3;
        i.LessEqualDepth = wt;
        var St = 4;
        i.EqualDepth = St;
        var Mt = 5;
        i.GreaterEqualDepth = Mt;
        var Tt = 6;
        i.GreaterDepth = Tt;
        var Ct = 7;
        i.NotEqualDepth = Ct;
        var R = 0;
        i.MultiplyOperation = R;
        var z = 1;
        i.MixOperation = z;
        var G = 2;
        i.AddOperation = G;
        var At = 0;
        i.NoToneMapping = At;
        var U = 1;
        i.LinearToneMapping = U;
        var j = 2;
        i.ReinhardToneMapping = j;
        var H = 3;
        i.CineonToneMapping = H;
        var Et = 4;
        i.ACESFilmicToneMapping = Et;
        var Dt = 5;
        i.CustomToneMapping = Dt;
        i.UVMapping = 300;
        var Pt = 301;
        i.CubeReflectionMapping = Pt;
        var Lt = 302;
        i.CubeRefractionMapping = Lt;
        var c = 303;
        i.EquirectangularReflectionMapping = c;
        var p = 304;
        i.EquirectangularRefractionMapping = p;
        var kt = 306;
        i.CubeUVReflectionMapping = kt;
        var Ot = 307;
        i.CubeUVRefractionMapping = Ot;
        var Ft = 1e3;
        i.RepeatWrapping = Ft;
        var It = 1001;
        i.ClampToEdgeWrapping = It;
        var Nt = 1002;
        i.MirroredRepeatWrapping = Nt;
        var Bt = 1003;
        i.NearestFilter = Bt;
        var Rt = 1004;
        i.NearestMipmapNearestFilter = Rt;
        i.NearestMipMapNearestFilter = 1004;
        var zt = 1005;
        i.NearestMipmapLinearFilter = zt;
        i.NearestMipMapLinearFilter = 1005;
        var Gt = 1006;
        i.LinearFilter = Gt;
        var Vt = 1007;
        i.LinearMipmapNearestFilter = Vt;
        i.LinearMipMapNearestFilter = 1007;
        var Ut = 1008;
        i.LinearMipmapLinearFilter = Ut;
        i.LinearMipMapLinearFilter = 1008;
        var jt = 1009;
        i.UnsignedByteType = jt;
        var l = 1010;
        i.ByteType = l;
        var m = 1011;
        i.ShortType = m;
        var Ht = 1012;
        i.UnsignedShortType = Ht;
        var v = 1013;
        i.IntType = v;
        var Wt = 1014;
        i.UnsignedIntType = Wt;
        var qt = 1015;
        i.FloatType = qt;
        var Xt = 1016;
        i.HalfFloatType = Xt;
        var b = 1017;
        i.UnsignedShort4444Type = b;
        var x = 1018;
        i.UnsignedShort5551Type = x;
        var _ = 1019;
        i.UnsignedShort565Type = _;
        var Yt = 1020;
        i.UnsignedInt248Type = Yt;
        var w = 1021;
        i.AlphaFormat = w;
        var Jt = 1022;
        i.RGBFormat = Jt;
        var Zt = 1023;
        i.RGBAFormat = Zt;
        var S = 1024;
        i.LuminanceFormat = S;
        var M = 1025;
        i.LuminanceAlphaFormat = M;
        var T = Zt;
        i.RGBEFormat = T;
        var $t = 1026;
        i.DepthFormat = $t;
        var Kt = 1027;
        i.DepthStencilFormat = Kt;
        var C = 1028;
        i.RedFormat = C;
        var A = 1029;
        i.RedIntegerFormat = A;
        var E = 1030;
        i.RGFormat = E;
        var D = 1031;
        i.RGIntegerFormat = D;
        var P = 1032;
        i.RGBIntegerFormat = P;
        var L = 1033;
        i.RGBAIntegerFormat = L;
        var O = 33776;
        i.RGB_S3TC_DXT1_Format = O;
        var F = 33777;
        i.RGBA_S3TC_DXT1_Format = F;
        var Qt = 33778;
        i.RGBA_S3TC_DXT3_Format = Qt;
        var te = 33779;
        i.RGBA_S3TC_DXT5_Format = te;
        var ee = 35840;
        i.RGB_PVRTC_4BPPV1_Format = ee;
        var ie = 35841;
        i.RGB_PVRTC_2BPPV1_Format = ie;
        var ne = 35842;
        i.RGBA_PVRTC_4BPPV1_Format = ne;
        var re = 35843;
        i.RGBA_PVRTC_2BPPV1_Format = re;
        var ae = 36196;
        i.RGB_ETC1_Format = ae;
        var se = 37492;
        i.RGB_ETC2_Format = se;
        var oe = 37496;
        i.RGBA_ETC2_EAC_Format = oe;
        var le = 37808;
        i.RGBA_ASTC_4x4_Format = le;
        var he = 37809;
        i.RGBA_ASTC_5x4_Format = he;
        var ue = 37810;
        i.RGBA_ASTC_5x5_Format = ue;
        var ce = 37811;
        i.RGBA_ASTC_6x5_Format = ce;
        var pe = 37812;
        i.RGBA_ASTC_6x6_Format = pe;
        var de = 37813;
        i.RGBA_ASTC_8x5_Format = de;
        var fe = 37814;
        i.RGBA_ASTC_8x6_Format = fe;
        var me = 37815;
        i.RGBA_ASTC_8x8_Format = me;
        var ge = 37816;
        i.RGBA_ASTC_10x5_Format = ge;
        var ve = 37817;
        i.RGBA_ASTC_10x6_Format = ve;
        var ye = 37818;
        i.RGBA_ASTC_10x8_Format = ye;
        var be = 37819;
        i.RGBA_ASTC_10x10_Format = be;
        var xe = 37820;
        i.RGBA_ASTC_12x10_Format = xe;
        var _e = 37821;
        i.RGBA_ASTC_12x12_Format = _e;
        var we = 36492;
        i.RGBA_BPTC_Format = we;
        var Se = 37840;
        i.SRGB8_ALPHA8_ASTC_4x4_Format = Se;
        var Me = 37841;
        i.SRGB8_ALPHA8_ASTC_5x4_Format = Me;
        var Te = 37842;
        i.SRGB8_ALPHA8_ASTC_5x5_Format = Te;
        var Ce = 37843;
        i.SRGB8_ALPHA8_ASTC_6x5_Format = Ce;
        var Ae = 37844;
        i.SRGB8_ALPHA8_ASTC_6x6_Format = Ae;
        var Ee = 37845;
        i.SRGB8_ALPHA8_ASTC_8x5_Format = Ee;
        var De = 37846;
        i.SRGB8_ALPHA8_ASTC_8x6_Format = De;
        var Pe = 37847;
        i.SRGB8_ALPHA8_ASTC_8x8_Format = Pe;
        var Le = 37848;
        i.SRGB8_ALPHA8_ASTC_10x5_Format = Le;
        var ke = 37849;
        i.SRGB8_ALPHA8_ASTC_10x6_Format = ke;
        var Oe = 37850;
        i.SRGB8_ALPHA8_ASTC_10x8_Format = Oe;
        var Fe = 37851;
        i.SRGB8_ALPHA8_ASTC_10x10_Format = Fe;
        var Ie = 37852;
        i.SRGB8_ALPHA8_ASTC_12x10_Format = Ie;
        var Ne = 37853;
        i.SRGB8_ALPHA8_ASTC_12x12_Format = Ne;
        i.LoopOnce = 2200;
        var Be = 2201;
        i.LoopRepeat = Be;
        i.LoopPingPong = 2202;
        var Re = 2300;
        i.InterpolateDiscrete = Re;
        var ze = 2301;
        i.InterpolateLinear = ze;
        i.InterpolateSmooth = 2302;
        var Ge = 2400;
        i.ZeroCurvatureEnding = Ge;
        var Ve = 2401;
        i.ZeroSlopeEnding = Ve;
        var Ue = 2402;
        i.WrapAroundEnding = Ue;
        var je = 2500;
        i.NormalAnimationBlendMode = je;
        i.AdditiveAnimationBlendMode = 2501;
        i.TrianglesDrawMode = 0;
        i.TriangleStripDrawMode = 1;
        i.TriangleFanDrawMode = 2;
        var He = 3e3;
        i.LinearEncoding = He;
        var We = 3001;
        i.sRGBEncoding = We;
        var qe = 3007;
        i.GammaEncoding = qe;
        var Xe = 3002;
        i.RGBEEncoding = Xe;
        var Ye = 3003;
        i.LogLuvEncoding = Ye;
        var Je = 3004;
        i.RGBM7Encoding = Je;
        var Ze = 3005;
        i.RGBM16Encoding = Ze;
        var $e = 3006;
        i.RGBDEncoding = $e;
        var Ke = 3200;
        i.BasicDepthPacking = Ke;
        var Qe = 3201;
        i.RGBADepthPacking = Qe;
        var ti = 0;
        i.TangentSpaceNormalMap = ti;
        var ei = 1;
        i.ObjectSpaceNormalMap = ei;
        i.ZeroStencilOp = 0;
        var ii = 7680;
        i.KeepStencilOp = ii;
        i.ReplaceStencilOp = 7681;
        i.IncrementStencilOp = 7682;
        i.DecrementStencilOp = 7683;
        i.IncrementWrapStencilOp = 34055;
        i.DecrementWrapStencilOp = 34056;
        i.InvertStencilOp = 5386;
        i.NeverStencilFunc = 512;
        i.LessStencilFunc = 513;
        i.EqualStencilFunc = 514;
        i.LessEqualStencilFunc = 515;
        i.GreaterStencilFunc = 516;
        i.NotEqualStencilFunc = 517;
        i.GreaterEqualStencilFunc = 518;
        var ni = 519;
        i.AlwaysStencilFunc = ni;
        var ri = 35044;
        i.StaticDrawUsage = ri;
        var ai = 35048;
        i.DynamicDrawUsage = ai;
        i.StreamDrawUsage = 35040;
        i.StaticReadUsage = 35045;
        i.DynamicReadUsage = 35049;
        i.StreamReadUsage = 35041;
        i.StaticCopyUsage = 35046;
        i.DynamicCopyUsage = 35050;
        i.StreamCopyUsage = 35042;
        i.GLSL1 = "100";
        var si = "300 es";

        function oi() {}
        i.GLSL3 = si, Object.assign(oi.prototype, {
            addEventListener: function(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                var i = this._listeners;
                void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
            },
            hasEventListener: function(t, e) {
                if (void 0 === this._listeners) return !1;
                var i = this._listeners;
                return void 0 !== i[t] && -1 !== i[t].indexOf(e)
            },
            removeEventListener: function(t, e) {
                var i, n;
                void 0 !== this._listeners && (void 0 === (i = this._listeners[t]) || -1 !== (n = i.indexOf(e)) && i.splice(n, 1))
            },
            dispatchEvent: function(t) {
                if (void 0 !== this._listeners) {
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, t)
                    }
                }
            }
        });
        for (var li = [], hi = 0; hi < 256; hi++) li[hi] = (hi < 16 ? "0" : "") + hi.toString(16);
        var ui = 1234567,
            ci = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    var t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0;
                    return (li[255 & t] + li[t >> 8 & 255] + li[t >> 16 & 255] + li[t >> 24 & 255] + "-" + li[255 & e] + li[e >> 8 & 255] + "-" + li[e >> 16 & 15 | 64] + li[e >> 24 & 255] + "-" + li[63 & i | 128] + li[i >> 8 & 255] + "-" + li[i >> 16 & 255] + li[i >> 24 & 255] + li[255 & n] + li[n >> 8 & 255] + li[n >> 16 & 255] + li[n >> 24 & 255]).toUpperCase()
                },
                clamp: function(t, e, i) {
                    return Math.max(e, Math.min(i, t))
                },
                euclideanModulo: function(t, e) {
                    return (t % e + e) % e
                },
                mapLinear: function(t, e, i, n, r) {
                    return n + (t - e) * (r - n) / (i - e)
                },
                lerp: function(t, e, i) {
                    return (1 - i) * t + i * e
                },
                smoothstep: function(t, e, i) {
                    return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
                },
                smootherstep: function(t, e, i) {
                    return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
                },
                randInt: function(t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                },
                randFloat: function(t, e) {
                    return t + Math.random() * (e - t)
                },
                randFloatSpread: function(t) {
                    return t * (.5 - Math.random())
                },
                seededRandom: function(t) {
                    return void 0 !== t && (ui = t % 2147483647), ((ui = 16807 * ui % 2147483647) - 1) / 2147483646
                },
                degToRad: function(t) {
                    return t * ci.DEG2RAD
                },
                radToDeg: function(t) {
                    return t * ci.RAD2DEG
                },
                isPowerOfTwo: function(t) {
                    return 0 == (t & t - 1) && 0 !== t
                },
                ceilPowerOfTwo: function(t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                },
                floorPowerOfTwo: function(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                },
                setQuaternionFromProperEuler: function(t, e, i, n, r) {
                    var a = Math.cos,
                        s = Math.sin,
                        o = a(i / 2),
                        l = s(i / 2),
                        h = a((e + n) / 2),
                        u = s((e + n) / 2),
                        c = a((e - n) / 2),
                        p = s((e - n) / 2),
                        d = a((n - e) / 2),
                        f = s((n - e) / 2);
                    switch (r) {
                        case "XYX":
                            t.set(o * u, l * c, l * p, o * h);
                            break;
                        case "YZY":
                            t.set(l * p, o * u, l * c, o * h);
                            break;
                        case "ZXZ":
                            t.set(l * c, l * p, o * u, o * h);
                            break;
                        case "XZX":
                            t.set(o * u, l * f, l * d, o * h);
                            break;
                        case "YXY":
                            t.set(l * d, o * u, l * f, o * h);
                            break;
                        case "ZYZ":
                            t.set(l * f, l * d, o * u, o * h)
                    }
                }
            };
        i.MathUtils = i.Math = ci;
        var pi = function() {
            function i() {
                var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                V(this, i), Object.defineProperty(this, "isVector2", {
                    value: !0
                }), this.x = t, this.y = e
            }
            return g(i, [{
                key: "set",
                value: function(t, e) {
                    return this.x = t, this.y = e, this
                }
            }, {
                key: "setScalar",
                value: function(t) {
                    return this.x = t, this.y = t, this
                }
            }, {
                key: "setX",
                value: function(t) {
                    return this.x = t, this
                }
            }, {
                key: "setY",
                value: function(t) {
                    return this.y = t, this
                }
            }, {
                key: "setComponent",
                value: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
            }, {
                key: "getComponent",
                value: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
            }, {
                key: "clone",
                value: function() {
                    return new this.constructor(this.x, this.y)
                }
            }, {
                key: "copy",
                value: function(t) {
                    return this.x = t.x, this.y = t.y, this
                }
            }, {
                key: "add",
                value: function(t, e) {
                    return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this)
                }
            }, {
                key: "addScalar",
                value: function(t) {
                    return this.x += t, this.y += t, this
                }
            }, {
                key: "addVectors",
                value: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                }
            }, {
                key: "addScaledVector",
                value: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                }
            }, {
                key: "sub",
                value: function(t, e) {
                    return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this)
                }
            }, {
                key: "subScalar",
                value: function(t) {
                    return this.x -= t, this.y -= t, this
                }
            }, {
                key: "subVectors",
                value: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                }
            }, {
                key: "multiply",
                value: function(t) {
                    return this.x *= t.x, this.y *= t.y, this
                }
            }, {
                key: "multiplyScalar",
                value: function(t) {
                    return this.x *= t, this.y *= t, this
                }
            }, {
                key: "divide",
                value: function(t) {
                    return this.x /= t.x, this.y /= t.y, this
                }
            }, {
                key: "divideScalar",
                value: function(t) {
                    return this.multiplyScalar(1 / t)
                }
            }, {
                key: "applyMatrix3",
                value: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = t.elements;
                    return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
                }
            }, {
                key: "min",
                value: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                }
            }, {
                key: "max",
                value: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                }
            }, {
                key: "clamp",
                value: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                }
            }, {
                key: "clampScalar",
                value: function(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                }
            }, {
                key: "clampLength",
                value: function(t, e) {
                    var i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                }
            }, {
                key: "floor",
                value: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
            }, {
                key: "ceil",
                value: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
            }, {
                key: "round",
                value: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
            }, {
                key: "roundToZero",
                value: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
            }, {
                key: "negate",
                value: function() {
                    return this.x = -this.x, this.y = -this.y, this
                }
            }, {
                key: "dot",
                value: function(t) {
                    return this.x * t.x + this.y * t.y
                }
            }, {
                key: "cross",
                value: function(t) {
                    return this.x * t.y - this.y * t.x
                }
            }, {
                key: "lengthSq",
                value: function() {
                    return this.x * this.x + this.y * this.y
                }
            }, {
                key: "length",
                value: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
            }, {
                key: "manhattanLength",
                value: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
            }, {
                key: "normalize",
                value: function() {
                    return this.divideScalar(this.length() || 1)
                }
            }, {
                key: "angle",
                value: function() {
                    var t = Math.atan2(-this.y, -this.x) + Math.PI;
                    return t
                }
            }, {
                key: "distanceTo",
                value: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
            }, {
                key: "distanceToSquared",
                value: function(t) {
                    var e = this.x - t.x,
                        i = this.y - t.y;
                    return e * e + i * i
                }
            }, {
                key: "manhattanDistanceTo",
                value: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                }
            }, {
                key: "setLength",
                value: function(t) {
                    return this.normalize().multiplyScalar(t)
                }
            }, {
                key: "lerp",
                value: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                }
            }, {
                key: "lerpVectors",
                value: function(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this
                }
            }, {
                key: "equals",
                value: function(t) {
                    return t.x === this.x && t.y === this.y
                }
            }, {
                key: "fromArray",
                value: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
                }
            }, {
                key: "toArray",
                value: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
                }
            }, {
                key: "fromBufferAttribute",
                value: function(t, e) {
                    return this.x = t.getX(e), this.y = t.getY(e), this
                }
            }, {
                key: "rotateAround",
                value: function(t, e) {
                    var i = Math.cos(e),
                        n = Math.sin(e),
                        r = this.x - t.x,
                        a = this.y - t.y;
                    return this.x = r * i - a * n + t.x, this.y = r * n + a * i + t.y, this
                }
            }, {
                key: "random",
                value: function() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }
            }, {
                key: "width",
                get: function() {
                    return this.x
                },
                set: function(t) {
                    this.x = t
                }
            }, {
                key: "height",
                get: function() {
                    return this.y
                },
                set: function(t) {
                    this.y = t
                }
            }]), i
        }();
        i.Vector2 = pi;
        var di, fi = function() {
            function t() {
                V(this, t), Object.defineProperty(this, "isMatrix3", {
                    value: !0
                }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
            }
            return g(t, [{
                key: "set",
                value: function(t, e, i, n, r, a, s, o, l) {
                    var h = this.elements;
                    return h[0] = t, h[1] = n, h[2] = s, h[3] = e, h[4] = r, h[5] = o, h[6] = i, h[7] = a, h[8] = l, this
                }
            }, {
                key: "identity",
                value: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }, {
                key: "copy",
                value: function(t) {
                    var e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
                }
            }, {
                key: "extractBasis",
                value: function(t, e, i) {
                    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
                }
            }, {
                key: "setFromMatrix4",
                value: function(t) {
                    var e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                }
            }, {
                key: "multiply",
                value: function(t) {
                    return this.multiplyMatrices(this, t)
                }
            }, {
                key: "premultiply",
                value: function(t) {
                    return this.multiplyMatrices(t, this)
                }
            }, {
                key: "multiplyMatrices",
                value: function(t, e) {
                    var i = t.elements,
                        n = e.elements,
                        r = this.elements,
                        a = i[0],
                        s = i[3],
                        o = i[6],
                        l = i[1],
                        h = i[4],
                        u = i[7],
                        c = i[2],
                        p = i[5],
                        d = i[8],
                        f = n[0],
                        m = n[3],
                        g = n[6],
                        v = n[1],
                        y = n[4],
                        b = n[7],
                        x = n[2],
                        _ = n[5],
                        w = n[8];
                    return r[0] = a * f + s * v + o * x, r[3] = a * m + s * y + o * _, r[6] = a * g + s * b + o * w, r[1] = l * f + h * v + u * x, r[4] = l * m + h * y + u * _, r[7] = l * g + h * b + u * w, r[2] = c * f + p * v + d * x, r[5] = c * m + p * y + d * _, r[8] = c * g + p * b + d * w, this
                }
            }, {
                key: "multiplyScalar",
                value: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                }
            }, {
                key: "determinant",
                value: function() {
                    var t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        r = t[3],
                        a = t[4],
                        s = t[5],
                        o = t[6],
                        l = t[7],
                        h = t[8];
                    return e * a * h - e * s * l - i * r * h + i * s * o + n * r * l - n * a * o
                }
            }, {
                key: "getInverse",
                value: function(t) {
                    var e = t.elements,
                        i = this.elements,
                        n = e[0],
                        r = e[1],
                        a = e[2],
                        s = e[3],
                        o = e[4],
                        l = e[5],
                        h = e[6],
                        u = e[7],
                        c = e[8],
                        p = c * o - l * u,
                        d = l * h - c * s,
                        f = u * s - o * h,
                        m = n * p + r * d + a * f;
                    if (0 == m) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    var g = 1 / m;
                    return i[0] = p * g, i[1] = (a * u - c * r) * g, i[2] = (l * r - a * o) * g, i[3] = d * g, i[4] = (c * n - a * h) * g, i[5] = (a * s - l * n) * g, i[6] = f * g, i[7] = (r * h - u * n) * g, i[8] = (o * n - r * s) * g, this
                }
            }, {
                key: "transpose",
                value: function() {
                    var t = this.elements,
                        e = t[1];
                    return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                }
            }, {
                key: "getNormalMatrix",
                value: function(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                }
            }, {
                key: "transposeIntoArray",
                value: function(t) {
                    var e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                }
            }, {
                key: "setUvTransform",
                value: function(t, e, i, n, r, a, s) {
                    var o = Math.cos(r),
                        l = Math.sin(r);
                    this.set(i * o, i * l, -i * (o * a + l * s) + a + t, -n * l, n * o, -n * (-l * a + o * s) + s + e, 0, 0, 1)
                }
            }, {
                key: "scale",
                value: function(t, e) {
                    var i = this.elements;
                    return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
                }
            }, {
                key: "rotate",
                value: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t),
                        n = this.elements,
                        r = n[0],
                        a = n[3],
                        s = n[6],
                        o = n[1],
                        l = n[4],
                        h = n[7];
                    return n[0] = e * r + i * o, n[3] = e * a + i * l, n[6] = e * s + i * h, n[1] = -i * r + e * o, n[4] = -i * a + e * l, n[7] = -i * s + e * h, this
                }
            }, {
                key: "translate",
                value: function(t, e) {
                    var i = this.elements;
                    return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
                }
            }, {
                key: "equals",
                value: function(t) {
                    for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
                        if (e[n] !== i[n]) return !1;
                    return !0
                }
            }, {
                key: "fromArray",
                value: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
                    return this
                }
            }, {
                key: "toArray",
                value: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
                }
            }]), t
        }();
        i.Matrix3 = fi;
        var mi = {
            getDataURL: function(t) {
                if (/^data:/i.test(t.src)) return t.src;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                var e, i = t instanceof HTMLCanvasElement ? t : (void 0 === di && (di = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), di.width = t.width, di.height = t.height, e = di.getContext("2d"), t instanceof ImageData ? e.putImageData(t, 0, 0) : e.drawImage(t, 0, 0, t.width, t.height), di);
                return 2048 < i.width || 2048 < i.height ? i.toDataURL("image/jpeg", .6) : i.toDataURL("image/png")
            }
        };
        i.ImageUtils = mi;
        var gi = 0;

        function vi(t, e, i, n, r, a, s, o, l, h) {
            Object.defineProperty(this, "id", {
                value: gi++
            }), this.uuid = ci.generateUUID(), this.name = "", this.image = void 0 !== t ? t : vi.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : vi.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : It, this.wrapT = void 0 !== n ? n : It, this.magFilter = void 0 !== r ? r : Gt, this.minFilter = void 0 !== a ? a : Ut, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== s ? s : Zt, this.internalFormat = null, this.type = void 0 !== o ? o : jt, this.offset = new pi(0, 0), this.repeat = new pi(1, 1), this.center = new pi(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new fi, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== h ? h : He, this.version = 0, this.onUpdate = null
        }
        vi.DEFAULT_IMAGE = void 0, vi.DEFAULT_MAPPING = 300, vi.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: vi,
            isTexture: !0,
            updateMatrix: function() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
            },
            toJSON: function(t) {
                var e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                var i = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    var n, r = this.image;
                    if (void 0 === r.uuid && (r.uuid = ci.generateUUID()), !e && void 0 === t.images[r.uuid]) {
                        if (Array.isArray(r)) {
                            n = [];
                            for (var a = 0, s = r.length; a < s; a++) n.push(mi.getDataURL(r[a]))
                        } else n = mi.getDataURL(r);
                        t.images[r.uuid] = {
                            uuid: r.uuid,
                            url: n
                        }
                    }
                    i.image = r.uuid
                }
                return e || (t.textures[this.uuid] = i), i
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function(t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || 1 < t.x) switch (this.wrapS) {
                    case Ft:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case It:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case Nt:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || 1 < t.y) switch (this.wrapT) {
                    case Ft:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case It:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case Nt:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
        }), Object.defineProperty(vi.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        });
        var yi = function() {
            function r() {
                var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                    i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                    n = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
                V(this, r), Object.defineProperty(this, "isVector4", {
                    value: !0
                }), this.x = t, this.y = e, this.z = i, this.w = n
            }
            return g(r, [{
                key: "set",
                value: function(t, e, i, n) {
                    return this.x = t, this.y = e, this.z = i, this.w = n, this
                }
            }, {
                key: "setScalar",
                value: function(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                }
            }, {
                key: "setX",
                value: function(t) {
                    return this.x = t, this
                }
            }, {
                key: "setY",
                value: function(t) {
                    return this.y = t, this
                }
            }, {
                key: "setZ",
                value: function(t) {
                    return this.z = t, this
                }
            }, {
                key: "setW",
                value: function(t) {
                    return this.w = t, this
                }
            }, {
                key: "setComponent",
                value: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
            }, {
                key: "getComponent",
                value: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
            }, {
                key: "clone",
                value: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
            }, {
                key: "copy",
                value: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                }
            }, {
                key: "add",
                value: function(t, e) {
                    return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                }
            }, {
                key: "addScalar",
                value: function(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                }
            }, {
                key: "addVectors",
                value: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                }
            }, {
                key: "addScaledVector",
                value: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                }
            }, {
                key: "sub",
                value: function(t, e) {
                    return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                }
            }, {
                key: "subScalar",
                value: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                }
            }, {
                key: "subVectors",
                value: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                }
            }, {
                key: "multiplyScalar",
                value: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                }
            }, {
                key: "applyMatrix4",
                value: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = this.w,
                        a = t.elements;
                    return this.x = a[0] * e + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * e + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * e + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * e + a[7] * i + a[11] * n + a[15] * r, this
                }
            }, {
                key: "divideScalar",
                value: function(t) {
                    return this.multiplyScalar(1 / t)
                }
            }, {
                key: "setAxisAngleFromQuaternion",
                value: function(t) {
                    this.w = 2 * Math.acos(t.w);
                    var e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                }
            }, {
                key: "setAxisAngleFromRotationMatrix",
                value: function(t) {
                    var e, i, n, r, a = t.elements,
                        s = a[0],
                        o = a[4],
                        l = a[8],
                        h = a[1],
                        u = a[5],
                        c = a[9],
                        p = a[2],
                        d = a[6],
                        f = a[10];
                    if (Math.abs(o - h) < .01 && Math.abs(l - p) < .01 && Math.abs(c - d) < .01) {
                        if (Math.abs(o + h) < .1 && Math.abs(l + p) < .1 && Math.abs(c + d) < .1 && Math.abs(s + u + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        var m = (s + 1) / 2,
                            g = (u + 1) / 2,
                            v = (f + 1) / 2,
                            y = (o + h) / 4,
                            b = (l + p) / 4,
                            x = (c + d) / 4;
                        return g < m && v < m ? r = m < .01 ? (i = 0, n = .707106781) : (n = y / (i = Math.sqrt(m)), b / i) : v < g ? r = g < .01 ? (n = 0, i = .707106781) : (i = y / (n = Math.sqrt(g)), x / n) : v < .01 ? (n = i = .707106781, r = 0) : (i = b / (r = Math.sqrt(v)), n = x / r), this.set(i, n, r, e), this
                    }
                    var _ = Math.sqrt((d - c) * (d - c) + (l - p) * (l - p) + (h - o) * (h - o));
                    return Math.abs(_) < .001 && (_ = 1), this.x = (d - c) / _, this.y = (l - p) / _, this.z = (h - o) / _, this.w = Math.acos((s + u + f - 1) / 2), this
                }
            }, {
                key: "min",
                value: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                }
            }, {
                key: "max",
                value: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                }
            }, {
                key: "clamp",
                value: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                }
            }, {
                key: "clampScalar",
                value: function(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                }
            }, {
                key: "clampLength",
                value: function(t, e) {
                    var i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                }
            }, {
                key: "floor",
                value: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
            }, {
                key: "ceil",
                value: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
            }, {
                key: "round",
                value: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
            }, {
                key: "roundToZero",
                value: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
            }, {
                key: "negate",
                value: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
            }, {
                key: "dot",
                value: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                }
            }, {
                key: "lengthSq",
                value: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
            }, {
                key: "length",
                value: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
            }, {
                key: "manhattanLength",
                value: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
            }, {
                key: "normalize",
                value: function() {
                    return this.divideScalar(this.length() || 1)
                }
            }, {
                key: "setLength",
                value: function(t) {
                    return this.normalize().multiplyScalar(t)
                }
            }, {
                key: "lerp",
                value: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                }
            }, {
                key: "lerpVectors",
                value: function(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this
                }
            }, {
                key: "equals",
                value: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                }
            }, {
                key: "fromArray",
                value: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                }
            }, {
                key: "toArray",
                value: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                }
            }, {
                key: "fromBufferAttribute",
                value: function(t, e) {
                    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
            }, {
                key: "random",
                value: function() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }
            }, {
                key: "width",
                get: function() {
                    return this.z
                },
                set: function(t) {
                    this.z = t
                }
            }, {
                key: "height",
                get: function() {
                    return this.w
                },
                set: function(t) {
                    this.w = t
                }
            }]), r
        }();

        function bi(t, e, i) {
            this.width = t, this.height = e, this.scissor = new yi(0, 0, t, e), this.scissorTest = !1, this.viewport = new yi(0, 0, t, e), i = i || {}, this.texture = new vi(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Gt, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
        }

        function xi(t, e, i) {
            bi.call(this, t, e, i), this.samples = 4
        }
        i.Vector4 = yi, bi.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: bi,
            isWebGLRenderTarget: !0,
            setSize: function(t, e) {
                this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), xi.prototype = Object.assign(Object.create(bi.prototype), {
            constructor: xi,
            isWebGLMultisampleRenderTarget: !0,
            copy: function(t) {
                return bi.prototype.copy.call(this, t), this.samples = t.samples, this
            }
        });
        var _i = function() {
            function r() {
                var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                    i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                    n = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
                V(this, r), Object.defineProperty(this, "isQuaternion", {
                    value: !0
                }), this._x = t, this._y = e, this._z = i, this._w = n
            }
            return g(r, [{
                key: "set",
                value: function(t, e, i, n) {
                    return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this
                }
            }, {
                key: "clone",
                value: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
            }, {
                key: "copy",
                value: function(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                }
            }, {
                key: "setFromEuler",
                value: function(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var i = t._x,
                        n = t._y,
                        r = t._z,
                        a = t._order,
                        s = Math.cos,
                        o = Math.sin,
                        l = s(i / 2),
                        h = s(n / 2),
                        u = s(r / 2),
                        c = o(i / 2),
                        p = o(n / 2),
                        d = o(r / 2);
                    switch (a) {
                        case "XYZ":
                            this._x = c * h * u + l * p * d, this._y = l * p * u - c * h * d, this._z = l * h * d + c * p * u, this._w = l * h * u - c * p * d;
                            break;
                        case "YXZ":
                            this._x = c * h * u + l * p * d, this._y = l * p * u - c * h * d, this._z = l * h * d - c * p * u, this._w = l * h * u + c * p * d;
                            break;
                        case "ZXY":
                            this._x = c * h * u - l * p * d, this._y = l * p * u + c * h * d, this._z = l * h * d + c * p * u, this._w = l * h * u - c * p * d;
                            break;
                        case "ZYX":
                            this._x = c * h * u - l * p * d, this._y = l * p * u + c * h * d, this._z = l * h * d - c * p * u, this._w = l * h * u + c * p * d;
                            break;
                        case "YZX":
                            this._x = c * h * u + l * p * d, this._y = l * p * u + c * h * d, this._z = l * h * d - c * p * u, this._w = l * h * u - c * p * d;
                            break;
                        case "XZY":
                            this._x = c * h * u - l * p * d, this._y = l * p * u - c * h * d, this._z = l * h * d + c * p * u, this._w = l * h * u + c * p * d
                    }
                    return !1 !== e && this._onChangeCallback(), this
                }
            }, {
                key: "setFromAxisAngle",
                value: function(t, e) {
                    var i = e / 2,
                        n = Math.sin(i);
                    return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this
                }
            }, {
                key: "setFromRotationMatrix",
                value: function(t) {
                    var e, i, n, r, a = t.elements,
                        s = a[0],
                        o = a[4],
                        l = a[8],
                        h = a[1],
                        u = a[5],
                        c = a[9],
                        p = a[2],
                        d = a[6],
                        f = a[10],
                        m = s + u + f;
                    return 0 < m ? (e = .5 / Math.sqrt(m + 1), this._w = .25 / e, this._x = (d - c) * e, this._y = (l - p) * e, this._z = (h - o) * e) : u < s && f < s ? (i = 2 * Math.sqrt(1 + s - u - f), this._w = (d - c) / i, this._x = .25 * i, this._y = (o + h) / i, this._z = (l + p) / i) : f < u ? (n = 2 * Math.sqrt(1 + u - s - f), this._w = (l - p) / n, this._x = (o + h) / n, this._y = .25 * n, this._z = (c + d) / n) : (r = 2 * Math.sqrt(1 + f - s - u), this._w = (h - o) / r, this._x = (l + p) / r, this._y = (c + d) / r, this._z = .25 * r), this._onChangeCallback(), this
                }
            }, {
                key: "setFromUnitVectors",
                value: function(t, e) {
                    var i = t.dot(e) + 1;
                    return i < 1e-6 ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0) : (this._x = 0, this._y = -t.z, this._z = t.y)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x), this._w = i, this.normalize()
                }
            }, {
                key: "angleTo",
                value: function(t) {
                    return 2 * Math.acos(Math.abs(ci.clamp(this.dot(t), -1, 1)))
                }
            }, {
                key: "rotateTowards",
                value: function(t, e) {
                    var i = this.angleTo(t);
                    if (0 === i) return this;
                    var n = Math.min(1, e / i);
                    return this.slerp(t, n), this
                }
            }, {
                key: "identity",
                value: function() {
                    return this.set(0, 0, 0, 1)
                }
            }, {
                key: "inverse",
                value: function() {
                    return this.conjugate()
                }
            }, {
                key: "conjugate",
                value: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
            }, {
                key: "dot",
                value: function(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                }
            }, {
                key: "lengthSq",
                value: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
            }, {
                key: "length",
                value: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
            }, {
                key: "normalize",
                value: function() {
                    var t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                }
            }, {
                key: "multiply",
                value: function(t, e) {
                    return void 0 !== e ? this.multiplyQuaternions(t, e) : this.multiplyQuaternions(this, t)
                }
            }, {
                key: "premultiply",
                value: function(t) {
                    return this.multiplyQuaternions(t, this)
                }
            }, {
                key: "multiplyQuaternions",
                value: function(t, e) {
                    var i = t._x,
                        n = t._y,
                        r = t._z,
                        a = t._w,
                        s = e._x,
                        o = e._y,
                        l = e._z,
                        h = e._w;
                    return this._x = i * h + a * s + n * l - r * o, this._y = n * h + a * o + r * s - i * l, this._z = r * h + a * l + i * o - n * s, this._w = a * h - i * s - n * o - r * l, this._onChangeCallback(), this
                }
            }, {
                key: "slerp",
                value: function(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    var i = this._x,
                        n = this._y,
                        r = this._z,
                        a = this._w,
                        s = a * t._w + i * t._x + n * t._y + r * t._z;
                    if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), 1 <= s) return this._w = a, this._x = i, this._y = n, this._z = r, this;
                    var o = 1 - s * s;
                    if (o <= Number.EPSILON) {
                        var l = 1 - e;
                        return this._w = l * a + e * this._w, this._x = l * i + e * this._x, this._y = l * n + e * this._y, this._z = l * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    var h = Math.sqrt(o),
                        u = Math.atan2(h, s),
                        c = Math.sin((1 - e) * u) / h,
                        p = Math.sin(e * u) / h;
                    return this._w = a * c + this._w * p, this._x = i * c + this._x * p, this._y = n * c + this._y * p, this._z = r * c + this._z * p, this._onChangeCallback(), this
                }
            }, {
                key: "equals",
                value: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                }
            }, {
                key: "fromArray",
                value: function(t, e) {
                    return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                }
            }, {
                key: "toArray",
                value: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                }
            }, {
                key: "fromBufferAttribute",
                value: function(t, e) {
                    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                }
            }, {
                key: "_onChange",
                value: function(t) {
                    return this._onChangeCallback = t, this
                }
            }, {
                key: "_onChangeCallback",
                value: function() {}
            }, {
                key: "x",
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this._onChangeCallback()
                }
            }, {
                key: "y",
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this._onChangeCallback()
                }
            }, {
                key: "z",
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this._onChangeCallback()
                }
            }, {
                key: "w",
                get: function() {
                    return this._w
                },
                set: function(t) {
                    this._w = t, this._onChangeCallback()
                }
            }], [{
                key: "slerp",
                value: function(t, e, i, n) {
                    return i.copy(t).slerp(e, n)
                }
            }, {
                key: "slerpFlat",
                value: function(t, e, i, n, r, a, s) {
                    var o, l, h, u, c, p, d, f, m = i[n + 0],
                        g = i[n + 1],
                        v = i[n + 2],
                        y = i[n + 3],
                        b = r[a + 0],
                        x = r[a + 1],
                        _ = r[a + 2],
                        w = r[a + 3];
                    y === w && m === b && g === x && v === _ || (p = 1 - s, l = 0 <= (o = m * b + g * x + v * _ + y * w) ? 1 : -1, (h = 1 - o * o) > Number.EPSILON && (u = Math.sqrt(h), c = Math.atan2(u, o * l), p = Math.sin(p * c) / u, s = Math.sin(s * c) / u), m = m * p + b * (d = s * l), g = g * p + x * d, v = v * p + _ * d, y = y * p + w * d, p === 1 - s && (m *= f = 1 / Math.sqrt(m * m + g * g + v * v + y * y), g *= f, v *= f, y *= f)), t[e] = m, t[e + 1] = g, t[e + 2] = v, t[e + 3] = y
                }
            }, {
                key: "multiplyQuaternionsFlat",
                value: function(t, e, i, n, r, a) {
                    var s = i[n],
                        o = i[n + 1],
                        l = i[n + 2],
                        h = i[n + 3],
                        u = r[a],
                        c = r[a + 1],
                        p = r[a + 2],
                        d = r[a + 3];
                    return t[e] = s * d + h * u + o * p - l * c, t[e + 1] = o * d + h * c + l * u - s * p, t[e + 2] = l * d + h * p + s * c - o * u, t[e + 3] = h * d - s * u - o * c - l * p, t
                }
            }]), r
        }();
        i.Quaternion = _i;
        var wi = function() {
                function n() {
                    var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                        e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                        i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                    V(this, n), Object.defineProperty(this, "isVector3", {
                        value: !0
                    }), this.x = t, this.y = e, this.z = i
                }
                return g(n, [{
                    key: "set",
                    value: function(t, e, i) {
                        return void 0 === i && (i = this.z), this.x = t, this.y = e, this.z = i, this
                    }
                }, {
                    key: "setScalar",
                    value: function(t) {
                        return this.x = t, this.y = t, this.z = t, this
                    }
                }, {
                    key: "setX",
                    value: function(t) {
                        return this.x = t, this
                    }
                }, {
                    key: "setY",
                    value: function(t) {
                        return this.y = t, this
                    }
                }, {
                    key: "setZ",
                    value: function(t) {
                        return this.z = t, this
                    }
                }, {
                    key: "setComponent",
                    value: function(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                }, {
                    key: "getComponent",
                    value: function(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return new this.constructor(this.x, this.y, this.z)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return this.x = t.x, this.y = t.y, this.z = t.z, this
                    }
                }, {
                    key: "add",
                    value: function(t, e) {
                        return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                    }
                }, {
                    key: "addScalar",
                    value: function(t) {
                        return this.x += t, this.y += t, this.z += t, this
                    }
                }, {
                    key: "addVectors",
                    value: function(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                    }
                }, {
                    key: "addScaledVector",
                    value: function(t, e) {
                        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                    }
                }, {
                    key: "sub",
                    value: function(t, e) {
                        return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                    }
                }, {
                    key: "subScalar",
                    value: function(t) {
                        return this.x -= t, this.y -= t, this.z -= t, this
                    }
                }, {
                    key: "subVectors",
                    value: function(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                    }
                }, {
                    key: "multiply",
                    value: function(t, e) {
                        return void 0 !== e ? this.multiplyVectors(t, e) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                    }
                }, {
                    key: "multiplyScalar",
                    value: function(t) {
                        return this.x *= t, this.y *= t, this.z *= t, this
                    }
                }, {
                    key: "multiplyVectors",
                    value: function(t, e) {
                        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                    }
                }, {
                    key: "applyEuler",
                    value: function(t) {
                        return t && t.isEuler, this.applyQuaternion(Mi.setFromEuler(t))
                    }
                }, {
                    key: "applyAxisAngle",
                    value: function(t, e) {
                        return this.applyQuaternion(Mi.setFromAxisAngle(t, e))
                    }
                }, {
                    key: "applyMatrix3",
                    value: function(t) {
                        var e = this.x,
                            i = this.y,
                            n = this.z,
                            r = t.elements;
                        return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
                    }
                }, {
                    key: "applyNormalMatrix",
                    value: function(t) {
                        return this.applyMatrix3(t).normalize()
                    }
                }, {
                    key: "applyMatrix4",
                    value: function(t) {
                        var e = this.x,
                            i = this.y,
                            n = this.z,
                            r = t.elements,
                            a = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                        return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * a, this
                    }
                }, {
                    key: "applyQuaternion",
                    value: function(t) {
                        var e = this.x,
                            i = this.y,
                            n = this.z,
                            r = t.x,
                            a = t.y,
                            s = t.z,
                            o = t.w,
                            l = o * e + a * n - s * i,
                            h = o * i + s * e - r * n,
                            u = o * n + r * i - a * e,
                            c = -r * e - a * i - s * n;
                        return this.x = l * o + c * -r + h * -s - u * -a, this.y = h * o + c * -a + u * -r - l * -s, this.z = u * o + c * -s + l * -a - h * -r, this
                    }
                }, {
                    key: "project",
                    value: function(t) {
                        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                    }
                }, {
                    key: "unproject",
                    value: function(t) {
                        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                    }
                }, {
                    key: "transformDirection",
                    value: function(t) {
                        var e = this.x,
                            i = this.y,
                            n = this.z,
                            r = t.elements;
                        return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
                    }
                }, {
                    key: "divide",
                    value: function(t) {
                        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                    }
                }, {
                    key: "divideScalar",
                    value: function(t) {
                        return this.multiplyScalar(1 / t)
                    }
                }, {
                    key: "min",
                    value: function(t) {
                        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                    }
                }, {
                    key: "max",
                    value: function(t) {
                        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                    }
                }, {
                    key: "clamp",
                    value: function(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                    }
                }, {
                    key: "clampScalar",
                    value: function(t, e) {
                        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                    }
                }, {
                    key: "clampLength",
                    value: function(t, e) {
                        var i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                    }
                }, {
                    key: "floor",
                    value: function() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                    }
                }, {
                    key: "ceil",
                    value: function() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                    }
                }, {
                    key: "round",
                    value: function() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                    }
                }, {
                    key: "roundToZero",
                    value: function() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                    }
                }, {
                    key: "negate",
                    value: function() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                    }
                }, {
                    key: "dot",
                    value: function(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z
                    }
                }, {
                    key: "lengthSq",
                    value: function() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                }, {
                    key: "length",
                    value: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                }, {
                    key: "manhattanLength",
                    value: function() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                }, {
                    key: "normalize",
                    value: function() {
                        return this.divideScalar(this.length() || 1)
                    }
                }, {
                    key: "setLength",
                    value: function(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                }, {
                    key: "lerp",
                    value: function(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                    }
                }, {
                    key: "lerpVectors",
                    value: function(t, e, i) {
                        return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this
                    }
                }, {
                    key: "cross",
                    value: function(t, e) {
                        return void 0 !== e ? this.crossVectors(t, e) : this.crossVectors(this, t)
                    }
                }, {
                    key: "crossVectors",
                    value: function(t, e) {
                        var i = t.x,
                            n = t.y,
                            r = t.z,
                            a = e.x,
                            s = e.y,
                            o = e.z;
                        return this.x = n * o - r * s, this.y = r * a - i * o, this.z = i * s - n * a, this
                    }
                }, {
                    key: "projectOnVector",
                    value: function(t) {
                        var e = t.lengthSq();
                        if (0 === e) return this.set(0, 0, 0);
                        var i = t.dot(this) / e;
                        return this.copy(t).multiplyScalar(i)
                    }
                }, {
                    key: "projectOnPlane",
                    value: function(t) {
                        return Si.copy(this).projectOnVector(t), this.sub(Si)
                    }
                }, {
                    key: "reflect",
                    value: function(t) {
                        return this.sub(Si.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                }, {
                    key: "angleTo",
                    value: function(t) {
                        var e = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (0 === e) return Math.PI / 2;
                        var i = this.dot(t) / e;
                        return Math.acos(ci.clamp(i, -1, 1))
                    }
                }, {
                    key: "distanceTo",
                    value: function(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                }, {
                    key: "distanceToSquared",
                    value: function(t) {
                        var e = this.x - t.x,
                            i = this.y - t.y,
                            n = this.z - t.z;
                        return e * e + i * i + n * n
                    }
                }, {
                    key: "manhattanDistanceTo",
                    value: function(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                    }
                }, {
                    key: "setFromSpherical",
                    value: function(t) {
                        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                    }
                }, {
                    key: "setFromSphericalCoords",
                    value: function(t, e, i) {
                        var n = Math.sin(e) * t;
                        return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
                    }
                }, {
                    key: "setFromCylindrical",
                    value: function(t) {
                        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                    }
                }, {
                    key: "setFromCylindricalCoords",
                    value: function(t, e, i) {
                        return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
                    }
                }, {
                    key: "setFromMatrixPosition",
                    value: function(t) {
                        var e = t.elements;
                        return this.x = e[12], this.y = e[13], this.z = e[14], this
                    }
                }, {
                    key: "setFromMatrixScale",
                    value: function(t) {
                        var e = this.setFromMatrixColumn(t, 0).length(),
                            i = this.setFromMatrixColumn(t, 1).length(),
                            n = this.setFromMatrixColumn(t, 2).length();
                        return this.x = e, this.y = i, this.z = n, this
                    }
                }, {
                    key: "setFromMatrixColumn",
                    value: function(t, e) {
                        return this.fromArray(t.elements, 4 * e)
                    }
                }, {
                    key: "setFromMatrix3Column",
                    value: function(t, e) {
                        return this.fromArray(t.elements, 3 * e)
                    }
                }, {
                    key: "equals",
                    value: function(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z
                    }
                }, {
                    key: "fromArray",
                    value: function(t, e) {
                        return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                    }
                }, {
                    key: "toArray",
                    value: function(t, e) {
                        return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                    }
                }, {
                    key: "fromBufferAttribute",
                    value: function(t, e) {
                        return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                    }
                }, {
                    key: "random",
                    value: function() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                    }
                }]), n
            }(),
            Si = new(i.Vector3 = wi),
            Mi = new _i,
            Ti = function() {
                function i(t, e) {
                    V(this, i), Object.defineProperty(this, "isBox3", {
                        value: !0
                    }), this.min = void 0 !== t ? t : new wi(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new wi(-1 / 0, -1 / 0, -1 / 0)
                }
                return g(i, [{
                    key: "set",
                    value: function(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    }
                }, {
                    key: "setFromArray",
                    value: function(t) {
                        for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, l = t.length; o < l; o += 3) {
                            var h = t[o],
                                u = t[o + 1],
                                c = t[o + 2];
                            h < e && (e = h), u < i && (i = u), c < n && (n = c), r < h && (r = h), a < u && (a = u), s < c && (s = c)
                        }
                        return this.min.set(e, i, n), this.max.set(r, a, s), this
                    }
                }, {
                    key: "setFromBufferAttribute",
                    value: function(t) {
                        for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, l = t.count; o < l; o++) {
                            var h = t.getX(o),
                                u = t.getY(o),
                                c = t.getZ(o);
                            h < e && (e = h), u < i && (i = u), c < n && (n = c), r < h && (r = h), a < u && (a = u), s < c && (s = c)
                        }
                        return this.min.set(e, i, n), this.max.set(r, a, s), this
                    }
                }, {
                    key: "setFromPoints",
                    value: function(t) {
                        this.makeEmpty();
                        for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                        return this
                    }
                }, {
                    key: "setFromCenterAndSize",
                    value: function(t, e) {
                        var i = Ei.copy(e).multiplyScalar(.5);
                        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                    }
                }, {
                    key: "setFromObject",
                    value: function(t) {
                        return this.makeEmpty(), this.expandByObject(t)
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    }
                }, {
                    key: "makeEmpty",
                    value: function() {
                        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                    }
                }, {
                    key: "isEmpty",
                    value: function() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    }
                }, {
                    key: "getCenter",
                    value: function(t) {
                        return void 0 === t && (t = new wi), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                }, {
                    key: "getSize",
                    value: function(t) {
                        return void 0 === t && (t = new wi), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                    }
                }, {
                    key: "expandByPoint",
                    value: function(t) {
                        return this.min.min(t), this.max.max(t), this
                    }
                }, {
                    key: "expandByVector",
                    value: function(t) {
                        return this.min.sub(t), this.max.add(t), this
                    }
                }, {
                    key: "expandByScalar",
                    value: function(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    }
                }, {
                    key: "expandByObject",
                    value: function(t) {
                        t.updateWorldMatrix(!1, !1);
                        var e = t.geometry;
                        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Di.copy(e.boundingBox), Di.applyMatrix4(t.matrixWorld), this.union(Di));
                        for (var i = t.children, n = 0, r = i.length; n < r; n++) this.expandByObject(i[n]);
                        return this
                    }
                }, {
                    key: "containsPoint",
                    value: function(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                    }
                }, {
                    key: "containsBox",
                    value: function(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                    }
                }, {
                    key: "getParameter",
                    value: function(t, e) {
                        return void 0 === e && (e = new wi), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                    }
                }, {
                    key: "intersectsBox",
                    value: function(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                    }
                }, {
                    key: "intersectsSphere",
                    value: function(t) {
                        return this.clampPoint(t.center, Ei), Ei.distanceToSquared(t.center) <= t.radius * t.radius
                    }
                }, {
                    key: "intersectsPlane",
                    value: function(t) {
                        var e, i = 0 < t.normal.x ? (e = t.normal.x * this.min.x, t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, t.normal.x * this.min.x);
                        return 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
                    }
                }, {
                    key: "intersectsTriangle",
                    value: function(t) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(Ni), Bi.subVectors(this.max, Ni), Pi.subVectors(t.a, Ni), Li.subVectors(t.b, Ni), ki.subVectors(t.c, Ni), Oi.subVectors(Li, Pi), Fi.subVectors(ki, Li), Ii.subVectors(Pi, ki);
                        var e = [0, -Oi.z, Oi.y, 0, -Fi.z, Fi.y, 0, -Ii.z, Ii.y, Oi.z, 0, -Oi.x, Fi.z, 0, -Fi.x, Ii.z, 0, -Ii.x, -Oi.y, Oi.x, 0, -Fi.y, Fi.x, 0, -Ii.y, Ii.x, 0];
                        return !!Ci(e, Pi, Li, ki, Bi) && (!!Ci(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], Pi, Li, ki, Bi) && (Ri.crossVectors(Oi, Fi), Ci(e = [Ri.x, Ri.y, Ri.z], Pi, Li, ki, Bi)))
                    }
                }, {
                    key: "clampPoint",
                    value: function(t, e) {
                        return void 0 === e && (e = new wi), e.copy(t).clamp(this.min, this.max)
                    }
                }, {
                    key: "distanceToPoint",
                    value: function(t) {
                        return Ei.copy(t).clamp(this.min, this.max).sub(t).length()
                    }
                }, {
                    key: "getBoundingSphere",
                    value: function(t) {
                        return this.getCenter(t.center), t.radius = .5 * this.getSize(Ei).length(), t
                    }
                }, {
                    key: "intersect",
                    value: function(t) {
                        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                    }
                }, {
                    key: "union",
                    value: function(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    }
                }, {
                    key: "applyMatrix4",
                    value: function(t) {
                        return this.isEmpty() || (Ai[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ai[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ai[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ai[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ai[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ai[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ai[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ai[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ai)), this
                    }
                }, {
                    key: "translate",
                    value: function(t) {
                        return this.min.add(t), this.max.add(t), this
                    }
                }, {
                    key: "equals",
                    value: function(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }]), i
            }();

        function Ci(t, e, i, n, r) {
            for (var a = 0, s = t.length - 3; a <= s; a += 3) {
                zi.fromArray(t, a);
                var o = r.x * Math.abs(zi.x) + r.y * Math.abs(zi.y) + r.z * Math.abs(zi.z),
                    l = e.dot(zi),
                    h = i.dot(zi),
                    u = n.dot(zi);
                if (Math.max(-Math.max(l, h, u), Math.min(l, h, u)) > o) return !1
            }
            return !0
        }
        i.Box3 = Ti;
        var Ai = [new wi, new wi, new wi, new wi, new wi, new wi, new wi, new wi],
            Ei = new wi,
            Di = new Ti,
            Pi = new wi,
            Li = new wi,
            ki = new wi,
            Oi = new wi,
            Fi = new wi,
            Ii = new wi,
            Ni = new wi,
            Bi = new wi,
            Ri = new wi,
            zi = new wi,
            Gi = new Ti,
            Vi = function() {
                function i(t, e) {
                    V(this, i), this.center = void 0 !== t ? t : new wi, this.radius = void 0 !== e ? e : -1
                }
                return g(i, [{
                    key: "set",
                    value: function(t, e) {
                        return this.center.copy(t), this.radius = e, this
                    }
                }, {
                    key: "setFromPoints",
                    value: function(t, e) {
                        var i = this.center;
                        void 0 !== e ? i.copy(e) : Gi.setFromPoints(t).getCenter(i);
                        for (var n = 0, r = 0, a = t.length; r < a; r++) n = Math.max(n, i.distanceToSquared(t[r]));
                        return this.radius = Math.sqrt(n), this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return this.center.copy(t.center), this.radius = t.radius, this
                    }
                }, {
                    key: "isEmpty",
                    value: function() {
                        return this.radius < 0
                    }
                }, {
                    key: "makeEmpty",
                    value: function() {
                        return this.center.set(0, 0, 0), this.radius = -1, this
                    }
                }, {
                    key: "containsPoint",
                    value: function(t) {
                        return t.distanceToSquared(this.center) <= this.radius * this.radius
                    }
                }, {
                    key: "distanceToPoint",
                    value: function(t) {
                        return t.distanceTo(this.center) - this.radius
                    }
                }, {
                    key: "intersectsSphere",
                    value: function(t) {
                        var e = this.radius + t.radius;
                        return t.center.distanceToSquared(this.center) <= e * e
                    }
                }, {
                    key: "intersectsBox",
                    value: function(t) {
                        return t.intersectsSphere(this)
                    }
                }, {
                    key: "intersectsPlane",
                    value: function(t) {
                        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                    }
                }, {
                    key: "clampPoint",
                    value: function(t, e) {
                        var i = this.center.distanceToSquared(t);
                        return void 0 === e && (e = new wi), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                    }
                }, {
                    key: "getBoundingBox",
                    value: function(t) {
                        return void 0 === t && (t = new Ti), this.isEmpty() ? t.makeEmpty() : (t.set(this.center, this.center), t.expandByScalar(this.radius)), t
                    }
                }, {
                    key: "applyMatrix4",
                    value: function(t) {
                        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                    }
                }, {
                    key: "translate",
                    value: function(t) {
                        return this.center.add(t), this
                    }
                }, {
                    key: "equals",
                    value: function(t) {
                        return t.center.equals(this.center) && t.radius === this.radius
                    }
                }]), i
            }();
        i.Sphere = Vi;
        var Ui = new wi,
            ji = new wi,
            Hi = new wi,
            Wi = new wi,
            qi = new wi,
            Xi = new wi,
            Yi = new wi,
            Ji = function() {
                function i(t, e) {
                    V(this, i), this.origin = void 0 !== t ? t : new wi, this.direction = void 0 !== e ? e : new wi(0, 0, -1)
                }
                return g(i, [{
                    key: "set",
                    value: function(t, e) {
                        return this.origin.copy(t), this.direction.copy(e), this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                    }
                }, {
                    key: "at",
                    value: function(t, e) {
                        return void 0 === e && (e = new wi), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                    }
                }, {
                    key: "lookAt",
                    value: function(t) {
                        return this.direction.copy(t).sub(this.origin).normalize(), this
                    }
                }, {
                    key: "recast",
                    value: function(t) {
                        return this.origin.copy(this.at(t, Ui)), this
                    }
                }, {
                    key: "closestPointToPoint",
                    value: function(t, e) {
                        void 0 === e && (e = new wi), e.subVectors(t, this.origin);
                        var i = e.dot(this.direction);
                        return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
                    }
                }, {
                    key: "distanceToPoint",
                    value: function(t) {
                        return Math.sqrt(this.distanceSqToPoint(t))
                    }
                }, {
                    key: "distanceSqToPoint",
                    value: function(t) {
                        var e = Ui.subVectors(t, this.origin).dot(this.direction);
                        return e < 0 ? this.origin.distanceToSquared(t) : (Ui.copy(this.direction).multiplyScalar(e).add(this.origin), Ui.distanceToSquared(t))
                    }
                }, {
                    key: "distanceSqToSegment",
                    value: function(t, e, i, n) {
                        ji.copy(t).add(e).multiplyScalar(.5), Hi.copy(e).sub(t).normalize(), Wi.copy(this.origin).sub(ji);
                        var r, a, s, o, l, h = .5 * t.distanceTo(e),
                            u = -this.direction.dot(Hi),
                            c = Wi.dot(this.direction),
                            p = -Wi.dot(Hi),
                            d = Wi.lengthSq(),
                            f = Math.abs(1 - u * u);
                        return a = 0 < f ? (o = u * c - p, l = h * f, 0 <= (s = u * p - c) ? -l <= o ? o <= l ? (s *= r = 1 / f) * (s + u * (o *= r) + 2 * c) + o * (u * s + o + 2 * p) + d : (o = h, -(s = Math.max(0, -(u * o + c))) * s + o * (o + 2 * p) + d) : (o = -h, -(s = Math.max(0, -(u * o + c))) * s + o * (o + 2 * p) + d) : o <= -l ? -(s = Math.max(0, -(-u * h + c))) * s + (o = 0 < s ? -h : Math.min(Math.max(-h, -p), h)) * (o + 2 * p) + d : o <= l ? (s = 0, (o = Math.min(Math.max(-h, -p), h)) * (o + 2 * p) + d) : -(s = Math.max(0, -(u * h + c))) * s + (o = 0 < s ? h : Math.min(Math.max(-h, -p), h)) * (o + 2 * p) + d) : (o = 0 < u ? -h : h, -(s = Math.max(0, -(u * o + c))) * s + o * (o + 2 * p) + d), i && i.copy(this.direction).multiplyScalar(s).add(this.origin), n && n.copy(Hi).multiplyScalar(o).add(ji), a
                    }
                }, {
                    key: "intersectSphere",
                    value: function(t, e) {
                        Ui.subVectors(t.center, this.origin);
                        var i = Ui.dot(this.direction),
                            n = Ui.dot(Ui) - i * i,
                            r = t.radius * t.radius;
                        if (r < n) return null;
                        var a = Math.sqrt(r - n),
                            s = i - a,
                            o = i + a;
                        return s < 0 && o < 0 ? null : s < 0 ? this.at(o, e) : this.at(s, e)
                    }
                }, {
                    key: "intersectsSphere",
                    value: function(t) {
                        return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                    }
                }, {
                    key: "distanceToPlane",
                    value: function(t) {
                        var e = t.normal.dot(this.direction);
                        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                        var i = -(this.origin.dot(t.normal) + t.constant) / e;
                        return 0 <= i ? i : null
                    }
                }, {
                    key: "intersectPlane",
                    value: function(t, e) {
                        var i = this.distanceToPlane(t);
                        return null === i ? null : this.at(i, e)
                    }
                }, {
                    key: "intersectsPlane",
                    value: function(t) {
                        var e = t.distanceToPoint(this.origin);
                        return 0 === e || t.normal.dot(this.direction) * e < 0
                    }
                }, {
                    key: "intersectBox",
                    value: function(t, e) {
                        var i, n, r, a, s = 1 / this.direction.x,
                            o = 1 / this.direction.y,
                            l = 1 / this.direction.z,
                            h = this.origin,
                            u = 0 <= s ? (i = (t.min.x - h.x) * s, (t.max.x - h.x) * s) : (i = (t.max.x - h.x) * s, (t.min.x - h.x) * s),
                            c = 0 <= o ? (n = (t.min.y - h.y) * o, (t.max.y - h.y) * o) : (n = (t.max.y - h.y) * o, (t.min.y - h.y) * o);
                        return c < i || u < n ? null : ((i < n || i != i) && (i = n), (c < u || u != u) && (u = c), (a = 0 <= l ? (r = (t.min.z - h.z) * l, (t.max.z - h.z) * l) : (r = (t.max.z - h.z) * l, (t.min.z - h.z) * l)) < i || u < r ? null : ((i < r || i != i) && (i = r), (a < u || u != u) && (u = a), u < 0 ? null : this.at(0 <= i ? i : u, e)))
                    }
                }, {
                    key: "intersectsBox",
                    value: function(t) {
                        return null !== this.intersectBox(t, Ui)
                    }
                }, {
                    key: "intersectTriangle",
                    value: function(t, e, i, n, r) {
                        qi.subVectors(e, t), Xi.subVectors(i, t), Yi.crossVectors(qi, Xi);
                        var a, s = this.direction.dot(Yi);
                        if (0 < s) {
                            if (n) return null;
                            a = 1
                        } else {
                            if (!(s < 0)) return null;
                            a = -1, s = -s
                        }
                        Wi.subVectors(this.origin, t);
                        var o = a * this.direction.dot(Xi.crossVectors(Wi, Xi));
                        if (o < 0) return null;
                        var l = a * this.direction.dot(qi.cross(Wi));
                        if (l < 0) return null;
                        if (s < o + l) return null;
                        var h = -a * Wi.dot(Yi);
                        return h < 0 ? null : this.at(h / s, r)
                    }
                }, {
                    key: "applyMatrix4",
                    value: function(t) {
                        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                    }
                }, {
                    key: "equals",
                    value: function(t) {
                        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                    }
                }]), i
            }();
        i.Ray = Ji;
        var Zi = function() {
            function t() {
                V(this, t), Object.defineProperty(this, "isMatrix4", {
                    value: !0
                }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
            }
            return g(t, [{
                key: "set",
                value: function(t, e, i, n, r, a, s, o, l, h, u, c, p, d, f, m) {
                    var g = this.elements;
                    return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = h, g[10] = u, g[14] = c, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this
                }
            }, {
                key: "identity",
                value: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new t).fromArray(this.elements)
                }
            }, {
                key: "copy",
                value: function(t) {
                    var e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
                }
            }, {
                key: "copyPosition",
                value: function(t) {
                    var e = this.elements,
                        i = t.elements;
                    return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
                }
            }, {
                key: "extractBasis",
                value: function(t, e, i) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
                }
            }, {
                key: "makeBasis",
                value: function(t, e, i) {
                    return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "extractRotation",
                value: function(t) {
                    var e = this.elements,
                        i = t.elements,
                        n = 1 / $i.setFromMatrixColumn(t, 0).length(),
                        r = 1 / $i.setFromMatrixColumn(t, 1).length(),
                        a = 1 / $i.setFromMatrixColumn(t, 2).length();
                    return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * a, e[9] = i[9] * a, e[10] = i[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
            }, {
                key: "makeRotationFromEuler",
                value: function(t) {
                    t && t.isEuler;
                    var e, i, n, r, a, s, o, l, h, u, c, p, d, f, m, g, v, y, b, x, _, w, S, M, T = this.elements,
                        C = t.x,
                        A = t.y,
                        E = t.z,
                        D = Math.cos(C),
                        P = Math.sin(C),
                        L = Math.cos(A),
                        k = Math.sin(A),
                        O = Math.cos(E),
                        F = Math.sin(E);
                    return "XYZ" === t.order ? (e = D * O, i = D * F, n = P * O, r = P * F, T[0] = L * O, T[4] = -L * F, T[8] = k, T[1] = i + n * k, T[5] = e - r * k, T[9] = -P * L, T[2] = r - e * k, T[6] = n + i * k, T[10] = D * L) : "YXZ" === t.order ? (a = L * O, s = L * F, o = k * O, l = k * F, T[0] = a + l * P, T[4] = o * P - s, T[8] = D * k, T[1] = D * F, T[5] = D * O, T[9] = -P, T[2] = s * P - o, T[6] = l + a * P, T[10] = D * L) : "ZXY" === t.order ? (h = L * O, u = L * F, c = k * O, p = k * F, T[0] = h - p * P, T[4] = -D * F, T[8] = c + u * P, T[1] = u + c * P, T[5] = D * O, T[9] = p - h * P, T[2] = -D * k, T[6] = P, T[10] = D * L) : "ZYX" === t.order ? (d = D * O, f = D * F, m = P * O, g = P * F, T[0] = L * O, T[4] = m * k - f, T[8] = d * k + g, T[1] = L * F, T[5] = g * k + d, T[9] = f * k - m, T[2] = -k, T[6] = P * L, T[10] = D * L) : "YZX" === t.order ? (v = D * L, y = D * k, b = P * L, x = P * k, T[0] = L * O, T[4] = x - v * F, T[8] = b * F + y, T[1] = F, T[5] = D * O, T[9] = -P * O, T[2] = -k * O, T[6] = y * F + b, T[10] = v - x * F) : "XZY" === t.order && (_ = D * L, w = D * k, S = P * L, M = P * k, T[0] = L * O, T[4] = -F, T[8] = k * O, T[1] = _ * F + M, T[5] = D * O, T[9] = w * F - S, T[2] = S * F - w, T[6] = P * O, T[10] = M * F + _), T[3] = 0, T[7] = 0, T[11] = 0, T[12] = 0, T[13] = 0, T[14] = 0, T[15] = 1, this
                }
            }, {
                key: "makeRotationFromQuaternion",
                value: function(t) {
                    return this.compose(Qi, t, tn)
                }
            }, {
                key: "lookAt",
                value: function(t, e, i) {
                    var n = this.elements;
                    return rn.subVectors(t, e), 0 === rn.lengthSq() && (rn.z = 1), rn.normalize(), en.crossVectors(i, rn), 0 === en.lengthSq() && (1 === Math.abs(i.z) ? rn.x += 1e-4 : rn.z += 1e-4, rn.normalize(), en.crossVectors(i, rn)), en.normalize(), nn.crossVectors(rn, en), n[0] = en.x, n[4] = nn.x, n[8] = rn.x, n[1] = en.y, n[5] = nn.y, n[9] = rn.y, n[2] = en.z, n[6] = nn.z, n[10] = rn.z, this
                }
            }, {
                key: "multiply",
                value: function(t, e) {
                    return void 0 !== e ? this.multiplyMatrices(t, e) : this.multiplyMatrices(this, t)
                }
            }, {
                key: "premultiply",
                value: function(t) {
                    return this.multiplyMatrices(t, this)
                }
            }, {
                key: "multiplyMatrices",
                value: function(t, e) {
                    var i = t.elements,
                        n = e.elements,
                        r = this.elements,
                        a = i[0],
                        s = i[4],
                        o = i[8],
                        l = i[12],
                        h = i[1],
                        u = i[5],
                        c = i[9],
                        p = i[13],
                        d = i[2],
                        f = i[6],
                        m = i[10],
                        g = i[14],
                        v = i[3],
                        y = i[7],
                        b = i[11],
                        x = i[15],
                        _ = n[0],
                        w = n[4],
                        S = n[8],
                        M = n[12],
                        T = n[1],
                        C = n[5],
                        A = n[9],
                        E = n[13],
                        D = n[2],
                        P = n[6],
                        L = n[10],
                        k = n[14],
                        O = n[3],
                        F = n[7],
                        I = n[11],
                        N = n[15];
                    return r[0] = a * _ + s * T + o * D + l * O, r[4] = a * w + s * C + o * P + l * F, r[8] = a * S + s * A + o * L + l * I, r[12] = a * M + s * E + o * k + l * N, r[1] = h * _ + u * T + c * D + p * O, r[5] = h * w + u * C + c * P + p * F, r[9] = h * S + u * A + c * L + p * I, r[13] = h * M + u * E + c * k + p * N, r[2] = d * _ + f * T + m * D + g * O, r[6] = d * w + f * C + m * P + g * F, r[10] = d * S + f * A + m * L + g * I, r[14] = d * M + f * E + m * k + g * N, r[3] = v * _ + y * T + b * D + x * O, r[7] = v * w + y * C + b * P + x * F, r[11] = v * S + y * A + b * L + x * I, r[15] = v * M + y * E + b * k + x * N, this
                }
            }, {
                key: "multiplyScalar",
                value: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                }
            }, {
                key: "determinant",
                value: function() {
                    var t = this.elements,
                        e = t[0],
                        i = t[4],
                        n = t[8],
                        r = t[12],
                        a = t[1],
                        s = t[5],
                        o = t[9],
                        l = t[13],
                        h = t[2],
                        u = t[6],
                        c = t[10],
                        p = t[14];
                    return t[3] * (r * o * u - n * l * u - r * s * c + i * l * c + n * s * p - i * o * p) + t[7] * (e * o * p - e * l * c + r * a * c - n * a * p + n * l * h - r * o * h) + t[11] * (e * l * u - e * s * p - r * a * u + i * a * p + r * s * h - i * l * h) + t[15] * (-n * s * h - e * o * u + e * s * c + n * a * u - i * a * c + i * o * h)
                }
            }, {
                key: "transpose",
                value: function() {
                    var t = this.elements,
                        e = t[1];
                    return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                }
            }, {
                key: "setPosition",
                value: function(t, e, i) {
                    var n = this.elements;
                    return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this
                }
            }, {
                key: "getInverse",
                value: function(t) {
                    var e = this.elements,
                        i = t.elements,
                        n = i[0],
                        r = i[1],
                        a = i[2],
                        s = i[3],
                        o = i[4],
                        l = i[5],
                        h = i[6],
                        u = i[7],
                        c = i[8],
                        p = i[9],
                        d = i[10],
                        f = i[11],
                        m = i[12],
                        g = i[13],
                        v = i[14],
                        y = i[15],
                        b = p * v * u - g * d * u + g * h * f - l * v * f - p * h * y + l * d * y,
                        x = m * d * u - c * v * u - m * h * f + o * v * f + c * h * y - o * d * y,
                        _ = c * g * u - m * p * u + m * l * f - o * g * f - c * l * y + o * p * y,
                        w = m * p * h - c * g * h - m * l * d + o * g * d + c * l * v - o * p * v,
                        S = n * b + r * x + a * _ + s * w;
                    if (0 == S) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    var M = 1 / S;
                    return e[0] = b * M, e[1] = (g * d * s - p * v * s - g * a * f + r * v * f + p * a * y - r * d * y) * M, e[2] = (l * v * s - g * h * s + g * a * u - r * v * u - l * a * y + r * h * y) * M, e[3] = (p * h * s - l * d * s - p * a * u + r * d * u + l * a * f - r * h * f) * M, e[4] = x * M, e[5] = (c * v * s - m * d * s + m * a * f - n * v * f - c * a * y + n * d * y) * M, e[6] = (m * h * s - o * v * s - m * a * u + n * v * u + o * a * y - n * h * y) * M, e[7] = (o * d * s - c * h * s + c * a * u - n * d * u - o * a * f + n * h * f) * M, e[8] = _ * M, e[9] = (m * p * s - c * g * s - m * r * f + n * g * f + c * r * y - n * p * y) * M, e[10] = (o * g * s - m * l * s + m * r * u - n * g * u - o * r * y + n * l * y) * M, e[11] = (c * l * s - o * p * s - c * r * u + n * p * u + o * r * f - n * l * f) * M, e[12] = w * M, e[13] = (c * g * a - m * p * a + m * r * d - n * g * d - c * r * v + n * p * v) * M, e[14] = (m * l * a - o * g * a - m * r * h + n * g * h + o * r * v - n * l * v) * M, e[15] = (o * p * a - c * l * a + c * r * h - n * p * h - o * r * d + n * l * d) * M, this
                }
            }, {
                key: "scale",
                value: function(t) {
                    var e = this.elements,
                        i = t.x,
                        n = t.y,
                        r = t.z;
                    return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
                }
            }, {
                key: "getMaxScaleOnAxis",
                value: function() {
                    var t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, i, n))
                }
            }, {
                key: "makeTranslation",
                value: function(t, e, i) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
                }
            }, {
                key: "makeRotationX",
                value: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "makeRotationY",
                value: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "makeRotationZ",
                value: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "makeRotationAxis",
                value: function(t, e) {
                    var i = Math.cos(e),
                        n = Math.sin(e),
                        r = 1 - i,
                        a = t.x,
                        s = t.y,
                        o = t.z,
                        l = r * a,
                        h = r * s;
                    return this.set(l * a + i, l * s - n * o, l * o + n * s, 0, l * s + n * o, h * s + i, h * o - n * a, 0, l * o - n * s, h * o + n * a, r * o * o + i, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "makeScale",
                value: function(t, e, i) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "makeShear",
                value: function(t, e, i) {
                    return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "compose",
                value: function(t, e, i) {
                    var n = this.elements,
                        r = e._x,
                        a = e._y,
                        s = e._z,
                        o = e._w,
                        l = r + r,
                        h = a + a,
                        u = s + s,
                        c = r * l,
                        p = r * h,
                        d = r * u,
                        f = a * h,
                        m = a * u,
                        g = s * u,
                        v = o * l,
                        y = o * h,
                        b = o * u,
                        x = i.x,
                        _ = i.y,
                        w = i.z;
                    return n[0] = (1 - (f + g)) * x, n[1] = (p + b) * x, n[2] = (d - y) * x, n[3] = 0, n[4] = (p - b) * _, n[5] = (1 - (c + g)) * _, n[6] = (m + v) * _, n[7] = 0, n[8] = (d + y) * w, n[9] = (m - v) * w, n[10] = (1 - (c + f)) * w, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
                }
            }, {
                key: "decompose",
                value: function(t, e, i) {
                    var n = this.elements,
                        r = $i.set(n[0], n[1], n[2]).length(),
                        a = $i.set(n[4], n[5], n[6]).length(),
                        s = $i.set(n[8], n[9], n[10]).length();
                    this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], Ki.copy(this);
                    var o = 1 / r,
                        l = 1 / a,
                        h = 1 / s;
                    return Ki.elements[0] *= o, Ki.elements[1] *= o, Ki.elements[2] *= o, Ki.elements[4] *= l, Ki.elements[5] *= l, Ki.elements[6] *= l, Ki.elements[8] *= h, Ki.elements[9] *= h, Ki.elements[10] *= h, e.setFromRotationMatrix(Ki), i.x = r, i.y = a, i.z = s, this
                }
            }, {
                key: "makePerspective",
                value: function(t, e, i, n, r, a) {
                    var s = this.elements,
                        o = 2 * r / (e - t),
                        l = 2 * r / (i - n),
                        h = (e + t) / (e - t),
                        u = (i + n) / (i - n),
                        c = -(a + r) / (a - r),
                        p = -2 * a * r / (a - r);
                    return s[0] = o, s[4] = 0, s[8] = h, s[12] = 0, s[1] = 0, s[5] = l, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = c, s[14] = p, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
                }
            }, {
                key: "makeOrthographic",
                value: function(t, e, i, n, r, a) {
                    var s = this.elements,
                        o = 1 / (e - t),
                        l = 1 / (i - n),
                        h = 1 / (a - r),
                        u = (e + t) * o,
                        c = (i + n) * l,
                        p = (a + r) * h;
                    return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -c, s[2] = 0, s[6] = 0, s[10] = -2 * h, s[14] = -p, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
                }
            }, {
                key: "equals",
                value: function(t) {
                    for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
                        if (e[n] !== i[n]) return !1;
                    return !0
                }
            }, {
                key: "fromArray",
                value: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
                    return this
                }
            }, {
                key: "toArray",
                value: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
                }
            }]), t
        }();
        i.Matrix4 = Zi;
        var $i = new wi,
            Ki = new Zi,
            Qi = new wi(0, 0, 0),
            tn = new wi(1, 1, 1),
            en = new wi,
            nn = new wi,
            rn = new wi,
            an = function() {
                function r() {
                    var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                        e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                        i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                        n = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : r.DefaultOrder;
                    V(this, r), Object.defineProperty(this, "isEuler", {
                        value: !0
                    }), this._x = t, this._y = e, this._z = i, this._order = n
                }
                return g(r, [{
                    key: "set",
                    value: function(t, e, i, n) {
                        return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this._onChangeCallback(), this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return new this.constructor(this._x, this._y, this._z, this._order)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                    }
                }, {
                    key: "setFromRotationMatrix",
                    value: function(t, e, i) {
                        var n = ci.clamp,
                            r = t.elements,
                            a = r[0],
                            s = r[4],
                            o = r[8],
                            l = r[1],
                            h = r[5],
                            u = r[9],
                            c = r[2],
                            p = r[6],
                            d = r[10];
                        switch (e = e || this._order) {
                            case "XYZ":
                                this._y = Math.asin(n(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(p, h), this._z = 0);
                                break;
                            case "YXZ":
                                this._x = Math.asin(-n(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-c, a), this._z = 0);
                                break;
                            case "ZXY":
                                this._x = Math.asin(n(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-s, h)) : (this._y = 0, this._z = Math.atan2(l, a));
                                break;
                            case "ZYX":
                                this._y = Math.asin(-n(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-s, h));
                                break;
                            case "YZX":
                                this._z = Math.asin(n(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, h), this._y = Math.atan2(-c, a)) : (this._x = 0, this._y = Math.atan2(o, d));
                                break;
                            case "XZY":
                                this._z = Math.asin(-n(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(p, h), this._y = Math.atan2(o, a)) : (this._x = Math.atan2(-u, d), this._y = 0)
                        }
                        return this._order = e, !1 !== i && this._onChangeCallback(), this
                    }
                }, {
                    key: "setFromQuaternion",
                    value: function(t, e, i) {
                        return sn.makeRotationFromQuaternion(t), this.setFromRotationMatrix(sn, e, i)
                    }
                }, {
                    key: "setFromVector3",
                    value: function(t, e) {
                        return this.set(t.x, t.y, t.z, e || this._order)
                    }
                }, {
                    key: "reorder",
                    value: function(t) {
                        return on.setFromEuler(this), this.setFromQuaternion(on, t)
                    }
                }, {
                    key: "equals",
                    value: function(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                    }
                }, {
                    key: "fromArray",
                    value: function(t) {
                        return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                    }
                }, {
                    key: "toArray",
                    value: function(t, e) {
                        return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                    }
                }, {
                    key: "toVector3",
                    value: function(t) {
                        return t ? t.set(this._x, this._y, this._z) : new wi(this._x, this._y, this._z)
                    }
                }, {
                    key: "_onChange",
                    value: function(t) {
                        return this._onChangeCallback = t, this
                    }
                }, {
                    key: "_onChangeCallback",
                    value: function() {}
                }, {
                    key: "x",
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this._onChangeCallback()
                    }
                }, {
                    key: "y",
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this._onChangeCallback()
                    }
                }, {
                    key: "z",
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this._onChangeCallback()
                    }
                }, {
                    key: "order",
                    get: function() {
                        return this._order
                    },
                    set: function(t) {
                        this._order = t, this._onChangeCallback()
                    }
                }]), r
            }();
        (i.Euler = an).DefaultOrder = "XYZ", an.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        var sn = new Zi,
            on = new _i,
            ln = function() {
                function t() {
                    V(this, t), this.mask = 1
                }
                return g(t, [{
                    key: "set",
                    value: function(t) {
                        this.mask = 1 << t | 0
                    }
                }, {
                    key: "enable",
                    value: function(t) {
                        this.mask |= 1 << t | 0
                    }
                }, {
                    key: "enableAll",
                    value: function() {
                        this.mask = -1
                    }
                }, {
                    key: "toggle",
                    value: function(t) {
                        this.mask ^= 1 << t | 0
                    }
                }, {
                    key: "disable",
                    value: function(t) {
                        this.mask &= ~(1 << t | 0)
                    }
                }, {
                    key: "disableAll",
                    value: function() {
                        this.mask = 0
                    }
                }, {
                    key: "test",
                    value: function(t) {
                        return 0 != (this.mask & t.mask)
                    }
                }]), t
            }();
        i.Layers = ln;
        var hn = 0,
            un = new wi,
            cn = new _i,
            pn = new Zi,
            dn = new wi,
            fn = new wi,
            mn = new wi,
            gn = new _i,
            vn = new wi(1, 0, 0),
            yn = new wi(0, 1, 0),
            bn = new wi(0, 0, 1),
            xn = {
                type: "added"
            },
            _n = {
                type: "removed"
            };

        function wn() {
            Object.defineProperty(this, "id", {
                value: hn++
            }), this.uuid = ci.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = wn.DefaultUp.clone();
            var t = new wi,
                e = new an,
                i = new _i,
                n = new wi(1, 1, 1);
            e._onChange(function() {
                i.setFromEuler(e, !1)
            }), i._onChange(function() {
                e.setFromQuaternion(i, void 0, !1)
            }), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                modelViewMatrix: {
                    value: new Zi
                },
                normalMatrix: {
                    value: new fi
                }
            }), this.matrix = new Zi, this.matrixWorld = new Zi, this.matrixAutoUpdate = wn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ln, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
        }
        wn.DefaultUp = new wi(0, 1, 0), wn.DefaultMatrixAutoUpdate = !0, wn.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: wn,
            isObject3D: !0,
            onBeforeRender: function() {},
            onAfterRender: function() {},
            applyMatrix4: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function(t) {
                return this.quaternion.premultiply(t), this
            },
            setRotationFromAxisAngle: function(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function(t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function(t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function(t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function(t, e) {
                return cn.setFromAxisAngle(t, e), this.quaternion.multiply(cn), this
            },
            rotateOnWorldAxis: function(t, e) {
                return cn.setFromAxisAngle(t, e), this.quaternion.premultiply(cn), this
            },
            rotateX: function(t) {
                return this.rotateOnAxis(vn, t)
            },
            rotateY: function(t) {
                return this.rotateOnAxis(yn, t)
            },
            rotateZ: function(t) {
                return this.rotateOnAxis(bn, t)
            },
            translateOnAxis: function(t, e) {
                return un.copy(t).applyQuaternion(this.quaternion), this.position.add(un.multiplyScalar(e)), this
            },
            translateX: function(t) {
                return this.translateOnAxis(vn, t)
            },
            translateY: function(t) {
                return this.translateOnAxis(yn, t)
            },
            translateZ: function(t) {
                return this.translateOnAxis(bn, t)
            },
            localToWorld: function(t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function(t) {
                return t.applyMatrix4(pn.getInverse(this.matrixWorld))
            },
            lookAt: function(t, e, i) {
                t.isVector3 ? dn.copy(t) : dn.set(t, e, i);
                var n = this.parent;
                this.updateWorldMatrix(!0, !1), fn.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? pn.lookAt(fn, dn, this.up) : pn.lookAt(dn, fn, this.up), this.quaternion.setFromRotationMatrix(pn), n && (pn.extractRotation(n.matrixWorld), cn.setFromRotationMatrix(pn), this.quaternion.premultiply(cn.inverse()))
            },
            add: function(t) {
                if (1 < arguments.length) {
                    for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return t === this || t && t.isObject3D && (null !== t.parent && t.parent.remove(t), (t.parent = this).children.push(t), t.dispatchEvent(xn)), this
            },
            remove: function(t) {
                if (1 < arguments.length) {
                    for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                var i = this.children.indexOf(t);
                return -1 !== i && (t.parent = null, this.children.splice(i, 1), t.dispatchEvent(_n)), this
            },
            attach: function(t) {
                return this.updateWorldMatrix(!0, !1), pn.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), pn.multiply(t.parent.matrixWorld)), t.applyMatrix4(pn), t.updateWorldMatrix(!1, !1), this.add(t), this
            },
            getObjectById: function(t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function(t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function(t, e) {
                if (this[t] === e) return this;
                for (var i = 0, n = this.children.length; i < n; i++) {
                    var r = this.children[i].getObjectByProperty(t, e);
                    if (void 0 !== r) return r
                }
            },
            getWorldPosition: function(t) {
                return void 0 === t && (t = new wi), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function(t) {
                return void 0 === t && (t = new _i), this.updateMatrixWorld(!0), this.matrixWorld.decompose(fn, t, mn), t
            },
            getWorldScale: function(t) {
                return void 0 === t && (t = new wi), this.updateMatrixWorld(!0), this.matrixWorld.decompose(fn, gn, t), t
            },
            getWorldDirection: function(t) {
                void 0 === t && (t = new wi), this.updateMatrixWorld(!0);
                var e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            },
            raycast: function() {},
            traverse: function(t) {
                t(this);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
            },
            traverseVisible: function(t) {
                if (!1 !== this.visible) {
                    t(this);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                }
            },
            traverseAncestors: function(t) {
                var e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t = !(this.matrixWorldNeedsUpdate = !1));
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
            },
            updateWorldMatrix: function(t, e) {
                var i = this.parent;
                if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                    for (var n = this.children, r = 0, a = n.length; r < a; r++) n[r].updateWorldMatrix(!1, !0)
            },
            toJSON: function(i) {
                var t = void 0 === i || "string" == typeof i,
                    e = {};
                t && (i = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                }, e.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var n, r, a, s, o, l = {};

                function h(t, e) {
                    return void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(i)), e.uuid
                }
                if (l.uuid = this.uuid, l.type = this.type, "" !== this.name && (l.name = this.name), !0 === this.castShadow && (l.castShadow = !0), !0 === this.receiveShadow && (l.receiveShadow = !0), !1 === this.visible && (l.visible = !1), !1 === this.frustumCulled && (l.frustumCulled = !1), 0 !== this.renderOrder && (l.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (l.userData = this.userData), l.layers = this.layers.mask, l.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (l.matrixAutoUpdate = !1), this.isInstancedMesh && (l.type = "InstancedMesh", l.count = this.count, l.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                    l.geometry = h(i.geometries, this.geometry);
                    var u = this.geometry.parameters;
                    if (void 0 !== u && void 0 !== u.shapes) {
                        var c = u.shapes;
                        if (Array.isArray(c))
                            for (var p = 0, d = c.length; p < d; p++) {
                                var f = c[p];
                                h(i.shapes, f)
                            } else h(i.shapes, c)
                    }
                }
                if (void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        for (var m = [], g = 0, v = this.material.length; g < v; g++) m.push(h(i.materials, this.material[g]));
                        l.material = m
                    } else l.material = h(i.materials, this.material);
                if (0 < this.children.length) {
                    l.children = [];
                    for (var y = 0; y < this.children.length; y++) l.children.push(this.children[y].toJSON(i).object)
                }
                return t && (n = b(i.geometries), r = b(i.materials), a = b(i.textures), s = b(i.images), o = b(i.shapes), 0 < n.length && (e.geometries = n), 0 < r.length && (e.materials = r), 0 < a.length && (e.textures = a), 0 < s.length && (e.images = s), 0 < o.length && (e.shapes = o)), e.object = l, e;

                function b(t) {
                    var e = [];
                    for (var i in t) {
                        var n = t[i];
                        delete n.metadata, e.push(n)
                    }
                    return e
                }
            },
            clone: function(t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function(t, e) {
                if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (var i = 0; i < t.children.length; i++) {
                        var n = t.children[i];
                        this.add(n.clone())
                    }
                return this
            }
        });
        var Sn = new wi,
            Mn = new wi,
            Tn = new fi,
            Cn = function() {
                function i(t, e) {
                    V(this, i), Object.defineProperty(this, "isPlane", {
                        value: !0
                    }), this.normal = void 0 !== t ? t : new wi(1, 0, 0), this.constant = void 0 !== e ? e : 0
                }
                return g(i, [{
                    key: "set",
                    value: function(t, e) {
                        return this.normal.copy(t), this.constant = e, this
                    }
                }, {
                    key: "setComponents",
                    value: function(t, e, i, n) {
                        return this.normal.set(t, e, i), this.constant = n, this
                    }
                }, {
                    key: "setFromNormalAndCoplanarPoint",
                    value: function(t, e) {
                        return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                    }
                }, {
                    key: "setFromCoplanarPoints",
                    value: function(t, e, i) {
                        var n = Sn.subVectors(i, e).cross(Mn.subVectors(t, e)).normalize();
                        return this.setFromNormalAndCoplanarPoint(n, t), this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return this.normal.copy(t.normal), this.constant = t.constant, this
                    }
                }, {
                    key: "normalize",
                    value: function() {
                        var t = 1 / this.normal.length();
                        return this.normal.multiplyScalar(t), this.constant *= t, this
                    }
                }, {
                    key: "negate",
                    value: function() {
                        return this.constant *= -1, this.normal.negate(), this
                    }
                }, {
                    key: "distanceToPoint",
                    value: function(t) {
                        return this.normal.dot(t) + this.constant
                    }
                }, {
                    key: "distanceToSphere",
                    value: function(t) {
                        return this.distanceToPoint(t.center) - t.radius
                    }
                }, {
                    key: "projectPoint",
                    value: function(t, e) {
                        return void 0 === e && (e = new wi), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                    }
                }, {
                    key: "intersectLine",
                    value: function(t, e) {
                        void 0 === e && (e = new wi);
                        var i = t.delta(Sn),
                            n = this.normal.dot(i);
                        if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
                        var r = -(t.start.dot(this.normal) + this.constant) / n;
                        return r < 0 || 1 < r ? void 0 : e.copy(i).multiplyScalar(r).add(t.start)
                    }
                }, {
                    key: "intersectsLine",
                    value: function(t) {
                        var e = this.distanceToPoint(t.start),
                            i = this.distanceToPoint(t.end);
                        return e < 0 && 0 < i || i < 0 && 0 < e
                    }
                }, {
                    key: "intersectsBox",
                    value: function(t) {
                        return t.intersectsPlane(this)
                    }
                }, {
                    key: "intersectsSphere",
                    value: function(t) {
                        return t.intersectsPlane(this)
                    }
                }, {
                    key: "coplanarPoint",
                    value: function(t) {
                        return void 0 === t && (t = new wi), t.copy(this.normal).multiplyScalar(-this.constant)
                    }
                }, {
                    key: "applyMatrix4",
                    value: function(t, e) {
                        var i = e || Tn.getNormalMatrix(t),
                            n = this.coplanarPoint(Sn).applyMatrix4(t),
                            r = this.normal.applyMatrix3(i).normalize();
                        return this.constant = -n.dot(r), this
                    }
                }, {
                    key: "translate",
                    value: function(t) {
                        return this.constant -= t.dot(this.normal), this
                    }
                }, {
                    key: "equals",
                    value: function(t) {
                        return t.normal.equals(this.normal) && t.constant === this.constant
                    }
                }]), i
            }();
        i.Plane = Cn;
        var An = new wi,
            En = new wi,
            Dn = new wi,
            Pn = new wi,
            Ln = new wi,
            kn = new wi,
            On = new wi,
            Fn = new wi,
            In = new wi,
            Nn = new wi,
            Bn = function() {
                function a(t, e, i) {
                    V(this, a), this.a = void 0 !== t ? t : new wi, this.b = void 0 !== e ? e : new wi, this.c = void 0 !== i ? i : new wi
                }
                return g(a, [{
                    key: "set",
                    value: function(t, e, i) {
                        return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
                    }
                }, {
                    key: "setFromPointsAndIndices",
                    value: function(t, e, i, n) {
                        return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                    }
                }, {
                    key: "getArea",
                    value: function() {
                        return An.subVectors(this.c, this.b), En.subVectors(this.a, this.b), .5 * An.cross(En).length()
                    }
                }, {
                    key: "getMidpoint",
                    value: function(t) {
                        return void 0 === t && (t = new wi), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                }, {
                    key: "getNormal",
                    value: function(t) {
                        return a.getNormal(this.a, this.b, this.c, t)
                    }
                }, {
                    key: "getPlane",
                    value: function(t) {
                        return void 0 === t && (t = new Cn), t.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                }, {
                    key: "getBarycoord",
                    value: function(t, e) {
                        return a.getBarycoord(t, this.a, this.b, this.c, e)
                    }
                }, {
                    key: "getUV",
                    value: function(t, e, i, n, r) {
                        return a.getUV(t, this.a, this.b, this.c, e, i, n, r)
                    }
                }, {
                    key: "containsPoint",
                    value: function(t) {
                        return a.containsPoint(t, this.a, this.b, this.c)
                    }
                }, {
                    key: "isFrontFacing",
                    value: function(t) {
                        return a.isFrontFacing(this.a, this.b, this.c, t)
                    }
                }, {
                    key: "intersectsBox",
                    value: function(t) {
                        return t.intersectsTriangle(this)
                    }
                }, {
                    key: "closestPointToPoint",
                    value: function(t, e) {
                        void 0 === e && (e = new wi);
                        var i = this.a,
                            n = this.b,
                            r = this.c;
                        Ln.subVectors(n, i), kn.subVectors(r, i), Fn.subVectors(t, i);
                        var a = Ln.dot(Fn),
                            s = kn.dot(Fn);
                        if (a <= 0 && s <= 0) return e.copy(i);
                        In.subVectors(t, n);
                        var o = Ln.dot(In),
                            l = kn.dot(In);
                        if (0 <= o && l <= o) return e.copy(n);
                        var h = a * l - o * s;
                        if (h <= 0 && 0 <= a && o <= 0) return m = a / (a - o), e.copy(i).addScaledVector(Ln, m);
                        Nn.subVectors(t, r);
                        var u = Ln.dot(Nn),
                            c = kn.dot(Nn);
                        if (0 <= c && u <= c) return e.copy(r);
                        var p = u * s - a * c;
                        if (p <= 0 && 0 <= s && c <= 0) return g = s / (s - c), e.copy(i).addScaledVector(kn, g);
                        var d = o * c - u * l;
                        if (d <= 0 && 0 <= l - o && 0 <= u - c) return On.subVectors(r, n), g = (l - o) / (l - o + (u - c)), e.copy(n).addScaledVector(On, g);
                        var f = 1 / (d + p + h),
                            m = p * f,
                            g = h * f;
                        return e.copy(i).addScaledVector(Ln, m).addScaledVector(kn, g)
                    }
                }, {
                    key: "equals",
                    value: function(t) {
                        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                    }
                }], [{
                    key: "getNormal",
                    value: function(t, e, i, n) {
                        void 0 === n && (n = new wi), n.subVectors(i, e), An.subVectors(t, e), n.cross(An);
                        var r = n.lengthSq();
                        return 0 < r ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
                    }
                }, {
                    key: "getBarycoord",
                    value: function(t, e, i, n, r) {
                        An.subVectors(n, e), En.subVectors(i, e), Dn.subVectors(t, e);
                        var a = An.dot(An),
                            s = An.dot(En),
                            o = An.dot(Dn),
                            l = En.dot(En),
                            h = En.dot(Dn),
                            u = a * l - s * s;
                        if (void 0 === r && (r = new wi), 0 == u) return r.set(-2, -1, -1);
                        var c = 1 / u,
                            p = (l * o - s * h) * c,
                            d = (a * h - s * o) * c;
                        return r.set(1 - p - d, d, p)
                    }
                }, {
                    key: "containsPoint",
                    value: function(t, e, i, n) {
                        return this.getBarycoord(t, e, i, n, Pn), 0 <= Pn.x && 0 <= Pn.y && Pn.x + Pn.y <= 1
                    }
                }, {
                    key: "getUV",
                    value: function(t, e, i, n, r, a, s, o) {
                        return this.getBarycoord(t, e, i, n, Pn), o.set(0, 0), o.addScaledVector(r, Pn.x), o.addScaledVector(a, Pn.y), o.addScaledVector(s, Pn.z), o
                    }
                }, {
                    key: "isFrontFacing",
                    value: function(t, e, i, n) {
                        return An.subVectors(i, e), En.subVectors(t, e), An.cross(En).dot(n) < 0
                    }
                }]), a
            }();
        i.Triangle = Bn;
        var Rn = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            zn = {
                h: 0,
                s: 0,
                l: 0
            },
            Gn = {
                h: 0,
                s: 0,
                l: 0
            };

        function Vn(t, e, i) {
            return i < 0 && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
        }

        function Un(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function jn(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        var Hn = function() {
            function n(t, e, i) {
                return V(this, n), Object.defineProperty(this, "isColor", {
                    value: !0
                }), void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
            }
            return g(n, [{
                key: "set",
                value: function(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                }
            }, {
                key: "setScalar",
                value: function(t) {
                    return this.r = t, this.g = t, this.b = t, this
                }
            }, {
                key: "setHex",
                value: function(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                }
            }, {
                key: "setRGB",
                value: function(t, e, i) {
                    return this.r = t, this.g = e, this.b = i, this
                }
            }, {
                key: "setHSL",
                value: function(t, e, i) {
                    var n, r;
                    return t = ci.euclideanModulo(t, 1), e = ci.clamp(e, 0, 1), i = ci.clamp(i, 0, 1), 0 === e ? this.r = this.g = this.b = i : (r = 2 * i - (n = i <= .5 ? i * (1 + e) : i + e - i * e), this.r = Vn(r, n, t + 1 / 3), this.g = Vn(r, n, t), this.b = Vn(r, n, t - 1 / 3)), this
                }
            }, {
                key: "setStyle",
                value: function(t) {
                    function e(t) {
                        void 0 !== t && parseFloat(t)
                    }
                    var i;
                    if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        var n, r = i[1],
                            a = i[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
                                if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                    var s = parseFloat(n[1]) / 360,
                                        o = parseInt(n[2], 10) / 100,
                                        l = parseInt(n[3], 10) / 100;
                                    return e(n[5]), this.setHSL(s, o, l)
                                }
                        }
                    } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        var h = i[1],
                            u = h.length;
                        if (3 === u) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255, this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
                        if (6 === u) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255, this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
                    }
                    return t && 0 < t.length ? this.setColorName(t) : this
                }
            }, {
                key: "setColorName",
                value: function(t) {
                    var e = Rn[t];
                    return void 0 !== e && this.setHex(e), this
                }
            }, {
                key: "clone",
                value: function() {
                    return new this.constructor(this.r, this.g, this.b)
                }
            }, {
                key: "copy",
                value: function(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                }
            }, {
                key: "copyGammaToLinear",
                value: function(t, e) {
                    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                }
            }, {
                key: "copyLinearToGamma",
                value: function(t, e) {
                    void 0 === e && (e = 2);
                    var i = 0 < e ? 1 / e : 1;
                    return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
                }
            }, {
                key: "convertGammaToLinear",
                value: function(t) {
                    return this.copyGammaToLinear(this, t), this
                }
            }, {
                key: "convertLinearToGamma",
                value: function(t) {
                    return this.copyLinearToGamma(this, t), this
                }
            }, {
                key: "copySRGBToLinear",
                value: function(t) {
                    return this.r = Un(t.r), this.g = Un(t.g), this.b = Un(t.b), this
                }
            }, {
                key: "copyLinearToSRGB",
                value: function(t) {
                    return this.r = jn(t.r), this.g = jn(t.g), this.b = jn(t.b), this
                }
            }, {
                key: "convertSRGBToLinear",
                value: function() {
                    return this.copySRGBToLinear(this), this
                }
            }, {
                key: "convertLinearToSRGB",
                value: function() {
                    return this.copyLinearToSRGB(this), this
                }
            }, {
                key: "getHex",
                value: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                }
            }, {
                key: "getHexString",
                value: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                }
            }, {
                key: "getHSL",
                value: function(t) {
                    void 0 === t && (t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var e, i = this.r,
                        n = this.g,
                        r = this.b,
                        a = Math.max(i, n, r),
                        s = Math.min(i, n, r),
                        o = (s + a) / 2;
                    if (s === a) h = e = 0;
                    else {
                        var l = a - s,
                            h = o <= .5 ? l / (a + s) : l / (2 - a - s);
                        switch (a) {
                            case i:
                                e = (n - r) / l + (n < r ? 6 : 0);
                                break;
                            case n:
                                e = (r - i) / l + 2;
                                break;
                            case r:
                                e = (i - n) / l + 4
                        }
                        e /= 6
                    }
                    return t.h = e, t.s = h, t.l = o, t
                }
            }, {
                key: "getStyle",
                value: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                }
            }, {
                key: "offsetHSL",
                value: function(t, e, i) {
                    return this.getHSL(zn), zn.h += t, zn.s += e, zn.l += i, this.setHSL(zn.h, zn.s, zn.l), this
                }
            }, {
                key: "add",
                value: function(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                }
            }, {
                key: "addColors",
                value: function(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                }
            }, {
                key: "addScalar",
                value: function(t) {
                    return this.r += t, this.g += t, this.b += t, this
                }
            }, {
                key: "sub",
                value: function(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                }
            }, {
                key: "multiply",
                value: function(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                }
            }, {
                key: "multiplyScalar",
                value: function(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                }
            }, {
                key: "lerp",
                value: function(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                }
            }, {
                key: "lerpHSL",
                value: function(t, e) {
                    this.getHSL(zn), t.getHSL(Gn);
                    var i = ci.lerp(zn.h, Gn.h, e),
                        n = ci.lerp(zn.s, Gn.s, e),
                        r = ci.lerp(zn.l, Gn.l, e);
                    return this.setHSL(i, n, r), this
                }
            }, {
                key: "equals",
                value: function(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                }
            }, {
                key: "fromArray",
                value: function(t, e) {
                    return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                }
            }, {
                key: "toArray",
                value: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                }
            }, {
                key: "fromBufferAttribute",
                value: function(t, e) {
                    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
            }, {
                key: "toJSON",
                value: function() {
                    return this.getHex()
                }
            }]), n
        }();
        (i.Color = Hn).NAMES = Rn, Hn.prototype.r = 1, Hn.prototype.g = 1, Hn.prototype.b = 1;
        var Wn = function() {
            function s(t, e, i, n, r, a) {
                V(this, s), this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new wi, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new Hn, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
            }
            return g(s, [{
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(t) {
                    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                    for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (var n = 0, r = t.vertexColors.length; n < r; n++) this.vertexColors[n] = t.vertexColors[n].clone();
                    return this
                }
            }]), s
        }();
        i.Face3 = Wn;
        var qn = 0;

        function Xn() {
            Object.defineProperty(this, "id", {
                value: qn++
            }), this.uuid = ci.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = K, this.side = k, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = pt, this.blendDst = dt, this.blendEquation = nt, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = wt, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = ni, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ii, this.stencilZFail = ii, this.stencilZPass = ii, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
        }

        function Yn(t) {
            Xn.call(this), this.type = "MeshBasicMaterial", this.color = new Hn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = R, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
        }
        Xn.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: Xn,
            isMaterial: !0,
            onBeforeCompile: function() {},
            customProgramCacheKey: function() {
                return this.onBeforeCompile.toString()
            },
            setValues: function(t) {
                if (void 0 !== t)
                    for (var e in t) {
                        var i, n = t[e];
                        void 0 !== n && ("shading" !== e ? void 0 !== (i = this[e]) && (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n) : this.flatShading = 1 === n)
                    }
            },
            toJSON: function(t) {
                var e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                var i, n, r = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function a(t) {
                    var e = [];
                    for (var i in t) {
                        var n = t[i];
                        delete n.metadata, e.push(n)
                    }
                    return e
                }
                return r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), void 0 !== this.roughness && (r.roughness = this.roughness), void 0 !== this.metalness && (r.metalness = this.metalness), this.sheen && this.sheen.isColor && (r.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), void 0 !== this.shininess && (r.shininess = this.shininess), void 0 !== this.clearcoat && (r.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (r.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(t).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(t).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(t).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(t).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(t).uuid, r.reflectivity = this.reflectivity, r.refractionRatio = this.refractionRatio, void 0 !== this.combine && (r.combine = this.combine), void 0 !== this.envMapIntensity && (r.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (r.size = this.size), void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== K && (r.blending = this.blending), !0 === this.flatShading && (r.flatShading = this.flatShading), this.side !== k && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), !0 === this.transparent && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (r.rotation = this.rotation), !0 === this.polygonOffset && (r.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (r.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (r.linewidth = this.linewidth), void 0 !== this.dashSize && (r.dashSize = this.dashSize), void 0 !== this.gapSize && (r.gapSize = this.gapSize), void 0 !== this.scale && (r.scale = this.scale), !0 === this.dithering && (r.dithering = !0), 0 < this.alphaTest && (r.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (r.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (r.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (r.morphTargets = !0), !0 === this.morphNormals && (r.morphNormals = !0), !0 === this.skinning && (r.skinning = !0), !1 === this.visible && (r.visible = !1), !1 === this.toneMapped && (r.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), e && (i = a(t.textures), n = a(t.images), 0 < i.length && (r.textures = i), 0 < n.length && (r.images = n)), r
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                var e = t.clippingPlanes,
                    i = null;
                if (null !== e)
                    for (var n = e.length, i = new Array(n), r = 0; r !== n; ++r) i[r] = e[r].clone();
                return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Object.defineProperty(Xn.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), ((Yn.prototype = Object.create(Xn.prototype)).constructor = Yn).prototype.isMeshBasicMaterial = !0, Yn.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
        };
        var Jn = new wi,
            Zn = new pi;

        function $n(t, e, i) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.usage = ri, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function Kn(t, e, i) {
            $n.call(this, new Int8Array(t), e, i)
        }

        function Qn(t, e, i) {
            $n.call(this, new Uint8Array(t), e, i)
        }

        function tr(t, e, i) {
            $n.call(this, new Uint8ClampedArray(t), e, i)
        }

        function er(t, e, i) {
            $n.call(this, new Int16Array(t), e, i)
        }

        function ir(t, e, i) {
            $n.call(this, new Uint16Array(t), e, i)
        }

        function nr(t, e, i) {
            $n.call(this, new Int32Array(t), e, i)
        }

        function rr(t, e, i) {
            $n.call(this, new Uint32Array(t), e, i)
        }

        function ar(t, e, i) {
            $n.call(this, new Float32Array(t), e, i)
        }

        function sr(t, e, i) {
            $n.call(this, new Float64Array(t), e, i)
        }
        Object.defineProperty($n.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign($n.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function() {},
            setUsage: function(t) {
                return this.usage = t, this
            },
            copy: function(t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
            },
            copyAt: function(t, e, i) {
                t *= this.itemSize, i *= e.itemSize;
                for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            copyArray: function(t) {
                return this.array.set(t), this
            },
            copyColorsArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var a = t[n];
                    void 0 === a && (a = new Hn), e[i++] = a.r, e[i++] = a.g, e[i++] = a.b
                }
                return this
            },
            copyVector2sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var a = t[n];
                    void 0 === a && (a = new pi), e[i++] = a.x, e[i++] = a.y
                }
                return this
            },
            copyVector3sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var a = t[n];
                    void 0 === a && (a = new wi), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z
                }
                return this
            },
            copyVector4sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var a = t[n];
                    void 0 === a && (a = new yi), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z, e[i++] = a.w
                }
                return this
            },
            applyMatrix3: function(t) {
                if (2 === this.itemSize)
                    for (var e = 0, i = this.count; e < i; e++) Zn.fromBufferAttribute(this, e), Zn.applyMatrix3(t), this.setXY(e, Zn.x, Zn.y);
                else if (3 === this.itemSize)
                    for (var n = 0, r = this.count; n < r; n++) Jn.fromBufferAttribute(this, n), Jn.applyMatrix3(t), this.setXYZ(n, Jn.x, Jn.y, Jn.z);
                return this
            },
            applyMatrix4: function(t) {
                for (var e = 0, i = this.count; e < i; e++) Jn.x = this.getX(e), Jn.y = this.getY(e), Jn.z = this.getZ(e), Jn.applyMatrix4(t), this.setXYZ(e, Jn.x, Jn.y, Jn.z);
                return this
            },
            applyNormalMatrix: function(t) {
                for (var e = 0, i = this.count; e < i; e++) Jn.x = this.getX(e), Jn.y = this.getY(e), Jn.z = this.getZ(e), Jn.applyNormalMatrix(t), this.setXYZ(e, Jn.x, Jn.y, Jn.z);
                return this
            },
            transformDirection: function(t) {
                for (var e = 0, i = this.count; e < i; e++) Jn.x = this.getX(e), Jn.y = this.getY(e), Jn.z = this.getZ(e), Jn.transformDirection(t), this.setXYZ(e, Jn.x, Jn.y, Jn.z);
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            getX: function(t) {
                return this.array[t * this.itemSize]
            },
            setX: function(t, e) {
                return this.array[t * this.itemSize] = e, this
            },
            getY: function(t) {
                return this.array[t * this.itemSize + 1]
            },
            setY: function(t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            },
            getZ: function(t) {
                return this.array[t * this.itemSize + 2]
            },
            setZ: function(t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            },
            getW: function(t) {
                return this.array[t * this.itemSize + 3]
            },
            setW: function(t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            },
            setXY: function(t, e, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            },
            clone: function() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            },
            toJSON: function() {
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                }
            }
        }), (Kn.prototype = Object.create($n.prototype)).constructor = Kn, (Qn.prototype = Object.create($n.prototype)).constructor = Qn, (tr.prototype = Object.create($n.prototype)).constructor = tr, (er.prototype = Object.create($n.prototype)).constructor = er, (ir.prototype = Object.create($n.prototype)).constructor = ir, (nr.prototype = Object.create($n.prototype)).constructor = nr, (rr.prototype = Object.create($n.prototype)).constructor = rr, (ar.prototype = Object.create($n.prototype)).constructor = ar, (sr.prototype = Object.create($n.prototype)).constructor = sr;
        var or = function() {
            function t() {
                V(this, t), this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }
            return g(t, [{
                key: "computeGroups",
                value: function(t) {
                    for (var e, i = [], n = void 0, r = t.faces, a = 0; a < r.length; a++) {
                        var s = r[a];
                        s.materialIndex !== n && (n = s.materialIndex, void 0 !== e && (e.count = 3 * a - e.start, i.push(e)), e = {
                            start: 3 * a,
                            materialIndex: n
                        })
                    }
                    void 0 !== e && (e.count = 3 * a - e.start, i.push(e)), this.groups = i
                }
            }, {
                key: "fromGeometry",
                value: function(t) {
                    var e, i = t.faces,
                        n = t.vertices,
                        r = t.faceVertexUvs,
                        a = r[0] && 0 < r[0].length,
                        s = r[1] && 0 < r[1].length,
                        o = t.morphTargets,
                        l = o.length;
                    if (0 < l) {
                        e = [];
                        for (var h = 0; h < l; h++) e[h] = {
                            name: o[h].name,
                            data: []
                        };
                        this.morphTargets.position = e
                    }
                    var u, c = t.morphNormals,
                        p = c.length;
                    if (0 < p) {
                        u = [];
                        for (var d = 0; d < p; d++) u[d] = {
                            name: c[d].name,
                            data: []
                        };
                        this.morphTargets.normal = u
                    }
                    var f = t.skinIndices,
                        m = t.skinWeights,
                        g = f.length === n.length,
                        v = m.length === n.length;
                    0 < n.length && i.length;
                    for (var y = 0; y < i.length; y++) {
                        var b = i[y];
                        this.vertices.push(n[b.a], n[b.b], n[b.c]);
                        var x, _ = b.vertexNormals;
                        3 === _.length ? this.normals.push(_[0], _[1], _[2]) : (x = b.normal, this.normals.push(x, x, x));
                        var w, S, M, T = b.vertexColors;
                        3 === T.length ? this.colors.push(T[0], T[1], T[2]) : (w = b.color, this.colors.push(w, w, w)), !0 === a && (void 0 !== (S = r[0][y]) ? this.uvs.push(S[0], S[1], S[2]) : this.uvs.push(new pi, new pi, new pi)), !0 === s && (void 0 !== (M = r[1][y]) ? this.uvs2.push(M[0], M[1], M[2]) : this.uvs2.push(new pi, new pi, new pi));
                        for (var C = 0; C < l; C++) {
                            var A = o[C].vertices;
                            e[C].data.push(A[b.a], A[b.b], A[b.c])
                        }
                        for (var E = 0; E < p; E++) {
                            var D = c[E].vertexNormals[y];
                            u[E].data.push(D.a, D.b, D.c)
                        }
                        g && this.skinIndices.push(f[b.a], f[b.b], f[b.c]), v && this.skinWeights.push(m[b.a], m[b.b], m[b.c])
                    }
                    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                }
            }]), t
        }();

        function lr(t) {
            if (0 === t.length) return -1 / 0;
            for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
            return e
        }
        var hr = 1,
            ur = new Zi,
            cr = new wn,
            pr = new wi,
            dr = new Ti,
            fr = new Ti,
            mr = new wi;

        function gr() {
            Object.defineProperty(this, "id", {
                value: hr += 2
            }), this.uuid = ci.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }
        gr.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: gr,
            isBufferGeometry: !0,
            getIndex: function() {
                return this.index
            },
            setIndex: function(t) {
                Array.isArray(t) ? this.index = new(65535 < lr(t) ? rr : ir)(t, 1) : this.index = t
            },
            getAttribute: function(t) {
                return this.attributes[t]
            },
            setAttribute: function(t, e) {
                return this.attributes[t] = e, this
            },
            deleteAttribute: function(t) {
                return delete this.attributes[t], this
            },
            addGroup: function(t, e, i) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: void 0 !== i ? i : 0
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            },
            applyMatrix4: function(t) {
                var e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                var i, n = this.attributes.normal;
                void 0 !== n && (i = (new fi).getNormalMatrix(t), n.applyNormalMatrix(i), n.needsUpdate = !0);
                var r = this.attributes.tangent;
                return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: function(t) {
                return ur.makeRotationX(t), this.applyMatrix4(ur), this
            },
            rotateY: function(t) {
                return ur.makeRotationY(t), this.applyMatrix4(ur), this
            },
            rotateZ: function(t) {
                return ur.makeRotationZ(t), this.applyMatrix4(ur), this
            },
            translate: function(t, e, i) {
                return ur.makeTranslation(t, e, i), this.applyMatrix4(ur), this
            },
            scale: function(t, e, i) {
                return ur.makeScale(t, e, i), this.applyMatrix4(ur), this
            },
            lookAt: function(t) {
                return cr.lookAt(t), cr.updateMatrix(), this.applyMatrix4(cr.matrix), this
            },
            center: function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(pr).negate(), this.translate(pr.x, pr.y, pr.z), this
            },
            setFromObject: function(t) {
                var e, i, n, r = t.geometry;
                return t.isPoints || t.isLine ? (e = new ar(3 * r.vertices.length, 3), i = new ar(3 * r.colors.length, 3), this.setAttribute("position", e.copyVector3sArray(r.vertices)), this.setAttribute("color", i.copyColorsArray(r.colors)), r.lineDistances && r.lineDistances.length === r.vertices.length && (n = new ar(r.lineDistances.length, 1), this.setAttribute("lineDistance", n.copyArray(r.lineDistances))), null !== r.boundingSphere && (this.boundingSphere = r.boundingSphere.clone()), null !== r.boundingBox && (this.boundingBox = r.boundingBox.clone())) : t.isMesh && r && r.isGeometry && this.fromGeometry(r), this
            },
            setFromPoints: function(t) {
                for (var e = [], i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.push(r.x, r.y, r.z || 0)
                }
                return this.setAttribute("position", new ar(e, 3)), this
            },
            updateFromObject: function(t) {
                var e, i, n, r, a, s = t.geometry;
                if (t.isMesh) {
                    var o = s.__directGeometry;
                    if (!0 === s.elementsNeedUpdate && (o = void 0, s.elementsNeedUpdate = !1), void 0 === o) return this.fromGeometry(s);
                    o.verticesNeedUpdate = s.verticesNeedUpdate, o.normalsNeedUpdate = s.normalsNeedUpdate, o.colorsNeedUpdate = s.colorsNeedUpdate, o.uvsNeedUpdate = s.uvsNeedUpdate, o.groupsNeedUpdate = s.groupsNeedUpdate, s.verticesNeedUpdate = !1, s.normalsNeedUpdate = !1, s.colorsNeedUpdate = !1, s.uvsNeedUpdate = !1, s.groupsNeedUpdate = !1, s = o
                }
                return !0 === s.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(s.vertices), e.needsUpdate = !0), s.verticesNeedUpdate = !1), !0 === s.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(s.normals), i.needsUpdate = !0), s.normalsNeedUpdate = !1), !0 === s.colorsNeedUpdate && (void 0 !== (n = this.attributes.color) && (n.copyColorsArray(s.colors), n.needsUpdate = !0), s.colorsNeedUpdate = !1), s.uvsNeedUpdate && (void 0 !== (r = this.attributes.uv) && (r.copyVector2sArray(s.uvs), r.needsUpdate = !0), s.uvsNeedUpdate = !1), s.lineDistancesNeedUpdate && (void 0 !== (a = this.attributes.lineDistance) && (a.copyArray(s.lineDistances), a.needsUpdate = !0), s.lineDistancesNeedUpdate = !1), s.groupsNeedUpdate && (s.computeGroups(t.geometry), this.groups = s.groups, s.groupsNeedUpdate = !1), this
            },
            fromGeometry: function(t) {
                return t.__directGeometry = (new or).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
            },
            fromDirectGeometry: function(t) {
                var e, i, n, r, a, s, o = new Float32Array(3 * t.vertices.length);
                for (var l in this.setAttribute("position", new $n(o, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.setAttribute("normal", new $n(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (i = new Float32Array(3 * t.colors.length), this.setAttribute("color", new $n(i, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (n = new Float32Array(2 * t.uvs.length), this.setAttribute("uv", new $n(n, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (r = new Float32Array(2 * t.uvs2.length), this.setAttribute("uv2", new $n(r, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups, t.morphTargets) {
                    for (var h = [], u = t.morphTargets[l], c = 0, p = u.length; c < p; c++) {
                        var d = u[c],
                            f = new ar(3 * d.data.length, 3);
                        f.name = d.name, h.push(f.copyVector3sArray(d.data))
                    }
                    this.morphAttributes[l] = h
                }
                return 0 < t.skinIndices.length && (a = new ar(4 * t.skinIndices.length, 4), this.setAttribute("skinIndex", a.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (s = new ar(4 * t.skinWeights.length, 4), this.setAttribute("skinWeight", s.copyVector4sArray(t.skinWeights))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new Ti);
                var t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) this.boundingBox.set(new wi(-1 / 0, -1 / 0, -1 / 0), new wi(1 / 0, 1 / 0, 1 / 0));
                else {
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (var i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                dr.setFromBufferAttribute(r), this.morphTargetsRelative ? (mr.addVectors(this.boundingBox.min, dr.min), this.boundingBox.expandByPoint(mr), mr.addVectors(this.boundingBox.max, dr.max), this.boundingBox.expandByPoint(mr)) : (this.boundingBox.expandByPoint(dr.min), this.boundingBox.expandByPoint(dr.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
                }
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new Vi);
                var t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) this.boundingSphere.set(new wi, 1 / 0);
                else if (t) {
                    var i = this.boundingSphere.center;
                    if (dr.setFromBufferAttribute(t), e)
                        for (var n = 0, r = e.length; n < r; n++) {
                            var a = e[n];
                            fr.setFromBufferAttribute(a), this.morphTargetsRelative ? (mr.addVectors(dr.min, fr.min), dr.expandByPoint(mr), mr.addVectors(dr.max, fr.max), dr.expandByPoint(mr)) : (dr.expandByPoint(fr.min), dr.expandByPoint(fr.max))
                        }
                    dr.getCenter(i);
                    for (var s = 0, o = 0, l = t.count; o < l; o++) mr.fromBufferAttribute(t, o), s = Math.max(s, i.distanceToSquared(mr));
                    if (e)
                        for (var h = 0, u = e.length; h < u; h++)
                            for (var c = e[h], p = this.morphTargetsRelative, d = 0, f = c.count; d < f; d++) mr.fromBufferAttribute(c, d), p && (pr.fromBufferAttribute(t, d), mr.add(pr)), s = Math.max(s, i.distanceToSquared(mr));
                    this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius)
                }
            },
            computeFaceNormals: function() {},
            computeVertexNormals: function() {
                var t = this.index,
                    e = this.getAttribute("position");
                if (void 0 !== e) {
                    var i = this.getAttribute("normal");
                    if (void 0 === i) i = new $n(new Float32Array(3 * e.count), 3), this.setAttribute("normal", i);
                    else
                        for (var n = 0, r = i.count; n < r; n++) i.setXYZ(n, 0, 0, 0);
                    var a = new wi,
                        s = new wi,
                        o = new wi,
                        l = new wi,
                        h = new wi,
                        u = new wi,
                        c = new wi,
                        p = new wi;
                    if (t)
                        for (var d = 0, f = t.count; d < f; d += 3) {
                            var m = t.getX(d + 0),
                                g = t.getX(d + 1),
                                v = t.getX(d + 2);
                            a.fromBufferAttribute(e, m), s.fromBufferAttribute(e, g), o.fromBufferAttribute(e, v), c.subVectors(o, s), p.subVectors(a, s), c.cross(p), l.fromBufferAttribute(i, m), h.fromBufferAttribute(i, g), u.fromBufferAttribute(i, v), l.add(c), h.add(c), u.add(c), i.setXYZ(m, l.x, l.y, l.z), i.setXYZ(g, h.x, h.y, h.z), i.setXYZ(v, u.x, u.y, u.z)
                        } else
                            for (var y = 0, b = e.count; y < b; y += 3) a.fromBufferAttribute(e, y + 0), s.fromBufferAttribute(e, y + 1), o.fromBufferAttribute(e, y + 2), c.subVectors(o, s), p.subVectors(a, s), c.cross(p), i.setXYZ(y + 0, c.x, c.y, c.z), i.setXYZ(y + 1, c.x, c.y, c.z), i.setXYZ(y + 2, c.x, c.y, c.z);
                    this.normalizeNormals(), i.needsUpdate = !0
                }
            },
            merge: function(t, e) {
                if (t && t.isBufferGeometry) {
                    void 0 === e && (e = 0);
                    var i = this.attributes;
                    for (var n in i)
                        if (void 0 !== t.attributes[n])
                            for (var r = i[n].array, a = t.attributes[n], s = a.array, o = a.itemSize * e, l = Math.min(s.length, r.length - o), h = 0, u = o; h < l; h++, u++) r[u] = s[h];
                    return this
                }
            },
            normalizeNormals: function() {
                for (var t = this.attributes.normal, e = 0, i = t.count; e < i; e++) mr.fromBufferAttribute(t, e), mr.normalize(), t.setXYZ(e, mr.x, mr.y, mr.z)
            },
            toNonIndexed: function() {
                function t(t, e) {
                    for (var i = t.array, n = t.itemSize, r = t.normalized, a = new i.constructor(e.length * n), s = 0, o = 0, l = 0, h = e.length; l < h; l++) {
                        s = e[l] * n;
                        for (var u = 0; u < n; u++) a[o++] = i[s++]
                    }
                    return new $n(a, n, r)
                }
                if (null === this.index) return this;
                var e = new gr,
                    i = this.index.array,
                    n = this.attributes;
                for (var r in n) {
                    var a = t(n[r], i);
                    e.setAttribute(r, a)
                }
                var s = this.morphAttributes;
                for (var o in s) {
                    for (var l = [], h = s[o], u = 0, c = h.length; u < c; u++) {
                        var p = t(h[u], i);
                        l.push(p)
                    }
                    e.morphAttributes[o] = l
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                for (var d = this.groups, f = 0, m = d.length; f < m; f++) {
                    var g = d[f];
                    e.addGroup(g.start, g.count, g.materialIndex)
                }
                return e
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                var n = this.index;
                null !== n && (t.data.index = {
                    type: n.array.constructor.name,
                    array: Array.prototype.slice.call(n.array)
                });
                var r = this.attributes;
                for (var a in r) {
                    var s = r[a],
                        o = s.toJSON(t.data);
                    "" !== s.name && (o.name = s.name), t.data.attributes[a] = o
                }
                var l = {},
                    h = !1;
                for (var u in this.morphAttributes) {
                    for (var c = this.morphAttributes[u], p = [], d = 0, f = c.length; d < f; d++) {
                        var m = c[d],
                            g = m.toJSON(t.data);
                        "" !== m.name && (g.name = m.name), p.push(g)
                    }
                    0 < p.length && (l[u] = p, h = !0)
                }
                h && (t.data.morphAttributes = l, t.data.morphTargetsRelative = this.morphTargetsRelative);
                var v = this.groups;
                0 < v.length && (t.data.groups = JSON.parse(JSON.stringify(v)));
                var y = this.boundingSphere;
                return null !== y && (t.data.boundingSphere = {
                    center: y.center.toArray(),
                    radius: y.radius
                }), t
            },
            clone: function() {
                return (new gr).copy(this)
            },
            copy: function(t) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                var e = {};
                this.name = t.name;
                var i = t.index;
                null !== i && this.setIndex(i.clone(e));
                var n = t.attributes;
                for (var r in n) {
                    var a = n[r];
                    this.setAttribute(r, a.clone(e))
                }
                var s = t.morphAttributes;
                for (var o in s) {
                    for (var l = [], h = s[o], u = 0, c = h.length; u < c; u++) l.push(h[u].clone(e));
                    this.morphAttributes[o] = l
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                for (var p = t.groups, d = 0, f = p.length; d < f; d++) {
                    var m = p[d];
                    this.addGroup(m.start, m.count, m.materialIndex)
                }
                var g = t.boundingBox;
                null !== g && (this.boundingBox = g.clone());
                var v = t.boundingSphere;
                return null !== v && (this.boundingSphere = v.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var vr = new Zi,
            yr = new Ji,
            br = new Vi,
            xr = new wi,
            _r = new wi,
            wr = new wi,
            Sr = new wi,
            Mr = new wi,
            Tr = new wi,
            Cr = new wi,
            Ar = new wi,
            Er = new wi,
            Dr = new pi,
            Pr = new pi,
            Lr = new pi,
            kr = new wi,
            Or = new wi;

        function Fr(t, e) {
            wn.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new gr, this.material = void 0 !== e ? e : new Yn, this.updateMorphTargets()
        }

        function Ir(t, e, i, n, r, a, s, o) {
            var l = e.side === J ? n.intersectTriangle(s, a, r, !0, o) : n.intersectTriangle(r, a, s, e.side !== Z, o);
            if (null === l) return null;
            Or.copy(o), Or.applyMatrix4(t.matrixWorld);
            var h = i.ray.origin.distanceTo(Or);
            return h < i.near || h > i.far ? null : {
                distance: h,
                point: Or.clone(),
                object: t
            }
        }

        function Nr(t, e, i, n, r, a, s, o, l, h, u, c) {
            xr.fromBufferAttribute(r, h), _r.fromBufferAttribute(r, u), wr.fromBufferAttribute(r, c);
            var p = t.morphTargetInfluences;
            if (e.morphTargets && a && p) {
                Cr.set(0, 0, 0), Ar.set(0, 0, 0), Er.set(0, 0, 0);
                for (var d = 0, f = a.length; d < f; d++) {
                    var m = p[d],
                        g = a[d];
                    0 !== m && (Sr.fromBufferAttribute(g, h), Mr.fromBufferAttribute(g, u), Tr.fromBufferAttribute(g, c), s ? (Cr.addScaledVector(Sr, m), Ar.addScaledVector(Mr, m), Er.addScaledVector(Tr, m)) : (Cr.addScaledVector(Sr.sub(xr), m), Ar.addScaledVector(Mr.sub(_r), m), Er.addScaledVector(Tr.sub(wr), m)))
                }
                xr.add(Cr), _r.add(Ar), wr.add(Er)
            }
            t.isSkinnedMesh && (t.boneTransform(h, xr), t.boneTransform(u, _r), t.boneTransform(c, wr));
            var v, y = Ir(t, e, i, n, xr, _r, wr, kr);
            return y && (o && (Dr.fromBufferAttribute(o, h), Pr.fromBufferAttribute(o, u), Lr.fromBufferAttribute(o, c), y.uv = Bn.getUV(kr, xr, _r, wr, Dr, Pr, Lr, new pi)), l && (Dr.fromBufferAttribute(l, h), Pr.fromBufferAttribute(l, u), Lr.fromBufferAttribute(l, c), y.uv2 = Bn.getUV(kr, xr, _r, wr, Dr, Pr, Lr, new pi)), v = new Wn(h, u, c), Bn.getNormal(xr, _r, wr, v.normal), y.face = v), y
        }
        Fr.prototype = Object.assign(Object.create(wn.prototype), {
            constructor: Fr,
            isMesh: !0,
            copy: function(t) {
                return wn.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
            },
            updateMorphTargets: function() {
                var t = this.geometry;
                if (t.isBufferGeometry) {
                    var e = t.morphAttributes,
                        i = Object.keys(e);
                    if (0 < i.length) {
                        var n = e[i[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (var r = 0, a = n.length; r < a; r++) {
                                var s = n[r].name || String(r);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = r
                            }
                        }
                    }
                } else {
                    var o = t.morphTargets;
                    void 0 !== o && o.length
                }
            },
            raycast: function(t, e) {
                var i = this.geometry,
                    n = this.material,
                    r = this.matrixWorld;
                if (void 0 !== n && (null === i.boundingSphere && i.computeBoundingSphere(), br.copy(i.boundingSphere), br.applyMatrix4(r), !1 !== t.ray.intersectsSphere(br) && (vr.getInverse(r), yr.copy(t.ray).applyMatrix4(vr), null === i.boundingBox || !1 !== yr.intersectsBox(i.boundingBox))))
                    if (i.isBufferGeometry) {
                        var a = i.index,
                            s = i.attributes.position,
                            o = i.morphAttributes.position,
                            l = i.morphTargetsRelative,
                            h = i.attributes.uv,
                            u = i.attributes.uv2,
                            c = i.groups,
                            p = i.drawRange;
                        if (null !== a)
                            if (Array.isArray(n))
                                for (var d = 0, f = c.length; d < f; d++)
                                    for (var m = c[d], g = n[m.materialIndex], v = Math.max(m.start, p.start), y = Math.min(m.start + m.count, p.start + p.count); v < y; v += 3) {
                                        var b, x = a.getX(v),
                                            _ = a.getX(v + 1),
                                            w = a.getX(v + 2);
                                        (b = Nr(this, g, t, yr, s, o, l, h, u, x, _, w)) && (b.faceIndex = Math.floor(v / 3), b.face.materialIndex = m.materialIndex, e.push(b))
                                    } else
                                        for (var S = Math.max(0, p.start), M = Math.min(a.count, p.start + p.count); S < M; S += 3) {
                                            var T = a.getX(S),
                                                C = a.getX(S + 1),
                                                A = a.getX(S + 2);
                                            (b = Nr(this, n, t, yr, s, o, l, h, u, T, C, A)) && (b.faceIndex = Math.floor(S / 3), e.push(b))
                                        } else if (void 0 !== s)
                                            if (Array.isArray(n))
                                                for (var E = 0, D = c.length; E < D; E++)
                                                    for (var P = c[E], L = n[P.materialIndex], k = Math.max(P.start, p.start), O = Math.min(P.start + P.count, p.start + p.count); k < O; k += 3) {
                                                        (b = Nr(this, L, t, yr, s, o, l, h, u, k, k + 1, k + 2)) && (b.faceIndex = Math.floor(k / 3), b.face.materialIndex = P.materialIndex, e.push(b))
                                                    } else
                                                        for (var F = Math.max(0, p.start), I = Math.min(s.count, p.start + p.count); F < I; F += 3) {
                                                            (b = Nr(this, n, t, yr, s, o, l, h, u, F, F + 1, F + 2)) && (b.faceIndex = Math.floor(F / 3), e.push(b))
                                                        }
                    } else if (i.isGeometry) {
                    var N, B = Array.isArray(n),
                        R = i.vertices,
                        z = i.faces,
                        G = i.faceVertexUvs[0];
                    0 < G.length && (N = G);
                    for (var V = 0, U = z.length; V < U; V++) {
                        var j, H, W, q, X = z[V],
                            Y = B ? n[X.materialIndex] : n;
                        void 0 !== Y && (j = R[X.a], H = R[X.b], W = R[X.c], (b = Ir(this, Y, t, yr, j, H, W, kr)) && (N && N[V] && (q = N[V], Dr.copy(q[0]), Pr.copy(q[1]), Lr.copy(q[2]), b.uv = Bn.getUV(kr, j, H, W, Dr, Pr, Lr, new pi)), b.face = X, b.faceIndex = V, e.push(b)))
                    }
                }
            }
        });
        var Br = 0,
            Rr = new Zi,
            zr = new wn,
            Gr = new wi;

        function Vr() {
            Object.defineProperty(this, "id", {
                value: Br += 2
            }), this.uuid = ci.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
        }
        Vr.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: Vr,
            isGeometry: !0,
            applyMatrix4: function(t) {
                for (var e = (new fi).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) {
                    this.vertices[i].applyMatrix4(t)
                }
                for (var r = 0, a = this.faces.length; r < a; r++) {
                    var s = this.faces[r];
                    s.normal.applyMatrix3(e).normalize();
                    for (var o = 0, l = s.vertexNormals.length; o < l; o++) s.vertexNormals[o].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
            },
            rotateX: function(t) {
                return Rr.makeRotationX(t), this.applyMatrix4(Rr), this
            },
            rotateY: function(t) {
                return Rr.makeRotationY(t), this.applyMatrix4(Rr), this
            },
            rotateZ: function(t) {
                return Rr.makeRotationZ(t), this.applyMatrix4(Rr), this
            },
            translate: function(t, e, i) {
                return Rr.makeTranslation(t, e, i), this.applyMatrix4(Rr), this
            },
            scale: function(t, e, i) {
                return Rr.makeScale(t, e, i), this.applyMatrix4(Rr), this
            },
            lookAt: function(t) {
                return zr.lookAt(t), zr.updateMatrix(), this.applyMatrix4(zr.matrix), this
            },
            fromBufferGeometry: function(t) {
                var o = this,
                    e = null !== t.index ? t.index : void 0,
                    i = t.attributes;
                if (void 0 === i.position) return this;
                var n = i.position,
                    l = i.normal,
                    h = i.color,
                    u = i.uv,
                    c = i.uv2;
                void 0 !== c && (this.faceVertexUvs[1] = []);
                for (var r = 0; r < n.count; r++) o.vertices.push((new wi).fromBufferAttribute(n, r)), void 0 !== h && o.colors.push((new Hn).fromBufferAttribute(h, r));

                function a(t, e, i, n) {
                    var r = void 0 === h ? [] : [o.colors[t].clone(), o.colors[e].clone(), o.colors[i].clone()],
                        a = void 0 === l ? [] : [(new wi).fromBufferAttribute(l, t), (new wi).fromBufferAttribute(l, e), (new wi).fromBufferAttribute(l, i)],
                        s = new Wn(t, e, i, a, r, n);
                    o.faces.push(s), void 0 !== u && o.faceVertexUvs[0].push([(new pi).fromBufferAttribute(u, t), (new pi).fromBufferAttribute(u, e), (new pi).fromBufferAttribute(u, i)]), void 0 !== c && o.faceVertexUvs[1].push([(new pi).fromBufferAttribute(c, t), (new pi).fromBufferAttribute(c, e), (new pi).fromBufferAttribute(c, i)])
                }
                var s = t.groups;
                if (0 < s.length)
                    for (var p = 0; p < s.length; p++)
                        for (var d = s[p], f = d.start, m = f, g = f + d.count; m < g; m += 3) void 0 !== e ? a(e.getX(m), e.getX(m + 1), e.getX(m + 2), d.materialIndex) : a(m, m + 1, m + 2, d.materialIndex);
                else if (void 0 !== e)
                    for (var v = 0; v < e.count; v += 3) a(e.getX(v), e.getX(v + 1), e.getX(v + 2));
                else
                    for (var y = 0; y < n.count; y += 3) a(y, y + 1, y + 2);
                return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            },
            center: function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Gr).negate(), this.translate(Gr.x, Gr.y, Gr.z), this
            },
            normalize: function() {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center,
                    e = this.boundingSphere.radius,
                    i = 0 === e ? 1 : 1 / e,
                    n = new Zi;
                return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix4(n), this
            },
            computeFaceNormals: function() {
                for (var t = new wi, e = new wi, i = 0, n = this.faces.length; i < n; i++) {
                    var r = this.faces[i],
                        a = this.vertices[r.a],
                        s = this.vertices[r.b],
                        o = this.vertices[r.c];
                    t.subVectors(o, s), e.subVectors(a, s), t.cross(e), t.normalize(), r.normal.copy(t)
                }
            },
            computeVertexNormals: function(t) {
                void 0 === t && (t = !0);
                for (var e = new Array(this.vertices.length), i = 0, n = this.vertices.length; i < n; i++) e[i] = new wi;
                if (t)
                    for (var r = new wi, a = new wi, s = 0, o = this.faces.length; s < o; s++) {
                        var l = this.faces[s],
                            h = this.vertices[l.a],
                            u = this.vertices[l.b],
                            c = this.vertices[l.c];
                        r.subVectors(c, u), a.subVectors(h, u), r.cross(a), e[l.a].add(r), e[l.b].add(r), e[l.c].add(r)
                    } else {
                        this.computeFaceNormals();
                        for (var p = 0, d = this.faces.length; p < d; p++) {
                            var f = this.faces[p];
                            e[f.a].add(f.normal), e[f.b].add(f.normal), e[f.c].add(f.normal)
                        }
                    }
                for (var m = 0, g = this.vertices.length; m < g; m++) e[m].normalize();
                for (var v = 0, y = this.faces.length; v < y; v++) {
                    var b = this.faces[v],
                        x = b.vertexNormals;
                    3 === x.length ? (x[0].copy(e[b.a]), x[1].copy(e[b.b]), x[2].copy(e[b.c])) : (x[0] = e[b.a].clone(), x[1] = e[b.b].clone(), x[2] = e[b.c].clone())
                }
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeFlatVertexNormals: function() {
                this.computeFaceNormals();
                for (var t = 0, e = this.faces.length; t < e; t++) {
                    var i = this.faces[t],
                        n = i.vertexNormals;
                    3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
                }
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function() {
                for (var t = 0, e = this.faces.length; t < e; t++) {
                    var i = this.faces[t];
                    i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []);
                    for (var n = 0, r = i.vertexNormals.length; n < r; n++) i.__originalVertexNormals[n] ? i.__originalVertexNormals[n].copy(i.vertexNormals[n]) : i.__originalVertexNormals[n] = i.vertexNormals[n].clone()
                }
                var a = new Vr;
                a.faces = this.faces;
                for (var s = 0, o = this.morphTargets.length; s < o; s++) {
                    if (!this.morphNormals[s]) {
                        this.morphNormals[s] = {}, this.morphNormals[s].faceNormals = [], this.morphNormals[s].vertexNormals = [];
                        for (var l = this.morphNormals[s].faceNormals, h = this.morphNormals[s].vertexNormals, u = 0, c = this.faces.length; u < c; u++) {
                            var p = new wi,
                                d = {
                                    a: new wi,
                                    b: new wi,
                                    c: new wi
                                };
                            l.push(p), h.push(d)
                        }
                    }
                    var f = this.morphNormals[s];
                    a.vertices = this.morphTargets[s].vertices, a.computeFaceNormals(), a.computeVertexNormals();
                    for (var m = 0, g = this.faces.length; m < g; m++) {
                        var v = this.faces[m],
                            y = f.faceNormals[m],
                            b = f.vertexNormals[m];
                        y.copy(v.normal), b.a.copy(v.vertexNormals[0]), b.b.copy(v.vertexNormals[1]), b.c.copy(v.vertexNormals[2])
                    }
                }
                for (var x = 0, _ = this.faces.length; x < _; x++) {
                    var w = this.faces[x];
                    w.normal = w.__originalFaceNormal, w.vertexNormals = w.__originalVertexNormals
                }
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new Ti), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new Vi), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function(t, e, i) {
                if (t && t.isGeometry) {
                    var n, r = this.vertices.length,
                        a = this.vertices,
                        s = t.vertices,
                        o = this.faces,
                        l = t.faces,
                        h = this.colors,
                        u = t.colors;
                    void 0 === i && (i = 0), void 0 !== e && (n = (new fi).getNormalMatrix(e));
                    for (var c = 0, p = s.length; c < p; c++) {
                        var d = s[c].clone();
                        void 0 !== e && d.applyMatrix4(e), a.push(d)
                    }
                    for (var f = 0, m = u.length; f < m; f++) h.push(u[f].clone());
                    for (var g = 0, v = l.length; g < v; g++) {
                        var y = l[g],
                            b = void 0,
                            x = void 0,
                            _ = y.vertexNormals,
                            w = y.vertexColors,
                            S = new Wn(y.a + r, y.b + r, y.c + r);
                        S.normal.copy(y.normal), void 0 !== n && S.normal.applyMatrix3(n).normalize();
                        for (var M = 0, T = _.length; M < T; M++) b = _[M].clone(), void 0 !== n && b.applyMatrix3(n).normalize(), S.vertexNormals.push(b);
                        S.color.copy(y.color);
                        for (var C = 0, A = w.length; C < A; C++) x = w[C], S.vertexColors.push(x.clone());
                        S.materialIndex = y.materialIndex + i, o.push(S)
                    }
                    for (var E = 0, D = t.faceVertexUvs.length; E < D; E++) {
                        var P = t.faceVertexUvs[E];
                        void 0 === this.faceVertexUvs[E] && (this.faceVertexUvs[E] = []);
                        for (var L = 0, k = P.length; L < k; L++) {
                            for (var O = P[L], F = [], I = 0, N = O.length; I < N; I++) F.push(O[I].clone());
                            this.faceVertexUvs[E].push(F)
                        }
                    }
                }
            },
            mergeMesh: function(t) {
                t && t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix))
            },
            mergeVertices: function() {
                for (var t = {}, e = [], i = [], n = Math.pow(10, 4), r = 0, a = this.vertices.length; r < a; r++) {
                    var s = this.vertices[r],
                        o = Math.round(s.x * n) + "_" + Math.round(s.y * n) + "_" + Math.round(s.z * n);
                    void 0 === t[o] ? (t[o] = r, e.push(this.vertices[r]), i[r] = e.length - 1) : i[r] = i[t[o]]
                }
                for (var l = [], h = 0, u = this.faces.length; h < u; h++) {
                    var c = this.faces[h];
                    c.a = i[c.a], c.b = i[c.b], c.c = i[c.c];
                    for (var p = [c.a, c.b, c.c], d = 0; d < 3; d++)
                        if (p[d] === p[(d + 1) % 3]) {
                            l.push(h);
                            break
                        }
                }
                for (var f = l.length - 1; 0 <= f; f--) {
                    var m = l[f];
                    this.faces.splice(m, 1);
                    for (var g = 0, v = this.faceVertexUvs.length; g < v; g++) this.faceVertexUvs[g].splice(m, 1)
                }
                var y = this.vertices.length - e.length;
                return this.vertices = e, y
            },
            setFromPoints: function(t) {
                this.vertices = [];
                for (var e = 0, i = t.length; e < i; e++) {
                    var n = t[e];
                    this.vertices.push(new wi(n.x, n.y, n.z || 0))
                }
                return this
            },
            sortFacesByMaterialIndex: function() {
                for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
                t.sort(function(t, e) {
                    return t.materialIndex - e.materialIndex
                });
                var n, r, a = this.faceVertexUvs[0],
                    s = this.faceVertexUvs[1];
                a && a.length === e && (n = []), s && s.length === e && (r = []);
                for (var o = 0; o < e; o++) {
                    var l = t[o]._id;
                    n && n.push(a[l]), r && r.push(s[l])
                }
                n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                    return t
                }
                for (var n = [], r = 0; r < this.vertices.length; r++) {
                    var a = this.vertices[r];
                    n.push(a.x, a.y, a.z)
                }
                for (var s = [], o = [], l = {}, h = [], u = {}, c = [], p = {}, d = 0; d < this.faces.length; d++) {
                    var f, m, g, v = this.faces[d],
                        y = void 0 !== this.faceVertexUvs[0][d],
                        b = 0 < v.normal.length(),
                        x = 0 < v.vertexNormals.length,
                        _ = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b,
                        w = 0 < v.vertexColors.length,
                        S = M(S = 0, 0, 0);
                    S = M(S, 1, !0), S = M(S, 2, !1), S = M(S, 3, y), S = M(S, 4, b), S = M(S, 5, x), S = M(S, 6, _), S = M(S, 7, w), s.push(S), s.push(v.a, v.b, v.c), s.push(v.materialIndex), y && (f = this.faceVertexUvs[0][d], s.push(A(f[0]), A(f[1]), A(f[2]))), b && s.push(T(v.normal)), x && (m = v.vertexNormals, s.push(T(m[0]), T(m[1]), T(m[2]))), _ && s.push(C(v.color)), w && (g = v.vertexColors, s.push(C(g[0]), C(g[1]), C(g[2])))
                }

                function M(t, e, i) {
                    return i ? t | 1 << e : t & ~(1 << e)
                }

                function T(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== l[e] || (l[e] = o.length / 3, o.push(t.x, t.y, t.z)), l[e]
                }

                function C(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== u[e] || (u[e] = h.length, h.push(t.getHex())), u[e]
                }

                function A(t) {
                    var e = t.x.toString() + t.y.toString();
                    return void 0 !== p[e] || (p[e] = c.length / 2, c.push(t.x, t.y)), p[e]
                }
                return t.data = {}, t.data.vertices = n, t.data.normals = o, 0 < h.length && (t.data.colors = h), 0 < c.length && (t.data.uvs = [c]), t.data.faces = s, t
            },
            clone: function() {
                return (new Vr).copy(this)
            },
            copy: function(t) {
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                for (var e = t.vertices, i = 0, n = e.length; i < n; i++) this.vertices.push(e[i].clone());
                for (var r = t.colors, a = 0, s = r.length; a < s; a++) this.colors.push(r[a].clone());
                for (var o = t.faces, l = 0, h = o.length; l < h; l++) this.faces.push(o[l].clone());
                for (var u = 0, c = t.faceVertexUvs.length; u < c; u++) {
                    var p = t.faceVertexUvs[u];
                    void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
                    for (var d = 0, f = p.length; d < f; d++) {
                        for (var m = p[d], g = [], v = 0, y = m.length; v < y; v++) {
                            var b = m[v];
                            g.push(b.clone())
                        }
                        this.faceVertexUvs[u].push(g)
                    }
                }
                for (var x = t.morphTargets, _ = 0, w = x.length; _ < w; _++) {
                    var S = {};
                    if (S.name = x[_].name, void 0 !== x[_].vertices) {
                        S.vertices = [];
                        for (var M = 0, T = x[_].vertices.length; M < T; M++) S.vertices.push(x[_].vertices[M].clone())
                    }
                    if (void 0 !== x[_].normals) {
                        S.normals = [];
                        for (var C = 0, A = x[_].normals.length; C < A; C++) S.normals.push(x[_].normals[C].clone())
                    }
                    this.morphTargets.push(S)
                }
                for (var E = t.morphNormals, D = 0, P = E.length; D < P; D++) {
                    var L = {};
                    if (void 0 !== E[D].vertexNormals) {
                        L.vertexNormals = [];
                        for (var k = 0, O = E[D].vertexNormals.length; k < O; k++) {
                            var F = E[D].vertexNormals[k],
                                I = {};
                            I.a = F.a.clone(), I.b = F.b.clone(), I.c = F.c.clone(), L.vertexNormals.push(I)
                        }
                    }
                    if (void 0 !== E[D].faceNormals) {
                        L.faceNormals = [];
                        for (var N = 0, B = E[D].faceNormals.length; N < B; N++) L.faceNormals.push(E[D].faceNormals[N].clone())
                    }
                    this.morphNormals.push(L)
                }
                for (var R = t.skinWeights, z = 0, G = R.length; z < G; z++) this.skinWeights.push(R[z].clone());
                for (var V = t.skinIndices, U = 0, j = V.length; U < j; U++) this.skinIndices.push(V[U].clone());
                for (var H = t.lineDistances, W = 0, q = H.length; W < q; W++) this.lineDistances.push(H[W]);
                var X = t.boundingBox;
                null !== X && (this.boundingBox = X.clone());
                var Y = t.boundingSphere;
                return null !== Y && (this.boundingSphere = Y.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var Ur = function() {
            d(l, Vr);
            var o = y(l);

            function l(t, e, i, n, r, a) {
                var s;
                return V(this, l), (s = o.call(this)).type = "BoxGeometry", s.parameters = {
                    width: t,
                    height: e,
                    depth: i,
                    widthSegments: n,
                    heightSegments: r,
                    depthSegments: a
                }, s.fromBufferGeometry(new jr(t, e, i, n, r, a)), s.mergeVertices(), s
            }
            return l
        }();
        i.CubeGeometry = i.BoxGeometry = Ur;
        var jr = function() {
            d(h, gr);
            var l = y(h);

            function h() {
                var t, e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1,
                    a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1,
                    s = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1;
                V(this, h), (t = l.call(this)).type = "BoxBufferGeometry", t.parameters = {
                    width: e,
                    height: i,
                    depth: n,
                    widthSegments: r,
                    heightSegments: a,
                    depthSegments: s
                };
                var L = u(t),
                    r = Math.floor(r),
                    a = Math.floor(a),
                    s = Math.floor(s),
                    k = [],
                    O = [],
                    F = [],
                    I = [],
                    N = 0,
                    B = 0;

                function o(t, e, i, n, r, a, s, o, l, h, u) {
                    for (var c = a / l, p = s / h, d = a / 2, f = s / 2, m = o / 2, g = l + 1, v = h + 1, y = 0, b = 0, x = new wi, _ = 0; _ < v; _++)
                        for (var w = _ * p - f, S = 0; S < g; S++) {
                            var M = S * c - d;
                            x[t] = M * n, x[e] = w * r, x[i] = m, O.push(x.x, x.y, x.z), x[t] = 0, x[e] = 0, x[i] = 0 < o ? 1 : -1, F.push(x.x, x.y, x.z), I.push(S / l), I.push(1 - _ / h), y += 1
                        }
                    for (var T = 0; T < h; T++)
                        for (var C = 0; C < l; C++) {
                            var A = N + C + g * T,
                                E = N + C + g * (T + 1),
                                D = N + (C + 1) + g * (T + 1),
                                P = N + (C + 1) + g * T;
                            k.push(A, E, P), k.push(E, D, P), b += 6
                        }
                    L.addGroup(B, b, u), B += b, N += y
                }
                return o("z", "y", "x", -1, -1, n, i, e, s, a, 0), o("z", "y", "x", 1, -1, n, i, -e, s, a, 1), o("x", "z", "y", 1, 1, e, n, i, r, s, 2), o("x", "z", "y", 1, -1, e, n, -i, r, s, 3), o("x", "y", "z", 1, -1, e, i, n, r, a, 4), o("x", "y", "z", -1, -1, e, i, -n, r, a, 5), t.setIndex(k), t.setAttribute("position", new ar(O, 3)), t.setAttribute("normal", new ar(F, 3)), t.setAttribute("uv", new ar(I, 2)), t
            }
            return h
        }();

        function Hr(t) {
            var e = {};
            for (var i in t)
                for (var n in e[i] = {}, t[i]) {
                    var r = t[i][n];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                }
            return e
        }

        function Wr(t) {
            for (var e = {}, i = 0; i < t.length; i++) {
                var n = Hr(t[i]);
                for (var r in n) e[r] = n[r]
            }
            return e
        }
        i.BoxBufferGeometry = jr;
        var qr = {
            clone: Hr,
            merge: Wr
        };
        i.UniformsUtils = qr;
        var Xr = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            Yr = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

        function Jr(t) {
            Xn.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = Xr, this.fragmentShader = Yr, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (t.attributes, this.setValues(t))
        }

        function Zr() {
            wn.call(this), this.type = "Camera", this.matrixWorldInverse = new Zi, this.projectionMatrix = new Zi, this.projectionMatrixInverse = new Zi
        }

        function $r(t, e, i, n) {
            Zr.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }((Jr.prototype = Object.create(Xn.prototype)).constructor = Jr).prototype.isShaderMaterial = !0, Jr.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Hr(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
        }, Jr.prototype.toJSON = function(t) {
            var e = Xn.prototype.toJSON.call(this, t);
            for (var i in e.glslVersion = this.glslVersion, e.uniforms = {}, this.uniforms) {
                var n = this.uniforms[i].value;
                n && n.isTexture ? e.uniforms[i] = {
                    type: "t",
                    value: n.toJSON(t).uuid
                } : n && n.isColor ? e.uniforms[i] = {
                    type: "c",
                    value: n.getHex()
                } : n && n.isVector2 ? e.uniforms[i] = {
                    type: "v2",
                    value: n.toArray()
                } : n && n.isVector3 ? e.uniforms[i] = {
                    type: "v3",
                    value: n.toArray()
                } : n && n.isVector4 ? e.uniforms[i] = {
                    type: "v4",
                    value: n.toArray()
                } : n && n.isMatrix3 ? e.uniforms[i] = {
                    type: "m3",
                    value: n.toArray()
                } : n && n.isMatrix4 ? e.uniforms[i] = {
                    type: "m4",
                    value: n.toArray()
                } : e.uniforms[i] = {
                    value: n
                }
            }
            0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
            var r = {};
            for (var a in this.extensions) !0 === this.extensions[a] && (r[a] = !0);
            return 0 < Object.keys(r).length && (e.extensions = r), e
        }, Zr.prototype = Object.assign(Object.create(wn.prototype), {
            constructor: Zr,
            isCamera: !0,
            copy: function(t, e) {
                return wn.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
            },
            getWorldDirection: function(t) {
                void 0 === t && (t = new wi), this.updateMatrixWorld(!0);
                var e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            },
            updateMatrixWorld: function(t) {
                wn.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            updateWorldMatrix: function(t, e) {
                wn.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }), $r.prototype = Object.assign(Object.create(Zr.prototype), {
            constructor: $r,
            isPerspectiveCamera: !0,
            copy: function(t, e) {
                return Zr.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            },
            setFocalLength: function(t) {
                var e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * ci.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
            },
            getFocalLength: function() {
                var t = Math.tan(.5 * ci.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            },
            getEffectiveFOV: function() {
                return 2 * ci.RAD2DEG * Math.atan(Math.tan(.5 * ci.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function() {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function() {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function(t, e, i, n, r, a) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t, e, i = this.near,
                    n = i * Math.tan(.5 * ci.DEG2RAD * this.fov) / this.zoom,
                    r = 2 * n,
                    a = this.aspect * r,
                    s = -.5 * a,
                    o = this.view;
                null !== this.view && this.view.enabled && (t = o.fullWidth, e = o.fullHeight, s += o.offsetX * a / t, n -= o.offsetY * r / e, a *= o.width / t, r *= o.height / e);
                var l = this.filmOffset;
                0 !== l && (s += i * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + a, n, n - r, i, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            },
            toJSON: function(t) {
                var e = wn.prototype.toJSON.call(this, t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        });
        var Kr = 90,
            Qr = 1;

        function ta(t, e, s) {
            var a, o, l, h, u, c;
            wn.call(this), this.type = "CubeCamera", !0 === s.isWebGLCubeRenderTarget && (this.renderTarget = s, (a = new $r(Kr, Qr, t, e)).layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new wi(1, 0, 0)), this.add(a), (o = new $r(Kr, Qr, t, e)).layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new wi(-1, 0, 0)), this.add(o), (l = new $r(Kr, Qr, t, e)).layers = this.layers, l.up.set(0, 0, 1), l.lookAt(new wi(0, 1, 0)), this.add(l), (h = new $r(Kr, Qr, t, e)).layers = this.layers, h.up.set(0, 0, -1), h.lookAt(new wi(0, -1, 0)), this.add(h), (u = new $r(Kr, Qr, t, e)).layers = this.layers, u.up.set(0, -1, 0), u.lookAt(new wi(0, 0, 1)), this.add(u), (c = new $r(Kr, Qr, t, e)).layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new wi(0, 0, -1)), this.add(c), this.update = function(t, e) {
                null === this.parent && this.updateMatrixWorld();
                var i = t.xr.enabled,
                    n = t.getRenderTarget();
                t.xr.enabled = !1;
                var r = s.texture.generateMipmaps;
                s.texture.generateMipmaps = !1, t.setRenderTarget(s, 0), t.render(e, a), t.setRenderTarget(s, 1), t.render(e, o), t.setRenderTarget(s, 2), t.render(e, l), t.setRenderTarget(s, 3), t.render(e, h), t.setRenderTarget(s, 4), t.render(e, u), s.texture.generateMipmaps = r, t.setRenderTarget(s, 5), t.render(e, c), t.setRenderTarget(n), t.xr.enabled = i
            }, this.clear = function(t, e, i, n) {
                for (var r = t.getRenderTarget(), a = 0; a < 6; a++) t.setRenderTarget(s, a), t.clear(e, i, n);
                t.setRenderTarget(r)
            })
        }

        function ea(t, e, i) {
            Number.isInteger(e) && (e = i), bi.call(this, t, t, e), this.texture.isWebGLCubeRenderTargetTexture = !0
        }

        function ia(t, e, i, n, r, a, s, o, l, h, u, c) {
            vi.call(this, null, a, s, o, l, h, n, r, u, c), this.image = {
                data: t || null,
                width: e || 1,
                height: i || 1
            }, this.magFilter = void 0 !== l ? l : Bt, this.minFilter = void 0 !== h ? h : Bt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
        }(ta.prototype = Object.create(wn.prototype)).constructor = ta, ((ea.prototype = Object.create(bi.prototype)).constructor = ea).prototype.isWebGLCubeRenderTarget = !0, ea.prototype.fromEquirectangularTexture = function(t, e) {
            this.texture.type = e.type, this.texture.format = Zt, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
            var i = {
                    tEquirect: {
                        value: null
                    }
                },
                n = "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
                r = "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t",
                a = new jr(5, 5, 5),
                s = new Jr({
                    name: "CubemapFromEquirect",
                    uniforms: Hr(i),
                    vertexShader: n,
                    fragmentShader: r,
                    side: J,
                    blending: $
                });
            s.uniforms.tEquirect.value = e;
            var o = new Fr(a, s),
                l = e.minFilter;
            return e.minFilter === Ut && (e.minFilter = Gt), new ta(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
        }, ((ia.prototype = Object.create(vi.prototype)).constructor = ia).prototype.isDataTexture = !0;
        var na = new Vi,
            ra = new wi,
            aa = function() {
                function s(t, e, i, n, r, a) {
                    V(this, s), this.planes = [void 0 !== t ? t : new Cn, void 0 !== e ? e : new Cn, void 0 !== i ? i : new Cn, void 0 !== n ? n : new Cn, void 0 !== r ? r : new Cn, void 0 !== a ? a : new Cn]
                }
                return g(s, [{
                    key: "set",
                    value: function(t, e, i, n, r, a) {
                        var s = this.planes;
                        return s[0].copy(t), s[1].copy(e), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(a), this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                        return this
                    }
                }, {
                    key: "setFromProjectionMatrix",
                    value: function(t) {
                        var e = this.planes,
                            i = t.elements,
                            n = i[0],
                            r = i[1],
                            a = i[2],
                            s = i[3],
                            o = i[4],
                            l = i[5],
                            h = i[6],
                            u = i[7],
                            c = i[8],
                            p = i[9],
                            d = i[10],
                            f = i[11],
                            m = i[12],
                            g = i[13],
                            v = i[14],
                            y = i[15];
                        return e[0].setComponents(s - n, u - o, f - c, y - m).normalize(), e[1].setComponents(s + n, u + o, f + c, y + m).normalize(), e[2].setComponents(s + r, u + l, f + p, y + g).normalize(), e[3].setComponents(s - r, u - l, f - p, y - g).normalize(), e[4].setComponents(s - a, u - h, f - d, y - v).normalize(), e[5].setComponents(s + a, u + h, f + d, y + v).normalize(), this
                    }
                }, {
                    key: "intersectsObject",
                    value: function(t) {
                        var e = t.geometry;
                        return null === e.boundingSphere && e.computeBoundingSphere(), na.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(na)
                    }
                }, {
                    key: "intersectsSprite",
                    value: function(t) {
                        return na.center.set(0, 0, 0), na.radius = .7071067811865476, na.applyMatrix4(t.matrixWorld), this.intersectsSphere(na)
                    }
                }, {
                    key: "intersectsSphere",
                    value: function(t) {
                        for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
                            if (e[r].distanceToPoint(i) < n) return !1
                        }
                        return !0
                    }
                }, {
                    key: "intersectsBox",
                    value: function(t) {
                        for (var e = this.planes, i = 0; i < 6; i++) {
                            var n = e[i];
                            if (ra.x = 0 < n.normal.x ? t.max.x : t.min.x, ra.y = 0 < n.normal.y ? t.max.y : t.min.y, ra.z = 0 < n.normal.z ? t.max.z : t.min.z, n.distanceToPoint(ra) < 0) return !1
                        }
                        return !0
                    }
                }, {
                    key: "containsPoint",
                    value: function(t) {
                        for (var e = this.planes, i = 0; i < 6; i++)
                            if (e[i].distanceToPoint(t) < 0) return !1;
                        return !0
                    }
                }]), s
            }();

        function sa() {
            var i = null,
                t = !1,
                n = null,
                r = null;

            function a(t, e) {
                n(t, e), r = i.requestAnimationFrame(a)
            }
            return {
                start: function() {
                    !0 !== t && null !== n && (r = i.requestAnimationFrame(a), t = !0)
                },
                stop: function() {
                    i.cancelAnimationFrame(r), t = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(t) {
                    i = t
                }
            }
        }

        function oa(h, t) {
            var u = t.isWebGL2,
                c = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), c.get(t)
                },
                remove: function(t) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    var e = c.get(t);
                    e && (h.deleteBuffer(e.buffer), c.delete(t))
                },
                update: function(t, e) {
                    var i, n, r, a, s, o, l;
                    t.isGLBufferAttribute ? (!(i = c.get(t)) || i.version < t.version) && c.set(t, {
                        buffer: t.buffer,
                        type: t.type,
                        bytesPerElement: t.elementSize,
                        version: t.version
                    }) : (t.isInterleavedBufferAttribute && (t = t.data), void 0 === (n = c.get(t)) ? c.set(t, function(t, e) {
                        var i = t.array,
                            n = t.usage,
                            r = h.createBuffer();
                        h.bindBuffer(e, r), h.bufferData(e, i, n), t.onUploadCallback();
                        var a = 5126;
                        return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array || (i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121)), {
                            buffer: r,
                            type: a,
                            bytesPerElement: i.BYTES_PER_ELEMENT,
                            version: t.version
                        }
                    }(t, e)) : n.version < t.version && (r = n.buffer, s = e, o = (a = t).array, l = a.updateRange, h.bindBuffer(s, r), -1 === l.count ? h.bufferSubData(s, 0, o) : (u ? h.bufferSubData(s, l.offset * o.BYTES_PER_ELEMENT, o, l.offset, l.count) : h.bufferSubData(s, l.offset * o.BYTES_PER_ELEMENT, o.subarray(l.offset, l.offset + l.count)), l.count = -1), n.version = t.version))
                }
            }
        }
        i.Frustum = aa;
        var la = function() {
            d(s, Vr);
            var a = y(s);

            function s(t, e, i, n) {
                var r;
                return V(this, s), (r = a.call(this)).type = "PlaneGeometry", r.parameters = {
                    width: t,
                    height: e,
                    widthSegments: i,
                    heightSegments: n
                }, r.fromBufferGeometry(new ha(t, e, i, n)), r.mergeVertices(), r
            }
            return s
        }();
        i.PlaneGeometry = la;
        var ha = function() {
            d(E, gr);
            var A = y(E);

            function E(t, e, i, n) {
                var r;
                V(this, E), (r = A.call(this)).type = "PlaneBufferGeometry", r.parameters = {
                    width: t,
                    height: e,
                    widthSegments: i,
                    heightSegments: n
                };
                for (var a = (t = t || 1) / 2, s = (e = e || 1) / 2, o = Math.floor(i) || 1, l = Math.floor(n) || 1, h = o + 1, u = l + 1, c = t / o, p = e / l, d = [], f = [], m = [], g = [], v = 0; v < u; v++)
                    for (var y = v * p - s, b = 0; b < h; b++) {
                        var x = b * c - a;
                        f.push(x, -y, 0), m.push(0, 0, 1), g.push(b / o), g.push(1 - v / l)
                    }
                for (var _ = 0; _ < l; _++)
                    for (var w = 0; w < o; w++) {
                        var S = w + h * _,
                            M = w + h * (_ + 1),
                            T = w + 1 + h * (_ + 1),
                            C = w + 1 + h * _;
                        d.push(S, M, C), d.push(M, T, C)
                    }
                return r.setIndex(d), r.setAttribute("position", new ar(f, 3)), r.setAttribute("normal", new ar(m, 3)), r.setAttribute("uv", new ar(g, 2)), r
            }
            return E
        }();
        i.PlaneBufferGeometry = ha;
        var ua = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
            transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
            uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        };
        i.ShaderChunk = ua;
        var ca = {
                common: {
                    diffuse: {
                        value: new Hn(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new fi
                    },
                    uv2Transform: {
                        value: new fi
                    },
                    alphaMap: {
                        value: null
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    },
                    maxMipLevel: {
                        value: 0
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new pi(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new Hn(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new Hn(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    uvTransform: {
                        value: new fi
                    }
                },
                sprite: {
                    diffuse: {
                        value: new Hn(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new pi(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    uvTransform: {
                        value: new fi
                    }
                }
            },
            pa = {
                basic: {
                    uniforms: Wr([(i.UniformsLib = ca).common, ca.specularmap, ca.envmap, ca.aomap, ca.lightmap, ca.fog]),
                    vertexShader: ua.meshbasic_vert,
                    fragmentShader: ua.meshbasic_frag
                },
                lambert: {
                    uniforms: Wr([ca.common, ca.specularmap, ca.envmap, ca.aomap, ca.lightmap, ca.emissivemap, ca.fog, ca.lights, {
                        emissive: {
                            value: new Hn(0)
                        }
                    }]),
                    vertexShader: ua.meshlambert_vert,
                    fragmentShader: ua.meshlambert_frag
                },
                phong: {
                    uniforms: Wr([ca.common, ca.specularmap, ca.envmap, ca.aomap, ca.lightmap, ca.emissivemap, ca.bumpmap, ca.normalmap, ca.displacementmap, ca.fog, ca.lights, {
                        emissive: {
                            value: new Hn(0)
                        },
                        specular: {
                            value: new Hn(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: ua.meshphong_vert,
                    fragmentShader: ua.meshphong_frag
                },
                standard: {
                    uniforms: Wr([ca.common, ca.envmap, ca.aomap, ca.lightmap, ca.emissivemap, ca.bumpmap, ca.normalmap, ca.displacementmap, ca.roughnessmap, ca.metalnessmap, ca.fog, ca.lights, {
                        emissive: {
                            value: new Hn(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: ua.meshphysical_vert,
                    fragmentShader: ua.meshphysical_frag
                },
                toon: {
                    uniforms: Wr([ca.common, ca.aomap, ca.lightmap, ca.emissivemap, ca.bumpmap, ca.normalmap, ca.displacementmap, ca.gradientmap, ca.fog, ca.lights, {
                        emissive: {
                            value: new Hn(0)
                        }
                    }]),
                    vertexShader: ua.meshtoon_vert,
                    fragmentShader: ua.meshtoon_frag
                },
                matcap: {
                    uniforms: Wr([ca.common, ca.bumpmap, ca.normalmap, ca.displacementmap, ca.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: ua.meshmatcap_vert,
                    fragmentShader: ua.meshmatcap_frag
                },
                points: {
                    uniforms: Wr([ca.points, ca.fog]),
                    vertexShader: ua.points_vert,
                    fragmentShader: ua.points_frag
                },
                dashed: {
                    uniforms: Wr([ca.common, ca.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: ua.linedashed_vert,
                    fragmentShader: ua.linedashed_frag
                },
                depth: {
                    uniforms: Wr([ca.common, ca.displacementmap]),
                    vertexShader: ua.depth_vert,
                    fragmentShader: ua.depth_frag
                },
                normal: {
                    uniforms: Wr([ca.common, ca.bumpmap, ca.normalmap, ca.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: ua.normal_vert,
                    fragmentShader: ua.normal_frag
                },
                sprite: {
                    uniforms: Wr([ca.sprite, ca.fog]),
                    vertexShader: ua.sprite_vert,
                    fragmentShader: ua.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new fi
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: ua.background_vert,
                    fragmentShader: ua.background_frag
                },
                cube: {
                    uniforms: Wr([ca.envmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: ua.cube_vert,
                    fragmentShader: ua.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: ua.equirect_vert,
                    fragmentShader: ua.equirect_frag
                },
                distanceRGBA: {
                    uniforms: Wr([ca.common, ca.displacementmap, {
                        referencePosition: {
                            value: new wi
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: ua.distanceRGBA_vert,
                    fragmentShader: ua.distanceRGBA_frag
                },
                shadow: {
                    uniforms: Wr([ca.lights, ca.fog, {
                        color: {
                            value: new Hn(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: ua.shadow_vert,
                    fragmentShader: ua.shadow_frag
                }
            };

        function da(o, l, i, h, n) {
            var u, c, p = new Hn(0),
                d = 0,
                f = null,
                m = 0,
                g = null;

            function v(t, e) {
                i.buffers.color.setClear(t.r, t.g, t.b, e, n)
            }
            return {
                getClearColor: function() {
                    return p
                },
                setClearColor: function(t, e) {
                    p.set(t), v(p, d = void 0 !== e ? e : 1)
                },
                getClearAlpha: function() {
                    return d
                },
                setClearAlpha: function(t) {
                    v(p, d = t)
                },
                render: function(t, e, i, n) {
                    var r = !0 === e.isScene ? e.background : null;
                    r && r.isTexture && (r = l.get(r));
                    var a = o.xr,
                        s = a.getSession && a.getSession();
                    s && "additive" === s.environmentBlendMode && (r = null), null === r ? v(p, d) : r && r.isColor && (v(r, 1), n = !0), (o.autoClear || n) && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil), r && (r.isCubeTexture || r.isWebGLCubeRenderTarget || r.isWebGLCubeRenderTargetTexture || r.mapping === kt) ? (void 0 === c && ((c = new Fr(new jr(1, 1, 1), new Jr({
                        name: "BackgroundCubeMaterial",
                        uniforms: Hr(pa.cube.uniforms),
                        vertexShader: pa.cube.vertexShader,
                        fragmentShader: pa.cube.fragmentShader,
                        side: J,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(t, e, i) {
                        this.matrixWorld.copyPosition(i.matrixWorld)
                    }, Object.defineProperty(c.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }), h.update(c)), r.isWebGLCubeRenderTarget && (r = r.texture), c.material.uniforms.envMap.value = r, c.material.uniforms.flipEnvMap.value = r.isCubeTexture ? -1 : 1, f === r && m === r.version && g === o.toneMapping || (c.material.needsUpdate = !0, m = (f = r).version, g = o.toneMapping), t.unshift(c, c.geometry, c.material, 0, 0, null)) : r && r.isTexture && (void 0 === u && ((u = new Fr(new ha(2, 2), new Jr({
                        name: "BackgroundMaterial",
                        uniforms: Hr(pa.background.uniforms),
                        vertexShader: pa.background.vertexShader,
                        fragmentShader: pa.background.fragmentShader,
                        side: k,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), h.update(u)), !0 === (u.material.uniforms.t2D.value = r).matrixAutoUpdate && r.updateMatrix(), u.material.uniforms.uvTransform.value.copy(r.matrix), f === r && m === r.version && g === o.toneMapping || (u.material.needsUpdate = !0, m = (f = r).version, g = o.toneMapping), t.unshift(u, u.geometry, u.material, 0, 0, null))
                }
            }
        }

        function fa(C, A, E, D) {
            var a = C.getParameter(34921),
                l = D.isWebGL2 ? null : A.get("OES_vertex_array_object"),
                h = D.isWebGL2 || null !== l,
                u = {},
                t = d(null),
                c = t;

            function p(t) {
                return D.isWebGL2 ? C.bindVertexArray(t) : l.bindVertexArrayOES(t)
            }

            function s(t) {
                return D.isWebGL2 ? C.deleteVertexArray(t) : l.deleteVertexArrayOES(t)
            }

            function d(t) {
                for (var e = [], i = [], n = [], r = 0; r < a; r++) e[r] = 0, i[r] = 0, n[r] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: i,
                    attributeDivisors: n,
                    object: t,
                    attributes: {},
                    index: null
                }
            }

            function P() {
                for (var t = c.newAttributes, e = 0, i = t.length; e < i; e++) t[e] = 0
            }

            function L(t) {
                k(t, 0)
            }

            function k(t, e) {
                var i = c.newAttributes,
                    n = c.enabledAttributes,
                    r = c.attributeDivisors;
                i[t] = 1, 0 === n[t] && (C.enableVertexAttribArray(t), n[t] = 1), r[t] !== e && ((D.isWebGL2 ? C : A.get("ANGLE_instanced_arrays"))[D.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](t, e), r[t] = e)
            }

            function O() {
                for (var t = c.newAttributes, e = c.enabledAttributes, i = 0, n = e.length; i < n; i++) e[i] !== t[i] && (C.disableVertexAttribArray(i), e[i] = 0)
            }

            function F(t, e, i, n, r, a) {
                !0 !== D.isWebGL2 || 5124 !== i && 5125 !== i ? C.vertexAttribPointer(t, e, i, n, r, a) : C.vertexAttribIPointer(t, e, i, r, a)
            }

            function o() {
                e(), c !== t && p((c = t).object)
            }

            function e() {
                t.geometry = null, t.program = null, t.wireframe = !1
            }
            return {
                setup: function(t, e, i, n, r) {
                    var a, s, o = !1;
                    h ? (a = function(t, e, i) {
                        var n = !0 === i.wireframe,
                            r = u[t.id];
                        void 0 === r && (r = {}, u[t.id] = r);
                        var a = r[e.id];
                        void 0 === a && (a = {}, r[e.id] = a);
                        var s = a[n];
                        void 0 === s && (s = d(D.isWebGL2 ? C.createVertexArray() : l.createVertexArrayOES()), a[n] = s);
                        return s
                    }(n, i, e), c !== a && p((c = a).object), (o = function(t, e) {
                        var i = c.attributes,
                            n = t.attributes;
                        if (Object.keys(i).length !== Object.keys(n).length) return !0;
                        for (var r in n) {
                            var a = i[r],
                                s = n[r];
                            if (void 0 === a) return !0;
                            if (a.attribute !== s) return !0;
                            if (a.data !== s.data) return !0
                        }
                        return c.index !== e
                    }(n, r)) && function(t, e) {
                        var i = {},
                            n = t.attributes;
                        for (var r in n) {
                            var a = n[r],
                                s = {};
                            (s.attribute = a).data && (s.data = a.data), i[r] = s
                        }
                        c.attributes = i, c.index = e
                    }(n, r)) : (s = !0 === e.wireframe, c.geometry === n.id && c.program === i.id && c.wireframe === s || (c.geometry = n.id, c.program = i.id, c.wireframe = s, o = !0)), !0 === t.isInstancedMesh && (o = !0), null !== r && E.update(r, 34963), o && (function(t, e, i, n) {
                        if (!1 === D.isWebGL2 && (t.isInstancedMesh || n.isInstancedBufferGeometry) && null === A.get("ANGLE_instanced_arrays")) return;
                        P();
                        var r = n.attributes,
                            a = i.getAttributes(),
                            s = e.defaultAttributeValues;
                        for (var o in a) {
                            var l = a[o];
                            if (0 <= l) {
                                var h = r[o];
                                if (void 0 !== h) {
                                    var u = h.normalized,
                                        c = h.itemSize,
                                        p = E.get(h);
                                    if (void 0 === p) continue;
                                    var d, f, m, g = p.buffer,
                                        v = p.type,
                                        y = p.bytesPerElement;
                                    h.isInterleavedBufferAttribute ? (d = h.data, f = d.stride, m = h.offset, d && d.isInstancedInterleavedBuffer ? (k(l, d.meshPerAttribute), void 0 === n._maxInstanceCount && (n._maxInstanceCount = d.meshPerAttribute * d.count)) : L(l), C.bindBuffer(34962, g), F(l, c, v, u, f * y, m * y)) : (h.isInstancedBufferAttribute ? (k(l, h.meshPerAttribute), void 0 === n._maxInstanceCount && (n._maxInstanceCount = h.meshPerAttribute * h.count)) : L(l), C.bindBuffer(34962, g), F(l, c, v, u, 0, 0))
                                } else if ("instanceMatrix" === o) {
                                    var b = E.get(t.instanceMatrix);
                                    if (void 0 === b) continue;
                                    var x = b.buffer,
                                        _ = b.type;
                                    k(l + 0, 1), k(l + 1, 1), k(l + 2, 1), k(l + 3, 1), C.bindBuffer(34962, x), C.vertexAttribPointer(l + 0, 4, _, !1, 64, 0), C.vertexAttribPointer(l + 1, 4, _, !1, 64, 16), C.vertexAttribPointer(l + 2, 4, _, !1, 64, 32), C.vertexAttribPointer(l + 3, 4, _, !1, 64, 48)
                                } else if ("instanceColor" === o) {
                                    var w = E.get(t.instanceColor);
                                    if (void 0 === w) continue;
                                    var S = w.buffer,
                                        M = w.type;
                                    k(l, 1), C.bindBuffer(34962, S), C.vertexAttribPointer(l, 3, M, !1, 12, 0)
                                } else if (void 0 !== s) {
                                    var T = s[o];
                                    if (void 0 !== T) switch (T.length) {
                                        case 2:
                                            C.vertexAttrib2fv(l, T);
                                            break;
                                        case 3:
                                            C.vertexAttrib3fv(l, T);
                                            break;
                                        case 4:
                                            C.vertexAttrib4fv(l, T);
                                            break;
                                        default:
                                            C.vertexAttrib1fv(l, T)
                                    }
                                }
                            }
                        }
                        O()
                    }(t, e, i, n), null !== r && C.bindBuffer(34963, E.get(r).buffer))
                },
                reset: o,
                resetDefaultState: e,
                dispose: function() {
                    for (var t in o(), u) {
                        var e = u[t];
                        for (var i in e) {
                            var n = e[i];
                            for (var r in n) s(n[r].object), delete n[r];
                            delete e[i]
                        }
                        delete u[t]
                    }
                },
                releaseStatesOfGeometry: function(t) {
                    if (void 0 !== u[t.id]) {
                        var e = u[t.id];
                        for (var i in e) {
                            var n = e[i];
                            for (var r in n) s(n[r].object), delete n[r];
                            delete e[i]
                        }
                        delete u[t.id]
                    }
                },
                releaseStatesOfProgram: function(t) {
                    for (var e in u) {
                        var i = u[e];
                        if (void 0 !== i[t.id]) {
                            var n = i[t.id];
                            for (var r in n) s(n[r].object), delete n[r];
                            delete i[t.id]
                        }
                    }
                },
                initAttributes: P,
                enableAttribute: L,
                disableUnusedAttributes: O
            }
        }

        function ma(a, s, o, t) {
            var l, h = t.isWebGL2;
            this.setMode = function(t) {
                l = t
            }, this.render = function(t, e) {
                a.drawArrays(l, t, e), o.update(e, l, 1)
            }, this.renderInstances = function(t, e, i) {
                if (0 !== i) {
                    var n, r;
                    if (h) n = a, r = "drawArraysInstanced";
                    else if (r = "drawArraysInstancedANGLE", null === (n = s.get("ANGLE_instanced_arrays"))) return;
                    n[r](l, t, e, i), o.update(e, l, i)
                }
            }
        }

        function ga(e, i, t) {
            var n;

            function r(t) {
                if ("highp" === t) {
                    if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                    t = "mediump"
                }
                return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
            }
            var a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext,
                s = void 0 !== t.precision ? t.precision : "highp",
                o = r(s);
            o !== s && (s = o);
            var l = !0 === t.logarithmicDepthBuffer,
                h = e.getParameter(34930),
                u = e.getParameter(35660),
                c = e.getParameter(3379),
                p = e.getParameter(34076),
                d = e.getParameter(34921),
                f = e.getParameter(36347),
                m = e.getParameter(36348),
                g = e.getParameter(36349),
                v = 0 < u,
                y = a || !!i.get("OES_texture_float");
            return {
                isWebGL2: a,
                getMaxAnisotropy: function() {
                    if (void 0 !== n) return n;
                    var t = i.get("EXT_texture_filter_anisotropic");
                    return n = null !== t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                },
                getMaxPrecision: r,
                precision: s,
                logarithmicDepthBuffer: l,
                maxTextures: h,
                maxVertexTextures: u,
                maxTextureSize: c,
                maxCubemapSize: p,
                maxAttributes: d,
                maxVertexUniforms: f,
                maxVaryings: m,
                maxFragmentUniforms: g,
                vertexTextures: v,
                floatFragmentTextures: y,
                floatVertexTextures: v && y,
                maxSamples: a ? e.getParameter(36183) : 0
            }
        }

        function va(c) {
            var u = this,
                p = null,
                d = 0,
                f = !1,
                m = !1,
                g = new Cn,
                v = new fi,
                y = {
                    value: null,
                    needsUpdate: !1
                };

            function b() {
                y.value !== p && (y.value = p, y.needsUpdate = 0 < d), u.numPlanes = d, u.numIntersection = 0
            }

            function x(t, e, i, n) {
                var r = null !== t ? t.length : 0,
                    a = null;
                if (0 !== r) {
                    if (a = y.value, !0 !== n || null === a) {
                        var s = i + 4 * r,
                            o = e.matrixWorldInverse;
                        v.getNormalMatrix(o), (null === a || a.length < s) && (a = new Float32Array(s));
                        for (var l = 0, h = i; l !== r; ++l, h += 4) g.copy(t[l]).applyMatrix4(o, v), g.normal.toArray(a, h), a[h + 3] = g.constant
                    }
                    y.value = a, y.needsUpdate = !0
                }
                return u.numPlanes = r, u.numIntersection = 0, a
            }
            this.uniform = y, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, i) {
                var n = 0 !== t.length || e || 0 !== d || f;
                return f = e, p = x(t, i, 0), d = t.length, n
            }, this.beginShadows = function() {
                m = !0, x(null)
            }, this.endShadows = function() {
                m = !1, b()
            }, this.setState = function(t, e, i) {
                var n = t.clippingPlanes,
                    r = t.clipIntersection,
                    a = t.clipShadows,
                    s = c.get(t);
                if (!f || null === n || 0 === n.length || m && !a) m ? x(null) : b();
                else {
                    var o = m ? 0 : d,
                        l = 4 * o,
                        h = s.clippingState || null;
                    y.value = h, h = x(n, e, l, i);
                    for (var u = 0; u !== l; ++u) h[u] = p[u];
                    s.clippingState = h, this.numIntersection = r ? this.numPlanes : 0, this.numPlanes += o
                }
            }
        }

        function ya(o) {
            var l = new WeakMap;

            function h(t, e) {
                return e === c ? t.mapping = Pt : e === p && (t.mapping = Lt), t
            }
            return {
                get: function(t) {
                    if (t && t.isTexture) {
                        var e = t.mapping;
                        if (e === c || e === p) {
                            if (l.has(t)) return h(l.get(t).texture, t.mapping);
                            var i = t.image;
                            if (i && 0 < i.height) {
                                var n = o.getRenderList(),
                                    r = o.getRenderTarget(),
                                    a = o.getRenderState(),
                                    s = new ea(i.height / 2);
                                return s.fromEquirectangularTexture(o, t), l.set(t, s), o.setRenderTarget(r), o.setRenderList(n), o.setRenderState(a), h(s.texture, t.mapping)
                            }
                            return null
                        }
                    }
                    return t
                },
                dispose: function() {
                    l = new WeakMap
                }
            }
        }

        function ba(i) {
            var n = {};
            return {
                has: function(t) {
                    if (void 0 !== n[t]) return null !== n[t];
                    var e;
                    switch (t) {
                        case "WEBGL_depth_texture":
                            e = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            e = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            e = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            e = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            e = i.getExtension(t)
                    }
                    return null !== (n[t] = e)
                },
                get: function(t) {
                    return this.has(t), n[t]
                }
            }
        }

        function xa(t, b, a, s) {
            var o = new WeakMap,
                x = new WeakMap;

            function l(t) {
                var e = t.target,
                    i = o.get(e);
                for (var n in null !== i.index && b.remove(i.index), i.attributes) b.remove(i.attributes[n]);
                e.removeEventListener("dispose", l), o.delete(e);
                var r = x.get(i);
                r && (b.remove(r), x.delete(i)), s.releaseStatesOfGeometry(e), !0 === e.isInstancedBufferGeometry && delete e._maxInstanceCount, a.memory.geometries--
            }

            function n(t) {
                var e = [],
                    i = t.index,
                    n = t.attributes.position,
                    r = 0;
                if (null !== i)
                    for (var a = i.array, r = i.version, s = 0, o = a.length; s < o; s += 3) {
                        var l = a[s + 0],
                            h = a[s + 1],
                            u = a[s + 2];
                        e.push(l, h, h, u, u, l)
                    } else {
                        var c = n.array;
                        r = n.version;
                        for (var p = 0, d = c.length / 3 - 1; p < d; p += 3) {
                            var f = p + 0,
                                m = p + 1,
                                g = p + 2;
                            e.push(f, m, m, g, g, f)
                        }
                    }
                var v = new(65535 < lr(e) ? rr : ir)(e, 1);
                v.version = r;
                var y = x.get(t);
                y && b.remove(y), x.set(t, v)
            }
            return {
                get: function(t, e) {
                    var i = o.get(e);
                    return i || (e.addEventListener("dispose", l), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new gr).setFromObject(t)), i = e._bufferGeometry), o.set(e, i), a.memory.geometries++, i)
                },
                update: function(t) {
                    var e = t.attributes;
                    for (var i in e) b.update(e[i], 34962);
                    var n = t.morphAttributes;
                    for (var r in n)
                        for (var a = n[r], s = 0, o = a.length; s < o; s++) b.update(a[s], 34962)
                },
                getWireframeAttribute: function(t) {
                    var e, i = x.get(t);
                    return (!i || null !== (e = t.index) && i.version < e.version) && n(t), x.get(t)
                }
            }
        }

        function _a(a, s, o, t) {
            var l, h, u, c = t.isWebGL2;
            this.setMode = function(t) {
                l = t
            }, this.setIndex = function(t) {
                h = t.type, u = t.bytesPerElement
            }, this.render = function(t, e) {
                a.drawElements(l, e, h, t * u), o.update(e, l, 1)
            }, this.renderInstances = function(t, e, i) {
                if (0 !== i) {
                    var n, r;
                    if (c) n = a, r = "drawElementsInstanced";
                    else if (r = "drawElementsInstancedANGLE", null === (n = s.get("ANGLE_instanced_arrays"))) return;
                    n[r](l, e, h, t * u, i), o.update(e, l, i)
                }
            }
        }

        function wa(t) {
            var n = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: n,
                programs: null,
                autoReset: !0,
                reset: function() {
                    n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0
                },
                update: function(t, e, i) {
                    switch (n.calls++, e) {
                        case 4:
                            n.triangles += i * (t / 3);
                            break;
                        case 1:
                            n.lines += i * (t / 2);
                            break;
                        case 3:
                            n.lines += i * (t - 1);
                            break;
                        case 2:
                            n.lines += i * t;
                            break;
                        case 0:
                            n.points += i * t
                    }
                }
            }
        }

        function Sa(t, e) {
            return t[0] - e[0]
        }

        function Ma(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function Ta(b) {
            for (var x = {}, _ = new Float32Array(8), w = [], t = 0; t < 8; t++) w[t] = [t, 0];
            return {
                update: function(t, e, i, n) {
                    var r = t.morphTargetInfluences,
                        a = void 0 === r ? 0 : r.length,
                        s = x[e.id];
                    if (void 0 === s) {
                        s = [];
                        for (var o = 0; o < a; o++) s[o] = [o, 0];
                        x[e.id] = s
                    }
                    for (var l = 0; l < a; l++) {
                        var h = s[l];
                        h[0] = l, h[1] = r[l]
                    }
                    s.sort(Ma);
                    for (var u = 0; u < 8; u++) u < a && s[u][1] ? (w[u][0] = s[u][0], w[u][1] = s[u][1]) : (w[u][0] = Number.MAX_SAFE_INTEGER, w[u][1] = 0);
                    w.sort(Sa);
                    for (var c = i.morphTargets && e.morphAttributes.position, p = i.morphNormals && e.morphAttributes.normal, d = 0, f = 0; f < 8; f++) {
                        var m = w[f],
                            g = m[0],
                            v = m[1];
                        g !== Number.MAX_SAFE_INTEGER && v ? (c && e.getAttribute("morphTarget" + f) !== c[g] && e.setAttribute("morphTarget" + f, c[g]), p && e.getAttribute("morphNormal" + f) !== p[g] && e.setAttribute("morphNormal" + f, p[g]), d += _[f] = v) : (c && void 0 !== e.getAttribute("morphTarget" + f) && e.deleteAttribute("morphTarget" + f), p && void 0 !== e.getAttribute("morphNormal" + f) && e.deleteAttribute("morphNormal" + f), _[f] = 0)
                    }
                    var y = e.morphTargetsRelative ? 1 : 1 - d;
                    n.getUniforms().setValue(b, "morphTargetBaseInfluence", y), n.getUniforms().setValue(b, "morphTargetInfluences", _)
                }
            }
        }

        function Ca(t, r, a, s) {
            var o = new WeakMap;
            return {
                update: function(t) {
                    var e = s.render.frame,
                        i = t.geometry,
                        n = r.get(t, i);
                    return o.get(n) !== e && (i.isGeometry && n.updateFromObject(t), r.update(n), o.set(n, e)), t.isInstancedMesh && (a.update(t.instanceMatrix, 34962), null !== t.instanceColor && a.update(t.instanceColor, 34962)), n
                },
                dispose: function() {
                    o = new WeakMap
                }
            }
        }

        function Aa(t, e, i, n, r, a, s, o, l, h) {
            vi.call(this, t = void 0 !== t ? t : [], e = void 0 !== e ? e : Pt, i, n, r, a, s = void 0 !== s ? s : Jt, o, l, h), this.flipY = !1
        }

        function Ea(t, e, i, n) {
            vi.call(this, null), this.image = {
                data: t || null,
                width: e || 1,
                height: i || 1,
                depth: n || 1
            }, this.magFilter = Bt, this.minFilter = Bt, this.wrapR = It, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
        }

        function Da(t, e, i, n) {
            vi.call(this, null), this.image = {
                data: t || null,
                width: e || 1,
                height: i || 1,
                depth: n || 1
            }, this.magFilter = Bt, this.minFilter = Bt, this.wrapR = It, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
        }(i.ShaderLib = pa).physical = {
            uniforms: Wr([pa.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new pi(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new Hn(0)
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                }
            }]),
            vertexShader: ua.meshphysical_vert,
            fragmentShader: ua.meshphysical_frag
        }, ((Aa.prototype = Object.create(vi.prototype)).constructor = Aa).prototype.isCubeTexture = !0, Object.defineProperty(Aa.prototype, "images", {
            get: function() {
                return this.image
            },
            set: function(t) {
                this.image = t
            }
        }), ((Ea.prototype = Object.create(vi.prototype)).constructor = Ea).prototype.isDataTexture2DArray = !0, ((Da.prototype = Object.create(vi.prototype)).constructor = Da).prototype.isDataTexture3D = !0;
        var Pa = new vi,
            La = new Ea,
            ka = new Da,
            Oa = new Aa,
            Fa = [],
            Ia = [],
            Na = new Float32Array(16),
            Ba = new Float32Array(9),
            Ra = new Float32Array(4);

        function za(t, e, i) {
            var n = t[0];
            if (n <= 0 || 0 < n) return t;
            var r = e * i,
                a = Fa[r];
            if (void 0 === a && (a = new Float32Array(r), Fa[r] = a), 0 !== e) {
                n.toArray(a, 0);
                for (var s = 1, o = 0; s !== e; ++s) o += i, t[s].toArray(a, o)
            }
            return a
        }

        function Ga(t, e) {
            if (t.length === e.length) {
                for (var i = 0, n = t.length; i < n; i++)
                    if (t[i] !== e[i]) return;
                return 1
            }
        }

        function Va(t, e) {
            for (var i = 0, n = e.length; i < n; i++) t[i] = e[i]
        }

        function Ua(t, e) {
            var i = Ia[e];
            void 0 === i && (i = new Int32Array(e), Ia[e] = i);
            for (var n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
            return i
        }

        function ja(t, e) {
            var i = this.cache;
            i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
        }

        function Ha(t, e) {
            var i = this.cache;
            if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
            else {
                if (Ga(i, e)) return;
                t.uniform2fv(this.addr, e), Va(i, e)
            }
        }

        function Wa(t, e) {
            var i = this.cache;
            if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
            else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
            else {
                if (Ga(i, e)) return;
                t.uniform3fv(this.addr, e), Va(i, e)
            }
        }

        function qa(t, e) {
            var i = this.cache;
            if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
            else {
                if (Ga(i, e)) return;
                t.uniform4fv(this.addr, e), Va(i, e)
            }
        }

        function Xa(t, e) {
            var i = this.cache,
                n = e.elements;
            if (void 0 === n) {
                if (Ga(i, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), Va(i, e)
            } else {
                if (Ga(i, n)) return;
                Ra.set(n), t.uniformMatrix2fv(this.addr, !1, Ra), Va(i, n)
            }
        }

        function Ya(t, e) {
            var i = this.cache,
                n = e.elements;
            if (void 0 === n) {
                if (Ga(i, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), Va(i, e)
            } else {
                if (Ga(i, n)) return;
                Ba.set(n), t.uniformMatrix3fv(this.addr, !1, Ba), Va(i, n)
            }
        }

        function Ja(t, e) {
            var i = this.cache,
                n = e.elements;
            if (void 0 === n) {
                if (Ga(i, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), Va(i, e)
            } else {
                if (Ga(i, n)) return;
                Na.set(n), t.uniformMatrix4fv(this.addr, !1, Na), Va(i, n)
            }
        }

        function Za(t, e, i) {
            var n = this.cache,
                r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(e || Pa, r)
        }

        function $a(t, e, i) {
            var n = this.cache,
                r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(e || La, r)
        }

        function Ka(t, e, i) {
            var n = this.cache,
                r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || ka, r)
        }

        function Qa(t, e, i) {
            var n = this.cache,
                r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(e || Oa, r)
        }

        function ts(t, e) {
            var i = this.cache;
            i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
        }

        function es(t, e) {
            var i = this.cache;
            Ga(i, e) || (t.uniform2iv(this.addr, e), Va(i, e))
        }

        function is(t, e) {
            var i = this.cache;
            Ga(i, e) || (t.uniform3iv(this.addr, e), Va(i, e))
        }

        function ns(t, e) {
            var i = this.cache;
            Ga(i, e) || (t.uniform4iv(this.addr, e), Va(i, e))
        }

        function rs(t, e) {
            var i = this.cache;
            i[0] !== e && (t.uniform1ui(this.addr, e), i[0] = e)
        }

        function as(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function ss(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function os(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function ls(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function hs(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function us(t, e) {
            var i = za(e, this.size, 2);
            t.uniform2fv(this.addr, i)
        }

        function cs(t, e) {
            var i = za(e, this.size, 3);
            t.uniform3fv(this.addr, i)
        }

        function ps(t, e) {
            var i = za(e, this.size, 4);
            t.uniform4fv(this.addr, i)
        }

        function ds(t, e) {
            var i = za(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, i)
        }

        function fs(t, e) {
            var i = za(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, i)
        }

        function ms(t, e) {
            var i = za(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, i)
        }

        function gs(t, e, i) {
            var n = e.length,
                r = Ua(i, n);
            t.uniform1iv(this.addr, r);
            for (var a = 0; a !== n; ++a) i.safeSetTexture2D(e[a] || Pa, r[a])
        }

        function vs(t, e, i) {
            var n = e.length,
                r = Ua(i, n);
            t.uniform1iv(this.addr, r);
            for (var a = 0; a !== n; ++a) i.safeSetTextureCube(e[a] || Oa, r[a])
        }

        function ys(t, e, i) {
            this.id = t, this.addr = i, this.cache = [], this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return ja;
                    case 35664:
                        return Ha;
                    case 35665:
                        return Wa;
                    case 35666:
                        return qa;
                    case 35674:
                        return Xa;
                    case 35675:
                        return Ya;
                    case 35676:
                        return Ja;
                    case 5124:
                    case 35670:
                        return ts;
                    case 35667:
                    case 35671:
                        return es;
                    case 35668:
                    case 35672:
                        return is;
                    case 35669:
                    case 35673:
                        return ns;
                    case 5125:
                        return rs;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Za;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Ka;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Qa;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return $a
                }
            }(e.type)
        }

        function bs(t, e, i) {
            this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return as;
                    case 35664:
                        return us;
                    case 35665:
                        return cs;
                    case 35666:
                        return ps;
                    case 35674:
                        return ds;
                    case 35675:
                        return fs;
                    case 35676:
                        return ms;
                    case 5124:
                    case 35670:
                        return ss;
                    case 35667:
                    case 35671:
                        return os;
                    case 35668:
                    case 35672:
                        return ls;
                    case 35669:
                    case 35673:
                        return hs;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return gs;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return vs
                }
            }(e.type)
        }

        function xs(t) {
            this.id = t, this.seq = [], this.map = {}
        }
        bs.prototype.updateCache = function(t) {
            var e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Va(e, t)
        }, xs.prototype.setValue = function(t, e, i) {
            for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
                var s = n[r];
                s.setValue(t, e[s.id], i)
            }
        };
        var _s = /([\w\d_]+)(\])?(\[|\.)?/g;

        function ws(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function Ss(t, e) {
            this.seq = [], this.map = {};
            for (var i = t.getProgramParameter(e, 35718), n = 0; n < i; ++n) {
                var r = t.getActiveUniform(e, n);
                ! function(t, e, i) {
                    var n = t.name,
                        r = n.length;
                    for (_s.lastIndex = 0;;) {
                        var a = _s.exec(n),
                            s = _s.lastIndex,
                            o = a[1],
                            l = "]" === a[2],
                            h = a[3];
                        if (l && (o |= 0), void 0 === h || "[" === h && s + 2 === r) {
                            ws(i, new(void 0 === h ? ys : bs)(o, t, e));
                            break
                        }
                        var u = i.map[o];
                        void 0 === u && ws(i, u = new xs(o)), i = u
                    }
                }(r, t.getUniformLocation(e, r.name), this)
            }
        }

        function Ms(t, e, i) {
            var n = t.createShader(e);
            return t.shaderSource(n, i), t.compileShader(n), n
        }
        Ss.prototype.setValue = function(t, e, i, n) {
            var r = this.map[e];
            void 0 !== r && r.setValue(t, i, n)
        }, Ss.prototype.setOptional = function(t, e, i) {
            var n = e[i];
            void 0 !== n && this.setValue(t, i, n)
        }, Ss.upload = function(t, e, i, n) {
            for (var r = 0, a = e.length; r !== a; ++r) {
                var s = e[r],
                    o = i[s.id];
                !1 !== o.needsUpdate && s.setValue(t, o.value, n)
            }
        }, Ss.seqWithValue = function(t, e) {
            for (var i = [], n = 0, r = t.length; n !== r; ++n) {
                var a = t[n];
                a.id in e && i.push(a)
            }
            return i
        };
        var Ts = 0;

        function Cs(t) {
            switch (t) {
                case He:
                    return ["Linear", "( value )"];
                case We:
                    return ["sRGB", "( value )"];
                case Xe:
                    return ["RGBE", "( value )"];
                case Je:
                    return ["RGBM", "( value, 7.0 )"];
                case Ze:
                    return ["RGBM", "( value, 16.0 )"];
                case $e:
                    return ["RGBD", "( value, 256.0 )"];
                case qe:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case Ye:
                    return ["LogLuv", "( value )"];
                default:
                    return ["Linear", "( value )"]
            }
        }

        function As(t, e, i) {
            var n = t.getShaderParameter(e, 35713),
                r = t.getShaderInfoLog(e).trim();
            return n && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + i + "\n" + r + function(t) {
                for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
                return e.join("\n")
            }(t.getShaderSource(e))
        }

        function Es(t, e) {
            var i = Cs(e);
            return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
        }

        function Ds(t) {
            return "" !== t
        }

        function Ps(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function Ls(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        var ks = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Os(t) {
            return t.replace(ks, Fs)
        }

        function Fs(t, e) {
            var i = ua[e];
            if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
            return Os(i)
        }
        var Is = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            Ns = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function Bs(t) {
            return t.replace(Ns, zs).replace(Is, Rs)
        }

        function Rs(t, e, i, n) {
            return zs(0, e, i, n)
        }

        function zs(t, e, i, n) {
            for (var r = "", a = parseInt(e); a < parseInt(i); a++) r += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
            return r
        }

        function Gs(t) {
            var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function Vs(t, e, i, n) {
            var r, a, s, o, l, h, u, c, p = t.getContext(),
                d = i.defines,
                f = i.vertexShader,
                m = i.fragmentShader,
                g = (a = "SHADOWMAP_TYPE_BASIC", (r = i).shadowMapType === I ? a = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === N ? a = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === B && (a = "SHADOWMAP_TYPE_VSM"), a),
                v = function(t) {
                    var e = "ENVMAP_TYPE_CUBE";
                    if (t.envMap) switch (t.envMapMode) {
                        case Pt:
                        case Lt:
                            e = "ENVMAP_TYPE_CUBE";
                            break;
                        case kt:
                        case Ot:
                            e = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return e
                }(i),
                y = function(t) {
                    var e = "ENVMAP_MODE_REFLECTION";
                    if (t.envMap) switch (t.envMapMode) {
                        case Lt:
                        case Ot:
                            e = "ENVMAP_MODE_REFRACTION"
                    }
                    return e
                }(i),
                b = function(t) {
                    var e = "ENVMAP_BLENDING_NONE";
                    if (t.envMap) switch (t.combine) {
                        case R:
                            e = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case z:
                            e = "ENVMAP_BLENDING_MIX";
                            break;
                        case G:
                            e = "ENVMAP_BLENDING_ADD"
                    }
                    return e
                }(i),
                x = 0 < t.gammaFactor ? t.gammaFactor : 1,
                _ = i.isWebGL2 ? "" : [(s = i).extensionDerivatives || s.envMapCubeUV || s.bumpMap || s.tangentSpaceNormalMap || s.clearcoatNormalMap || s.flatShading || "physical" === s.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (s.extensionFragDepth || s.logarithmicDepthBuffer) && s.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", s.extensionDrawBuffers && s.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (s.extensionShaderTextureLOD || s.envMap) && s.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ds).join("\n"),
                w = function(t) {
                    var e = [];
                    for (var i in t) {
                        var n = t[i];
                        !1 !== n && e.push("#define " + i + " " + n)
                    }
                    return e.join("\n")
                }(d),
                S = p.createProgram(),
                M = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
            i.isRawShaderMaterial ? (0 < (o = [w].filter(Ds).join("\n")).length && (o += "\n"), 0 < (l = [_, w].filter(Ds).join("\n")).length && (l += "\n")) : (o = [Gs(i), "#define SHADER_NAME " + i.shaderName, w, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + x, "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + y : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + g : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ds).join("\n"), l = [_, Gs(i), "#define SHADER_NAME " + i.shaderName, w, i.alphaTest ? "#define ALPHATEST " + i.alphaTest + (i.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + x, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + v : "", i.envMap ? "#define " + y : "", i.envMap ? "#define " + b : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.sheen ? "#define USE_SHEEN" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + g : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== At ? "#define TONE_MAPPING" : "", i.toneMapping !== At ? ua.tonemapping_pars_fragment : "", i.toneMapping !== At ? function(t, e) {
                var i;
                switch (e) {
                    case U:
                        i = "Linear";
                        break;
                    case j:
                        i = "Reinhard";
                        break;
                    case H:
                        i = "OptimizedCineon";
                        break;
                    case Et:
                        i = "ACESFilmic";
                        break;
                    case Dt:
                        i = "Custom";
                        break;
                    default:
                        i = "Linear"
                }
                return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
            }("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", ua.encodings_pars_fragment, i.map ? Es("mapTexelToLinear", i.mapEncoding) : "", i.matcap ? Es("matcapTexelToLinear", i.matcapEncoding) : "", i.envMap ? Es("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMap ? Es("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.lightMap ? Es("lightMapTexelToLinear", i.lightMapEncoding) : "", (h = "linearToOutputTexel", u = i.outputEncoding, c = Cs(u), "vec4 " + h + "( vec4 value ) { return LinearTo" + c[0] + c[1] + "; }"), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Ds).join("\n")), f = Ls(f = Ps(f = Os(f), i), i), m = Ls(m = Ps(m = Os(m), i), i), f = Bs(f), m = Bs(m), i.isWebGL2 && !0 !== i.isRawShaderMaterial && (M = "#version 300 es\n", o = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + o, l = ["#define varying in", i.glslVersion === si ? "" : "out highp vec4 pc_fragColor;", i.glslVersion === si ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + l);
            var T, C, A, E, D, P, L, k = M + l + m,
                O = Ms(p, 35633, M + o + f),
                F = Ms(p, 35632, k);
            return p.attachShader(S, O), p.attachShader(S, F), void 0 !== i.index0AttributeName ? p.bindAttribLocation(S, 0, i.index0AttributeName) : !0 === i.morphTargets && p.bindAttribLocation(S, 0, "position"), p.linkProgram(S), t.debug.checkShaderErrors && (T = p.getProgramInfoLog(S).trim(), C = p.getShaderInfoLog(O).trim(), A = p.getShaderInfoLog(F).trim(), !(D = E = !0) === p.getProgramParameter(S, 35714) ? (E = !1, As(p, O, "vertex"), As(p, F, "fragment")) : "" !== T || "" !== C && "" !== A || (D = !1), D && (this.diagnostics = {
                runnable: E,
                programLog: T,
                vertexShader: {
                    log: C,
                    prefix: o
                },
                fragmentShader: {
                    log: A,
                    prefix: l
                }
            })), p.deleteShader(O), p.deleteShader(F), this.getUniforms = function() {
                return void 0 === P && (P = new Ss(p, S)), P
            }, this.getAttributes = function() {
                return void 0 === L && (L = function(t, e) {
                    for (var i = {}, n = t.getProgramParameter(e, 35721), r = 0; r < n; r++) {
                        var a = t.getActiveAttrib(e, r).name;
                        i[a] = t.getAttribLocation(e, a)
                    }
                    return i
                }(p, S)), L
            }, this.destroy = function() {
                n.releaseStatesOfProgram(this), p.deleteProgram(S), this.program = void 0
            }, this.name = i.shaderName, this.id = Ts++, this.cacheKey = e, this.usedTimes = 1, this.program = S, this.vertexShader = O, this.fragmentShader = F, this
        }

        function Us(f, m, g, v, s, y) {
            var o = [],
                b = v.isWebGL2,
                x = v.logarithmicDepthBuffer,
                _ = v.floatVertexTextures,
                w = v.maxVertexUniforms,
                S = v.vertexTextures,
                M = v.precision,
                T = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                r = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

            function C(t) {
                var e;
                return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (e = t.texture.encoding) : e = He, e
            }
            return {
                getParameters: function(t, e, i, n, r) {
                    var a, s, o, l = n.fog,
                        h = t.isMeshStandardMaterial ? n.environment : null,
                        u = m.get(t.envMap || h),
                        c = T[t.type],
                        p = r.isSkinnedMesh ? function(t) {
                            var e = t.skeleton.bones;
                            if (_) return 1024;
                            var i = Math.floor((w - 20) / 4),
                                n = Math.min(i, e.length);
                            return n < e.length ? 0 : n
                        }(r) : 0;
                    null !== t.precision && (M = v.getMaxPrecision(t.precision), t.precision), o = c ? (s = (a = pa[c]).vertexShader, a.fragmentShader) : (s = t.vertexShader, t.fragmentShader);
                    var d = f.getRenderTarget();
                    return {
                        isWebGL2: b,
                        shaderID: c,
                        shaderName: t.type,
                        vertexShader: s,
                        fragmentShader: o,
                        defines: t.defines,
                        isRawShaderMaterial: !0 === t.isRawShaderMaterial,
                        glslVersion: t.glslVersion,
                        precision: M,
                        instancing: !0 === r.isInstancedMesh,
                        instancingColor: !0 === r.isInstancedMesh && null !== r.instanceColor,
                        supportsVertexTextures: S,
                        outputEncoding: null !== d ? C(d.texture) : f.outputEncoding,
                        map: !!t.map,
                        mapEncoding: C(t.map),
                        matcap: !!t.matcap,
                        matcapEncoding: C(t.matcap),
                        envMap: !!u,
                        envMapMode: u && u.mapping,
                        envMapEncoding: C(u),
                        envMapCubeUV: !!u && (u.mapping === kt || u.mapping === Ot),
                        lightMap: !!t.lightMap,
                        lightMapEncoding: C(t.lightMap),
                        aoMap: !!t.aoMap,
                        emissiveMap: !!t.emissiveMap,
                        emissiveMapEncoding: C(t.emissiveMap),
                        bumpMap: !!t.bumpMap,
                        normalMap: !!t.normalMap,
                        objectSpaceNormalMap: t.normalMapType === ei,
                        tangentSpaceNormalMap: t.normalMapType === ti,
                        clearcoatMap: !!t.clearcoatMap,
                        clearcoatRoughnessMap: !!t.clearcoatRoughnessMap,
                        clearcoatNormalMap: !!t.clearcoatNormalMap,
                        displacementMap: !!t.displacementMap,
                        roughnessMap: !!t.roughnessMap,
                        metalnessMap: !!t.metalnessMap,
                        specularMap: !!t.specularMap,
                        alphaMap: !!t.alphaMap,
                        gradientMap: !!t.gradientMap,
                        sheen: !!t.sheen,
                        transmissionMap: !!t.transmissionMap,
                        combine: t.combine,
                        vertexTangents: t.normalMap && t.vertexTangents,
                        vertexColors: t.vertexColors,
                        vertexUvs: !!(t.map || t.bumpMap || t.normalMap || t.specularMap || t.alphaMap || t.emissiveMap || t.roughnessMap || t.metalnessMap || t.clearcoatMap || t.clearcoatRoughnessMap || t.clearcoatNormalMap || t.displacementMap || t.transmissionMap),
                        uvsVertexOnly: !(t.map || t.bumpMap || t.normalMap || t.specularMap || t.alphaMap || t.emissiveMap || t.roughnessMap || t.metalnessMap || t.clearcoatNormalMap || t.transmissionMap || !t.displacementMap),
                        fog: !!l,
                        useFog: t.fog,
                        fogExp2: l && l.isFogExp2,
                        flatShading: t.flatShading,
                        sizeAttenuation: t.sizeAttenuation,
                        logarithmicDepthBuffer: x,
                        skinning: t.skinning && 0 < p,
                        maxBones: p,
                        useVertexTexture: _,
                        morphTargets: t.morphTargets,
                        morphNormals: t.morphNormals,
                        maxMorphTargets: f.maxMorphTargets,
                        maxMorphNormals: f.maxMorphNormals,
                        numDirLights: e.directional.length,
                        numPointLights: e.point.length,
                        numSpotLights: e.spot.length,
                        numRectAreaLights: e.rectArea.length,
                        numHemiLights: e.hemi.length,
                        numDirLightShadows: e.directionalShadowMap.length,
                        numPointLightShadows: e.pointShadowMap.length,
                        numSpotLightShadows: e.spotShadowMap.length,
                        numClippingPlanes: y.numPlanes,
                        numClipIntersection: y.numIntersection,
                        dithering: t.dithering,
                        shadowMapEnabled: f.shadowMap.enabled && 0 < i.length,
                        shadowMapType: f.shadowMap.type,
                        toneMapping: t.toneMapped ? f.toneMapping : At,
                        physicallyCorrectLights: f.physicallyCorrectLights,
                        premultipliedAlpha: t.premultipliedAlpha,
                        alphaTest: t.alphaTest,
                        doubleSided: t.side === Z,
                        flipSided: t.side === J,
                        depthPacking: void 0 !== t.depthPacking && t.depthPacking,
                        index0AttributeName: t.index0AttributeName,
                        extensionDerivatives: t.extensions && t.extensions.derivatives,
                        extensionFragDepth: t.extensions && t.extensions.fragDepth,
                        extensionDrawBuffers: t.extensions && t.extensions.drawBuffers,
                        extensionShaderTextureLOD: t.extensions && t.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: b || g.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: b || g.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: b || g.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: t.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(t) {
                    var e = [];
                    if (t.shaderID ? e.push(t.shaderID) : (e.push(t.fragmentShader), e.push(t.vertexShader)), void 0 !== t.defines)
                        for (var i in t.defines) e.push(i), e.push(t.defines[i]);
                    if (!1 === t.isRawShaderMaterial) {
                        for (var n = 0; n < r.length; n++) e.push(t[r[n]]);
                        e.push(f.outputEncoding), e.push(f.gammaFactor)
                    }
                    return e.push(t.customProgramCacheKey), e.join()
                },
                getUniforms: function(t) {
                    var e, i = T[t.type];
                    return i ? (e = pa[i], qr.clone(e.uniforms)) : t.uniforms
                },
                acquireProgram: function(t, e) {
                    for (var i, n = 0, r = o.length; n < r; n++) {
                        var a = o[n];
                        if (a.cacheKey === e) {
                            ++(i = a).usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new Vs(f, e, t, s), o.push(i)), i
                },
                releaseProgram: function(t) {
                    var e;
                    0 == --t.usedTimes && (e = o.indexOf(t), o[e] = o[o.length - 1], o.pop(), t.destroy())
                },
                programs: o
            }
        }

        function js() {
            var n = new WeakMap;
            return {
                get: function(t) {
                    var e = n.get(t);
                    return void 0 === e && (e = {}, n.set(t, e)), e
                },
                remove: function(t) {
                    n.delete(t)
                },
                update: function(t, e, i) {
                    n.get(t)[e] = i
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }

        function Hs(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function Ws(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function qs(l) {
            var h = [],
                u = 0,
                o = [],
                c = [],
                p = {
                    id: -1
                };

            function d(t, e, i, n, r, a) {
                var s = h[u],
                    o = l.get(i);
                return void 0 === s ? (s = {
                    id: t.id,
                    object: t,
                    geometry: e,
                    material: i,
                    program: o.program || p,
                    groupOrder: n,
                    renderOrder: t.renderOrder,
                    z: r,
                    group: a
                }, h[u] = s) : (s.id = t.id, s.object = t, s.geometry = e, s.material = i, s.program = o.program || p, s.groupOrder = n, s.renderOrder = t.renderOrder, s.z = r, s.group = a), u++, s
            }
            return {
                opaque: o,
                transparent: c,
                init: function() {
                    u = 0, o.length = 0, c.length = 0
                },
                push: function(t, e, i, n, r, a) {
                    var s = d(t, e, i, n, r, a);
                    (!0 === i.transparent ? c : o).push(s)
                },
                unshift: function(t, e, i, n, r, a) {
                    var s = d(t, e, i, n, r, a);
                    (!0 === i.transparent ? c : o).unshift(s)
                },
                finish: function() {
                    for (var t = u, e = h.length; t < e; t++) {
                        var i = h[t];
                        if (null === i.id) break;
                        i.id = null, i.object = null, i.geometry = null, i.material = null, i.program = null, i.group = null
                    }
                },
                sort: function(t, e) {
                    1 < o.length && o.sort(t || Hs), 1 < c.length && c.sort(e || Ws)
                }
            }
        }

        function Xs(r) {
            var a = new WeakMap;
            return {
                get: function(t, e) {
                    var i, n = a.get(t);
                    return void 0 === n ? (i = new qs(r), a.set(t, new WeakMap), a.get(t).set(e, i)) : void 0 === (i = n.get(e)) && (i = new qs(r), n.set(e, i)), i
                },
                dispose: function() {
                    a = new WeakMap
                }
            }
        }

        function Ys() {
            var i = {};
            return {
                get: function(t) {
                    if (void 0 !== i[t.id]) return i[t.id];
                    var e;
                    switch (t.type) {
                        case "DirectionalLight":
                            e = {
                                direction: new wi,
                                color: new Hn
                            };
                            break;
                        case "SpotLight":
                            e = {
                                position: new wi,
                                direction: new wi,
                                color: new Hn,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            e = {
                                position: new wi,
                                color: new Hn,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            e = {
                                direction: new wi,
                                skyColor: new Hn,
                                groundColor: new Hn
                            };
                            break;
                        case "RectAreaLight":
                            e = {
                                color: new Hn,
                                position: new wi,
                                halfWidth: new wi,
                                halfHeight: new wi
                            }
                    }
                    return i[t.id] = e
                }
            }
        }
        var Js = 0;

        function Zs(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }

        function $s() {
            for (var i, N = new Ys, B = (i = {}, {
                    get: function(t) {
                        if (void 0 !== i[t.id]) return i[t.id];
                        var e;
                        switch (t.type) {
                            case "DirectionalLight":
                            case "SpotLight":
                                e = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new pi
                                };
                                break;
                            case "PointLight":
                                e = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new pi,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                }
                        }
                        return i[t.id] = e
                    }
                }), R = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                }, t = 0; t < 9; t++) R.probe.push(new wi);
            var z = new wi,
                G = new Zi,
                V = new Zi;
            return {
                setup: function(t, e, i) {
                    for (var n = 0, r = 0, a = 0, s = 0; s < 9; s++) R.probe[s].set(0, 0, 0);
                    var o = 0,
                        l = 0,
                        h = 0,
                        u = 0,
                        c = 0,
                        p = 0,
                        d = 0,
                        f = 0,
                        m = i.matrixWorldInverse;
                    t.sort(Zs);
                    for (var g = 0, v = t.length; g < v; g++) {
                        var y, b, x, _, w, S, M, T, C, A, E, D = t[g],
                            P = D.color,
                            L = D.intensity,
                            k = D.distance,
                            O = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
                        if (D.isAmbientLight) n += P.r * L, r += P.g * L, a += P.b * L;
                        else if (D.isLightProbe)
                            for (var F = 0; F < 9; F++) R.probe[F].addScaledVector(D.sh.coefficients[F], L);
                        else {
                            D.isDirectionalLight ? ((y = N.get(D)).color.copy(D.color).multiplyScalar(D.intensity), y.direction.setFromMatrixPosition(D.matrixWorld), z.setFromMatrixPosition(D.target.matrixWorld), y.direction.sub(z), y.direction.transformDirection(m), D.castShadow && (b = D.shadow, (x = B.get(D)).shadowBias = b.bias, x.shadowNormalBias = b.normalBias, x.shadowRadius = b.radius, x.shadowMapSize = b.mapSize, R.directionalShadow[o] = x, R.directionalShadowMap[o] = O, R.directionalShadowMatrix[o] = D.shadow.matrix, p++), R.directional[o] = y, o++) : D.isSpotLight ? ((_ = N.get(D)).position.setFromMatrixPosition(D.matrixWorld), _.position.applyMatrix4(m), _.color.copy(P).multiplyScalar(L), _.distance = k, _.direction.setFromMatrixPosition(D.matrixWorld), z.setFromMatrixPosition(D.target.matrixWorld), _.direction.sub(z), _.direction.transformDirection(m), _.coneCos = Math.cos(D.angle), _.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), _.decay = D.decay, D.castShadow && (w = D.shadow, (S = B.get(D)).shadowBias = w.bias, S.shadowNormalBias = w.normalBias, S.shadowRadius = w.radius, S.shadowMapSize = w.mapSize, R.spotShadow[h] = S, R.spotShadowMap[h] = O, R.spotShadowMatrix[h] = D.shadow.matrix, f++), R.spot[h] = _, h++) : D.isRectAreaLight ? ((M = N.get(D)).color.copy(P).multiplyScalar(L), M.position.setFromMatrixPosition(D.matrixWorld), M.position.applyMatrix4(m), V.identity(), G.copy(D.matrixWorld), G.premultiply(m), V.extractRotation(G), M.halfWidth.set(.5 * D.width, 0, 0), M.halfHeight.set(0, .5 * D.height, 0), M.halfWidth.applyMatrix4(V), M.halfHeight.applyMatrix4(V), R.rectArea[u] = M, u++) : D.isPointLight ? ((T = N.get(D)).position.setFromMatrixPosition(D.matrixWorld), T.position.applyMatrix4(m), T.color.copy(D.color).multiplyScalar(D.intensity), T.distance = D.distance, T.decay = D.decay, D.castShadow && (C = D.shadow, (A = B.get(D)).shadowBias = C.bias, A.shadowNormalBias = C.normalBias, A.shadowRadius = C.radius, A.shadowMapSize = C.mapSize, A.shadowCameraNear = C.camera.near, A.shadowCameraFar = C.camera.far, R.pointShadow[l] = A, R.pointShadowMap[l] = O, R.pointShadowMatrix[l] = D.shadow.matrix, d++), R.point[l] = T, l++) : D.isHemisphereLight && ((E = N.get(D)).direction.setFromMatrixPosition(D.matrixWorld), E.direction.transformDirection(m), E.direction.normalize(), E.skyColor.copy(D.color).multiplyScalar(L), E.groundColor.copy(D.groundColor).multiplyScalar(L), R.hemi[c] = E, c++)
                        }
                    }
                    0 < u && (R.rectAreaLTC1 = ca.LTC_1, R.rectAreaLTC2 = ca.LTC_2), R.ambient[0] = n, R.ambient[1] = r, R.ambient[2] = a;
                    var I = R.hash;
                    I.directionalLength === o && I.pointLength === l && I.spotLength === h && I.rectAreaLength === u && I.hemiLength === c && I.numDirectionalShadows === p && I.numPointShadows === d && I.numSpotShadows === f || (R.directional.length = o, R.spot.length = h, R.rectArea.length = u, R.point.length = l, R.hemi.length = c, R.directionalShadow.length = p, R.directionalShadowMap.length = p, R.pointShadow.length = d, R.pointShadowMap.length = d, R.spotShadow.length = f, R.spotShadowMap.length = f, R.directionalShadowMatrix.length = p, R.pointShadowMatrix.length = d, R.spotShadowMatrix.length = f, I.directionalLength = o, I.pointLength = l, I.spotLength = h, I.rectAreaLength = u, I.hemiLength = c, I.numDirectionalShadows = p, I.numPointShadows = d, I.numSpotShadows = f, R.version = Js++)
                },
                state: R
            }
        }

        function Ks() {
            var e = new $s,
                i = [],
                n = [];
            return {
                init: function() {
                    i.length = 0, n.length = 0
                },
                state: {
                    lightsArray: i,
                    shadowsArray: n,
                    lights: e
                },
                setupLights: function(t) {
                    e.setup(i, n, t)
                },
                pushLight: function(t) {
                    i.push(t)
                },
                pushShadow: function(t) {
                    n.push(t)
                }
            }
        }

        function Qs() {
            var n = new WeakMap;
            return {
                get: function(t, e) {
                    var i;
                    return !1 === n.has(t) ? (i = new Ks, n.set(t, new WeakMap), n.get(t).set(e, i)) : !1 === n.get(t).has(e) ? (i = new Ks, n.get(t).set(e, i)) : i = n.get(t).get(e), i
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }

        function to(t) {
            Xn.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Ke, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
        }

        function eo(t) {
            Xn.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new wi, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
        }((to.prototype = Object.create(Xn.prototype)).constructor = to).prototype.isMeshDepthMaterial = !0, to.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }, ((eo.prototype = Object.create(Xn.prototype)).constructor = eo).prototype.isMeshDistanceMaterial = !0, eo.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
        };
        var io = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
            no = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

        function ro(x, _, w) {
            var S = new aa,
                M = new pi,
                T = new pi,
                C = new yi,
                a = [],
                s = [],
                g = {},
                v = {
                    0: J,
                    1: k,
                    2: Z
                },
                A = new Jr({
                    defines: {
                        SAMPLE_RATE: .25,
                        HALF_SAMPLE_RATE: 1 / 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new pi
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: no,
                    fragmentShader: io
                }),
                E = A.clone();
            E.defines.HORIZONAL_PASS = 1;
            var t = new gr;
            t.setAttribute("position", new $n(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            var D = new Fr(t, A),
                P = this;

            function y(t, e, i) {
                var n = t << 0 | e << 1 | i << 2,
                    r = a[n];
                return void 0 === r && (r = new to({
                    depthPacking: Qe,
                    morphTargets: t,
                    skinning: e
                }), a[n] = r), r
            }

            function b(t, e, i) {
                var n = t << 0 | e << 1 | i << 2,
                    r = s[n];
                return void 0 === r && (r = new eo({
                    morphTargets: t,
                    skinning: e
                }), s[n] = r), r
            }

            function L(t, e, i, n, r, a, s) {
                var o, l, h, u, c, p, d = null,
                    f = y,
                    m = t.customDepthMaterial;
                return !0 === n.isPointLight && (f = b, m = t.customDistanceMaterial), d = void 0 === m ? (!(o = !1) === i.morphTargets && (o = e.morphAttributes && e.morphAttributes.position && 0 < e.morphAttributes.position.length), !(l = !1) === t.isSkinnedMesh && !0 === i.skinning && (l = !0), f(o, l, !0 === t.isInstancedMesh)) : m, x.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (h = d.uuid, u = i.uuid, void 0 === (c = g[h]) && (c = {}, g[h] = c), void 0 === (p = c[u]) && (p = d.clone(), c[u] = p), d = p), d.visible = i.visible, d.wireframe = i.wireframe, d.side = s === B ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : v[i.side], d.clipShadows = i.clipShadows, d.clippingPlanes = i.clippingPlanes, d.clipIntersection = i.clipIntersection, d.wireframeLinewidth = i.wireframeLinewidth, d.linewidth = i.linewidth, !0 === n.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(n.matrixWorld), d.nearDistance = r, d.farDistance = a), d
            }
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = I, this.render = function(t, e, i) {
                if (!1 !== P.enabled && (!1 !== P.autoUpdate || !1 !== P.needsUpdate) && 0 !== t.length) {
                    var n = x.getRenderTarget(),
                        r = x.getActiveCubeFace(),
                        a = x.getActiveMipmapLevel(),
                        s = x.state;
                    s.setBlending($), s.buffers.color.setClear(1, 1, 1, 1), s.buffers.depth.setTest(!0), s.setScissorTest(!1);
                    for (var o, l, h, u = 0, c = t.length; u < c; u++) {
                        var p = t[u],
                            d = p.shadow;
                        if ((!1 !== d.autoUpdate || !1 !== d.needsUpdate) && void 0 !== d) {
                            M.copy(d.mapSize);
                            var f, m, g = d.getFrameExtents();
                            M.multiply(g), T.copy(d.mapSize), (M.x > w || M.y > w) && (M.x > w && (T.x = Math.floor(w / g.x), M.x = T.x * g.x, d.mapSize.x = T.x), M.y > w && (T.y = Math.floor(w / g.y), M.y = T.y * g.y, d.mapSize.y = T.y)), null !== d.map || d.isPointLightShadow || this.type !== B || (f = {
                                minFilter: Gt,
                                magFilter: Gt,
                                format: Zt
                            }, d.map = new bi(M.x, M.y, f), d.map.texture.name = p.name + ".shadowMap", d.mapPass = new bi(M.x, M.y, f), d.camera.updateProjectionMatrix()), null === d.map && (m = {
                                minFilter: Bt,
                                magFilter: Bt,
                                format: Zt
                            }, d.map = new bi(M.x, M.y, m), d.map.texture.name = p.name + ".shadowMap", d.camera.updateProjectionMatrix()), x.setRenderTarget(d.map), x.clear();
                            for (var v = d.getViewportCount(), y = 0; y < v; y++) {
                                var b = d.getViewport(y);
                                C.set(T.x * b.x, T.y * b.y, T.x * b.z, T.y * b.w), s.viewport(C), d.updateMatrices(p, y), S = d.getFrustum(),
                                    function t(e, i, n, r, a) {
                                        if (!1 === e.visible) return;
                                        var s = e.layers.test(i.layers);
                                        if (s && (e.isMesh || e.isLine || e.isPoints) && (e.castShadow || e.receiveShadow && a === B) && (!e.frustumCulled || S.intersectsObject(e))) {
                                            e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld);
                                            var o, l = _.update(e),
                                                h = e.material;
                                            if (Array.isArray(h))
                                                for (var u = l.groups, c = 0, p = u.length; c < p; c++) {
                                                    var d, f = u[c],
                                                        m = h[f.materialIndex];
                                                    m && m.visible && (d = L(e, l, m, r, n.near, n.far, a), x.renderBufferDirect(n, null, l, d, e, f))
                                                } else h.visible && (o = L(e, l, h, r, n.near, n.far, a), x.renderBufferDirect(n, null, l, o, e, null))
                                        }
                                        var g = e.children;
                                        for (var v = 0, y = g.length; v < y; v++) t(g[v], i, n, r, a)
                                    }(e, i, d.camera, p, this.type)
                            }
                            d.isPointLightShadow || this.type !== B || (o = d, l = i, h = _.update(D), A.uniforms.shadow_pass.value = o.map.texture, A.uniforms.resolution.value = o.mapSize, A.uniforms.radius.value = o.radius, x.setRenderTarget(o.mapPass), x.clear(), x.renderBufferDirect(l, null, h, A, D, null), E.uniforms.shadow_pass.value = o.mapPass.texture, E.uniforms.resolution.value = o.mapSize, E.uniforms.radius.value = o.radius, x.setRenderTarget(o.map), x.clear(), x.renderBufferDirect(l, null, h, E, D, null)), d.needsUpdate = !1
                        }
                    }
                    P.needsUpdate = !1, x.setRenderTarget(n, r, a)
                }
            }
        }

        function ao(u, t, e) {
            var i, n, r = e.isWebGL2;
            var a = new function() {
                    var e = !1,
                        a = new yi,
                        i = null,
                        s = new yi(0, 0, 0, 0);
                    return {
                        setMask: function(t) {
                            i === t || e || (u.colorMask(t, t, t, t), i = t)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(t, e, i, n, r) {
                            !0 === r && (t *= n, e *= n, i *= n), a.set(t, e, i, n), !1 === s.equals(a) && (u.clearColor(t, e, i, n), s.copy(a))
                        },
                        reset: function() {
                            e = !1, i = null, s.set(-1, 0, 0, 0)
                        }
                    }
                },
                s = new function() {
                    var e = !1,
                        i = null,
                        n = null,
                        r = null;
                    return {
                        setTest: function(t) {
                            (t ? I : N)(2929)
                        },
                        setMask: function(t) {
                            i === t || e || (u.depthMask(t), i = t)
                        },
                        setFunc: function(t) {
                            if (n !== t) {
                                if (t) switch (t) {
                                    case bt:
                                        u.depthFunc(512);
                                        break;
                                    case xt:
                                        u.depthFunc(519);
                                        break;
                                    case _t:
                                        u.depthFunc(513);
                                        break;
                                    case wt:
                                        u.depthFunc(515);
                                        break;
                                    case St:
                                        u.depthFunc(514);
                                        break;
                                    case Mt:
                                        u.depthFunc(518);
                                        break;
                                    case Tt:
                                        u.depthFunc(516);
                                        break;
                                    case Ct:
                                        u.depthFunc(517);
                                        break;
                                    default:
                                        u.depthFunc(515)
                                } else u.depthFunc(515);
                                n = t
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(t) {
                            r !== t && (u.clearDepth(t), r = t)
                        },
                        reset: function() {
                            e = !1, r = n = i = null
                        }
                    }
                },
                o = new function() {
                    var e = !1,
                        i = null,
                        n = null,
                        r = null,
                        a = null,
                        s = null,
                        o = null,
                        l = null,
                        h = null;
                    return {
                        setTest: function(t) {
                            e || (t ? I : N)(2960)
                        },
                        setMask: function(t) {
                            i === t || e || (u.stencilMask(t), i = t)
                        },
                        setFunc: function(t, e, i) {
                            n === t && r === e && a === i || (u.stencilFunc(t, e, i), n = t, r = e, a = i)
                        },
                        setOp: function(t, e, i) {
                            s === t && o === e && l === i || (u.stencilOp(t, e, i), s = t, o = e, l = i)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(t) {
                            h !== t && (u.clearStencil(t), h = t)
                        },
                        reset: function() {
                            e = !1, h = l = o = s = a = r = n = i = null
                        }
                    }
                },
                l = {},
                h = null,
                c = null,
                p = null,
                d = null,
                f = null,
                m = null,
                g = null,
                v = null,
                y = null,
                b = !1,
                x = null,
                _ = null,
                w = null,
                S = null,
                M = null,
                T = u.getParameter(35661),
                C = !1,
                A = 0,
                E = u.getParameter(7938); - 1 !== E.indexOf("WebGL") ? (A = parseFloat(/^WebGL\ ([0-9])/.exec(E)[1]), C = 1 <= A) : -1 !== E.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(E)[1]), C = 2 <= A);
            var D = null,
                P = {},
                L = new yi,
                k = new yi;

            function O(t, e, i) {
                var n = new Uint8Array(4),
                    r = u.createTexture();
                u.bindTexture(t, r), u.texParameteri(t, 10241, 9728), u.texParameteri(t, 10240, 9728);
                for (var a = 0; a < i; a++) u.texImage2D(e + a, 0, 6408, 1, 1, 0, 6408, 5121, n);
                return r
            }
            var F = {};

            function I(t) {
                !0 !== l[t] && (u.enable(t), l[t] = !0)
            }

            function N(t) {
                !1 !== l[t] && (u.disable(t), l[t] = !1)
            }
            F[3553] = O(3553, 3553, 1), F[34067] = O(34067, 34069, 6), a.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), I(2929), s.setFunc(wt), V(!1), U(X), I(2884), G($);
            var B, R = (W(i = {}, nt, 32774), W(i, rt, 32778), W(i, at, 32779), i);
            r ? (R[st] = 32775, R[ot] = 32776) : null !== (B = t.get("EXT_blend_minmax")) && (R[st] = B.MIN_EXT, R[ot] = B.MAX_EXT);
            var z = (W(n = {}, lt, 0), W(n, ht, 1), W(n, ut, 768), W(n, pt, 770), W(n, yt, 776), W(n, gt, 774), W(n, ft, 772), W(n, ct, 769), W(n, dt, 771), W(n, vt, 775), W(n, mt, 773), n);

            function G(t, e, i, n, r, a, s, o) {
                if (t !== $) {
                    if (c || (I(3042), c = !0), t === it) r = r || e, a = a || i, s = s || n, e === d && r === g || (u.blendEquationSeparate(R[e], R[r]), d = e, g = r), i === f && n === m && a === v && s === y || (u.blendFuncSeparate(z[i], z[n], z[a], z[s]), f = i, m = n, v = a, y = s), p = t, b = null;
                    else if (t !== p || o !== b) {
                        if (d === nt && g === nt || (u.blendEquation(32774), g = d = nt), o) switch (t) {
                            case K:
                                u.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case Q:
                                u.blendFunc(1, 1);
                                break;
                            case tt:
                                u.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case et:
                                u.blendFuncSeparate(0, 768, 0, 770)
                        } else switch (t) {
                            case K:
                                u.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case Q:
                                u.blendFunc(770, 1);
                                break;
                            case tt:
                                u.blendFunc(0, 769);
                                break;
                            case et:
                                u.blendFunc(0, 768)
                        }
                        y = v = m = f = null, p = t, b = o
                    }
                } else c && (N(3042), c = !1)
            }

            function V(t) {
                x !== t && (t ? u.frontFace(2304) : u.frontFace(2305), x = t)
            }

            function U(t) {
                t !== q ? (I(2884), t !== _ && (t === X ? u.cullFace(1029) : t === Y ? u.cullFace(1028) : u.cullFace(1032))) : N(2884), _ = t
            }

            function j(t, e, i) {
                t ? (I(32823), S === e && M === i || (u.polygonOffset(e, i), S = e, M = i)) : N(32823)
            }

            function H(t) {
                void 0 === t && (t = 33984 + T - 1), D !== t && (u.activeTexture(t), D = t)
            }
            return {
                buffers: {
                    color: a,
                    depth: s,
                    stencil: o
                },
                enable: I,
                disable: N,
                useProgram: function(t) {
                    return h !== t && (u.useProgram(t), h = t, !0)
                },
                setBlending: G,
                setMaterial: function(t, e) {
                    (t.side === Z ? N : I)(2884);
                    var i = t.side === J;
                    e && (i = !i), V(i), t.blending === K && !1 === t.transparent ? G($) : G(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), a.setMask(t.colorWrite);
                    var n = t.stencilWrite;
                    o.setTest(n), n && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), j(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                },
                setFlipSided: V,
                setCullFace: U,
                setLineWidth: function(t) {
                    t !== w && (C && u.lineWidth(t), w = t)
                },
                setPolygonOffset: j,
                setScissorTest: function(t) {
                    (t ? I : N)(3089)
                },
                activeTexture: H,
                bindTexture: function(t, e) {
                    null === D && H();
                    var i = P[D];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, P[D] = i), i.type === t && i.texture === e || (u.bindTexture(t, e || F[t]), i.type = t, i.texture = e)
                },
                unbindTexture: function() {
                    var t = P[D];
                    void 0 !== t && void 0 !== t.type && (u.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        u.compressedTexImage2D.apply(u, arguments)
                    } catch (t) {}
                },
                texImage2D: function() {
                    try {
                        u.texImage2D.apply(u, arguments)
                    } catch (t) {}
                },
                texImage3D: function() {
                    try {
                        u.texImage3D.apply(u, arguments)
                    } catch (t) {}
                },
                scissor: function(t) {
                    !1 === L.equals(t) && (u.scissor(t.x, t.y, t.z, t.w), L.copy(t))
                },
                viewport: function(t) {
                    !1 === k.equals(t) && (u.viewport(t.x, t.y, t.z, t.w), k.copy(t))
                },
                reset: function() {
                    l = {}, P = {}, _ = x = p = h = D = null, a.reset(), s.reset(), o.reset()
                }
            }
        }

        function so(_, r, w, S, a, M, p) {
            var t, e, h, T = a.isWebGL2,
                C = (a.maxTextures, a.maxCubemapSize),
                b = a.maxTextureSize,
                i = a.maxSamples,
                s = new WeakMap,
                n = !1;
            try {
                n = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (t) {}

            function u(t, e) {
                return n ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }

            function A(t, e, i, n) {
                var r = 1;
                if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        var a = e ? ci.floorPowerOfTwo : Math.floor,
                            s = a(r * t.width),
                            o = a(r * t.height);
                        void 0 === h && (h = u(s, o));
                        var l = i ? u(s, o) : h;
                        return l.width = s, l.height = o, l.getContext("2d").drawImage(t, 0, 0, s, o), l
                    }
                    return t
                }
                return t
            }

            function E(t) {
                return ci.isPowerOfTwo(t.width) && ci.isPowerOfTwo(t.height)
            }

            function D(t, e) {
                return t.generateMipmaps && e && t.minFilter !== Bt && t.minFilter !== Gt
            }

            function P(t, e, i, n) {
                _.generateMipmap(t), S.get(e).__maxMipLevel = Math.log(Math.max(i, n)) * Math.LOG2E
            }

            function L(t, e, i) {
                if (!1 === T) return e;
                if (null !== t && void 0 !== _[t]) return _[t];
                var n = e;
                return 6403 === e && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === e && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === e && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 !== n && 33326 !== n && 34842 !== n && 34836 !== n || r.get("EXT_color_buffer_float"), n
            }

            function o(t) {
                return t === Bt || t === Rt || t === zt ? 9728 : 9729
            }

            function l(t) {
                var e = t.target;
                e.removeEventListener("dispose", l),
                    function(t) {
                        var e = S.get(t);
                        if (void 0 === e.__webglInit) return;
                        _.deleteTexture(e.__webglTexture), S.remove(t)
                    }(e), e.isVideoTexture && s.delete(e), p.memory.textures--
            }

            function d(t) {
                var e = t.target;
                e.removeEventListener("dispose", d),
                    function(t) {
                        var e = S.get(t),
                            i = S.get(t.texture);
                        if (!t) return;
                        void 0 !== i.__webglTexture && _.deleteTexture(i.__webglTexture);
                        t.depthTexture && t.depthTexture.dispose();
                        if (t.isWebGLCubeRenderTarget)
                            for (var n = 0; n < 6; n++) _.deleteFramebuffer(e.__webglFramebuffer[n]), e.__webglDepthbuffer && _.deleteRenderbuffer(e.__webglDepthbuffer[n]);
                        else _.deleteFramebuffer(e.__webglFramebuffer), e.__webglDepthbuffer && _.deleteRenderbuffer(e.__webglDepthbuffer), e.__webglMultisampledFramebuffer && _.deleteFramebuffer(e.__webglMultisampledFramebuffer), e.__webglColorRenderbuffer && _.deleteRenderbuffer(e.__webglColorRenderbuffer), e.__webglDepthRenderbuffer && _.deleteRenderbuffer(e.__webglDepthRenderbuffer);
                        S.remove(t.texture), S.remove(t)
                    }(e), p.memory.textures--
            }
            var c = 0;

            function f(t, e) {
                var i, n, r = S.get(t);
                if (t.isVideoTexture && (i = t, n = p.render.frame, s.get(i) !== n && (s.set(i, n), i.update())), 0 < t.version && r.__version !== t.version) {
                    var a = t.image;
                    if (void 0 !== a && !1 !== a.complete) return void x(r, t, e)
                }
                w.activeTexture(33984 + e), w.bindTexture(3553, r.__webglTexture)
            }

            function m(t, e) {
                if (6 === t.image.length) {
                    var i = S.get(t);
                    if (0 < t.version && i.__version !== t.version) {
                        O(i, t), w.activeTexture(33984 + e), w.bindTexture(34067, i.__webglTexture), _.pixelStorei(37440, t.flipY);
                        for (var n = t && (t.isCompressedTexture || t.image[0].isCompressedTexture), r = t.image[0] && t.image[0].isDataTexture, a = [], s = 0; s < 6; s++) a[s] = n || r ? r ? t.image[s].image : t.image[s] : A(t.image[s], !1, !0, C);
                        var o, l = a[0],
                            h = E(l) || T,
                            u = M.convert(t.format),
                            c = M.convert(t.type),
                            p = L(t.internalFormat, u, c);
                        if (k(34067, t, h), n) {
                            for (var d = 0; d < 6; d++) {
                                o = a[d].mipmaps;
                                for (var f = 0; f < o.length; f++) {
                                    var m = o[f];
                                    t.format !== Zt && t.format !== Jt ? null !== u && w.compressedTexImage2D(34069 + d, f, p, m.width, m.height, 0, m.data) : w.texImage2D(34069 + d, f, p, m.width, m.height, 0, u, c, m.data)
                                }
                            }
                            i.__maxMipLevel = o.length - 1
                        } else {
                            o = t.mipmaps;
                            for (var g = 0; g < 6; g++)
                                if (r) {
                                    w.texImage2D(34069 + g, 0, p, a[g].width, a[g].height, 0, u, c, a[g].data);
                                    for (var v = 0; v < o.length; v++) {
                                        var y = o[v].image[g].image;
                                        w.texImage2D(34069 + g, v + 1, p, y.width, y.height, 0, u, c, y.data)
                                    }
                                } else {
                                    w.texImage2D(34069 + g, 0, p, u, c, a[g]);
                                    for (var b = 0; b < o.length; b++) {
                                        var x = o[b];
                                        w.texImage2D(34069 + g, b + 1, p, u, c, x.image[g])
                                    }
                                }
                            i.__maxMipLevel = o.length
                        }
                        D(t, h) && P(34067, t, l.width, l.height), i.__version = t.version, t.onUpdate && t.onUpdate(t)
                    } else w.activeTexture(33984 + e), w.bindTexture(34067, i.__webglTexture)
                }
            }

            function g(t, e) {
                w.activeTexture(33984 + e), w.bindTexture(34067, S.get(t).__webglTexture)
            }
            var v = (W(t = {}, Ft, 10497), W(t, It, 33071), W(t, Nt, 33648), t),
                y = (W(e = {}, Bt, 9728), W(e, Rt, 9984), W(e, zt, 9986), W(e, Gt, 9729), W(e, Vt, 9985), W(e, Ut, 9987), e);

            function k(t, e, i) {
                i ? (_.texParameteri(t, 10242, v[e.wrapS]), _.texParameteri(t, 10243, v[e.wrapT]), 32879 !== t && 35866 !== t || _.texParameteri(t, 32882, v[e.wrapR]), _.texParameteri(t, 10240, y[e.magFilter]), _.texParameteri(t, 10241, y[e.minFilter])) : (_.texParameteri(t, 10242, 33071), _.texParameteri(t, 10243, 33071), 32879 !== t && 35866 !== t || _.texParameteri(t, 32882, 33071), e.wrapS !== It || e.wrapT, _.texParameteri(t, 10240, o(e.magFilter)), _.texParameteri(t, 10241, o(e.minFilter)), e.minFilter !== Bt && e.minFilter);
                var n = r.get("EXT_texture_filter_anisotropic");
                if (n) {
                    if (e.type === qt && null === r.get("OES_texture_float_linear")) return;
                    if (e.type === Xt && null === (T || r.get("OES_texture_half_float_linear"))) return;
                    (1 < e.anisotropy || S.get(e).__currentAnisotropy) && (_.texParameterf(t, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, a.getMaxAnisotropy())), S.get(e).__currentAnisotropy = e.anisotropy)
                }
            }

            function O(t, e) {
                void 0 === t.__webglInit && (t.__webglInit = !0, e.addEventListener("dispose", l), t.__webglTexture = _.createTexture(), p.memory.textures++)
            }

            function x(t, e, i) {
                var n = 3553;
                e.isDataTexture2DArray && (n = 35866), e.isDataTexture3D && (n = 32879), O(t, e), w.activeTexture(33984 + i), w.bindTexture(n, t.__webglTexture), _.pixelStorei(37440, e.flipY), _.pixelStorei(37441, e.premultiplyAlpha), _.pixelStorei(3317, e.unpackAlignment);
                var r, a, s = (r = e, !T && (r.wrapS !== It || r.wrapT !== It || r.minFilter !== Bt && r.minFilter !== Gt) && !1 === E(e.image)),
                    o = A(e.image, s, !1, b),
                    l = E(o) || T,
                    h = M.convert(e.format),
                    u = M.convert(e.type),
                    c = L(e.internalFormat, h, u);
                k(n, e, l);
                var p = e.mipmaps;
                if (e.isDepthTexture) c = 6402, T ? c = e.type === qt ? 36012 : e.type === Wt ? 33190 : e.type === Yt ? 35056 : 33189 : e.type, e.format === $t && 6402 === c && e.type !== Ht && e.type !== Wt && (e.type = Ht, u = M.convert(e.type)), e.format === Kt && 6402 === c && (c = 34041, e.type !== Yt && (e.type = Yt, u = M.convert(e.type))), w.texImage2D(3553, 0, c, o.width, o.height, 0, h, u, null);
                else if (e.isDataTexture)
                    if (0 < p.length && l) {
                        for (var d = 0, f = p.length; d < f; d++) a = p[d], w.texImage2D(3553, d, c, a.width, a.height, 0, h, u, a.data);
                        e.generateMipmaps = !1, t.__maxMipLevel = p.length - 1
                    } else w.texImage2D(3553, 0, c, o.width, o.height, 0, h, u, o.data), t.__maxMipLevel = 0;
                else if (e.isCompressedTexture) {
                    for (var m = 0, g = p.length; m < g; m++) a = p[m], e.format !== Zt && e.format !== Jt ? null !== h && w.compressedTexImage2D(3553, m, c, a.width, a.height, 0, a.data) : w.texImage2D(3553, m, c, a.width, a.height, 0, h, u, a.data);
                    t.__maxMipLevel = p.length - 1
                } else if (e.isDataTexture2DArray) w.texImage3D(35866, 0, c, o.width, o.height, o.depth, 0, h, u, o.data), t.__maxMipLevel = 0;
                else if (e.isDataTexture3D) w.texImage3D(32879, 0, c, o.width, o.height, o.depth, 0, h, u, o.data), t.__maxMipLevel = 0;
                else if (0 < p.length && l) {
                    for (var v = 0, y = p.length; v < y; v++) a = p[v], w.texImage2D(3553, v, c, h, u, a);
                    e.generateMipmaps = !1, t.__maxMipLevel = p.length - 1
                } else w.texImage2D(3553, 0, c, h, u, o), t.__maxMipLevel = 0;
                D(e, l) && P(n, e, o.width, o.height), t.__version = e.version, e.onUpdate && e.onUpdate(e)
            }

            function F(t, e, i, n) {
                var r = M.convert(e.texture.format),
                    a = M.convert(e.texture.type),
                    s = L(e.texture.internalFormat, r, a);
                w.texImage2D(n, 0, s, e.width, e.height, 0, r, a, null), _.bindFramebuffer(36160, t), _.framebufferTexture2D(36160, i, n, S.get(e.texture).__webglTexture, 0), _.bindFramebuffer(36160, null)
            }

            function I(t, e, i) {
                var n, r, a, s, o, l, h, u;
                _.bindRenderbuffer(36161, t), e.depthBuffer && !e.stencilBuffer ? (n = 33189, i ? ((r = e.depthTexture) && r.isDepthTexture && (r.type === qt ? n = 36012 : r.type === Wt && (n = 33190)), a = B(e), _.renderbufferStorageMultisample(36161, a, n, e.width, e.height)) : _.renderbufferStorage(36161, n, e.width, e.height), _.framebufferRenderbuffer(36160, 36096, 36161, t)) : e.depthBuffer && e.stencilBuffer ? (i ? (s = B(e), _.renderbufferStorageMultisample(36161, s, 35056, e.width, e.height)) : _.renderbufferStorage(36161, 34041, e.width, e.height), _.framebufferRenderbuffer(36160, 33306, 36161, t)) : (o = M.convert(e.texture.format), l = M.convert(e.texture.type), h = L(e.texture.internalFormat, o, l), i ? (u = B(e), _.renderbufferStorageMultisample(36161, u, h, e.width, e.height)) : _.renderbufferStorage(36161, h, e.width, e.height)), _.bindRenderbuffer(36161, null)
            }

            function N(t) {
                var e = S.get(t),
                    i = !0 === t.isWebGLCubeRenderTarget;
                if (t.depthTexture) {
                    if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function(t, e) {
                        if (e && e.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (_.bindFramebuffer(36160, t), !e.depthTexture || !e.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        S.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), f(e.depthTexture, 0);
                        var i = S.get(e.depthTexture).__webglTexture;
                        if (e.depthTexture.format === $t) _.framebufferTexture2D(36160, 36096, 3553, i, 0);
                        else {
                            if (e.depthTexture.format !== Kt) throw new Error("Unknown depthTexture format");
                            _.framebufferTexture2D(36160, 33306, 3553, i, 0)
                        }
                    }(e.__webglFramebuffer, t)
                } else if (i) {
                    e.__webglDepthbuffer = [];
                    for (var n = 0; n < 6; n++) _.bindFramebuffer(36160, e.__webglFramebuffer[n]), e.__webglDepthbuffer[n] = _.createRenderbuffer(), I(e.__webglDepthbuffer[n], t, !1)
                } else _.bindFramebuffer(36160, e.__webglFramebuffer), e.__webglDepthbuffer = _.createRenderbuffer(), I(e.__webglDepthbuffer, t, !1);
                _.bindFramebuffer(36160, null)
            }

            function B(t) {
                return T && t.isWebGLMultisampleRenderTarget ? Math.min(i, t.samples) : 0
            }
            var R = !1,
                z = !1;
            this.allocateTextureUnit = function() {
                var t = c;
                return c += 1, t
            }, this.resetTextureUnits = function() {
                c = 0
            }, this.setTexture2D = f, this.setTexture2DArray = function(t, e) {
                var i = S.get(t);
                0 < t.version && i.__version !== t.version ? x(i, t, e) : (w.activeTexture(33984 + e), w.bindTexture(35866, i.__webglTexture))
            }, this.setTexture3D = function(t, e) {
                var i = S.get(t);
                0 < t.version && i.__version !== t.version ? x(i, t, e) : (w.activeTexture(33984 + e), w.bindTexture(32879, i.__webglTexture))
            }, this.setTextureCube = m, this.setTextureCubeDynamic = g, this.setupRenderTarget = function(t) {
                var e = S.get(t),
                    i = S.get(t.texture);
                t.addEventListener("dispose", d), i.__webglTexture = _.createTexture(), p.memory.textures++;
                var n, r, a, s, o = !0 === t.isWebGLCubeRenderTarget,
                    l = !0 === t.isWebGLMultisampleRenderTarget,
                    h = E(t) || T;
                if (!T || t.texture.format !== Jt || t.texture.type !== qt && t.texture.type !== Xt || (t.texture.format = Zt), o) {
                    e.__webglFramebuffer = [];
                    for (var u = 0; u < 6; u++) e.__webglFramebuffer[u] = _.createFramebuffer()
                } else {
                    e.__webglFramebuffer = _.createFramebuffer(), l && T && (e.__webglMultisampledFramebuffer = _.createFramebuffer(), e.__webglColorRenderbuffer = _.createRenderbuffer(), _.bindRenderbuffer(36161, e.__webglColorRenderbuffer), n = M.convert(t.texture.format), r = M.convert(t.texture.type), a = L(t.texture.internalFormat, n, r), s = B(t), _.renderbufferStorageMultisample(36161, s, a, t.width, t.height), _.bindFramebuffer(36160, e.__webglMultisampledFramebuffer), _.framebufferRenderbuffer(36160, 36064, 36161, e.__webglColorRenderbuffer), _.bindRenderbuffer(36161, null), t.depthBuffer && (e.__webglDepthRenderbuffer = _.createRenderbuffer(), I(e.__webglDepthRenderbuffer, t, !0)), _.bindFramebuffer(36160, null))
                }
                if (o) {
                    w.bindTexture(34067, i.__webglTexture), k(34067, t.texture, h);
                    for (var c = 0; c < 6; c++) F(e.__webglFramebuffer[c], t, 36064, 34069 + c);
                    D(t.texture, h) && P(34067, t.texture, t.width, t.height), w.bindTexture(34067, null)
                } else w.bindTexture(3553, i.__webglTexture), k(3553, t.texture, h), F(e.__webglFramebuffer, t, 36064, 3553), D(t.texture, h) && P(3553, t.texture, t.width, t.height), w.bindTexture(3553, null);
                t.depthBuffer && N(t)
            }, this.updateRenderTargetMipmap = function(t) {
                var e, i, n = t.texture;
                D(n, E(t) || T) && (e = t.isWebGLCubeRenderTarget ? 34067 : 3553, i = S.get(n).__webglTexture, w.bindTexture(e, i), P(e, n, t.width, t.height), w.bindTexture(e, null))
            }, this.updateMultisampleRenderTarget = function(t) {
                var e, i, n, r;
                t.isWebGLMultisampleRenderTarget && T && (e = S.get(t), _.bindFramebuffer(36008, e.__webglMultisampledFramebuffer), _.bindFramebuffer(36009, e.__webglFramebuffer), i = t.width, n = t.height, r = 16384, t.depthBuffer && (r |= 256), t.stencilBuffer && (r |= 1024), _.blitFramebuffer(0, 0, i, n, 0, 0, i, n, r, 9728), _.bindFramebuffer(36160, e.__webglMultisampledFramebuffer))
            }, this.safeSetTexture2D = function(t, e) {
                t && t.isWebGLRenderTarget && (!1 === R && (R = !0), t = t.texture), f(t, e)
            }, this.safeSetTextureCube = function(t, e) {
                t && t.isWebGLCubeRenderTarget && (!1 === z && (z = !0), t = t.texture), (t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? m : g)(t, e)
            }
        }

        function oo(t, i, e) {
            var n = e.isWebGL2;
            return {
                convert: function(t) {
                    var e;
                    if (t === jt) return 5121;
                    if (t === b) return 32819;
                    if (t === x) return 32820;
                    if (t === _) return 33635;
                    if (t === l) return 5120;
                    if (t === m) return 5122;
                    if (t === Ht) return 5123;
                    if (t === v) return 5124;
                    if (t === Wt) return 5125;
                    if (t === qt) return 5126;
                    if (t === Xt) return n ? 5131 : null !== (e = i.get("OES_texture_half_float")) ? e.HALF_FLOAT_OES : null;
                    if (t === w) return 6406;
                    if (t === Jt) return 6407;
                    if (t === Zt) return 6408;
                    if (t === S) return 6409;
                    if (t === M) return 6410;
                    if (t === $t) return 6402;
                    if (t === Kt) return 34041;
                    if (t === C) return 6403;
                    if (t === A) return 36244;
                    if (t === E) return 33319;
                    if (t === D) return 33320;
                    if (t === P) return 36248;
                    if (t === L) return 36249;
                    if (t === O || t === F || t === Qt || t === te) {
                        if (null === (e = i.get("WEBGL_compressed_texture_s3tc"))) return null;
                        if (t === O) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (t === F) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (t === Qt) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (t === te) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (t === ee || t === ie || t === ne || t === re) {
                        if (null === (e = i.get("WEBGL_compressed_texture_pvrtc"))) return null;
                        if (t === ee) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (t === ie) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (t === ne) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (t === re) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (t === ae) return null !== (e = i.get("WEBGL_compressed_texture_etc1")) ? e.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((t === se || t === oe) && null !== (e = i.get("WEBGL_compressed_texture_etc"))) {
                        if (t === se) return e.COMPRESSED_RGB8_ETC2;
                        if (t === oe) return e.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return t === le || t === he || t === ue || t === ce || t === pe || t === de || t === fe || t === me || t === ge || t === ve || t === ye || t === be || t === xe || t === _e || t === Se || t === Me || t === Te || t === Ce || t === Ae || t === Ee || t === De || t === Pe || t === Le || t === ke || t === Oe || t === Fe || t === Ie || t === Ne ? null !== (e = i.get("WEBGL_compressed_texture_astc")) ? t : null : t === we ? null !== (e = i.get("EXT_texture_compression_bptc")) ? t : null : t === Yt ? n ? 34042 : null !== (e = i.get("WEBGL_depth_texture")) ? e.UNSIGNED_INT_24_8_WEBGL : null : void 0
                }
            }
        }

        function lo(t) {
            $r.call(this), this.cameras = t || []
        }

        function ho() {
            wn.call(this), this.type = "Group"
        }

        function uo() {
            this._targetRay = null, this._grip = null, this._hand = null
        }

        function co(d, r) {
            var e = this,
                f = null,
                a = 1,
                m = null,
                s = "local-floor",
                g = null,
                v = [],
                h = new Map,
                o = new $r;
            o.layers.enable(1), o.viewport = new yi;
            var l = new $r;
            l.layers.enable(2), l.viewport = new yi;
            var y = [o, l],
                b = new lo;
            b.layers.enable(1), b.layers.enable(2);
            var u = null,
                c = null;

            function p(t) {
                var e = h.get(t.inputSource);
                e && e.dispatchEvent({
                    type: t.type
                })
            }

            function x() {
                h.forEach(function(t, e) {
                    t.disconnect(e)
                }), h.clear(), d.setFramebuffer(null), d.setRenderTarget(d.getRenderTarget()), i.stop(), e.isPresenting = !1, e.dispatchEvent({
                    type: "sessionend"
                })
            }

            function _(t) {
                m = t, i.setContext(f), i.start(), e.isPresenting = !0, e.dispatchEvent({
                    type: "sessionstart"
                })
            }

            function w(t) {
                for (var e = f.inputSources, i = 0; i < v.length; i++) h.set(e[i], v[i]);
                for (var n = 0; n < t.removed.length; n++) {
                    var r = t.removed[n],
                        a = h.get(r);
                    a && (a.dispatchEvent({
                        type: "disconnected",
                        data: r
                    }), h.delete(r))
                }
                for (var s = 0; s < t.added.length; s++) {
                    var o = t.added[s],
                        l = h.get(o);
                    l && l.dispatchEvent({
                        type: "connected",
                        data: o
                    })
                }
            }
            this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                var e = v[t];
                return void 0 === e && (e = new uo, v[t] = e), e.getTargetRaySpace()
            }, this.getControllerGrip = function(t) {
                var e = v[t];
                return void 0 === e && (e = new uo, v[t] = e), e.getGripSpace()
            }, this.getHand = function(t) {
                var e = v[t];
                return void 0 === e && (e = new uo, v[t] = e), e.getHandSpace()
            }, this.setFramebufferScaleFactor = function(t) {
                a = t, e.isPresenting
            }, this.setReferenceSpaceType = function(t) {
                s = t, e.isPresenting
            }, this.getReferenceSpace = function() {
                return m
            }, this.getSession = function() {
                return f
            }, this.setSession = function(t) {
                var e, i, n;
                null !== (f = t) && (f.addEventListener("select", p), f.addEventListener("selectstart", p), f.addEventListener("selectend", p), f.addEventListener("squeeze", p), f.addEventListener("squeezestart", p), f.addEventListener("squeezeend", p), f.addEventListener("end", x), !0 !== (e = r.getContextAttributes()).xrCompatible && r.makeXRCompatible(), i = {
                    antialias: e.antialias,
                    alpha: e.alpha,
                    depth: e.depth,
                    stencil: e.stencil,
                    framebufferScaleFactor: a
                }, n = new XRWebGLLayer(f, r, i), f.updateRenderState({
                    baseLayer: n
                }), f.requestReferenceSpace(s).then(_), f.addEventListener("inputsourceschange", w))
            };
            var S = new wi,
                M = new wi;

            function T(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
            }
            this.getCamera = function(t) {
                b.near = l.near = o.near = t.near, b.far = l.far = o.far = t.far, u === b.near && c === b.far || (f.updateRenderState({
                    depthNear: b.near,
                    depthFar: b.far
                }), u = b.near, c = b.far);
                var e = t.parent,
                    i = b.cameras;
                T(b, e);
                for (var n = 0; n < i.length; n++) T(i[n], e);
                t.matrixWorld.copy(b.matrixWorld);
                for (var r = t.children, a = 0, s = r.length; a < s; a++) r[a].updateMatrixWorld(!0);
                return 2 === i.length ? function(t, e, i) {
                    S.setFromMatrixPosition(e.matrixWorld), M.setFromMatrixPosition(i.matrixWorld);
                    var n = S.distanceTo(M),
                        r = e.projectionMatrix.elements,
                        a = i.projectionMatrix.elements,
                        s = r[14] / (r[10] - 1),
                        o = r[14] / (r[10] + 1),
                        l = (r[9] + 1) / r[5],
                        h = (r[9] - 1) / r[5],
                        u = (r[8] - 1) / r[0],
                        c = (a[8] + 1) / a[0],
                        p = s * u,
                        d = s * c,
                        f = n / (c - u),
                        m = f * -u;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                    var g = s + f,
                        v = o + f,
                        y = p - m,
                        b = n - m + d,
                        x = l * o / v * g,
                        _ = h * o / v * g;
                    t.projectionMatrix.makePerspective(y, b, x, _, g, v)
                }(b, o, l) : b.projectionMatrix.copy(o.projectionMatrix), b
            };
            var C = null;
            var i = new sa;
            i.setAnimationLoop(function(t, e) {
                if (null !== (g = e.getViewerPose(m))) {
                    var i = g.views,
                        n = f.renderState.baseLayer;
                    d.setFramebuffer(n.framebuffer);
                    var r = !1;
                    i.length !== b.cameras.length && (r = !(b.cameras.length = 0));
                    for (var a = 0; a < i.length; a++) {
                        var s = i[a],
                            o = n.getViewport(s),
                            l = y[a];
                        l.matrix.fromArray(s.transform.matrix), l.projectionMatrix.fromArray(s.projectionMatrix), l.viewport.set(o.x, o.y, o.width, o.height), 0 === a && b.matrix.copy(l.matrix), !0 === r && b.cameras.push(l)
                    }
                }
                for (var h = f.inputSources, u = 0; u < v.length; u++) {
                    var c = v[u],
                        p = h[u];
                    c.update(p, e, m)
                }
                C && C(t, e)
            }), this.setAnimationLoop = function(t) {
                C = t
            }, this.dispose = function() {}
        }

        function po(s) {
            function p(t, e) {
                t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap);
                var i, n, r, a = s.get(e).envMap;
                a && (t.envMap.value = a, t.flipEnvMap.value = a.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, void 0 !== (i = s.get(a).__maxMipLevel) && (t.maxMipLevel.value = i)), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap ? n = e.emissiveMap : e.clearcoatMap ? n = e.clearcoatMap : e.clearcoatNormalMap ? n = e.clearcoatNormalMap : e.clearcoatRoughnessMap && (n = e.clearcoatRoughnessMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)), e.aoMap ? r = e.aoMap : e.lightMap && (r = e.lightMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uv2Transform.value.copy(r.matrix))
            }

            function d(t, e) {
                t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === J && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === J && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), s.get(e).envMap && (t.envMapIntensity.value = e.envMapIntensity)
            }
            return {
                refreshFogUniforms: function(t, e) {
                    t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                },
                refreshMaterialUniforms: function(t, e, i, n) {
                    var r, a, s, o, l, h, u, c;
                    e.isMeshBasicMaterial ? p(t, e) : e.isMeshLambertMaterial ? (p(t, e), u = t, (c = e).emissiveMap && (u.emissiveMap.value = c.emissiveMap)) : e.isMeshToonMaterial ? (p(t, e), function(t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap);
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === J && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === J && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, e)) : e.isMeshPhongMaterial ? (p(t, e), function(t, e) {
                        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === J && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === J && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, e)) : e.isMeshStandardMaterial ? (p(t, e), (e.isMeshPhysicalMaterial ? function(t, e) {
                        d(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                        e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                        e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === J && t.clearcoatNormalScale.value.negate());
                        t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                    } : d)(t, e)) : e.isMeshMatcapMaterial ? (p(t, e), function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === J && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === J && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, e)) : e.isMeshDepthMaterial ? (p(t, e), l = t, (h = e).displacementMap && (l.displacementMap.value = h.displacementMap, l.displacementScale.value = h.displacementScale, l.displacementBias.value = h.displacementBias)) : e.isMeshDistanceMaterial ? (p(t, e), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(t, e)) : e.isMeshNormalMaterial ? (p(t, e), function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === J && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === J && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, e)) : e.isLineBasicMaterial ? (o = e, (s = t).diffuse.value.copy(o.color), s.opacity.value = o.opacity, e.isLineDashedMaterial && (a = e, (r = t).dashSize.value = a.dashSize, r.totalSize.value = a.dashSize + a.gapSize, r.scale.value = a.scale)) : e.isPointsMaterial ? function(t, e, i, n) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = .5 * n, e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        var r;
                        e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                        void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                    }(t, e, i, n) : e.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        var i;
                        e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
                        void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
                    }(t, e) : e.isShadowMaterial ? (t.color.value.copy(e.color), t.opacity.value = e.opacity) : e.isShaderMaterial && (e.uniformsNeedUpdate = !1)
                }
            }
        }

        function fo(t) {
            var a = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                e = void 0 !== t.context ? t.context : null,
                i = void 0 !== t.alpha && t.alpha,
                n = void 0 === t.depth || t.depth,
                r = void 0 === t.stencil || t.stencil,
                s = void 0 !== t.antialias && t.antialias,
                o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                h = void 0 !== t.powerPreference ? t.powerPreference : "default",
                u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat,
                y = null,
                T = null;
            this.domElement = a, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = He, this.physicallyCorrectLights = !1, this.toneMapping = At, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var C = this,
                c = !1,
                p = null,
                d = 0,
                f = 0,
                A = null,
                m = null,
                E = -1,
                D = null,
                g = null,
                v = new yi,
                b = new yi,
                x = null,
                _ = a.width,
                P = a.height,
                L = 1,
                w = null,
                S = null,
                M = new yi(0, 0, _, P),
                k = new yi(0, 0, _, P),
                O = !1,
                F = new aa,
                I = !1,
                N = !1,
                B = new Zi,
                R = new wi,
                z = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };

            function G() {
                return null === A ? L : 1
            }
            var V, U, j, H, W, q, X, Y, J, Z, $, K, Q, tt, et, it, nt, rt, at, st, ot, lt = e;

            function ht(t, e) {
                for (var i = 0; i < t.length; i++) {
                    var n = t[i],
                        r = a.getContext(n, e);
                    if (null !== r) return r
                }
                return null
            }
            try {
                var ut = {
                    alpha: i,
                    depth: n,
                    stencil: r,
                    antialias: s,
                    premultipliedAlpha: o,
                    preserveDrawingBuffer: l,
                    powerPreference: h,
                    failIfMajorPerformanceCaveat: u
                };
                if (a.addEventListener("webglcontextlost", mt, !1), a.addEventListener("webglcontextrestored", gt, !1), null === lt) {
                    var ct = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === C.isWebGL1Renderer && ct.shift(), null === (lt = ht(ct, ut))) throw ht(ct) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === lt.getShaderPrecisionFormat && (lt.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (t) {
                throw t
            }

            function pt() {
                V = new ba(lt), !1 === (U = new ga(lt, V, t)).isWebGL2 && (V.get("WEBGL_depth_texture"), V.get("OES_texture_float"), V.get("OES_texture_half_float"), V.get("OES_texture_half_float_linear"), V.get("OES_standard_derivatives"), V.get("OES_element_index_uint"), V.get("OES_vertex_array_object"), V.get("ANGLE_instanced_arrays")), V.get("OES_texture_float_linear"), st = new oo(0, V, U), (j = new ao(lt, V, U)).scissor(b.copy(k).multiplyScalar(L).floor()), j.viewport(v.copy(M).multiplyScalar(L).floor()), H = new wa, W = new js, q = new so(lt, V, j, W, U, st, H), X = new ya(C), Y = new oa(lt, U), ot = new fa(lt, V, Y, U), J = new xa(0, Y, H, ot), Z = new Ca(0, J, Y, H), nt = new Ta(lt), et = new va(W), $ = new Us(C, X, V, U, ot, et), K = new po(W), Q = new Xs(W), tt = new Qs, it = new da(C, X, j, Z, o), rt = new ma(lt, V, H, U), at = new _a(lt, V, H, U), H.programs = $.programs, C.capabilities = U, C.extensions = V, C.properties = W, C.renderLists = Q, C.state = j, C.info = H
            }
            pt();
            var dt = new co(C, lt);
            this.xr = dt;
            var ft = new ro(C, Z, U.maxTextureSize);

            function mt(t) {
                t.preventDefault(), c = !0
            }

            function gt() {
                c = !1, pt()
            }

            function vt(t) {
                var e, i = t.target;
                i.removeEventListener("dispose", vt), yt(e = i), W.remove(e)
            }

            function yt(t) {
                var e = W.get(t).program;
                void 0 !== e && $.releaseProgram(e)
            }
            this.shadowMap = ft, this.getContext = function() {
                return lt
            }, this.getContextAttributes = function() {
                return lt.getContextAttributes()
            }, this.forceContextLoss = function() {
                var t = V.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function() {
                var t = V.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function() {
                return L
            }, this.setPixelRatio = function(t) {
                void 0 !== t && (L = t, this.setSize(_, P, !1))
            }, this.getSize = function(t) {
                return void 0 === t && (t = new pi), t.set(_, P)
            }, this.setSize = function(t, e, i) {
                dt.isPresenting || (_ = t, P = e, a.width = Math.floor(t * L), a.height = Math.floor(e * L), !1 !== i && (a.style.width = t + "px", a.style.height = e + "px"), this.setViewport(0, 0, t, e))
            }, this.getDrawingBufferSize = function(t) {
                return void 0 === t && (t = new pi), t.set(_ * L, P * L).floor()
            }, this.setDrawingBufferSize = function(t, e, i) {
                _ = t, P = e, L = i, a.width = Math.floor(t * i), a.height = Math.floor(e * i), this.setViewport(0, 0, t, e)
            }, this.getCurrentViewport = function(t) {
                return void 0 === t && (t = new yi), t.copy(v)
            }, this.getViewport = function(t) {
                return t.copy(M)
            }, this.setViewport = function(t, e, i, n) {
                t.isVector4 ? M.set(t.x, t.y, t.z, t.w) : M.set(t, e, i, n), j.viewport(v.copy(M).multiplyScalar(L).floor())
            }, this.getScissor = function(t) {
                return t.copy(k)
            }, this.setScissor = function(t, e, i, n) {
                t.isVector4 ? k.set(t.x, t.y, t.z, t.w) : k.set(t, e, i, n), j.scissor(b.copy(k).multiplyScalar(L).floor())
            }, this.getScissorTest = function() {
                return O
            }, this.setScissorTest = function(t) {
                j.setScissorTest(O = t)
            }, this.setOpaqueSort = function(t) {
                w = t
            }, this.setTransparentSort = function(t) {
                S = t
            }, this.getClearColor = function() {
                return it.getClearColor()
            }, this.setClearColor = function() {
                it.setClearColor.apply(it, arguments)
            }, this.getClearAlpha = function() {
                return it.getClearAlpha()
            }, this.setClearAlpha = function() {
                it.setClearAlpha.apply(it, arguments)
            }, this.clear = function(t, e, i) {
                var n = 0;
                void 0 !== t && !t || (n |= 16384), void 0 !== e && !e || (n |= 256), void 0 !== i && !i || (n |= 1024), lt.clear(n)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                a.removeEventListener("webglcontextlost", mt, !1), a.removeEventListener("webglcontextrestored", gt, !1), Q.dispose(), tt.dispose(), W.dispose(), X.dispose(), Z.dispose(), ot.dispose(), dt.dispose(), xt.stop()
            }, this.renderBufferImmediate = function(t, e) {
                ot.initAttributes();
                var i = W.get(t);
                t.hasPositions && !i.position && (i.position = lt.createBuffer()), t.hasNormals && !i.normal && (i.normal = lt.createBuffer()), t.hasUvs && !i.uv && (i.uv = lt.createBuffer()), t.hasColors && !i.color && (i.color = lt.createBuffer());
                var n = e.getAttributes();
                t.hasPositions && (lt.bindBuffer(34962, i.position), lt.bufferData(34962, t.positionArray, 35048), ot.enableAttribute(n.position), lt.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (lt.bindBuffer(34962, i.normal), lt.bufferData(34962, t.normalArray, 35048), ot.enableAttribute(n.normal), lt.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (lt.bindBuffer(34962, i.uv), lt.bufferData(34962, t.uvArray, 35048), ot.enableAttribute(n.uv), lt.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), t.hasColors && (lt.bindBuffer(34962, i.color), lt.bufferData(34962, t.colorArray, 35048), ot.enableAttribute(n.color), lt.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), ot.disableUnusedAttributes(), lt.drawArrays(4, 0, t.count), t.count = 0
            }, this.renderBufferDirect = function(t, e, i, n, r, a) {
                null === e && (e = z);
                var s = r.isMesh && r.matrixWorld.determinant() < 0,
                    o = Mt(t, e, n, r);
                j.setMaterial(n, s);
                var l = i.index,
                    h = i.attributes.position;
                if (null === l) {
                    if (void 0 === h || 0 === h.count) return
                } else if (0 === l.count) return;
                var u, c = 1;
                !0 === n.wireframe && (l = J.getWireframeAttribute(i), c = 2), (n.morphTargets || n.morphNormals) && nt.update(r, i, n, o), ot.setup(r, n, o, i, l);
                var p = rt;
                null !== l && (u = Y.get(l), (p = at).setIndex(u));
                var d, f, m = null !== l ? l.count : h.count,
                    g = i.drawRange.start * c,
                    v = i.drawRange.count * c,
                    y = null !== a ? a.start * c : 0,
                    b = null !== a ? a.count * c : 1 / 0,
                    x = Math.max(g, y),
                    _ = Math.min(m, g + v, y + b) - 1,
                    w = Math.max(0, _ - x + 1);
                0 !== w && (r.isMesh ? !0 === n.wireframe ? (j.setLineWidth(n.wireframeLinewidth * G()), p.setMode(1)) : p.setMode(4) : r.isLine ? (void 0 === (d = n.linewidth) && (d = 1), j.setLineWidth(d * G()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)) : r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4), r.isInstancedMesh ? p.renderInstances(x, w, r.count) : i.isInstancedBufferGeometry ? (f = Math.min(i.instanceCount, i._maxInstanceCount), p.renderInstances(x, w, f)) : p.render(x, w))
            }, this.compile = function(r, t) {
                (T = tt.get(r, t)).init(), r.traverse(function(t) {
                    t.isLight && (T.pushLight(t), t.castShadow && T.pushShadow(t))
                }), T.setupLights(t);
                var a = new WeakMap;
                r.traverse(function(t) {
                    var e = t.material;
                    if (e)
                        if (Array.isArray(e))
                            for (var i = 0; i < e.length; i++) {
                                var n = e[i];
                                !1 === a.has(n) && (St(n, r, t), a.set(n))
                            } else !1 === a.has(e) && (St(e, r, t), a.set(e))
                })
            };
            var bt = null;
            var xt = new sa;

            function _t(t, e, i) {
                for (var n = !0 === e.isScene ? e.overrideMaterial : null, r = 0, a = t.length; r < a; r++) {
                    var s = t[r],
                        o = s.object,
                        l = s.geometry,
                        h = null === n ? s.material : n,
                        u = s.group;
                    if (i.isArrayCamera)
                        for (var c = (g = i).cameras, p = 0, d = c.length; p < d; p++) {
                            var f = c[p];
                            o.layers.test(f.layers) && (j.viewport(v.copy(f.viewport)), T.setupLights(f), wt(o, e, f, l, h, u))
                        } else g = null, wt(o, e, i, l, h, u)
                }
            }

            function wt(t, e, i, n, r, a) {
                var s, o;
                t.onBeforeRender(C, e, i, n, r, a), T = tt.get(e, g || i), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject ? (s = Mt(i, e, r, t), j.setMaterial(r), ot.reset(), o = s, t.render(function(t) {
                    C.renderBufferImmediate(t, o)
                })) : C.renderBufferDirect(i, e, n, r, t, a), t.onAfterRender(C, e, i, n, r, a), T = tt.get(e, g || i)
            }

            function St(t, e, i) {
                !0 !== e.isScene && (e = z);
                var n = W.get(t),
                    r = T.state.lights,
                    a = T.state.shadowsArray,
                    s = r.state.version,
                    o = $.getParameters(t, r.state, a, e, i),
                    l = $.getProgramCacheKey(o),
                    h = n.program,
                    u = !0;
                if (void 0 === h) t.addEventListener("dispose", vt);
                else if (h.cacheKey !== l) yt(t);
                else if (n.lightsStateVersion !== s) u = !1;
                else {
                    if (void 0 !== o.shaderID) {
                        var c = t.isMeshStandardMaterial ? e.environment : null;
                        return void(n.envMap = X.get(t.envMap || c))
                    }
                    u = !1
                }
                u && (o.uniforms = $.getUniforms(t), t.onBeforeCompile(o, C), h = $.acquireProgram(o, l), n.program = h, n.uniforms = o.uniforms, n.outputEncoding = o.outputEncoding);
                var p, d = n.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = et.numPlanes, n.numIntersection = et.numIntersection, d.clippingPlanes = et.uniform), n.environment = t.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = X.get(t.envMap || n.environment), n.needsLights = (p = t).isMeshLambertMaterial || p.isMeshToonMaterial || p.isMeshPhongMaterial || p.isMeshStandardMaterial || p.isShadowMaterial || p.isShaderMaterial && !0 === p.lights, n.lightsStateVersion = s, n.needsLights && (d.ambientLightColor.value = r.state.ambient, d.lightProbe.value = r.state.probe, d.directionalLights.value = r.state.directional, d.directionalLightShadows.value = r.state.directionalShadow, d.spotLights.value = r.state.spot, d.spotLightShadows.value = r.state.spotShadow, d.rectAreaLights.value = r.state.rectArea, d.ltc_1.value = r.state.rectAreaLTC1, d.ltc_2.value = r.state.rectAreaLTC2, d.pointLights.value = r.state.point, d.pointLightShadows.value = r.state.pointShadow, d.hemisphereLights.value = r.state.hemi, d.directionalShadowMap.value = r.state.directionalShadowMap, d.directionalShadowMatrix.value = r.state.directionalShadowMatrix, d.spotShadowMap.value = r.state.spotShadowMap, d.spotShadowMatrix.value = r.state.spotShadowMatrix, d.pointShadowMap.value = r.state.pointShadowMap, d.pointShadowMatrix.value = r.state.pointShadowMatrix);
                var f = n.program.getUniforms(),
                    m = Ss.seqWithValue(f.seq, d);
                n.uniformsList = m
            }

            function Mt(t, e, i, n) {
                !0 !== e.isScene && (e = z), q.resetTextureUnits();
                var r, a = e.fog,
                    s = i.isMeshStandardMaterial ? e.environment : null,
                    o = null === A ? C.outputEncoding : A.texture.encoding,
                    l = X.get(i.envMap || s),
                    h = W.get(i),
                    u = T.state.lights;
                !0 === I && (!0 !== N && t === D || (r = t === D && i.id === E, et.setState(i, t, r))), i.version === h.__version ? (i.fog && h.fog !== a || h.environment !== s || h.needsLights && h.lightsStateVersion !== u.state.version || void 0 !== h.numClippingPlanes && (h.numClippingPlanes !== et.numPlanes || h.numIntersection !== et.numIntersection) || h.outputEncoding !== o || h.envMap !== l) && St(i, e, n) : (St(i, e, n), h.__version = i.version);
                var c, p, d, f, m, g, v, y, b = !1,
                    x = !1,
                    _ = !1,
                    w = h.program,
                    S = w.getUniforms(),
                    M = h.uniforms;
                return j.useProgram(w.program) && (_ = x = b = !0), i.id !== E && (E = i.id, x = !0), !b && D === t || (S.setValue(lt, "projectionMatrix", t.projectionMatrix), U.logarithmicDepthBuffer && S.setValue(lt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), D !== t && (D = t, _ = x = !0), !(i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) || void 0 !== (c = S.map.cameraPosition) && c.setValue(lt, R.setFromMatrixPosition(t.matrixWorld)), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && S.setValue(lt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || i.skinning) && S.setValue(lt, "viewMatrix", t.matrixWorldInverse)), i.skinning && (S.setOptional(lt, n, "bindMatrix"), S.setOptional(lt, n, "bindMatrixInverse"), (p = n.skeleton) && (d = p.bones, U.floatVertexTextures ? (void 0 === p.boneTexture && (f = Math.sqrt(4 * d.length), f = ci.ceilPowerOfTwo(f), f = Math.max(f, 4), (m = new Float32Array(f * f * 4)).set(p.boneMatrices), g = new ia(m, f, f, Zt, qt), p.boneMatrices = m, p.boneTexture = g, p.boneTextureSize = f), S.setValue(lt, "boneTexture", p.boneTexture, q), S.setValue(lt, "boneTextureSize", p.boneTextureSize)) : S.setOptional(lt, p, "boneMatrices"))), !x && h.receiveShadow === n.receiveShadow || (h.receiveShadow = n.receiveShadow, S.setValue(lt, "receiveShadow", n.receiveShadow)), x && (S.setValue(lt, "toneMappingExposure", C.toneMappingExposure), h.needsLights && (y = _, (v = M).ambientLightColor.needsUpdate = y, v.lightProbe.needsUpdate = y, v.directionalLights.needsUpdate = y, v.directionalLightShadows.needsUpdate = y, v.pointLights.needsUpdate = y, v.pointLightShadows.needsUpdate = y, v.spotLights.needsUpdate = y, v.spotLightShadows.needsUpdate = y, v.rectAreaLights.needsUpdate = y, v.hemisphereLights.needsUpdate = y), a && i.fog && K.refreshFogUniforms(M, a), K.refreshMaterialUniforms(M, i, L, P), Ss.upload(lt, h.uniformsList, M, q)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Ss.upload(lt, h.uniformsList, M, q), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && S.setValue(lt, "center", n.center), S.setValue(lt, "modelViewMatrix", n.modelViewMatrix), S.setValue(lt, "normalMatrix", n.normalMatrix), S.setValue(lt, "modelMatrix", n.matrixWorld), w
            }
            xt.setAnimationLoop(function(t) {
                dt.isPresenting || bt && bt(t)
            }), "undefined" != typeof window && xt.setContext(window), this.setAnimationLoop = function(t) {
                bt = t, dt.setAnimationLoop(t), null === t ? xt.stop() : xt.start()
            }, this.render = function(t, e) {
                var i, n, r, a, s;
                void 0 !== arguments[2] && (i = arguments[2]), void 0 !== arguments[3] && (n = arguments[3]), void 0 !== e && !0 !== e.isCamera || !0 !== c && (ot.resetDefaultState(), E = -1, !(D = null) === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === dt.enabled && !0 === dt.isPresenting && (e = dt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(C, t, e, i || A), (T = tt.get(t, e)).init(), B.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), F.setFromProjectionMatrix(B), N = this.localClippingEnabled, I = et.init(this.clippingPlanes, N, e), (y = Q.get(t, e)).init(), function t(e, i, n, r) {
                    if (!1 === e.visible) return;
                    var a = e.layers.test(i.layers);
                    if (a)
                        if (e.isGroup) n = e.renderOrder;
                        else if (e.isLOD) !0 === e.autoUpdate && e.update(i);
                    else if (e.isLight) T.pushLight(e), e.castShadow && T.pushShadow(e);
                    else if (e.isSprite) {
                        var s, o;
                        e.frustumCulled && !F.intersectsSprite(e) || (r && R.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B), s = Z.update(e), (o = e.material).visible && y.push(e, s, o, n, R.z, null))
                    } else if (e.isImmediateRenderObject) r && R.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B), y.push(e, null, e.material, n, R.z, null);
                    else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== H.render.frame && (e.skeleton.update(), e.skeleton.frame = H.render.frame), !e.frustumCulled || F.intersectsObject(e))) {
                        r && R.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B);
                        var l = Z.update(e),
                            h = e.material;
                        if (Array.isArray(h))
                            for (var u = l.groups, c = 0, p = u.length; c < p; c++) {
                                var d = u[c],
                                    f = h[d.materialIndex];
                                f && f.visible && y.push(e, l, f, n, R.z, d)
                            } else h.visible && y.push(e, l, h, n, R.z, null)
                    }
                    var m = e.children;
                    for (var g = 0, v = m.length; g < v; g++) t(m[g], i, n, r)
                }(t, e, 0, C.sortObjects), y.finish(), !0 === C.sortObjects && y.sort(w, S), !0 === I && et.beginShadows(), r = T.state.shadowsArray, ft.render(r, t, e), T.setupLights(e), !0 === I && et.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i), it.render(y, t, e, n), a = y.opaque, s = y.transparent, 0 < a.length && _t(a, t, e), 0 < s.length && _t(s, t, e), !0 === t.isScene && t.onAfterRender(C, t, e), null !== A && (q.updateRenderTargetMipmap(A), q.updateMultisampleRenderTarget(A)), j.buffers.depth.setTest(!0), j.buffers.depth.setMask(!0), j.buffers.color.setMask(!0), j.setPolygonOffset(!1), T = y = null)
            }, this.setFramebuffer = function(t) {
                p !== t && null === A && lt.bindFramebuffer(36160, t), p = t
            }, this.getActiveCubeFace = function() {
                return d
            }, this.getActiveMipmapLevel = function() {
                return f
            }, this.getRenderList = function() {
                return y
            }, this.setRenderList = function(t) {
                y = t
            }, this.getRenderState = function() {
                return T
            }, this.setRenderState = function(t) {
                T = t
            }, this.getRenderTarget = function() {
                return A
            }, this.setRenderTarget = function(t) {
                var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                    i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                d = e, f = i, (A = t) && void 0 === W.get(t).__webglFramebuffer && q.setupRenderTarget(t);
                var n, r, a = p,
                    s = !1;
                x = t ? (n = W.get(t).__webglFramebuffer, t.isWebGLCubeRenderTarget ? (a = n[e], s = !0) : a = t.isWebGLMultisampleRenderTarget ? W.get(t).__webglMultisampledFramebuffer : n, v.copy(t.viewport), b.copy(t.scissor), t.scissorTest) : (v.copy(M).multiplyScalar(L).floor(), b.copy(k).multiplyScalar(L).floor(), O), m !== a && (lt.bindFramebuffer(36160, a), m = a), j.viewport(v), j.scissor(b), j.setScissorTest(x), s && (r = W.get(t.texture), lt.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, i))
            }, this.readRenderTargetPixels = function(t, e, i, n, r, a, s) {
                if (t && t.isWebGLRenderTarget) {
                    var o = W.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) {
                        var l = !1;
                        o !== m && (lt.bindFramebuffer(36160, o), l = !0);
                        try {
                            var h = t.texture,
                                u = h.format,
                                c = h.type;
                            if (u !== Zt && st.convert(u) !== lt.getParameter(35739)) return;
                            if (!(c === jt || st.convert(c) === lt.getParameter(35738) || c === qt && (U.isWebGL2 || V.get("OES_texture_float") || V.get("WEBGL_color_buffer_float")) || c === Xt && (U.isWebGL2 ? V.get("EXT_color_buffer_float") : V.get("EXT_color_buffer_half_float")))) return;
                            36053 === lt.checkFramebufferStatus(36160) && 0 <= e && e <= t.width - n && 0 <= i && i <= t.height - r && lt.readPixels(e, i, n, r, st.convert(u), st.convert(c), a)
                        } finally {
                            l && lt.bindFramebuffer(36160, m)
                        }
                    }
                }
            }, this.copyFramebufferToTexture = function(t, e, i) {
                void 0 === i && (i = 0);
                var n = Math.pow(2, -i),
                    r = Math.floor(e.image.width * n),
                    a = Math.floor(e.image.height * n),
                    s = st.convert(e.format);
                q.setTexture2D(e, 0), lt.copyTexImage2D(3553, i, s, t.x, t.y, r, a, 0), j.unbindTexture()
            }, this.copyTextureToTexture = function(t, e, i, n) {
                void 0 === n && (n = 0);
                var r = e.image.width,
                    a = e.image.height,
                    s = st.convert(i.format),
                    o = st.convert(i.type);
                q.setTexture2D(i, 0), lt.pixelStorei(37440, i.flipY), lt.pixelStorei(37441, i.premultiplyAlpha), lt.pixelStorei(3317, i.unpackAlignment), e.isDataTexture ? lt.texSubImage2D(3553, n, t.x, t.y, r, a, s, o, e.image.data) : e.isCompressedTexture ? lt.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : lt.texSubImage2D(3553, n, t.x, t.y, s, o, e.image), 0 === n && i.generateMipmaps && lt.generateMipmap(3553), j.unbindTexture()
            }, this.initTexture = function(t) {
                q.setTexture2D(t, 0), j.unbindTexture()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }

        function mo(t) {
            fo.call(this, t)
        }
        lo.prototype = Object.assign(Object.create($r.prototype), {
            constructor: lo,
            isArrayCamera: !0
        }), ho.prototype = Object.assign(Object.create(wn.prototype), {
            constructor: ho,
            isGroup: !0
        }), Object.assign(uo.prototype, {
            constructor: uo,
            getHandSpace: function() {
                if (null === this._hand && (this._hand = new ho, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = {
                        pinching: !1
                    }, window.XRHand))
                    for (var t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
                        var e = new ho;
                        e.matrixAutoUpdate = !1, e.visible = !1, this._hand.joints.push(e), this._hand.add(e)
                    }
                return this._hand
            },
            getTargetRaySpace: function() {
                return null === this._targetRay && (this._targetRay = new ho, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
            },
            getGripSpace: function() {
                return null === this._grip && (this._grip = new ho, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
            },
            dispatchEvent: function(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
            },
            disconnect: function(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            },
            update: function(t, e, i) {
                var n = null,
                    r = null,
                    a = null,
                    s = this._targetRay,
                    o = this._grip,
                    l = this._hand;
                if (t)
                    if (l && t.hand) {
                        a = !0;
                        for (var h, u, c, p, d, f = 0; f <= window.XRHand.LITTLE_PHALANX_TIP; f++) {
                            t.hand[f] && (h = e.getJointPose(t.hand[f], i), u = l.joints[f], null !== h && (u.matrix.fromArray(h.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.jointRadius = h.radius), u.visible = null !== h, c = l.joints[window.XRHand.INDEX_PHALANX_TIP], p = l.joints[window.XRHand.THUMB_PHALANX_TIP], d = c.position.distanceTo(p.position), l.inputState.pinching && .025 < d ? (l.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: t.handedness,
                                target: this
                            })) : !l.inputState.pinching && d <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: t.handedness,
                                target: this
                            })))
                        }
                    } else null !== s && null !== (n = e.getPose(t.targetRaySpace, i)) && (s.matrix.fromArray(n.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)), null !== o && t.gripSpace && null !== (r = e.getPose(t.gripSpace, i)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale));
                return null !== s && (s.visible = null !== n), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== a), this
            }
        }), Object.assign(co.prototype, oi.prototype), mo.prototype = Object.assign(Object.create(fo.prototype), {
            constructor: mo,
            isWebGL1Renderer: !0
        });
        var go = function() {
            function i(t, e) {
                V(this, i), Object.defineProperty(this, "isFogExp2", {
                    value: !0
                }), this.name = "", this.color = new Hn(t), this.density = void 0 !== e ? e : 25e-5
            }
            return g(i, [{
                key: "clone",
                value: function() {
                    return new i(this.color, this.density)
                }
            }, {
                key: "toJSON",
                value: function() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }]), i
        }();
        i.FogExp2 = go;
        var vo = function() {
            function n(t, e, i) {
                V(this, n), Object.defineProperty(this, "isFog", {
                    value: !0
                }), this.name = "", this.color = new Hn(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
            }
            return g(n, [{
                key: "clone",
                value: function() {
                    return new n(this.color, this.near, this.far)
                }
            }, {
                key: "toJSON",
                value: function() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }]), n
        }();
        i.Fog = vo;
        var yo = function() {
            d(i, wn);
            var e = y(i);

            function i() {
                var t;
                return V(this, i), t = e.call(this), Object.defineProperty(u(t), "isScene", {
                    value: !0
                }), t.type = "Scene", t.background = null, t.environment = null, t.fog = null, t.overrideMaterial = null, t.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: u(t)
                })), t
            }
            return g(i, [{
                key: "copy",
                value: function(t, e) {
                    return h(f(i.prototype), "copy", this).call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                }
            }, {
                key: "toJSON",
                value: function(t) {
                    var e = h(f(i.prototype), "toJSON", this).call(this, t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                }
            }]), i
        }();

        function bo(t, e) {
            this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = ri, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0, this.uuid = ci.generateUUID()
        }
        i.Scene = yo, Object.defineProperty(bo.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(bo.prototype, {
            isInterleavedBuffer: !0,
            onUploadCallback: function() {},
            setUsage: function(t) {
                return this.usage = t, this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
            },
            copyAt: function(t, e, i) {
                t *= this.stride, i *= e.stride;
                for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            clone: function(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ci.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                var e = new bo(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride);
                return e.setUsage(this.usage), e
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            },
            toJSON: function(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ci.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        });
        var xo, _o = new wi;

        function wo(t, e, i, n) {
            this.name = "", this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
        }

        function So(t) {
            Xn.call(this), this.type = "SpriteMaterial", this.color = new Hn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
        }
        Object.defineProperties(wo.prototype, {
            count: {
                get: function() {
                    return this.data.count
                }
            },
            array: {
                get: function() {
                    return this.data.array
                }
            },
            needsUpdate: {
                set: function(t) {
                    this.data.needsUpdate = t
                }
            }
        }), Object.assign(wo.prototype, {
            isInterleavedBufferAttribute: !0,
            applyMatrix4: function(t) {
                for (var e = 0, i = this.data.count; e < i; e++) _o.x = this.getX(e), _o.y = this.getY(e), _o.z = this.getZ(e), _o.applyMatrix4(t), this.setXYZ(e, _o.x, _o.y, _o.z);
                return this
            },
            setX: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            },
            setY: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            },
            setZ: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            },
            setW: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            },
            getX: function(t) {
                return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function(t, e, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
            },
            clone: function(t) {
                if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new wo(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
                for (var e = [], i = 0; i < this.count; i++)
                    for (var n = i * this.data.stride + this.offset, r = 0; r < this.itemSize; r++) e.push(this.data.array[n + r]);
                return new $n(new this.array.constructor(e), this.itemSize, this.normalized)
            },
            toJSON: function(t) {
                if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                };
                for (var e = [], i = 0; i < this.count; i++)
                    for (var n = i * this.data.stride + this.offset, r = 0; r < this.itemSize; r++) e.push(this.data.array[n + r]);
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: e,
                    normalized: this.normalized
                }
            }
        }), ((So.prototype = Object.create(Xn.prototype)).constructor = So).prototype.isSpriteMaterial = !0, So.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
        };
        var Mo = new wi,
            To = new wi,
            Co = new wi,
            Ao = new pi,
            Eo = new pi,
            Do = new Zi,
            Po = new wi,
            Lo = new wi,
            ko = new wi,
            Oo = new pi,
            Fo = new pi,
            Io = new pi;

        function No(t) {
            var e;
            wn.call(this), this.type = "Sprite", void 0 === xo && (xo = new gr, e = new bo(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5), xo.setIndex([0, 1, 2, 0, 2, 3]), xo.setAttribute("position", new wo(e, 3, 0, !1)), xo.setAttribute("uv", new wo(e, 2, 3, !1))), this.geometry = xo, this.material = void 0 !== t ? t : new So, this.center = new pi(.5, .5)
        }

        function Bo(t, e, i, n, r, a) {
            Ao.subVectors(t, i).addScalar(.5).multiply(n), void 0 !== r ? (Eo.x = a * Ao.x - r * Ao.y, Eo.y = r * Ao.x + a * Ao.y) : Eo.copy(Ao), t.copy(e), t.x += Eo.x, t.y += Eo.y, t.applyMatrix4(Do)
        }
        No.prototype = Object.assign(Object.create(wn.prototype), {
            constructor: No,
            isSprite: !0,
            raycast: function(t, e) {
                t.camera, To.setFromMatrixScale(this.matrixWorld), Do.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Co.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && To.multiplyScalar(-Co.z);
                var i, n, r = this.material.rotation;
                0 !== r && (n = Math.cos(r), i = Math.sin(r));
                var a = this.center;
                Bo(Po.set(-.5, -.5, 0), Co, a, To, i, n), Bo(Lo.set(.5, -.5, 0), Co, a, To, i, n), Bo(ko.set(.5, .5, 0), Co, a, To, i, n), Oo.set(0, 0), Fo.set(1, 0), Io.set(1, 1);
                var s, o = t.ray.intersectTriangle(Po, Lo, ko, !1, Mo);
                null === o && (Bo(Lo.set(-.5, .5, 0), Co, a, To, i, n), Fo.set(0, 1), null === (o = t.ray.intersectTriangle(Po, ko, Lo, !1, Mo))) || ((s = t.ray.origin.distanceTo(Mo)) < t.near || s > t.far || e.push({
                    distance: s,
                    point: Mo.clone(),
                    uv: Bn.getUV(Mo, Po, Lo, ko, Oo, Fo, Io, new pi),
                    face: null,
                    object: this
                }))
            },
            copy: function(t) {
                return wn.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
            }
        });
        var Ro, zo, Go, Vo, Uo, jo = new wi,
            Ho = new wi;

        function Wo() {
            wn.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            }), this.autoUpdate = !0
        }

        function qo(t, e) {
            t && t.isGeometry, Fr.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Zi, this.bindMatrixInverse = new Zi
        }
        Wo.prototype = Object.assign(Object.create(wn.prototype), {
            constructor: Wo,
            isLOD: !0,
            copy: function(t) {
                wn.prototype.copy.call(this, t, !1);
                for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
                    var r = e[i];
                    this.addLevel(r.object.clone(), r.distance)
                }
                return this.autoUpdate = t.autoUpdate, this
            },
            addLevel: function(t, e) {
                void 0 === e && (e = 0), e = Math.abs(e);
                for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
                return i.splice(n, 0, {
                    distance: e,
                    object: t
                }), this.add(t), this
            },
            getCurrentLevel: function() {
                return this._currentLevel
            },
            getObjectForDistance: function(t) {
                var e = this.levels;
                if (0 < e.length) {
                    for (var i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
                    return e[i - 1].object
                }
                return null
            },
            raycast: function(t, e) {
                var i;
                0 < this.levels.length && (jo.setFromMatrixPosition(this.matrixWorld), i = t.ray.origin.distanceTo(jo), this.getObjectForDistance(i).raycast(t, e))
            },
            update: function(t) {
                var e = this.levels;
                if (1 < e.length) {
                    jo.setFromMatrixPosition(t.matrixWorld), Ho.setFromMatrixPosition(this.matrixWorld);
                    var i, n, r = jo.distanceTo(Ho) / t.zoom;
                    for (e[0].object.visible = !0, i = 1, n = e.length; i < n && r >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                    for (this._currentLevel = i - 1; i < n; i++) e[i].object.visible = !1
                }
            },
            toJSON: function(t) {
                var e = wn.prototype.toJSON.call(this, t);
                !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                    var a = i[n];
                    e.object.levels.push({
                        object: a.object.uuid,
                        distance: a.distance
                    })
                }
                return e
            }
        }), qo.prototype = Object.assign(Object.create(Fr.prototype), {
            constructor: qo,
            isSkinnedMesh: !0,
            copy: function(t) {
                return Fr.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
            },
            bind: function(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
            },
            pose: function() {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function() {
                for (var t = new yi, e = this.geometry.attributes.skinWeight, i = 0, n = e.count; i < n; i++) {
                    t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
                    var r = 1 / t.manhattanLength();
                    r != 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                }
            },
            updateMatrixWorld: function(t) {
                Fr.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode && this.bindMatrixInverse.getInverse(this.bindMatrix)
            },
            boneTransform: (Ro = new wi, zo = new yi, Go = new yi, Vo = new wi, Uo = new Zi, function(t, e) {
                var i = this.skeleton,
                    n = this.geometry;
                zo.fromBufferAttribute(n.attributes.skinIndex, t), Go.fromBufferAttribute(n.attributes.skinWeight, t), Ro.fromBufferAttribute(n.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                for (var r = 0; r < 4; r++) {
                    var a, s = Go.getComponent(r);
                    0 !== s && (a = zo.getComponent(r), Uo.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), e.addScaledVector(Vo.copy(Ro).applyMatrix4(Uo), s))
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            })
        });
        var Xo = new Zi,
            Yo = new Zi;

        function Jo(t, e) {
            if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();
            else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
            else {
                this.boneInverses = [];
                for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new Zi)
            }
        }

        function Zo() {
            wn.call(this), this.type = "Bone"
        }
        Object.assign(Jo.prototype, {
            calculateInverses: function() {
                this.boneInverses = [];
                for (var t = 0, e = this.bones.length; t < e; t++) {
                    var i = new Zi;
                    this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
                }
            },
            pose: function() {
                for (var t = 0, e = this.bones.length; t < e; t++) {
                    var i = this.bones[t];
                    i && i.matrixWorld.getInverse(this.boneInverses[t])
                }
                for (var n = 0, r = this.bones.length; n < r; n++) {
                    var a = this.bones[n];
                    a && (a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
                }
            },
            update: function() {
                for (var t = this.bones, e = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, a = t.length; r < a; r++) {
                    var s = t[r] ? t[r].matrixWorld : Yo;
                    Xo.multiplyMatrices(s, e[r]), Xo.toArray(i, 16 * r)
                }
                void 0 !== n && (n.needsUpdate = !0)
            },
            clone: function() {
                return new Jo(this.bones, this.boneInverses)
            },
            getBoneByName: function(t) {
                for (var e = 0, i = this.bones.length; e < i; e++) {
                    var n = this.bones[e];
                    if (n.name === t) return n
                }
            },
            dispose: function() {
                this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0)
            }
        }), Zo.prototype = Object.assign(Object.create(wn.prototype), {
            constructor: Zo,
            isBone: !0
        });
        var $o = new Zi,
            Ko = new Zi,
            Qo = [],
            tl = new Fr;

        function el(t, e, i) {
            Fr.call(this, t, e), this.instanceMatrix = new $n(new Float32Array(16 * i), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1
        }

        function il(t) {
            Xn.call(this), this.type = "LineBasicMaterial", this.color = new Hn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
        }
        el.prototype = Object.assign(Object.create(Fr.prototype), {
            constructor: el,
            isInstancedMesh: !0,
            copy: function(t) {
                return Fr.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this
            },
            setColorAt: function(t, e) {
                null === this.instanceColor && (this.instanceColor = new $n(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
            },
            getMatrixAt: function(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            },
            raycast: function(t, e) {
                var i = this.matrixWorld,
                    n = this.count;
                if (tl.geometry = this.geometry, tl.material = this.material, void 0 !== tl.material)
                    for (var r = 0; r < n; r++) {
                        this.getMatrixAt(r, $o), Ko.multiplyMatrices(i, $o), tl.matrixWorld = Ko, tl.raycast(t, Qo);
                        for (var a = 0, s = Qo.length; a < s; a++) {
                            var o = Qo[a];
                            o.instanceId = r, o.object = this, e.push(o)
                        }
                        Qo.length = 0
                    }
            },
            setMatrixAt: function(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            },
            updateMorphTargets: function() {}
        }), ((il.prototype = Object.create(Xn.prototype)).constructor = il).prototype.isLineBasicMaterial = !0, il.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
        };
        var nl = new wi,
            rl = new wi,
            al = new Zi,
            sl = new Ji,
            ol = new Vi;

        function ll(t, e, i) {
            wn.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new gr, this.material = void 0 !== e ? e : new il, this.updateMorphTargets()
        }
        ll.prototype = Object.assign(Object.create(wn.prototype), {
            constructor: ll,
            isLine: !0,
            copy: function(t) {
                return wn.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
            },
            computeLineDistances: function() {
                var t = this.geometry;
                if (t.isBufferGeometry) {
                    if (null === t.index) {
                        for (var e = t.attributes.position, i = [0], n = 1, r = e.count; n < r; n++) nl.fromBufferAttribute(e, n - 1), rl.fromBufferAttribute(e, n), i[n] = i[n - 1], i[n] += nl.distanceTo(rl);
                        t.setAttribute("lineDistance", new ar(i, 1))
                    }
                } else if (t.isGeometry) {
                    var a = t.vertices,
                        s = t.lineDistances;
                    s[0] = 0;
                    for (var o = 1, l = a.length; o < l; o++) s[o] = s[o - 1], s[o] += a[o - 1].distanceTo(a[o])
                }
                return this
            },
            raycast: function(t, e) {
                var i = this.geometry,
                    n = this.matrixWorld,
                    r = t.params.Line.threshold;
                if (null === i.boundingSphere && i.computeBoundingSphere(), ol.copy(i.boundingSphere), ol.applyMatrix4(n), ol.radius += r, !1 !== t.ray.intersectsSphere(ol)) {
                    al.getInverse(n), sl.copy(t.ray).applyMatrix4(al);
                    var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        s = a * a,
                        o = new wi,
                        l = new wi,
                        h = new wi,
                        u = new wi,
                        c = this && this.isLineSegments ? 2 : 1;
                    if (i.isBufferGeometry) {
                        var p = i.index,
                            d = i.attributes.position.array;
                        if (null !== p)
                            for (var f = p.array, m = 0, g = f.length - 1; m < g; m += c) {
                                var v, y = f[m],
                                    b = f[m + 1];
                                o.fromArray(d, 3 * y), l.fromArray(d, 3 * b), s < sl.distanceSqToSegment(o, l, u, h) || (u.applyMatrix4(this.matrixWorld), (v = t.ray.origin.distanceTo(u)) < t.near || v > t.far || e.push({
                                    distance: v,
                                    point: h.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            } else
                                for (var x, _ = 0, w = d.length / 3 - 1; _ < w; _ += c) {
                                    o.fromArray(d, 3 * _), l.fromArray(d, 3 * _ + 3), s < sl.distanceSqToSegment(o, l, u, h) || (u.applyMatrix4(this.matrixWorld), (x = t.ray.origin.distanceTo(u)) < t.near || x > t.far || e.push({
                                        distance: x,
                                        point: h.clone().applyMatrix4(this.matrixWorld),
                                        index: _,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                                }
                    } else if (i.isGeometry)
                        for (var S, M = i.vertices, T = M.length, C = 0; C < T - 1; C += c) {
                            s < sl.distanceSqToSegment(M[C], M[C + 1], u, h) || (u.applyMatrix4(this.matrixWorld), (S = t.ray.origin.distanceTo(u)) < t.near || S > t.far || e.push({
                                distance: S,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: C,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                        }
                }
            },
            updateMorphTargets: function() {
                var t = this.geometry;
                if (t.isBufferGeometry) {
                    var e = t.morphAttributes,
                        i = Object.keys(e);
                    if (0 < i.length) {
                        var n = e[i[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (var r = 0, a = n.length; r < a; r++) {
                                var s = n[r].name || String(r);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = r
                            }
                        }
                    }
                } else {
                    var o = t.morphTargets;
                    void 0 !== o && o.length
                }
            }
        });
        var hl = new wi,
            ul = new wi;

        function cl(t, e) {
            ll.call(this, t, e), this.type = "LineSegments"
        }

        function pl(t, e) {
            ll.call(this, t, e), this.type = "LineLoop"
        }

        function dl(t) {
            Xn.call(this), this.type = "PointsMaterial", this.color = new Hn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
        }
        cl.prototype = Object.assign(Object.create(ll.prototype), {
            constructor: cl,
            isLineSegments: !0,
            computeLineDistances: function() {
                var t = this.geometry;
                if (t.isBufferGeometry) {
                    if (null === t.index) {
                        for (var e = t.attributes.position, i = [], n = 0, r = e.count; n < r; n += 2) hl.fromBufferAttribute(e, n), ul.fromBufferAttribute(e, n + 1), i[n] = 0 === n ? 0 : i[n - 1], i[n + 1] = i[n] + hl.distanceTo(ul);
                        t.setAttribute("lineDistance", new ar(i, 1))
                    }
                } else if (t.isGeometry)
                    for (var a = t.vertices, s = t.lineDistances, o = 0, l = a.length; o < l; o += 2) hl.copy(a[o]), ul.copy(a[o + 1]), s[o] = 0 === o ? 0 : s[o - 1], s[o + 1] = s[o] + hl.distanceTo(ul);
                return this
            }
        }), pl.prototype = Object.assign(Object.create(ll.prototype), {
            constructor: pl,
            isLineLoop: !0
        }), ((dl.prototype = Object.create(Xn.prototype)).constructor = dl).prototype.isPointsMaterial = !0, dl.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
        };
        var fl = new Zi,
            ml = new Ji,
            gl = new Vi,
            vl = new wi;

        function yl(t, e) {
            wn.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new gr, this.material = void 0 !== e ? e : new dl, this.updateMorphTargets()
        }

        function bl(t, e, i, n, r, a, s) {
            var o = ml.distanceSqToPoint(t);
            if (o < i) {
                var l = new wi;
                ml.closestPointToPoint(t, l), l.applyMatrix4(n);
                var h = r.ray.origin.distanceTo(l);
                if (h < r.near || h > r.far) return;
                a.push({
                    distance: h,
                    distanceToRay: Math.sqrt(o),
                    point: l,
                    index: e,
                    face: null,
                    object: s
                })
            }
        }

        function xl(e, t, i, n, r, a, s, o, l) {
            vi.call(this, e, t, i, n, r, a, s, o, l), this.format = void 0 !== s ? s : Jt, this.minFilter = void 0 !== a ? a : Gt, this.magFilter = void 0 !== r ? r : Gt, this.generateMipmaps = !1;
            var h = this;
            "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() {
                h.needsUpdate = !0, e.requestVideoFrameCallback(t)
            })
        }

        function _l(t, e, i, n, r, a, s, o, l, h, u, c) {
            vi.call(this, null, a, s, o, l, h, n, r, u, c), this.image = {
                width: e,
                height: i
            }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
        }

        function wl(t, e, i, n, r, a, s, o, l) {
            vi.call(this, t, e, i, n, r, a, s, o, l), this.needsUpdate = !0
        }

        function Sl(t, e, i, n, r, a, s, o, l, h) {
            if ((h = void 0 !== h ? h : $t) !== $t && h !== Kt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === i && h === $t && (i = Ht), void 0 === i && h === Kt && (i = Yt), vi.call(this, null, n, r, a, s, o, h, i, l), this.image = {
                width: t,
                height: e
            }, this.magFilter = void 0 !== s ? s : Bt, this.minFilter = void 0 !== o ? o : Bt, this.flipY = !1, this.generateMipmaps = !1
        }
        yl.prototype = Object.assign(Object.create(wn.prototype), {
            constructor: yl,
            isPoints: !0,
            copy: function(t) {
                return wn.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
            },
            raycast: function(t, e) {
                var i = this.geometry,
                    n = this.matrixWorld,
                    r = t.params.Points.threshold;
                if (null === i.boundingSphere && i.computeBoundingSphere(), gl.copy(i.boundingSphere), gl.applyMatrix4(n), gl.radius += r, !1 !== t.ray.intersectsSphere(gl)) {
                    fl.getInverse(n), ml.copy(t.ray).applyMatrix4(fl);
                    var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        s = a * a;
                    if (i.isBufferGeometry) {
                        var o = i.index,
                            l = i.attributes.position.array;
                        if (null !== o)
                            for (var h = o.array, u = 0, c = h.length; u < c; u++) {
                                var p = h[u];
                                vl.fromArray(l, 3 * p), bl(vl, p, s, n, t, e, this)
                            } else
                                for (var d = 0, f = l.length / 3; d < f; d++) vl.fromArray(l, 3 * d), bl(vl, d, s, n, t, e, this)
                    } else
                        for (var m = i.vertices, g = 0, v = m.length; g < v; g++) bl(m[g], g, s, n, t, e, this)
                }
            },
            updateMorphTargets: function() {
                var t = this.geometry;
                if (t.isBufferGeometry) {
                    var e = t.morphAttributes,
                        i = Object.keys(e);
                    if (0 < i.length) {
                        var n = e[i[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (var r = 0, a = n.length; r < a; r++) {
                                var s = n[r].name || String(r);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = r
                            }
                        }
                    }
                } else {
                    var o = t.morphTargets;
                    void 0 !== o && o.length
                }
            }
        }), xl.prototype = Object.assign(Object.create(vi.prototype), {
            constructor: xl,
            isVideoTexture: !0,
            update: function() {
                var t = this.image;
                !1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }), ((_l.prototype = Object.create(vi.prototype)).constructor = _l).prototype.isCompressedTexture = !0, ((wl.prototype = Object.create(vi.prototype)).constructor = wl).prototype.isCanvasTexture = !0, ((Sl.prototype = Object.create(vi.prototype)).constructor = Sl).prototype.isDepthTexture = !0;
        var Ml = function() {
            d(G, gr);
            var z = y(G);

            function G(t) {
                var e;
                V(this, G), (e = z.call(this)).type = "WireframeGeometry";
                var i = [],
                    n = [0, 0],
                    r = {},
                    a = ["a", "b", "c"];
                if (t && t.isGeometry) {
                    for (var s = t.faces, o = 0, l = s.length; o < l; o++)
                        for (var h = s[o], u = 0; u < 3; u++) {
                            var c = h[a[u]],
                                p = h[a[(u + 1) % 3]];
                            n[0] = Math.min(c, p), n[1] = Math.max(c, p);
                            var d = n[0] + "," + n[1];
                            void 0 === r[d] && (r[d] = {
                                index1: n[0],
                                index2: n[1]
                            })
                        }
                    for (var f in r) {
                        var m = r[f],
                            g = t.vertices[m.index1];
                        i.push(g.x, g.y, g.z), g = t.vertices[m.index2], i.push(g.x, g.y, g.z)
                    }
                } else if (t && t.isBufferGeometry) {
                    var v = new wi;
                    if (null !== t.index) {
                        var y = t.attributes.position,
                            b = t.index,
                            x = t.groups;
                        0 === x.length && (x = [{
                            start: 0,
                            count: b.count,
                            materialIndex: 0
                        }]);
                        for (var _ = 0, w = x.length; _ < w; ++_)
                            for (var S = x[_], M = S.start, T = M, C = M + S.count; T < C; T += 3)
                                for (var A = 0; A < 3; A++) {
                                    var E = b.getX(T + A),
                                        D = b.getX(T + (A + 1) % 3);
                                    n[0] = Math.min(E, D), n[1] = Math.max(E, D);
                                    var P = n[0] + "," + n[1];
                                    void 0 === r[P] && (r[P] = {
                                        index1: n[0],
                                        index2: n[1]
                                    })
                                }
                        for (var L in r) {
                            var k = r[L];
                            v.fromBufferAttribute(y, k.index1), i.push(v.x, v.y, v.z), v.fromBufferAttribute(y, k.index2), i.push(v.x, v.y, v.z)
                        }
                    } else
                        for (var O = t.attributes.position, F = 0, I = O.count / 3; F < I; F++)
                            for (var N = 0; N < 3; N++) {
                                var B = 3 * F + N;
                                v.fromBufferAttribute(O, B), i.push(v.x, v.y, v.z);
                                var R = 3 * F + (N + 1) % 3;
                                v.fromBufferAttribute(O, R), i.push(v.x, v.y, v.z)
                            }
                }
                return e.setAttribute("position", new ar(i, 3)), e
            }
            return G
        }();

        function Tl(t, e, i) {
            Vr.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            }, this.fromBufferGeometry(new Cl(t, e, i)), this.mergeVertices()
        }

        function Cl(t, e, i) {
            gr.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            };
            var n = [],
                r = [],
                a = [],
                s = [],
                o = new wi,
                l = new wi,
                h = new wi,
                u = new wi,
                c = new wi;
            t.length;
            for (var p = e + 1, d = 0; d <= i; d++)
                for (var f = d / i, m = 0; m <= e; m++) {
                    var g = m / e;
                    t(g, f, l), r.push(l.x, l.y, l.z), 0 <= g - 1e-5 ? (t(g - 1e-5, f, h), u.subVectors(l, h)) : (t(1e-5 + g, f, h), u.subVectors(h, l)), 0 <= f - 1e-5 ? (t(g, f - 1e-5, h), c.subVectors(l, h)) : (t(g, 1e-5 + f, h), c.subVectors(h, l)), o.crossVectors(u, c).normalize(), a.push(o.x, o.y, o.z), s.push(g, f)
                }
            for (var v = 0; v < i; v++)
                for (var y = 0; y < e; y++) {
                    var b = v * p + y,
                        x = v * p + y + 1,
                        _ = (v + 1) * p + y + 1,
                        w = (v + 1) * p + y;
                    n.push(b, x, w), n.push(x, _, w)
                }
            this.setIndex(n), this.setAttribute("position", new ar(r, 3)), this.setAttribute("normal", new ar(a, 3)), this.setAttribute("uv", new ar(s, 2))
        }
        i.WireframeGeometry = Ml, (Tl.prototype = Object.create(Vr.prototype)).constructor = Tl, (Cl.prototype = Object.create(gr.prototype)).constructor = Cl;
        var Al = function() {
            d(s, Vr);
            var a = y(s);

            function s(t, e, i, n) {
                var r;
                return V(this, s), (r = a.call(this)).type = "PolyhedronGeometry", r.parameters = {
                    vertices: t,
                    indices: e,
                    radius: i,
                    detail: n
                }, r.fromBufferGeometry(new El(t, e, i, n)), r.mergeVertices(), r
            }
            return s
        }();
        i.PolyhedronGeometry = Al;
        var El = function() {
            d(o, gr);
            var r = y(o);

            function o(n, a, t, e) {
                var i;
                V(this, o), (i = r.call(this)).type = "PolyhedronBufferGeometry", i.parameters = {
                    vertices: n,
                    indices: a,
                    radius: t,
                    detail: e
                }, t = t || 1;
                var u = [],
                    c = [];

                function f(t) {
                    u.push(t.x, t.y, t.z)
                }

                function s(t, e) {
                    var i = 3 * t;
                    e.x = n[0 + i], e.y = n[1 + i], e.z = n[2 + i]
                }

                function p(t, e, i, n) {
                    n < 0 && 1 === t.x && (c[e] = t.x - 1), 0 === i.x && 0 === i.z && (c[e] = n / 2 / Math.PI + .5)
                }

                function d(t) {
                    return Math.atan2(t.z, -t.x)
                }
                return function(t) {
                        for (var e = new wi, i = new wi, n = new wi, r = 0; r < a.length; r += 3) s(a[r + 0], e), s(a[r + 1], i), s(a[r + 2], n),
                            function(t, e, i, n) {
                                for (var r = Math.pow(2, n), a = [], s = 0; s <= r; s++) {
                                    a[s] = [];
                                    for (var o = t.clone().lerp(i, s / r), l = e.clone().lerp(i, s / r), h = r - s, u = 0; u <= h; u++) a[s][u] = 0 === u && s === r ? o : o.clone().lerp(l, u / h)
                                }
                                for (var c = 0; c < r; c++)
                                    for (var p = 0; p < 2 * (r - c) - 1; p++) {
                                        var d = Math.floor(p / 2);
                                        p % 2 == 0 ? (f(a[c][d + 1]), f(a[c + 1][d]), f(a[c][d])) : (f(a[c][d + 1]), f(a[c + 1][d + 1]), f(a[c + 1][d]))
                                    }
                            }(e, i, n, t)
                    }(e = e || 0),
                    function(t) {
                        for (var e = new wi, i = 0; i < u.length; i += 3) e.x = u[i + 0], e.y = u[i + 1], e.z = u[i + 2], e.normalize().multiplyScalar(t), u[i + 0] = e.x, u[i + 1] = e.y, u[i + 2] = e.z
                    }(t),
                    function() {
                        for (var t = new wi, e = 0; e < u.length; e += 3) {
                            t.x = u[e + 0], t.y = u[e + 1], t.z = u[e + 2];
                            var i = d(t) / 2 / Math.PI + .5,
                                n = function(t) {
                                    return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
                                }(t) / Math.PI + .5;
                            c.push(i, 1 - n)
                        }(function() {
                            for (var t = new wi, e = new wi, i = new wi, n = new wi, r = new pi, a = new pi, s = new pi, o = 0, l = 0; o < u.length; o += 9, l += 6) {
                                t.set(u[o + 0], u[o + 1], u[o + 2]), e.set(u[o + 3], u[o + 4], u[o + 5]), i.set(u[o + 6], u[o + 7], u[o + 8]), r.set(c[l + 0], c[l + 1]), a.set(c[l + 2], c[l + 3]), s.set(c[l + 4], c[l + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                                var h = d(n);
                                p(r, l + 0, t, h), p(a, l + 2, e, h), p(s, l + 4, i, h)
                            }
                        })(),
                        function() {
                            for (var t = 0; t < c.length; t += 6) {
                                var e = c[t + 0],
                                    i = c[t + 2],
                                    n = c[t + 4],
                                    r = Math.max(e, i, n),
                                    a = Math.min(e, i, n);
                                .9 < r && a < .1 && (e < .2 && (c[t + 0] += 1), i < .2 && (c[t + 2] += 1), n < .2 && (c[t + 4] += 1))
                            }
                        }()
                    }(), i.setAttribute("position", new ar(u, 3)), i.setAttribute("normal", new ar(u.slice(), 3)), i.setAttribute("uv", new ar(c, 2)), 0 === e ? i.computeVertexNormals() : i.normalizeNormals(), i
            }
            return o
        }();
        i.PolyhedronBufferGeometry = El;
        var Dl = function() {
            d(r, Vr);
            var n = y(r);

            function r(t, e) {
                var i;
                return V(this, r), (i = n.call(this)).type = "TetrahedronGeometry", i.parameters = {
                    radius: t,
                    detail: e
                }, i.fromBufferGeometry(new Pl(t, e)), i.mergeVertices(), i
            }
            return r
        }();
        i.TetrahedronGeometry = Dl;
        var Pl = function() {
            d(r, El);
            var n = y(r);

            function r(t, e) {
                V(this, r);
                var i;
                return (i = n.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e)).type = "TetrahedronBufferGeometry", i.parameters = {
                    radius: t,
                    detail: e
                }, i
            }
            return r
        }();
        i.TetrahedronBufferGeometry = Pl;
        var Ll = function() {
            d(r, Vr);
            var n = y(r);

            function r(t, e) {
                var i;
                return V(this, r), (i = n.call(this)).type = "OctahedronGeometry", i.parameters = {
                    radius: t,
                    detail: e
                }, i.fromBufferGeometry(new kl(t, e)), i.mergeVertices(), i
            }
            return r
        }();
        i.OctahedronGeometry = Ll;
        var kl = function() {
            d(r, El);
            var n = y(r);

            function r(t, e) {
                V(this, r);
                var i;
                return (i = n.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e)).type = "OctahedronBufferGeometry", i.parameters = {
                    radius: t,
                    detail: e
                }, i
            }
            return r
        }();
        i.OctahedronBufferGeometry = kl;
        var Ol = function() {
            d(r, Vr);
            var n = y(r);

            function r(t, e) {
                var i;
                return V(this, r), (i = n.call(this)).type = "IcosahedronGeometry", i.parameters = {
                    radius: t,
                    detail: e
                }, i.fromBufferGeometry(new Fl(t, e)), i.mergeVertices(), i
            }
            return r
        }();
        i.IcosahedronGeometry = Ol;
        var Fl = function() {
            d(s, El);
            var a = y(s);

            function s(t, e) {
                V(this, s);
                var i, n = (1 + Math.sqrt(5)) / 2,
                    r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
                return (i = a.call(this, r, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e)).type = "IcosahedronBufferGeometry", i.parameters = {
                    radius: t,
                    detail: e
                }, i
            }
            return s
        }();
        i.IcosahedronBufferGeometry = Fl;
        var Il = function() {
            d(r, Vr);
            var n = y(r);

            function r(t, e) {
                var i;
                return V(this, r), (i = n.call(this)).type = "DodecahedronGeometry", i.parameters = {
                    radius: t,
                    detail: e
                }, i.fromBufferGeometry(new Nl(t, e)), i.mergeVertices(), i
            }
            return r
        }();
        i.DodecahedronGeometry = Il;
        var Nl = function() {
            d(o, El);
            var s = y(o);

            function o(t, e) {
                V(this, o);
                var i, n = (1 + Math.sqrt(5)) / 2,
                    r = 1 / n,
                    a = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r];
                return (i = s.call(this, a, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e)).type = "DodecahedronBufferGeometry", i.parameters = {
                    radius: t,
                    detail: e
                }, i
            }
            return o
        }();
        i.DodecahedronBufferGeometry = Nl;
        var Bl = function() {
            d(h, Vr);
            var l = y(h);

            function h(t, e, i, n, r, a) {
                var s;
                V(this, h), (s = l.call(this)).type = "TubeGeometry", s.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: i,
                    radialSegments: n,
                    closed: r
                };
                var o = new Rl(t, e, i, n, r);
                return s.tangents = o.tangents, s.normals = o.normals, s.binormals = o.binormals, s.fromBufferGeometry(o), s.mergeVertices(), s
            }
            return h
        }();
        i.TubeGeometry = Bl;
        var Rl = function() {
            d(v, gr);
            var a = y(v);

            function v(o, l, h, u, e) {
                var t;
                V(this, v), (t = a.call(this)).type = "TubeBufferGeometry", t.parameters = {
                    path: o,
                    tubularSegments: l,
                    radius: h,
                    radialSegments: u,
                    closed: e
                }, l = l || 64, h = h || 1, u = u || 8, e = e || !1;
                var c = o.computeFrenetFrames(l, e);
                t.tangents = c.tangents, t.normals = c.normals, t.binormals = c.binormals;
                var p = new wi,
                    d = new wi,
                    i = new pi,
                    f = new wi,
                    m = [],
                    g = [],
                    n = [],
                    s = [];

                function r(t) {
                    f = o.getPointAt(t / l, f);
                    for (var e = c.normals[t], i = c.binormals[t], n = 0; n <= u; n++) {
                        var r = n / u * Math.PI * 2,
                            a = Math.sin(r),
                            s = -Math.cos(r);
                        d.x = s * e.x + a * i.x, d.y = s * e.y + a * i.y, d.z = s * e.z + a * i.z, d.normalize(), g.push(d.x, d.y, d.z), p.x = f.x + h * d.x, p.y = f.y + h * d.y, p.z = f.z + h * d.z, m.push(p.x, p.y, p.z)
                    }
                }
                return function() {
                    for (var t = 0; t < l; t++) r(t);
                    r(!1 === e ? l : 0),
                        function() {
                            for (var t = 0; t <= l; t++)
                                for (var e = 0; e <= u; e++) i.x = t / l, i.y = e / u, n.push(i.x, i.y)
                        }(),
                        function() {
                            for (var t = 1; t <= l; t++)
                                for (var e = 1; e <= u; e++) {
                                    var i = (u + 1) * (t - 1) + (e - 1),
                                        n = (u + 1) * t + (e - 1),
                                        r = (u + 1) * t + e,
                                        a = (u + 1) * (t - 1) + e;
                                    s.push(i, n, a), s.push(n, r, a)
                                }
                        }()
                }(), t.setIndex(s), t.setAttribute("position", new ar(m, 3)), t.setAttribute("normal", new ar(g, 3)), t.setAttribute("uv", new ar(n, 2)), t
            }
            return g(v, [{
                key: "toJSON",
                value: function() {
                    var t = gr.prototype.toJSON.call(this);
                    return t.path = this.parameters.path.toJSON(), t
                }
            }]), v
        }();
        i.TubeBufferGeometry = Rl;
        var zl = function() {
            d(h, Vr);
            var l = y(h);

            function h(t, e, i, n, r, a, s) {
                var o;
                return V(this, h), (o = l.call(this)).type = "TorusKnotGeometry", o.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: i,
                    radialSegments: n,
                    p: r,
                    q: a
                }, o.fromBufferGeometry(new Gl(t, e, i, n, r, a)), o.mergeVertices(), o
            }
            return h
        }();
        i.TorusKnotGeometry = zl;
        var Gl = function() {
            d(k, gr);
            var L = y(k);

            function k(t, e, i, n, r, a) {
                var s;
                V(this, k), (s = L.call(this)).type = "TorusKnotBufferGeometry", s.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: i,
                    radialSegments: n,
                    p: r,
                    q: a
                }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, a = a || 3;
                for (var o = [], l = [], h = [], u = [], c = new wi, p = new wi, d = new wi, f = new wi, m = new wi, g = new wi, v = new wi, y = 0; y <= i; ++y) {
                    var b = y / i * r * Math.PI * 2;
                    P(b, r, a, t, d), P(.01 + b, r, a, t, f), g.subVectors(f, d), v.addVectors(f, d), m.crossVectors(g, v), v.crossVectors(m, g), m.normalize(), v.normalize();
                    for (var x = 0; x <= n; ++x) {
                        var _ = x / n * Math.PI * 2,
                            w = -e * Math.cos(_),
                            S = e * Math.sin(_);
                        c.x = d.x + (w * v.x + S * m.x), c.y = d.y + (w * v.y + S * m.y), c.z = d.z + (w * v.z + S * m.z), l.push(c.x, c.y, c.z), p.subVectors(c, d).normalize(), h.push(p.x, p.y, p.z), u.push(y / i), u.push(x / n)
                    }
                }
                for (var M = 1; M <= i; M++)
                    for (var T = 1; T <= n; T++) {
                        var C = (n + 1) * (M - 1) + (T - 1),
                            A = (n + 1) * M + (T - 1),
                            E = (n + 1) * M + T,
                            D = (n + 1) * (M - 1) + T;
                        o.push(C, A, D), o.push(A, E, D)
                    }

                function P(t, e, i, n, r) {
                    var a = Math.cos(t),
                        s = Math.sin(t),
                        o = i / e * t,
                        l = Math.cos(o);
                    r.x = n * (2 + l) * .5 * a, r.y = n * (2 + l) * s * .5, r.z = n * Math.sin(o) * .5
                }
                return s.setIndex(o), s.setAttribute("position", new ar(l, 3)), s.setAttribute("normal", new ar(h, 3)), s.setAttribute("uv", new ar(u, 2)), s
            }
            return k
        }();
        i.TorusKnotBufferGeometry = Gl;
        var Vl = function() {
            d(o, Vr);
            var s = y(o);

            function o(t, e, i, n, r) {
                var a;
                return V(this, o), (a = s.call(this)).type = "TorusGeometry", a.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: i,
                    tubularSegments: n,
                    arc: r
                }, a.fromBufferGeometry(new Ul(t, e, i, n, r)), a.mergeVertices(), a
            }
            return o
        }();
        i.TorusGeometry = Vl;
        var Ul = function() {
            d(M, gr);
            var S = y(M);

            function M(t, e, i, n, r) {
                var a;
                V(this, M), (a = S.call(this)).type = "TorusBufferGeometry", a.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: i,
                    tubularSegments: n,
                    arc: r
                }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
                for (var s = [], o = [], l = [], h = [], u = new wi, c = new wi, p = new wi, d = 0; d <= i; d++)
                    for (var f = 0; f <= n; f++) {
                        var m = f / n * r,
                            g = d / i * Math.PI * 2;
                        c.x = (t + e * Math.cos(g)) * Math.cos(m), c.y = (t + e * Math.cos(g)) * Math.sin(m), c.z = e * Math.sin(g), o.push(c.x, c.y, c.z), u.x = t * Math.cos(m), u.y = t * Math.sin(m), p.subVectors(c, u).normalize(), l.push(p.x, p.y, p.z), h.push(f / n), h.push(d / i)
                    }
                for (var v = 1; v <= i; v++)
                    for (var y = 1; y <= n; y++) {
                        var b = (n + 1) * v + y - 1,
                            x = (n + 1) * (v - 1) + y - 1,
                            _ = (n + 1) * (v - 1) + y,
                            w = (n + 1) * v + y;
                        s.push(b, x, w), s.push(x, _, w)
                    }
                return a.setIndex(s), a.setAttribute("position", new ar(o, 3)), a.setAttribute("normal", new ar(l, 3)), a.setAttribute("uv", new ar(h, 2)), a
            }
            return M
        }();
        i.TorusBufferGeometry = Ul;
        var jl = function(t, e, i) {
            i = i || 2;
            var n, r, a, s, o, l, h, u = e && e.length,
                c = u ? e[0] * i : t.length,
                p = Hl(t, 0, c, i, !0),
                d = [];
            if (!p || p.next === p.prev) return d;
            if (u && (p = function(t, e, i, n) {
                    var r, a, s, o, l, h = [];
                    for (r = 0, a = e.length; r < a; r++) s = e[r] * n, o = r < a - 1 ? e[r + 1] * n : t.length, (l = Hl(t, s, o, n, !1)) === l.next && (l.steiner = !0), h.push(function(t) {
                        var e = t,
                            i = t;
                        for (;
                            (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next, e !== t;);
                        return i
                    }(l));
                    for (h.sort(Xl), r = 0; r < h.length; r++) ! function(t, e) {
                        {
                            var i;
                            (e = function(t, e) {
                                var i, n = e,
                                    r = t.x,
                                    a = t.y,
                                    s = -1 / 0;
                                do {
                                    if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
                                        var o = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                        if (o <= r && s < o) {
                                            if ((s = o) === r) {
                                                if (a === n.y) return n;
                                                if (a === n.next.y) return n.next
                                            }
                                            i = n.x < n.next.x ? n : n.next
                                        }
                                    }
                                    n = n.next
                                } while (n !== e);
                                if (!i) return null;
                                if (r === s) return i;
                                var l, h = i,
                                    u = i.x,
                                    c = i.y,
                                    p = 1 / 0;
                                n = i;
                                for (; r >= n.x && n.x >= u && r !== n.x && Jl(a < c ? r : s, a, u, c, a < c ? s : r, a, n.x, n.y) && (l = Math.abs(a - n.y) / (r - n.x), eh(n, t) && (l < p || l === p && (n.x > i.x || n.x === i.x && function(t, e) {
                                        return Zl(t.prev, t, e.prev) < 0 && Zl(e.next, t, t.next) < 0
                                    }(i, n))) && (i = n, p = l)), n = n.next, n !== h;);
                                return i
                            }(t, e)) && (i = ih(e, t), Wl(e, e.next), Wl(i, i.next))
                        }
                    }(h[r], i), i = Wl(i, i.next);
                    return i
                }(t, e, p, i)), t.length > 80 * i) {
                n = a = t[0], r = s = t[1];
                for (var f = i; f < c; f += i)(o = t[f]) < n && (n = o), (l = t[f + 1]) < r && (r = l), a < o && (a = o), s < l && (s = l);
                h = 0 !== (h = Math.max(a - n, s - r)) ? 1 / h : 0
            }
            return ql(p, d, i, n, r, h), d
        };

        function Hl(t, e, i, n, r) {
            var a, s;
            if (r === 0 < function(t, e, i, n) {
                    for (var r = 0, a = e, s = i - n; a < i; a += n) r += (t[s] - t[a]) * (t[a + 1] + t[s + 1]), s = a;
                    return r
                }(t, e, i, n))
                for (a = e; a < i; a += n) s = nh(a, t[a], t[a + 1], s);
            else
                for (a = i - n; e <= a; a -= n) s = nh(a, t[a], t[a + 1], s);
            return s && $l(s, s.next) && (rh(s), s = s.next), s
        }

        function Wl(t, e) {
            if (!t) return t;
            e = e || t;
            var i, n = t;
            do {
                if (i = !1, n.steiner || !$l(n, n.next) && 0 !== Zl(n.prev, n, n.next)) n = n.next;
                else {
                    if (rh(n), (n = e = n.prev) === n.next) break;
                    i = !0
                }
            } while (i || n !== e);
            return e
        }

        function ql(t, e, i, n, r, a, s) {
            if (t) {
                !s && a && function(t, e, i, n) {
                    var r = t;
                    for (; null === r.z && (r.z = Yl(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next, r !== t;);
                    r.prevZ.nextZ = null, r.prevZ = null,
                        function(t) {
                            var e, i, n, r, a, s, o, l, h = 1;
                            do {
                                for (i = t, a = t = null, s = 0; i;) {
                                    for (s++, n = i, e = o = 0; e < h && (o++, n = n.nextZ); e++);
                                    for (l = h; 0 < o || 0 < l && n;) 0 !== o && (0 === l || !n || i.z <= n.z) ? (i = (r = i).nextZ, o--) : (n = (r = n).nextZ, l--), a ? a.nextZ = r : t = r, r.prevZ = a, a = r;
                                    i = n
                                }
                                a.nextZ = null, h *= 2
                            } while (1 < s)
                        }(r)
                }(t, n, r, a);
                for (var o, l, h = t; t.prev !== t.next;)
                    if (o = t.prev, l = t.next, a ? function(t, e, i, n) {
                            var r = t.prev,
                                a = t,
                                s = t.next;
                            if (0 <= Zl(r, a, s)) return !1;
                            var o = r.x < a.x ? r.x < s.x ? r.x : s.x : a.x < s.x ? a.x : s.x,
                                l = r.y < a.y ? r.y < s.y ? r.y : s.y : a.y < s.y ? a.y : s.y,
                                h = r.x > a.x ? r.x > s.x ? r.x : s.x : a.x > s.x ? a.x : s.x,
                                u = r.y > a.y ? r.y > s.y ? r.y : s.y : a.y > s.y ? a.y : s.y,
                                c = Yl(o, l, e, i, n),
                                p = Yl(h, u, e, i, n),
                                d = t.prevZ,
                                f = t.nextZ;
                            for (; d && d.z >= c && f && f.z <= p;) {
                                if (d !== t.prev && d !== t.next && Jl(r.x, r.y, a.x, a.y, s.x, s.y, d.x, d.y) && 0 <= Zl(d.prev, d, d.next)) return !1;
                                if (d = d.prevZ, f !== t.prev && f !== t.next && Jl(r.x, r.y, a.x, a.y, s.x, s.y, f.x, f.y) && 0 <= Zl(f.prev, f, f.next)) return !1;
                                f = f.nextZ
                            }
                            for (; d && d.z >= c;) {
                                if (d !== t.prev && d !== t.next && Jl(r.x, r.y, a.x, a.y, s.x, s.y, d.x, d.y) && 0 <= Zl(d.prev, d, d.next)) return !1;
                                d = d.prevZ
                            }
                            for (; f && f.z <= p;) {
                                if (f !== t.prev && f !== t.next && Jl(r.x, r.y, a.x, a.y, s.x, s.y, f.x, f.y) && 0 <= Zl(f.prev, f, f.next)) return !1;
                                f = f.nextZ
                            }
                            return !0
                        }(t, n, r, a) : function(t) {
                            var e = t.prev,
                                i = t,
                                n = t.next;
                            if (0 <= Zl(e, i, n)) return !1;
                            var r = t.next.next;
                            for (; r !== t.prev;) {
                                if (Jl(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && 0 <= Zl(r.prev, r, r.next)) return !1;
                                r = r.next
                            }
                            return !0
                        }(t)) e.push(o.i / i), e.push(t.i / i), e.push(l.i / i), rh(t), t = l.next, h = l.next;
                    else if ((t = l) === h) {
                    s ? 1 === s ? ql(t = function(t, e, i) {
                        var n = t;
                        do {
                            var r = n.prev,
                                a = n.next.next;
                            !$l(r, a) && Kl(r, n, n.next, a) && eh(r, a) && eh(a, r) && (e.push(r.i / i), e.push(n.i / i), e.push(a.i / i), rh(n), rh(n.next), n = t = a), n = n.next
                        } while (n !== t);
                        return Wl(n)
                    }(Wl(t), e, i), e, i, n, r, a, 2) : 2 === s && function(t, e, i, n, r, a) {
                        var s = t;
                        do {
                            for (var o = s.next.next; o !== s.prev;) {
                                if (s.i !== o.i && function(t, e) {
                                        return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                                            var i = t;
                                            do {
                                                if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && Kl(i, i.next, t, e)) return !0;
                                                i = i.next
                                            } while (i !== t);
                                            return !1
                                        }(t, e) && (eh(t, e) && eh(e, t) && function(t, e) {
                                            var i = t,
                                                n = !1,
                                                r = (t.x + e.x) / 2,
                                                a = (t.y + e.y) / 2;
                                            for (; i.y > a != i.next.y > a && i.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next, i !== t;);
                                            return n
                                        }(t, e) && (Zl(t.prev, t, e.prev) || Zl(t, e.prev, e)) || $l(t, e) && 0 < Zl(t.prev, t, t.next) && 0 < Zl(e.prev, e, e.next))
                                    }(s, o)) {
                                    var l = ih(s, o);
                                    return s = Wl(s, s.next), l = Wl(l, l.next), ql(s, e, i, n, r, a), ql(l, e, i, n, r, a)
                                }
                                o = o.next
                            }
                            s = s.next
                        } while (s !== t)
                    }(t, e, i, n, r, a) : ql(Wl(t), e, i, n, r, a, 1);
                    break
                }
            }
        }

        function Xl(t, e) {
            return t.x - e.x
        }

        function Yl(t, e, i, n, r) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }

        function Jl(t, e, i, n, r, a, s, o) {
            return 0 <= (r - s) * (e - o) - (t - s) * (a - o) && 0 <= (t - s) * (n - o) - (i - s) * (e - o) && 0 <= (i - s) * (a - o) - (r - s) * (n - o)
        }

        function Zl(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }

        function $l(t, e) {
            return t.x === e.x && t.y === e.y
        }

        function Kl(t, e, i, n) {
            var r = th(Zl(t, e, i)),
                a = th(Zl(t, e, n)),
                s = th(Zl(i, n, t)),
                o = th(Zl(i, n, e));
            return r !== a && s !== o || (0 === r && Ql(t, i, e) || (0 === a && Ql(t, n, e) || (0 === s && Ql(i, t, n) || !(0 !== o || !Ql(i, e, n)))))
        }

        function Ql(t, e, i) {
            return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
        }

        function th(t) {
            return 0 < t ? 1 : t < 0 ? -1 : 0
        }

        function eh(t, e) {
            return Zl(t.prev, t, t.next) < 0 ? 0 <= Zl(t, e, t.next) && 0 <= Zl(t, t.prev, e) : Zl(t, e, t.prev) < 0 || Zl(t, t.next, e) < 0
        }

        function ih(t, e) {
            var i = new ah(t.i, t.x, t.y),
                n = new ah(e.i, e.x, e.y),
                r = t.next,
                a = e.prev;
            return (t.next = e).prev = t, (i.next = r).prev = i, (n.next = i).prev = n, (a.next = n).prev = a, n
        }

        function nh(t, e, i, n) {
            var r = new ah(t, e, i);
            return n ? (r.next = n.next, (r.prev = n).next.prev = r, n.next = r) : (r.prev = r).next = r, r
        }

        function rh(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }

        function ah(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }
        var sh = {
            area: function(t) {
                for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                return .5 * i
            },
            isClockWise: function(t) {
                return sh.area(t) < 0
            },
            triangulateShape: function(t, e) {
                var i = [],
                    n = [],
                    r = [];
                oh(t), lh(i, t);
                var a = t.length;
                e.forEach(oh);
                for (var s = 0; s < e.length; s++) n.push(a), a += e[s].length, lh(i, e[s]);
                for (var o = jl(i, n), l = 0; l < o.length; l += 3) r.push(o.slice(l, l + 3));
                return r
            }
        };

        function oh(t) {
            var e = t.length;
            2 < e && t[e - 1].equals(t[0]) && t.pop()
        }

        function lh(t, e) {
            for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
        }
        i.ShapeUtils = sh;
        var hh = function() {
            d(r, Vr);
            var n = y(r);

            function r(t, e) {
                var i;
                return V(this, r), (i = n.call(this)).type = "ExtrudeGeometry", i.parameters = {
                    shapes: t,
                    options: e
                }, i.fromBufferGeometry(new uh(t, e)), i.mergeVertices(), i
            }
            return g(r, [{
                key: "toJSON",
                value: function() {
                    var t = h(f(r.prototype), "toJSON", this).call(this);
                    return ph(this.parameters.shapes, this.parameters.options, t)
                }
            }]), r
        }();
        i.ExtrudeGeometry = hh;
        var uh = function() {
            d(a, gr);
            var r = y(a);

            function a(t, Lt) {
                var e;
                V(this, a), (e = r.call(this)).type = "ExtrudeBufferGeometry", e.parameters = {
                    shapes: t,
                    options: Lt
                }, t = Array.isArray(t) ? t : [t];
                for (var kt = u(e), Ot = [], Ft = [], i = 0, n = t.length; i < n; i++) {
                    ! function(t) {
                        var n = [],
                            e = void 0 !== Lt.curveSegments ? Lt.curveSegments : 12,
                            c = void 0 !== Lt.steps ? Lt.steps : 1,
                            i = void 0 !== Lt.depth ? Lt.depth : 100,
                            p = void 0 === Lt.bevelEnabled || Lt.bevelEnabled,
                            r = void 0 !== Lt.bevelThickness ? Lt.bevelThickness : 6,
                            a = void 0 !== Lt.bevelSize ? Lt.bevelSize : r - 2,
                            s = void 0 !== Lt.bevelOffset ? Lt.bevelOffset : 0,
                            d = void 0 !== Lt.bevelSegments ? Lt.bevelSegments : 3,
                            o = Lt.extrudePath,
                            h = void 0 !== Lt.UVGenerator ? Lt.UVGenerator : ch;
                        void 0 !== Lt.amount && (i = Lt.amount);
                        var l, u, f, m, g, v = !1;
                        o && (l = o.getSpacedPoints(c), p = !(v = !0), u = o.computeFrenetFrames(c, !1), f = new wi, m = new wi, g = new wi);
                        p || (s = a = r = d = 0);
                        var y = t.extractPoints(e),
                            b = y.shape,
                            x = y.holes;
                        if (!sh.isClockWise(b)) {
                            b = b.reverse();
                            for (var _ = 0, w = x.length; _ < w; _++) {
                                var S = x[_];
                                sh.isClockWise(S) && (x[_] = S.reverse())
                            }
                        }
                        for (var M = sh.triangulateShape(b, x), T = b, C = 0, A = x.length; C < A; C++) {
                            var E = x[C];
                            b = b.concat(E)
                        }

                        function D(t, e, i) {
                            return e.clone().multiplyScalar(i).add(t)
                        }
                        var P = b.length,
                            L = M.length;

                        function k(t, e, i) {
                            var n, r = t.x - e.x,
                                a = t.y - e.y,
                                s = i.x - t.x,
                                o = i.y - t.y,
                                l = r * r + a * a,
                                h = r * o - a * s;
                            if (Math.abs(h) > Number.EPSILON) {
                                var u, c, p = Math.sqrt(l),
                                    d = Math.sqrt(s * s + o * o),
                                    f = e.x - a / p,
                                    m = e.y + r / p,
                                    g = ((i.x - o / d - f) * o - (i.y + s / d - m) * s) / (r * o - a * s),
                                    v = (u = f + r * g - t.x) * u + (c = m + a * g - t.y) * c;
                                if (v <= 2) return new pi(u, c);
                                n = Math.sqrt(v / 2)
                            } else {
                                var y = !1;
                                r > Number.EPSILON ? s > Number.EPSILON && (y = !0) : r < -Number.EPSILON ? s < -Number.EPSILON && (y = !0) : Math.sign(a) === Math.sign(o) && (y = !0), n = y ? (u = -a, c = r, Math.sqrt(l)) : (u = r, c = a, Math.sqrt(l / 2))
                            }
                            return new pi(u / n, c / n)
                        }
                        for (var O = [], F = 0, I = T.length, N = I - 1, B = F + 1; F < I; F++, N++, B++) N === I && (N = 0), B === I && (B = 0), O[F] = k(T[F], T[N], T[B]);
                        for (var R, z = [], G = O.concat(), V = 0, U = x.length; V < U; V++) {
                            var j = x[V];
                            R = [];
                            for (var H = 0, W = j.length, q = W - 1, X = H + 1; H < W; H++, q++, X++) q === W && (q = 0), X === W && (X = 0), R[H] = k(j[H], j[q], j[X]);
                            z.push(R), G = G.concat(R)
                        }
                        for (var Y = 0; Y < d; Y++) {
                            for (var J = Y / d, Z = r * Math.cos(J * Math.PI / 2), $ = a * Math.sin(J * Math.PI / 2) + s, K = 0, Q = T.length; K < Q; K++) {
                                var tt = D(T[K], O[K], $);
                                At(tt.x, tt.y, -Z)
                            }
                            for (var et = 0, it = x.length; et < it; et++) {
                                var nt = x[et];
                                R = z[et];
                                for (var rt = 0, at = nt.length; rt < at; rt++) {
                                    var st = D(nt[rt], R[rt], $);
                                    At(st.x, st.y, -Z)
                                }
                            }
                        }
                        for (var ot = a + s, lt = 0; lt < P; lt++) {
                            var ht = p ? D(b[lt], G[lt], ot) : b[lt];
                            v ? (m.copy(u.normals[0]).multiplyScalar(ht.x), f.copy(u.binormals[0]).multiplyScalar(ht.y), g.copy(l[0]).add(m).add(f), At(g.x, g.y, g.z)) : At(ht.x, ht.y, 0)
                        }
                        for (var ut = 1; ut <= c; ut++)
                            for (var ct = 0; ct < P; ct++) {
                                var pt = p ? D(b[ct], G[ct], ot) : b[ct];
                                v ? (m.copy(u.normals[ut]).multiplyScalar(pt.x), f.copy(u.binormals[ut]).multiplyScalar(pt.y), g.copy(l[ut]).add(m).add(f), At(g.x, g.y, g.z)) : At(pt.x, pt.y, i / c * ut)
                            }
                        for (var dt = d - 1; 0 <= dt; dt--) {
                            for (var ft = dt / d, mt = r * Math.cos(ft * Math.PI / 2), gt = a * Math.sin(ft * Math.PI / 2) + s, vt = 0, yt = T.length; vt < yt; vt++) {
                                var bt = D(T[vt], O[vt], gt);
                                At(bt.x, bt.y, i + mt)
                            }
                            for (var xt = 0, _t = x.length; xt < _t; xt++) {
                                var wt = x[xt];
                                R = z[xt];
                                for (var St = 0, Mt = wt.length; St < Mt; St++) {
                                    var Tt = D(wt[St], R[St], gt);
                                    v ? At(Tt.x, Tt.y + l[c - 1].y, l[c - 1].x + mt) : At(Tt.x, Tt.y, i + mt)
                                }
                            }
                        }

                        function Ct(t, e) {
                            for (var i = t.length; 0 <= --i;) {
                                var n = i,
                                    r = i - 1;
                                r < 0 && (r = t.length - 1);
                                for (var a = 0, s = c + 2 * d; a < s; a++) {
                                    var o = P * a,
                                        l = P * (a + 1);
                                    ! function(t, e, i, n) {
                                        Dt(t), Dt(e), Dt(n), Dt(e), Dt(i), Dt(n);
                                        var r = Ot.length / 3,
                                            a = h.generateSideWallUV(kt, Ot, r - 6, r - 3, r - 2, r - 1);
                                        Pt(a[0]), Pt(a[1]), Pt(a[3]), Pt(a[1]), Pt(a[2]), Pt(a[3])
                                    }(e + n + o, e + r + o, e + r + l, e + n + l)
                                }
                            }
                        }

                        function At(t, e, i) {
                            n.push(t), n.push(e), n.push(i)
                        }

                        function Et(t, e, i) {
                            Dt(t), Dt(e), Dt(i);
                            var n = Ot.length / 3,
                                r = h.generateTopUV(kt, Ot, n - 3, n - 2, n - 1);
                            Pt(r[0]), Pt(r[1]), Pt(r[2])
                        }

                        function Dt(t) {
                            Ot.push(n[3 * t + 0]), Ot.push(n[3 * t + 1]), Ot.push(n[3 * t + 2])
                        }

                        function Pt(t) {
                            Ft.push(t.x), Ft.push(t.y)
                        }(function() {
                            var t = Ot.length / 3;
                            if (p) {
                                for (var e = 0, i = P * e, n = 0; n < L; n++) {
                                    var r = M[n];
                                    Et(r[2] + i, r[1] + i, r[0] + i)
                                }
                                i = P * (e = c + 2 * d);
                                for (var a = 0; a < L; a++) {
                                    var s = M[a];
                                    Et(s[0] + i, s[1] + i, s[2] + i)
                                }
                            } else {
                                for (var o = 0; o < L; o++) {
                                    var l = M[o];
                                    Et(l[2], l[1], l[0])
                                }
                                for (var h = 0; h < L; h++) {
                                    var u = M[h];
                                    Et(u[0] + P * c, u[1] + P * c, u[2] + P * c)
                                }
                            }
                            kt.addGroup(t, Ot.length / 3 - t, 0)
                        })(),
                        function() {
                            var t = Ot.length / 3,
                                e = 0;
                            Ct(T, e), e += T.length;
                            for (var i = 0, n = x.length; i < n; i++) {
                                var r = x[i];
                                Ct(r, e), e += r.length
                            }
                            kt.addGroup(t, Ot.length / 3 - t, 1)
                        }()
                    }(t[i])
                }
                return e.setAttribute("position", new ar(Ot, 3)), e.setAttribute("uv", new ar(Ft, 2)), e.computeVertexNormals(), e
            }
            return g(a, [{
                key: "toJSON",
                value: function() {
                    var t = gr.prototype.toJSON.call(this);
                    return ph(this.parameters.shapes, this.parameters.options, t)
                }
            }]), a
        }();
        i.ExtrudeBufferGeometry = uh;
        var ch = {
            generateTopUV: function(t, e, i, n, r) {
                var a = e[3 * i],
                    s = e[3 * i + 1],
                    o = e[3 * n],
                    l = e[3 * n + 1],
                    h = e[3 * r],
                    u = e[3 * r + 1];
                return [new pi(a, s), new pi(o, l), new pi(h, u)]
            },
            generateSideWallUV: function(t, e, i, n, r, a) {
                var s = e[3 * i],
                    o = e[3 * i + 1],
                    l = e[3 * i + 2],
                    h = e[3 * n],
                    u = e[3 * n + 1],
                    c = e[3 * n + 2],
                    p = e[3 * r],
                    d = e[3 * r + 1],
                    f = e[3 * r + 2],
                    m = e[3 * a],
                    g = e[3 * a + 1],
                    v = e[3 * a + 2];
                return Math.abs(o - u) < .01 ? [new pi(s, 1 - l), new pi(h, 1 - c), new pi(p, 1 - f), new pi(m, 1 - v)] : [new pi(o, 1 - l), new pi(u, 1 - c), new pi(d, 1 - f), new pi(g, 1 - v)]
            }
        };

        function ph(t, e, i) {
            if (i.shapes = [], Array.isArray(t))
                for (var n = 0, r = t.length; n < r; n++) {
                    var a = t[n];
                    i.shapes.push(a.uuid)
                } else i.shapes.push(t.uuid);
            return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
        }
        var dh = function() {
            d(r, Vr);
            var n = y(r);

            function r(t, e) {
                var i;
                return V(this, r), (i = n.call(this)).type = "TextGeometry", i.parameters = {
                    text: t,
                    parameters: e
                }, i.fromBufferGeometry(new fh(t, e)), i.mergeVertices(), i
            }
            return r
        }();
        i.TextGeometry = dh;
        var fh = function() {
            d(s, uh);
            var a = y(s);

            function s(t, e) {
                var i;
                V(this, s);
                var n = (e = e || {}).font;
                if (!n || !n.isFont) return o(i, new Vr);
                var r = n.generateShapes(t, e.size);
                return e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), (i = a.call(this, r, e)).type = "TextBufferGeometry", i
            }
            return s
        }();
        i.TextBufferGeometry = fh;
        var mh = function() {
            d(h, Vr);
            var l = y(h);

            function h(t, e, i, n, r, a, s) {
                var o;
                return V(this, h), (o = l.call(this)).type = "SphereGeometry", o.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: i,
                    phiStart: n,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: s
                }, o.fromBufferGeometry(new gh(t, e, i, n, r, a, s)), o.mergeVertices(), o
            }
            return h
        }();
        i.SphereGeometry = mh;
        var gh = function() {
            d(P, gr);
            var D = y(P);

            function P(t, e, i, n, r, a, s) {
                var o;
                V(this, P), (o = D.call(this)).type = "SphereBufferGeometry", o.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: i,
                    phiStart: n,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: s
                }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : Math.PI;
                for (var l = Math.min(a + s, Math.PI), h = 0, u = [], c = new wi, p = new wi, d = [], f = [], m = [], g = [], v = 0; v <= i; v++) {
                    var y = [],
                        b = v / i,
                        x = 0;
                    0 == v && 0 == a ? x = .5 / e : v == i && l == Math.PI && (x = -.5 / e);
                    for (var _ = 0; _ <= e; _++) {
                        var w = _ / e;
                        c.x = -t * Math.cos(n + w * r) * Math.sin(a + b * s), c.y = t * Math.cos(a + b * s), c.z = t * Math.sin(n + w * r) * Math.sin(a + b * s), f.push(c.x, c.y, c.z), p.copy(c).normalize(), m.push(p.x, p.y, p.z), g.push(w + x, 1 - b), y.push(h++)
                    }
                    u.push(y)
                }
                for (var S = 0; S < i; S++)
                    for (var M = 0; M < e; M++) {
                        var T = u[S][M + 1],
                            C = u[S][M],
                            A = u[S + 1][M],
                            E = u[S + 1][M + 1];
                        (0 !== S || 0 < a) && d.push(T, C, E), (S !== i - 1 || l < Math.PI) && d.push(C, A, E)
                    }
                return o.setIndex(d), o.setAttribute("position", new ar(f, 3)), o.setAttribute("normal", new ar(m, 3)), o.setAttribute("uv", new ar(g, 2)), o
            }
            return P
        }();
        i.SphereBufferGeometry = gh;
        var vh = function() {
            d(l, Vr);
            var o = y(l);

            function l(t, e, i, n, r, a) {
                var s;
                return V(this, l), (s = o.call(this)).type = "RingGeometry", s.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: r,
                    thetaLength: a
                }, s.fromBufferGeometry(new yh(t, e, i, n, r, a)), s.mergeVertices(), s
            }
            return l
        }();
        i.RingGeometry = vh;
        var yh = function() {
            d(C, gr);
            var T = y(C);

            function C(t, e, i, n, r, a) {
                var s;
                V(this, C), (s = T.call(this)).type = "RingBufferGeometry", s.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: r,
                    thetaLength: a
                }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
                for (var o = [], l = [], h = [], u = [], c = t, p = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1), d = new wi, f = new pi, m = 0; m <= n; m++) {
                    for (var g = 0; g <= i; g++) {
                        var v = r + g / i * a;
                        d.x = c * Math.cos(v), d.y = c * Math.sin(v), l.push(d.x, d.y, d.z), h.push(0, 0, 1), f.x = (d.x / e + 1) / 2, f.y = (d.y / e + 1) / 2, u.push(f.x, f.y)
                    }
                    c += p
                }
                for (var y = 0; y < n; y++)
                    for (var b = y * (i + 1), x = 0; x < i; x++) {
                        var _ = x + b,
                            w = _ + i + 1,
                            S = _ + i + 2,
                            M = _ + 1;
                        o.push(_, w, M), o.push(w, S, M)
                    }
                return s.setIndex(o), s.setAttribute("position", new ar(l, 3)), s.setAttribute("normal", new ar(h, 3)), s.setAttribute("uv", new ar(u, 2)), s
            }
            return C
        }();
        i.RingBufferGeometry = yh;
        var bh = function() {
            d(s, Vr);
            var a = y(s);

            function s(t, e, i, n) {
                var r;
                return V(this, s), (r = a.call(this)).type = "LatheGeometry", r.parameters = {
                    points: t,
                    segments: e,
                    phiStart: i,
                    phiLength: n
                }, r.fromBufferGeometry(new xh(t, e, i, n)), r.mergeVertices(), r
            }
            return s
        }();
        i.LatheGeometry = bh;
        var xh = function() {
            d(P, gr);
            var D = y(P);

            function P(t, e, i, n) {
                var r;
                V(this, P), (r = D.call(this)).type = "LatheBufferGeometry", r.parameters = {
                    points: t,
                    segments: e,
                    phiStart: i,
                    phiLength: n
                }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = ci.clamp(n, 0, 2 * Math.PI);
                for (var a = [], s = [], o = [], l = 1 / e, h = new wi, u = new pi, c = 0; c <= e; c++)
                    for (var p = i + c * l * n, d = Math.sin(p), f = Math.cos(p), m = 0; m <= t.length - 1; m++) h.x = t[m].x * d, h.y = t[m].y, h.z = t[m].x * f, s.push(h.x, h.y, h.z), u.x = c / e, u.y = m / (t.length - 1), o.push(u.x, u.y);
                for (var g = 0; g < e; g++)
                    for (var v = 0; v < t.length - 1; v++) {
                        var y = v + g * t.length,
                            b = y + t.length,
                            x = y + t.length + 1,
                            _ = y + 1;
                        a.push(y, b, _), a.push(b, x, _)
                    }
                if (r.setIndex(a), r.setAttribute("position", new ar(s, 3)), r.setAttribute("uv", new ar(o, 2)), r.computeVertexNormals(), n === 2 * Math.PI)
                    for (var w = r.attributes.normal.array, S = new wi, M = new wi, T = new wi, C = e * t.length * 3, A = 0, E = 0; A < t.length; A++, E += 3) S.x = w[E + 0], S.y = w[E + 1], S.z = w[E + 2], M.x = w[C + E + 0], M.y = w[C + E + 1], M.z = w[C + E + 2], T.addVectors(S, M).normalize(), w[E + 0] = w[C + E + 0] = T.x, w[E + 1] = w[C + E + 1] = T.y, w[E + 2] = w[C + E + 2] = T.z;
                return r
            }
            return P
        }();
        i.LatheBufferGeometry = xh;
        var _h = function() {
            d(r, Vr);
            var n = y(r);

            function r(t, e) {
                var i;
                return V(this, r), (i = n.call(this)).type = "ShapeGeometry", "object" === a(e) && (e = e.curveSegments), i.parameters = {
                    shapes: t,
                    curveSegments: e
                }, i.fromBufferGeometry(new wh(t, e)), i.mergeVertices(), i
            }
            return g(r, [{
                key: "toJSON",
                value: function() {
                    var t = Vr.prototype.toJSON.call(this);
                    return Sh(this.parameters.shapes, t)
                }
            }]), r
        }();
        i.ShapeGeometry = _h;
        var wh = function() {
            d(s, gr);
            var a = y(s);

            function s(t, _) {
                var e;
                V(this, s), (e = a.call(this)).type = "ShapeBufferGeometry", e.parameters = {
                    shapes: t,
                    curveSegments: _
                }, _ = _ || 12;
                var w = [],
                    S = [],
                    M = [],
                    T = [],
                    i = 0,
                    C = 0;
                if (!1 === Array.isArray(t)) r(t);
                else
                    for (var n = 0; n < t.length; n++) r(t[n]), e.addGroup(i, C, n), i += C, C = 0;

                function r(t) {
                    var e = S.length / 3,
                        i = t.extractPoints(_),
                        n = i.shape,
                        r = i.holes;
                    !1 === sh.isClockWise(n) && (n = n.reverse());
                    for (var a = 0, s = r.length; a < s; a++) {
                        var o = r[a];
                        !0 === sh.isClockWise(o) && (r[a] = o.reverse())
                    }
                    for (var l = sh.triangulateShape(n, r), h = 0, u = r.length; h < u; h++) var c = r[h],
                        n = n.concat(c);
                    for (var p = 0, d = n.length; p < d; p++) {
                        var f = n[p];
                        S.push(f.x, f.y, 0), M.push(0, 0, 1), T.push(f.x, f.y)
                    }
                    for (var m = 0, g = l.length; m < g; m++) {
                        var v = l[m],
                            y = v[0] + e,
                            b = v[1] + e,
                            x = v[2] + e;
                        w.push(y, b, x), C += 3
                    }
                }
                return e.setIndex(w), e.setAttribute("position", new ar(S, 3)), e.setAttribute("normal", new ar(M, 3)), e.setAttribute("uv", new ar(T, 2)), e
            }
            return g(s, [{
                key: "toJSON",
                value: function() {
                    var t = gr.prototype.toJSON.call(this);
                    return Sh(this.parameters.shapes, t)
                }
            }]), s
        }();

        function Sh(t, e) {
            if (e.shapes = [], Array.isArray(t))
                for (var i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.shapes.push(r.uuid)
                } else e.shapes.push(t.uuid);
            return e
        }
        i.ShapeBufferGeometry = wh;
        var Mh = function() {
            d(_, gr);
            var x = y(_);

            function _(t, e) {
                var i;
                V(this, _), (i = x.call(this)).type = "EdgesGeometry", i.parameters = {
                    thresholdAngle: e
                }, e = void 0 !== e ? e : 1;
                var n, r, a, s, o = [],
                    l = Math.cos(ci.DEG2RAD * e),
                    h = [0, 0],
                    u = {},
                    c = ["a", "b", "c"];
                t.isBufferGeometry ? (s = new Vr).fromBufferGeometry(t) : s = t.clone(), s.mergeVertices(), s.computeFaceNormals();
                for (var p = s.vertices, d = s.faces, f = 0, m = d.length; f < m; f++)
                    for (var g = d[f], v = 0; v < 3; v++) n = g[c[v]], r = g[c[(v + 1) % 3]], h[0] = Math.min(n, r), h[1] = Math.max(n, r), void 0 === u[a = h[0] + "," + h[1]] ? u[a] = {
                        index1: h[0],
                        index2: h[1],
                        face1: f,
                        face2: void 0
                    } : u[a].face2 = f;
                for (a in u) {
                    var y, b = u[a];
                    (void 0 === b.face2 || d[b.face1].normal.dot(d[b.face2].normal) <= l) && (y = p[b.index1], o.push(y.x, y.y, y.z), y = p[b.index2], o.push(y.x, y.y, y.z))
                }
                return i.setAttribute("position", new ar(o, 3)), i
            }
            return _
        }();
        i.EdgesGeometry = Mh;
        var Th = function() {
            d(u, Vr);
            var h = y(u);

            function u(t, e, i, n, r, a, s, o) {
                var l;
                return V(this, u), (l = h.call(this)).type = "CylinderGeometry", l.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: i,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: a,
                    thetaStart: s,
                    thetaLength: o
                }, l.fromBufferGeometry(new Ch(t, e, i, n, r, a, s, o)), l.mergeVertices(), l
            }
            return u
        }();
        i.CylinderGeometry = Th;
        var Ch = function() {
            d(r, gr);
            var n = y(r);

            function r(b, x, _, w, S, t, M, T) {
                var e;
                V(this, r), (e = n.call(this)).type = "CylinderBufferGeometry", e.parameters = {
                    radiusTop: b,
                    radiusBottom: x,
                    height: _,
                    radialSegments: w,
                    heightSegments: S,
                    openEnded: t,
                    thetaStart: M,
                    thetaLength: T
                };
                var C = u(e);
                b = void 0 !== b ? b : 1, x = void 0 !== x ? x : 1, _ = _ || 1, w = Math.floor(w) || 8, S = Math.floor(S) || 1, t = void 0 !== t && t, M = void 0 !== M ? M : 0, T = void 0 !== T ? T : 2 * Math.PI;
                var A = [],
                    E = [],
                    D = [],
                    P = [],
                    L = 0,
                    k = [],
                    O = _ / 2,
                    F = 0;

                function i(t) {
                    for (var e = L, i = new pi, n = new wi, r = 0, a = !0 === t ? b : x, s = !0 === t ? 1 : -1, o = 1; o <= w; o++) E.push(0, O * s, 0), D.push(0, s, 0), P.push(.5, .5), L++;
                    for (var l = L, h = 0; h <= w; h++) {
                        var u = h / w * T + M,
                            c = Math.cos(u),
                            p = Math.sin(u);
                        n.x = a * p, n.y = O * s, n.z = a * c, E.push(n.x, n.y, n.z), D.push(0, s, 0), i.x = .5 * c + .5, i.y = .5 * p * s + .5, P.push(i.x, i.y), L++
                    }
                    for (var d = 0; d < w; d++) {
                        var f = e + d,
                            m = l + d;
                        !0 === t ? A.push(m, m + 1, f) : A.push(m + 1, m, f), r += 3
                    }
                    C.addGroup(F, r, !0 === t ? 1 : 2), F += r
                }
                return function() {
                    for (var t = new wi, e = new wi, i = 0, n = (x - b) / _, r = 0; r <= S; r++) {
                        for (var a = [], s = r / S, o = s * (x - b) + b, l = 0; l <= w; l++) {
                            var h = l / w,
                                u = h * T + M,
                                c = Math.sin(u),
                                p = Math.cos(u);
                            e.x = o * c, e.y = -s * _ + O, e.z = o * p, E.push(e.x, e.y, e.z), t.set(c, n, p).normalize(), D.push(t.x, t.y, t.z), P.push(h, 1 - s), a.push(L++)
                        }
                        k.push(a)
                    }
                    for (var d = 0; d < w; d++)
                        for (var f = 0; f < S; f++) {
                            var m = k[f][d],
                                g = k[f + 1][d],
                                v = k[f + 1][d + 1],
                                y = k[f][d + 1];
                            A.push(m, g, y), A.push(g, v, y), i += 6
                        }
                    C.addGroup(F, i, 0), F += i
                }(), !1 === t && (0 < b && i(!0), 0 < x && i(!1)), e.setIndex(A), e.setAttribute("position", new ar(E, 3)), e.setAttribute("normal", new ar(D, 3)), e.setAttribute("uv", new ar(P, 2)), e
            }
            return r
        }();
        i.CylinderBufferGeometry = Ch;
        var Ah = function() {
            d(h, Th);
            var l = y(h);

            function h(t, e, i, n, r, a, s) {
                var o;
                return V(this, h), (o = l.call(this, 0, t, e, i, n, r, a, s)).type = "ConeGeometry", o.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: i,
                    heightSegments: n,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: s
                }, o
            }
            return h
        }();
        i.ConeGeometry = Ah;
        var Eh = function() {
            d(h, Ch);
            var l = y(h);

            function h(t, e, i, n, r, a, s) {
                var o;
                return V(this, h), (o = l.call(this, 0, t, e, i, n, r, a, s)).type = "ConeBufferGeometry", o.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: i,
                    heightSegments: n,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: s
                }, o
            }
            return h
        }();
        i.ConeBufferGeometry = Eh;
        var Dh = function() {
            d(s, Vr);
            var a = y(s);

            function s(t, e, i, n) {
                var r;
                return V(this, s), (r = a.call(this)).type = "CircleGeometry", r.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: i,
                    thetaLength: n
                }, r.fromBufferGeometry(new Ph(t, e, i, n)), r.mergeVertices(), r
            }
            return s
        }();
        i.CircleGeometry = Dh;
        var Ph = function() {
            d(g, gr);
            var m = y(g);

            function g(t, e, i, n) {
                var r;
                V(this, g), (r = m.call(this)).type = "CircleBufferGeometry", r.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: i,
                    thetaLength: n
                }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI;
                var a = [],
                    s = [],
                    o = [],
                    l = [],
                    h = new wi,
                    u = new pi;
                s.push(0, 0, 0), o.push(0, 0, 1), l.push(.5, .5);
                for (var c = 0, p = 3; c <= e; c++, p += 3) {
                    var d = i + c / e * n;
                    h.x = t * Math.cos(d), h.y = t * Math.sin(d), s.push(h.x, h.y, h.z), o.push(0, 0, 1), u.x = (s[p] / t + 1) / 2, u.y = (s[p + 1] / t + 1) / 2, l.push(u.x, u.y)
                }
                for (var f = 1; f <= e; f++) a.push(f, f + 1, 0);
                return r.setIndex(a), r.setAttribute("position", new ar(s, 3)), r.setAttribute("normal", new ar(o, 3)), r.setAttribute("uv", new ar(l, 2)), r
            }
            return g
        }();
        i.CircleBufferGeometry = Ph;
        var Lh = Object.freeze({
            __proto__: null,
            WireframeGeometry: Ml,
            ParametricGeometry: Tl,
            ParametricBufferGeometry: Cl,
            TetrahedronGeometry: Dl,
            TetrahedronBufferGeometry: Pl,
            OctahedronGeometry: Ll,
            OctahedronBufferGeometry: kl,
            IcosahedronGeometry: Ol,
            IcosahedronBufferGeometry: Fl,
            DodecahedronGeometry: Il,
            DodecahedronBufferGeometry: Nl,
            PolyhedronGeometry: Al,
            PolyhedronBufferGeometry: El,
            TubeGeometry: Bl,
            TubeBufferGeometry: Rl,
            TorusKnotGeometry: zl,
            TorusKnotBufferGeometry: Gl,
            TorusGeometry: Vl,
            TorusBufferGeometry: Ul,
            TextGeometry: dh,
            TextBufferGeometry: fh,
            SphereGeometry: mh,
            SphereBufferGeometry: gh,
            RingGeometry: vh,
            RingBufferGeometry: yh,
            PlaneGeometry: la,
            PlaneBufferGeometry: ha,
            LatheGeometry: bh,
            LatheBufferGeometry: xh,
            ShapeGeometry: _h,
            ShapeBufferGeometry: wh,
            ExtrudeGeometry: hh,
            ExtrudeBufferGeometry: uh,
            EdgesGeometry: Mh,
            ConeGeometry: Ah,
            ConeBufferGeometry: Eh,
            CylinderGeometry: Th,
            CylinderBufferGeometry: Ch,
            CircleGeometry: Dh,
            CircleBufferGeometry: Ph,
            BoxGeometry: Ur,
            BoxBufferGeometry: jr
        });

        function kh(t) {
            Xn.call(this), this.type = "ShadowMaterial", this.color = new Hn(0), this.transparent = !0, this.setValues(t)
        }

        function Oh(t) {
            Jr.call(this, t), this.type = "RawShaderMaterial"
        }

        function Fh(t) {
            Xn.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new Hn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ti, this.normalScale = new pi(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t)
        }

        function Ih(t) {
            Fh.call(this), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new pi(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t)
        }

        function Nh(t) {
            Xn.call(this), this.type = "MeshPhongMaterial", this.color = new Hn(16777215), this.specular = new Hn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ti, this.normalScale = new pi(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = R, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Bh(t) {
            Xn.call(this), this.defines = {
                TOON: ""
            }, this.type = "MeshToonMaterial", this.color = new Hn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ti, this.normalScale = new pi(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Rh(t) {
            Xn.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ti, this.normalScale = new pi(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function zh(t) {
            Xn.call(this), this.type = "MeshLambertMaterial", this.color = new Hn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = R, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Gh(t) {
            Xn.call(this), this.defines = {
                MATCAP: ""
            }, this.type = "MeshMatcapMaterial", this.color = new Hn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ti, this.normalScale = new pi(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function Vh(t) {
            il.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
        }((kh.prototype = Object.create(Xn.prototype)).constructor = kh).prototype.isShadowMaterial = !0, kh.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.color.copy(t.color), this
        }, ((Oh.prototype = Object.create(Jr.prototype)).constructor = Oh).prototype.isRawShaderMaterial = !0, ((Fh.prototype = Object.create(Xn.prototype)).constructor = Fh).prototype.isMeshStandardMaterial = !0, Fh.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.defines = {
                STANDARD: ""
            }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this
        }, ((Ih.prototype = Object.create(Fh.prototype)).constructor = Ih).prototype.isMeshPhysicalMaterial = !0, Ih.prototype.copy = function(t) {
            return Fh.prototype.copy.call(this, t), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Hn).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this
        }, ((Nh.prototype = Object.create(Xn.prototype)).constructor = Nh).prototype.isMeshPhongMaterial = !0, Nh.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, ((Bh.prototype = Object.create(Xn.prototype)).constructor = Bh).prototype.isMeshToonMaterial = !0, Bh.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, ((Rh.prototype = Object.create(Xn.prototype)).constructor = Rh).prototype.isMeshNormalMaterial = !0, Rh.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, ((zh.prototype = Object.create(Xn.prototype)).constructor = zh).prototype.isMeshLambertMaterial = !0, zh.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, ((Gh.prototype = Object.create(Xn.prototype)).constructor = Gh).prototype.isMeshMatcapMaterial = !0, Gh.prototype.copy = function(t) {
            return Xn.prototype.copy.call(this, t), this.defines = {
                MATCAP: ""
            }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, ((Vh.prototype = Object.create(il.prototype)).constructor = Vh).prototype.isLineDashedMaterial = !0, Vh.prototype.copy = function(t) {
            return il.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
        };
        var Uh = Object.freeze({
                __proto__: null,
                ShadowMaterial: kh,
                SpriteMaterial: So,
                RawShaderMaterial: Oh,
                ShaderMaterial: Jr,
                PointsMaterial: dl,
                MeshPhysicalMaterial: Ih,
                MeshStandardMaterial: Fh,
                MeshPhongMaterial: Nh,
                MeshToonMaterial: Bh,
                MeshNormalMaterial: Rh,
                MeshLambertMaterial: zh,
                MeshDepthMaterial: to,
                MeshDistanceMaterial: eo,
                MeshBasicMaterial: Yn,
                MeshMatcapMaterial: Gh,
                LineDashedMaterial: Vh,
                LineBasicMaterial: il,
                Material: Xn
            }),
            jh = {
                arraySlice: function(t, e, i) {
                    return jh.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
                },
                convertArray: function(t, e, i) {
                    return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                },
                isTypedArray: function(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                },
                getKeyframeOrder: function(i) {
                    for (var t = i.length, e = new Array(t), n = 0; n !== t; ++n) e[n] = n;
                    return e.sort(function(t, e) {
                        return i[t] - i[e]
                    }), e
                },
                sortedArray: function(t, e, i) {
                    for (var n = t.length, r = new t.constructor(n), a = 0, s = 0; s !== n; ++a)
                        for (var o = i[a] * e, l = 0; l !== e; ++l) r[s++] = t[o + l];
                    return r
                },
                flattenJSON: function(t, e, i, n) {
                    for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n];) a = t[r++];
                    if (void 0 !== a) {
                        var s = a[n];
                        if (void 0 !== s)
                            if (Array.isArray(s))
                                for (; void 0 !== (s = a[n]) && (e.push(a.time), i.push.apply(i, s)), void 0 !== (a = t[r++]););
                            else if (void 0 !== s.toArray)
                            for (; void 0 !== (s = a[n]) && (e.push(a.time), s.toArray(i, i.length)), void 0 !== (a = t[r++]););
                        else
                            for (; void 0 !== (s = a[n]) && (e.push(a.time), i.push(s)), void 0 !== (a = t[r++]););
                    }
                },
                subclip: function(t, e, i, n, r) {
                    r = r || 30;
                    var a = t.clone();
                    a.name = e;
                    for (var s = [], o = 0; o < a.tracks.length; ++o) {
                        for (var l = a.tracks[o], h = l.getValueSize(), u = [], c = [], p = 0; p < l.times.length; ++p) {
                            var d = l.times[p] * r;
                            if (!(d < i || n <= d)) {
                                u.push(l.times[p]);
                                for (var f = 0; f < h; ++f) c.push(l.values[p * h + f])
                            }
                        }
                        0 !== u.length && (l.times = jh.convertArray(u, l.times.constructor), l.values = jh.convertArray(c, l.values.constructor), s.push(l))
                    }
                    a.tracks = s;
                    for (var m = 1 / 0, g = 0; g < a.tracks.length; ++g) m > a.tracks[g].times[0] && (m = a.tracks[g].times[0]);
                    for (var v = 0; v < a.tracks.length; ++v) a.tracks[v].shift(-1 * m);
                    return a.resetDuration(), a
                },
                makeClipAdditive: function(_, t, w, e) {
                    void 0 === t && (t = 0), void 0 === w && (w = _), (void 0 === e || e <= 0) && (e = 30);
                    for (var i = _.tracks.length, S = t / e, n = 0; n < i; ++n)(function(t) {
                        var e = w.tracks[t],
                            i = e.ValueTypeName;
                        if ("bool" === i || "string" === i) return;
                        var n = _.tracks.find(function(t) {
                            return t.name === e.name && t.ValueTypeName === i
                        });
                        if (void 0 === n) return;
                        var r = 0,
                            a = e.getValueSize();
                        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (r = a / 3);
                        var s = 0,
                            o = n.getValueSize();
                        n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = o / 3);
                        var l, h, u, c, p, d, f = e.times.length - 1,
                            m = void 0;
                        m = S <= e.times[0] ? (l = a - r, jh.arraySlice(e.values, r, l)) : S >= e.times[f] ? (u = (h = f * a + r) + a - r, jh.arraySlice(e.values, h, u)) : (d = a - (p = r), (c = e.createInterpolant()).evaluate(S), jh.arraySlice(c.resultBuffer, p, d)), "quaternion" === i && (new _i).fromArray(m).normalize().conjugate().toArray(m);
                        for (var g = n.times.length, v = 0; v < g; ++v) {
                            var y = v * o + s;
                            if ("quaternion" === i) _i.multiplyQuaternionsFlat(n.values, y, m, 0, n.values, y);
                            else
                                for (var b = o - 2 * s, x = 0; x < b; ++x) n.values[y + x] -= m[x]
                        }
                    })(n);
                    return _.blendMode = 2501, _
                }
            };

        function Hh(t, e, i, n) {
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
        }

        function Wh(t, e, i, n) {
            Hh.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
        }

        function qh(t, e, i, n) {
            Hh.call(this, t, e, i, n)
        }

        function Xh(t, e, i, n) {
            Hh.call(this, t, e, i, n)
        }

        function Yh(t, e, i, n) {
            if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            this.name = t, this.times = jh.convertArray(e, this.TimeBufferType), this.values = jh.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
        }

        function Jh(t, e, i) {
            Yh.call(this, t, e, i)
        }

        function Zh(t, e, i, n) {
            Yh.call(this, t, e, i, n)
        }

        function $h(t, e, i, n) {
            Yh.call(this, t, e, i, n)
        }

        function Kh(t, e, i, n) {
            Hh.call(this, t, e, i, n)
        }

        function Qh(t, e, i, n) {
            Yh.call(this, t, e, i, n)
        }

        function tu(t, e, i, n) {
            Yh.call(this, t, e, i, n)
        }

        function eu(t, e, i, n) {
            Yh.call(this, t, e, i, n)
        }

        function iu(t, e, i, n) {
            this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== n ? n : je, this.uuid = ci.generateUUID(), this.duration < 0 && this.resetDuration()
        }

        function nu(t) {
            if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            var e, i, n = function(t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return $h;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return eu;
                    case "color":
                        return Zh;
                    case "quaternion":
                        return Qh;
                    case "bool":
                    case "boolean":
                        return Jh;
                    case "string":
                        return tu
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            return void 0 === t.times && (e = [], i = [], jh.flattenJSON(t.keys, e, i, "value"), t.times = e, t.values = i), void 0 !== n.parse ? n.parse(t) : new n(t.name, t.times, t.values, t.interpolation)
        }
        i.AnimationUtils = jh, Object.assign(Hh.prototype, {
            evaluate: function(t) {
                var e, i = this.parameterPositions,
                    n = this._cachedIndex,
                    r = i[n],
                    a = i[n - 1];
                t: {
                    e: {
                        i: {
                            n: if (!(t < r)) {
                                for (var s = n + 2;;) {
                                    if (void 0 === r) {
                                        if (t < a) break n;
                                        return n = i.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, a)
                                    }
                                    if (n === s) break;
                                    if (a = r, t < (r = i[++n])) break e
                                }
                                e = i.length;
                                break i
                            }if (a <= t) break t;
                            var o = i[1];t < o && (n = 2, a = o);
                            for (var l = n - 2;;) {
                                if (void 0 === a) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                                if (n === l) break;
                                if (r = a, (a = i[--n - 1]) <= t) break e
                            }
                            e = n,
                            n = 0
                        }
                        for (; n < e;) {
                            var h = n + e >>> 1;
                            t < i[h] ? e = h : n = 1 + h
                        }
                        if (r = i[n], void 0 === (a = i[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                        if (void 0 === r) return n = i.length, this._cachedIndex = n, this.afterEnd_(n - 1, a, t)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, a, r)
                }
                return this.interpolate_(n, a, t, r)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(t) {
                for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, a = 0; a !== n; ++a) e[a] = i[r + a];
                return e
            },
            interpolate_: function() {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function() {}
        }), Object.assign(Hh.prototype, {
            beforeStart_: Hh.prototype.copySampleValue_,
            afterEnd_: Hh.prototype.copySampleValue_
        }), Wh.prototype = Object.assign(Object.create(Hh.prototype), {
            constructor: Wh,
            DefaultSettings_: {
                endingStart: Ge,
                endingEnd: Ge
            },
            intervalChanged_: function(t, e, i) {
                var n = this.parameterPositions,
                    r = t - 2,
                    a = t + 1,
                    s = n[r],
                    o = n[a];
                if (void 0 === s) switch (this.getSettings_().endingStart) {
                    case Ve:
                        r = t, s = 2 * e - i;
                        break;
                    case Ue:
                        s = e + n[r = n.length - 2] - n[r + 1];
                        break;
                    default:
                        r = t, s = i
                }
                if (void 0 === o) switch (this.getSettings_().endingEnd) {
                    case Ve:
                        a = t, o = 2 * i - e;
                        break;
                    case Ue:
                        o = i + n[a = 1] - n[0];
                        break;
                    default:
                        a = t - 1, o = e
                }
                var l = .5 * (i - e),
                    h = this.valueSize;
                this._weightPrev = l / (e - s), this._weightNext = l / (o - i), this._offsetPrev = r * h, this._offsetNext = a * h
            },
            interpolate_: function(t, e, i, n) {
                for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = t * s, l = o - s, h = this._offsetPrev, u = this._offsetNext, c = this._weightPrev, p = this._weightNext, d = (i - e) / (n - e), f = d * d, m = f * d, g = -c * m + 2 * c * f - c * d, v = (1 + c) * m + (-1.5 - 2 * c) * f + (-.5 + c) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, b = p * m - p * f, x = 0; x !== s; ++x) r[x] = g * a[h + x] + v * a[l + x] + y * a[o + x] + b * a[u + x];
                return r
            }
        }), qh.prototype = Object.assign(Object.create(Hh.prototype), {
            constructor: qh,
            interpolate_: function(t, e, i, n) {
                for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = t * s, l = o - s, h = (i - e) / (n - e), u = 1 - h, c = 0; c !== s; ++c) r[c] = a[l + c] * u + a[o + c] * h;
                return r
            }
        }), Xh.prototype = Object.assign(Object.create(Hh.prototype), {
            constructor: Xh,
            interpolate_: function(t) {
                return this.copySampleValue_(t - 1)
            }
        }), Object.assign(Yh, {
            toJSON: function(t) {
                var e, i, n = t.constructor;
                return void 0 !== n.toJSON ? e = n.toJSON(t) : (e = {
                    name: t.name,
                    times: jh.convertArray(t.times, Array),
                    values: jh.convertArray(t.values, Array)
                }, (i = t.getInterpolation()) !== t.DefaultInterpolation && (e.interpolation = i)), e.type = t.ValueTypeName, e
            }
        }), Object.assign(Yh.prototype, {
            constructor: Yh,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: ze,
            InterpolantFactoryMethodDiscrete: function(t) {
                return new Xh(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodLinear: function(t) {
                return new qh(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: function(t) {
                return new Wh(this.times, this.values, this.getValueSize(), t)
            },
            setInterpolation: function(t) {
                var e;
                switch (t) {
                    case Re:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case ze:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case 2302:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 !== e) return this.createInterpolant = e, this;
                var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation) throw new Error(i);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return this
            },
            getInterpolation: function() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return Re;
                    case this.InterpolantFactoryMethodLinear:
                        return ze;
                    case this.InterpolantFactoryMethodSmooth:
                        return 2302
                }
            },
            getValueSize: function() {
                return this.values.length / this.times.length
            },
            shift: function(t) {
                if (0 !== t)
                    for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
                return this
            },
            scale: function(t) {
                if (1 !== t)
                    for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
                return this
            },
            trim: function(t, e) {
                for (var i, n = this.times, r = n.length, a = 0, s = r - 1; a !== r && n[a] < t;) ++a;
                for (; - 1 !== s && n[s] > e;) --s;
                return ++s, 0 === a && s === r || (s <= a && (a = (s = Math.max(s, 1)) - 1), i = this.getValueSize(), this.times = jh.arraySlice(n, a, s), this.values = jh.arraySlice(this.values, a * i, s * i)), this
            },
            validate: function() {
                var t = !0,
                    e = this.getValueSize();
                e - Math.floor(e) != 0 && (t = !1);
                var i = this.times,
                    n = this.values,
                    r = i.length;
                0 === r && (t = !1);
                for (var a = null, s = 0; s !== r; s++) {
                    var o = i[s];
                    if ("number" == typeof o && isNaN(o)) {
                        t = !1;
                        break
                    }
                    if (null !== a && o < a) {
                        t = !1;
                        break
                    }
                    a = o
                }
                if (void 0 !== n && jh.isTypedArray(n))
                    for (var l = 0, h = n.length; l !== h; ++l) {
                        var u = n[l];
                        if (isNaN(u)) {
                            t = !1;
                            break
                        }
                    }
                return t
            },
            optimize: function() {
                for (var t = jh.arraySlice(this.times), e = jh.arraySlice(this.values), i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = t.length - 1, a = 1, s = 1; s < r; ++s) {
                    var o = !1,
                        l = t[s];
                    if (l !== t[s + 1] && (1 !== s || l !== l[0]))
                        if (n) o = !0;
                        else
                            for (var h = s * i, u = h - i, c = h + i, p = 0; p !== i; ++p) {
                                var d = e[h + p];
                                if (d !== e[u + p] || d !== e[c + p]) {
                                    o = !0;
                                    break
                                }
                            }
                    if (o) {
                        if (s !== a) {
                            t[a] = t[s];
                            for (var f = s * i, m = a * i, g = 0; g !== i; ++g) e[m + g] = e[f + g]
                        }++a
                    }
                }
                if (0 < r) {
                    t[a] = t[r];
                    for (var v = r * i, y = a * i, b = 0; b !== i; ++b) e[y + b] = e[v + b];
                    ++a
                }
                return a !== t.length ? (this.times = jh.arraySlice(t, 0, a), this.values = jh.arraySlice(e, 0, a * i)) : (this.times = t, this.values = e), this
            },
            clone: function() {
                var t = jh.arraySlice(this.times, 0),
                    e = jh.arraySlice(this.values, 0),
                    i = new this.constructor(this.name, t, e);
                return i.createInterpolant = this.createInterpolant, i
            }
        }), Jh.prototype = Object.assign(Object.create(Yh.prototype), {
            constructor: Jh,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: Re,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Zh.prototype = Object.assign(Object.create(Yh.prototype), {
            constructor: Zh,
            ValueTypeName: "color"
        }), $h.prototype = Object.assign(Object.create(Yh.prototype), {
            constructor: $h,
            ValueTypeName: "number"
        }), Kh.prototype = Object.assign(Object.create(Hh.prototype), {
            constructor: Kh,
            interpolate_: function(t, e, i, n) {
                for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = (i - e) / (n - e), l = t * s, h = l + s; l !== h; l += 4) _i.slerpFlat(r, 0, a, l - s, a, l, o);
                return r
            }
        }), Qh.prototype = Object.assign(Object.create(Yh.prototype), {
            constructor: Qh,
            ValueTypeName: "quaternion",
            DefaultInterpolation: ze,
            InterpolantFactoryMethodLinear: function(t) {
                return new Kh(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), tu.prototype = Object.assign(Object.create(Yh.prototype), {
            constructor: tu,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: Re,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), eu.prototype = Object.assign(Object.create(Yh.prototype), {
            constructor: eu,
            ValueTypeName: "vector"
        }), Object.assign(iu, {
            parse: function(t) {
                for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i.length; r !== a; ++r) e.push(nu(i[r]).scale(n));
                return new iu(t.name, t.duration, e, t.blendMode)
            },
            toJSON: function(t) {
                for (var e = [], i = t.tracks, n = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e,
                        uuid: t.uuid,
                        blendMode: t.blendMode
                    }, r = 0, a = i.length; r !== a; ++r) e.push(Yh.toJSON(i[r]));
                return n
            },
            CreateFromMorphTargetSequence: function(t, e, i, n) {
                for (var r = e.length, a = [], s = 0; s < r; s++) {
                    var o = [];
                    (h = []).push((s + r - 1) % r, s, (s + 1) % r), o.push(0, 1, 0);
                    var l = jh.getKeyframeOrder(h),
                        h = jh.sortedArray(h, 1, l),
                        o = jh.sortedArray(o, 1, l);
                    n || 0 !== h[0] || (h.push(r), o.push(o[0])), a.push(new $h(".morphTargetInfluences[" + e[s].name + "]", h, o).scale(1 / i))
                }
                return new iu(t, -1, a)
            },
            findByName: function(t, e) {
                var i = t;
                Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations);
                for (var n = 0; n < i.length; n++)
                    if (i[n].name === e) return i[n];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(t, e, i) {
                for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, s = t.length; a < s; a++) {
                    var o, l, h = t[a],
                        u = h.name.match(r);
                    u && 1 < u.length && ((l = n[o = u[1]]) || (n[o] = l = []), l.push(h))
                }
                var c = [];
                for (var p in n) c.push(iu.CreateFromMorphTargetSequence(p, n[p], e, i));
                return c
            },
            parseAnimation: function(t, e) {
                if (!t) return null;
                for (var i = function(t, e, i, n, r) {
                        var a, s;
                        0 !== i.length && (a = [], s = [], jh.flattenJSON(i, a, s, n), 0 !== a.length && r.push(new t(e, a, s)))
                    }, n = [], r = t.name || "default", a = t.fps || 30, s = t.blendMode, o = t.length || -1, l = t.hierarchy || [], h = 0; h < l.length; h++) {
                    var u = l[h].keys;
                    if (u && 0 !== u.length)
                        if (u[0].morphTargets) {
                            for (var c = {}, p = void 0, p = 0; p < u.length; p++)
                                if (u[p].morphTargets)
                                    for (var d = 0; d < u[p].morphTargets.length; d++) c[u[p].morphTargets[d]] = -1;
                            for (var f in c) {
                                for (var m = [], g = [], v = 0; v !== u[p].morphTargets.length; ++v) {
                                    var y = u[p];
                                    m.push(y.time), g.push(y.morphTarget === f ? 1 : 0)
                                }
                                n.push(new $h(".morphTargetInfluence[" + f + "]", m, g))
                            }
                            o = c.length * (a || 1)
                        } else {
                            var b = ".bones[" + e[h].name + "]";
                            i(eu, b + ".position", u, "pos", n), i(Qh, b + ".quaternion", u, "rot", n), i(eu, b + ".scale", u, "scl", n)
                        }
                }
                return 0 === n.length ? null : new iu(r, o, n, s)
            }
        }), Object.assign(iu.prototype, {
            resetDuration: function() {
                for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) var n = this.tracks[e],
                    t = Math.max(t, n.times[n.times.length - 1]);
                return this.duration = t, this
            },
            trim: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            },
            validate: function() {
                for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                return t
            },
            optimize: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            },
            clone: function() {
                for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                return new iu(this.name, this.duration, t, this.blendMode)
            }
        });
        var ru = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled) return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };

        function au(t, e, i) {
            var n = this,
                r = !1,
                a = 0,
                s = 0,
                o = void 0,
                l = [];
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                s++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, s), r = !0
            }, this.itemEnd = function(t) {
                a++, void 0 !== n.onProgress && n.onProgress(t, a, s), a === s && (r = !1, void 0 !== n.onLoad && n.onLoad())
            }, this.itemError = function(t) {
                void 0 !== n.onError && n.onError(t)
            }, this.resolveURL = function(t) {
                return o ? o(t) : t
            }, this.setURLModifier = function(t) {
                return o = t, this
            }, this.addHandler = function(t, e) {
                return l.push(t, e), this
            }, this.removeHandler = function(t) {
                var e = l.indexOf(t);
                return -1 !== e && l.splice(e, 2), this
            }, this.getHandler = function(t) {
                for (var e = 0, i = l.length; e < i; e += 2) {
                    var n = l[e],
                        r = l[e + 1];
                    if (n.global && (n.lastIndex = 0), n.test(t)) return r
                }
                return null
            }
        }
        i.Cache = ru;
        var su = new au;

        function ou(t) {
            this.manager = void 0 !== t ? t : su, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "", this.requestHeader = {}
        }
        i.DefaultLoadingManager = su, Object.assign(ou.prototype, {
            load: function() {},
            loadAsync: function(i, n) {
                var r = this;
                return new Promise(function(t, e) {
                    r.load(i, t, n, e)
                })
            },
            parse: function() {},
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            },
            setResourcePath: function(t) {
                return this.resourcePath = t, this
            },
            setRequestHeader: function(t) {
                return this.requestHeader = t, this
            }
        });
        var lu = {};

        function hu(t) {
            ou.call(this, t)
        }

        function uu(t) {
            ou.call(this, t)
        }

        function cu(t) {
            ou.call(this, t)
        }

        function pu(t) {
            ou.call(this, t)
        }

        function du(t) {
            ou.call(this, t)
        }

        function fu(t) {
            ou.call(this, t)
        }

        function mu(t) {
            ou.call(this, t)
        }

        function gu() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }

        function vu(t, e, i, n, r, a, s, o) {
            gu.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = o || 0
        }

        function yu(t, e, i, n, r, a) {
            vu.call(this, t, e, i, i, n, r, a), this.type = "ArcCurve"
        }

        function bu() {
            var r = 0,
                a = 0,
                s = 0,
                o = 0;

            function h(t, e, i, n) {
                s = -3 * (r = t) + 3 * e - 2 * (a = i) - n, o = 2 * t - 2 * e + i + n
            }
            return {
                initCatmullRom: function(t, e, i, n, r) {
                    h(e, i, r * (i - t), r * (n - e))
                },
                initNonuniformCatmullRom: function(t, e, i, n, r, a, s) {
                    var o = (e - t) / r - (i - t) / (r + a) + (i - e) / a,
                        l = (i - e) / a - (n - e) / (a + s) + (n - i) / s;
                    h(e, i, o *= a, l *= a)
                },
                calc: function(t) {
                    var e = t * t;
                    return r + a * t + s * e + o * (e * t)
                }
            }
        }
        hu.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: hu,
            load: function(h, t, e, i) {
                void 0 === h && (h = ""), void 0 !== this.path && (h = this.path + h), h = this.manager.resolveURL(h);
                var u = this,
                    n = ru.get(h);
                if (void 0 !== n) return u.manager.itemStart(h), setTimeout(function() {
                    t && t(n), u.manager.itemEnd(h)
                }, 0), n;
                if (void 0 === lu[h]) {
                    var r, a = h.match(/^data:(.*?)(;base64)?,(.*)$/);
                    if (a) {
                        var s = a[1],
                            o = !!a[2],
                            l = a[3],
                            l = decodeURIComponent(l);
                        o && (l = atob(l));
                        try {
                            var c = (this.responseType || "").toLowerCase();
                            switch (c) {
                                case "arraybuffer":
                                case "blob":
                                    for (var p = new Uint8Array(l.length), d = 0; d < l.length; d++) p[d] = l.charCodeAt(d);
                                    f = "blob" === c ? new Blob([p.buffer], {
                                        type: s
                                    }) : p.buffer;
                                    break;
                                case "document":
                                    var f = (new DOMParser).parseFromString(l, s);
                                    break;
                                case "json":
                                    f = JSON.parse(l);
                                    break;
                                default:
                                    f = l
                            }
                            setTimeout(function() {
                                t && t(f), u.manager.itemEnd(h)
                            }, 0)
                        } catch (t) {
                            setTimeout(function() {
                                i && i(t), u.manager.itemError(h), u.manager.itemEnd(h)
                            }, 0)
                        }
                    } else {
                        for (var m in lu[h] = [], lu[h].push({
                                onLoad: t,
                                onProgress: e,
                                onError: i
                            }), (r = new XMLHttpRequest).open("GET", h, !0), r.addEventListener("load", function(t) {
                                var e = this.response,
                                    i = lu[h];
                                if (delete lu[h], 200 === this.status || 0 === this.status) {
                                    this.status, ru.add(h, e);
                                    for (var n = 0, r = i.length; n < r; n++) {
                                        var a = i[n];
                                        a.onLoad && a.onLoad(e)
                                    }
                                    u.manager.itemEnd(h)
                                } else {
                                    for (var s = 0, o = i.length; s < o; s++) {
                                        var l = i[s];
                                        l.onError && l.onError(t)
                                    }
                                    u.manager.itemError(h), u.manager.itemEnd(h)
                                }
                            }, !1), r.addEventListener("progress", function(t) {
                                for (var e = lu[h], i = 0, n = e.length; i < n; i++) {
                                    var r = e[i];
                                    r.onProgress && r.onProgress(t)
                                }
                            }, !1), r.addEventListener("error", function(t) {
                                var e = lu[h];
                                delete lu[h];
                                for (var i = 0, n = e.length; i < n; i++) {
                                    var r = e[i];
                                    r.onError && r.onError(t)
                                }
                                u.manager.itemError(h), u.manager.itemEnd(h)
                            }, !1), r.addEventListener("abort", function(t) {
                                var e = lu[h];
                                delete lu[h];
                                for (var i = 0, n = e.length; i < n; i++) {
                                    var r = e[i];
                                    r.onError && r.onError(t)
                                }
                                u.manager.itemError(h), u.manager.itemEnd(h)
                            }, !1), void 0 !== this.responseType && (r.responseType = this.responseType), void 0 !== this.withCredentials && (r.withCredentials = this.withCredentials), r.overrideMimeType && r.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) r.setRequestHeader(m, this.requestHeader[m]);
                        r.send(null)
                    }
                    return u.manager.itemStart(h), r
                }
                lu[h].push({
                    onLoad: t,
                    onProgress: e,
                    onError: i
                })
            },
            setResponseType: function(t) {
                return this.responseType = t, this
            },
            setWithCredentials: function(t) {
                return this.withCredentials = t, this
            },
            setMimeType: function(t) {
                return this.mimeType = t, this
            }
        }), uu.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: uu,
            load: function(e, i, t, n) {
                var r = this,
                    a = new hu(r.manager);
                a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.load(e, function(t) {
                    try {
                        i(r.parse(JSON.parse(t)))
                    } catch (t) {
                        n && n(t), r.manager.itemError(e)
                    }
                }, t, n)
            },
            parse: function(t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var n = iu.parse(t[i]);
                    e.push(n)
                }
                return e
            }
        }), cu.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: cu,
            load: function(t, a, e, n) {
                var s = this,
                    o = [],
                    l = new _l;
                l.image = o;
                var r = new hu(this.manager);
                r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader);
                var h = 0;
                if (Array.isArray(t))
                    for (var i = 0, u = t.length; i < u; ++i) ! function(i) {
                        r.load(t[i], function(t) {
                            var e = s.parse(t, !0);
                            o[i] = {
                                width: e.width,
                                height: e.height,
                                format: e.format,
                                mipmaps: e.mipmaps
                            }, 6 === (h += 1) && (1 === e.mipmapCount && (l.minFilter = Gt), l.format = e.format, l.needsUpdate = !0, a && a(l))
                        }, e, n)
                    }(i);
                else r.load(t, function(t) {
                    var e = s.parse(t, !0);
                    if (e.isCubemap)
                        for (var i = e.mipmaps.length / e.mipmapCount, n = 0; n < i; n++) {
                            o[n] = {
                                mipmaps: []
                            };
                            for (var r = 0; r < e.mipmapCount; r++) o[n].mipmaps.push(e.mipmaps[n * e.mipmapCount + r]), o[n].format = e.format, o[n].width = e.width, o[n].height = e.height
                        } else l.image.width = e.width, l.image.height = e.height, l.mipmaps = e.mipmaps;
                    1 === e.mipmapCount && (l.minFilter = Gt), l.format = e.format, l.needsUpdate = !0, a && a(l)
                }, e, n);
                return l
            }
        }), pu.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: pu,
            load: function(e, t, i, n) {
                void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                var r = this,
                    a = ru.get(e);
                if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function() {
                    t && t(a), r.manager.itemEnd(e)
                }, 0), a;
                var s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                function o() {
                    s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1), ru.add(e, this), t && t(this), r.manager.itemEnd(e)
                }

                function l(t) {
                    s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1), n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                }
                return s.addEventListener("load", o, !1), s.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(e), s.src = e, s
            }
        }), du.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: du,
            load: function(t, i, e, n) {
                var r = new Aa,
                    a = new pu(this.manager);
                a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                var s = 0;
                for (var o = 0; o < t.length; ++o) ! function(e) {
                    a.load(t[e], function(t) {
                        r.images[e] = t, 6 === ++s && (r.needsUpdate = !0, i && i(r))
                    }, void 0, n)
                }(o);
                return r
            }
        }), fu.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: fu,
            load: function(t, i, e, n) {
                var r = this,
                    a = new ia,
                    s = new hu(this.manager);
                return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.load(t, function(t) {
                    var e = r.parse(t);
                    e && (void 0 !== e.image ? a.image = e.image : void 0 !== e.data && (a.image.width = e.width, a.image.height = e.height, a.image.data = e.data), a.wrapS = void 0 !== e.wrapS ? e.wrapS : It, a.wrapT = void 0 !== e.wrapT ? e.wrapT : It, a.magFilter = void 0 !== e.magFilter ? e.magFilter : Gt, a.minFilter = void 0 !== e.minFilter ? e.minFilter : Gt, a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (a.format = e.format), void 0 !== e.type && (a.type = e.type), void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps, a.minFilter = Ut), 1 === e.mipmapCount && (a.minFilter = Gt), a.needsUpdate = !0, i && i(a, e))
                }, e, n), a
            }
        }), mu.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: mu,
            load: function(i, n, t, e) {
                var r = new vi,
                    a = new pu(this.manager);
                return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(i, function(t) {
                    r.image = t;
                    var e = 0 < i.search(/\.jpe?g($|\?)/i) || 0 === i.search(/^data\:image\/jpeg/);
                    r.format = e ? Jt : Zt, r.needsUpdate = !0, void 0 !== n && n(r)
                }, t, e), r
            }
        }), Object.assign(gu.prototype, {
            getPoint: function() {
                return null
            },
            getPointAt: function(t, e) {
                var i = this.getUtoTmapping(t);
                return this.getPoint(i, e)
            },
            getPoints: function(t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return e
            },
            getSpacedPoints: function(t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                return e
            },
            getLength: function() {
                var t = this.getLengths();
                return t[t.length - 1]
            },
            getLengths: function(t) {
                if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var e, i = [],
                    n = this.getPoint(0),
                    r = 0;
                i.push(0);
                for (var a = 1; a <= t; a++) r += (e = this.getPoint(a / t)).distanceTo(n), i.push(r), n = e;
                return this.cacheArcLengths = i
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function(t, e) {
                for (var i, n = this.getLengths(), r = 0, a = n.length, s = e || t * n[a - 1], o = 0, l = a - 1; o <= l;)
                    if ((i = n[r = Math.floor(o + (l - o) / 2)] - s) < 0) o = r + 1;
                    else {
                        if (!(0 < i)) {
                            l = r;
                            break
                        }
                        l = r - 1
                    }
                if (n[r = l] === s) return r / (a - 1);
                var h = n[r];
                return (r + (s - h) / (n[r + 1] - h)) / (a - 1)
            },
            getTangent: function(t, e) {
                var i = t - 1e-4,
                    n = t + 1e-4;
                i < 0 && (i = 0), 1 < n && (n = 1);
                var r = this.getPoint(i),
                    a = this.getPoint(n),
                    s = e || new(r.isVector2 ? pi : wi);
                return s.copy(a).sub(r).normalize(), s
            },
            getTangentAt: function(t, e) {
                var i = this.getUtoTmapping(t);
                return this.getTangent(i, e)
            },
            computeFrenetFrames: function(t, e) {
                for (var i = new wi, n = [], r = [], a = [], s = new wi, o = new Zi, l = 0; l <= t; l++) {
                    var h = l / t;
                    n[l] = this.getTangentAt(h, new wi), n[l].normalize()
                }
                r[0] = new wi, a[0] = new wi;
                var u = Number.MAX_VALUE,
                    c = Math.abs(n[0].x),
                    p = Math.abs(n[0].y),
                    d = Math.abs(n[0].z);
                c <= u && (u = c, i.set(1, 0, 0)), p <= u && (u = p, i.set(0, 1, 0)), d <= u && i.set(0, 0, 1), s.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], s), a[0].crossVectors(n[0], r[0]);
                for (var f, m = 1; m <= t; m++) {
                    r[m] = r[m - 1].clone(), a[m] = a[m - 1].clone(), s.crossVectors(n[m - 1], n[m]), s.length() > Number.EPSILON && (s.normalize(), f = Math.acos(ci.clamp(n[m - 1].dot(n[m]), -1, 1)), r[m].applyMatrix4(o.makeRotationAxis(s, f))), a[m].crossVectors(n[m], r[m])
                }
                if (!0 === e) {
                    var g = Math.acos(ci.clamp(r[0].dot(r[t]), -1, 1));
                    g /= t, 0 < n[0].dot(s.crossVectors(r[0], r[t])) && (g = -g);
                    for (var v = 1; v <= t; v++) r[v].applyMatrix4(o.makeRotationAxis(n[v], g * v)), a[v].crossVectors(n[v], r[v])
                }
                return {
                    tangents: n,
                    normals: r,
                    binormals: a
                }
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
            },
            fromJSON: function(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
        }), ((vu.prototype = Object.create(gu.prototype)).constructor = vu).prototype.isEllipseCurve = !0, vu.prototype.getPoint = function(t, e) {
            for (var i = e || new pi, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; r < 0;) r += n;
            for (; n < r;) r -= n;
            r < Number.EPSILON && (r = a ? 0 : n), !0 !== this.aClockwise || a || (r === n ? r = -n : r -= n);
            var s, o, l, h, u = this.aStartAngle + t * r,
                c = this.aX + this.xRadius * Math.cos(u),
                p = this.aY + this.yRadius * Math.sin(u);
            return 0 !== this.aRotation && (s = Math.cos(this.aRotation), o = Math.sin(this.aRotation), c = (l = c - this.aX) * s - (h = p - this.aY) * o + this.aX, p = l * o + h * s + this.aY), i.set(c, p)
        }, vu.prototype.copy = function(t) {
            return gu.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, vu.prototype.toJSON = function() {
            var t = gu.prototype.toJSON.call(this);
            return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
        }, vu.prototype.fromJSON = function(t) {
            return gu.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, ((yu.prototype = Object.create(vu.prototype)).constructor = yu).prototype.isArcCurve = !0;
        var xu = new wi,
            _u = new bu,
            wu = new bu,
            Su = new bu;

        function Mu(t, e, i, n) {
            gu.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = void 0 !== n ? n : .5
        }

        function Tu(t, e, i, n, r) {
            var a = .5 * (n - e),
                s = .5 * (r - i),
                o = t * t;
            return (2 * i - 2 * n + a + s) * (t * o) + (-3 * i + 3 * n - 2 * a - s) * o + a * t + i
        }

        function Cu(t, e, i, n) {
            return (s = 1 - t) * s * e + 2 * (1 - (a = t)) * a * i + (r = t) * r * n;
            var r, a, s
        }

        function Au(t, e, i, n, r) {
            return (h = 1 - t) * h * h * e + 3 * (l = 1 - (o = t)) * l * o * i + 3 * (1 - (s = t)) * s * s * n + (a = t) * a * a * r;
            var a, s, o, l, h
        }

        function Eu(t, e, i, n) {
            gu.call(this), this.type = "CubicBezierCurve", this.v0 = t || new pi, this.v1 = e || new pi, this.v2 = i || new pi, this.v3 = n || new pi
        }

        function Du(t, e, i, n) {
            gu.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new wi, this.v1 = e || new wi, this.v2 = i || new wi, this.v3 = n || new wi
        }

        function Pu(t, e) {
            gu.call(this), this.type = "LineCurve", this.v1 = t || new pi, this.v2 = e || new pi
        }

        function Lu(t, e) {
            gu.call(this), this.type = "LineCurve3", this.v1 = t || new wi, this.v2 = e || new wi
        }

        function ku(t, e, i) {
            gu.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new pi, this.v1 = e || new pi, this.v2 = i || new pi
        }

        function Ou(t, e, i) {
            gu.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new wi, this.v1 = e || new wi, this.v2 = i || new wi
        }

        function Fu(t) {
            gu.call(this), this.type = "SplineCurve", this.points = t || []
        }((Mu.prototype = Object.create(gu.prototype)).constructor = Mu).prototype.isCatmullRomCurve3 = !0, Mu.prototype.getPoint = function(t, e) {
            var i, n = e || new wi,
                r = this.points,
                a = r.length,
                s = (a - (this.closed ? 0 : 1)) * t,
                o = Math.floor(s),
                l = s - o;
            this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / a) + 1) * a : 0 === l && o === a - 1 && (o = a - 2, l = 1), i = this.closed || 0 < o ? r[(o - 1) % a] : (xu.subVectors(r[0], r[1]).add(r[0]), xu);
            var h, u, c, p, d = r[o % a],
                f = r[(o + 1) % a],
                m = this.closed || o + 2 < a ? r[(o + 2) % a] : (xu.subVectors(r[a - 1], r[a - 2]).add(r[a - 1]), xu);
            return "centripetal" === this.curveType || "chordal" === this.curveType ? (h = "chordal" === this.curveType ? .5 : .25, u = Math.pow(i.distanceToSquared(d), h), (c = Math.pow(d.distanceToSquared(f), h)) < 1e-4 && (c = 1), u < 1e-4 && (u = c), (p = Math.pow(f.distanceToSquared(m), h)) < 1e-4 && (p = c), _u.initNonuniformCatmullRom(i.x, d.x, f.x, m.x, u, c, p), wu.initNonuniformCatmullRom(i.y, d.y, f.y, m.y, u, c, p), Su.initNonuniformCatmullRom(i.z, d.z, f.z, m.z, u, c, p)) : "catmullrom" === this.curveType && (_u.initCatmullRom(i.x, d.x, f.x, m.x, this.tension), wu.initCatmullRom(i.y, d.y, f.y, m.y, this.tension), Su.initCatmullRom(i.z, d.z, f.z, m.z, this.tension)), n.set(_u.calc(l), wu.calc(l), Su.calc(l)), n
        }, Mu.prototype.copy = function(t) {
            gu.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push(n.clone())
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, Mu.prototype.toJSON = function() {
            var t = gu.prototype.toJSON.call(this);
            t.points = [];
            for (var e = 0, i = this.points.length; e < i; e++) {
                var n = this.points[e];
                t.points.push(n.toArray())
            }
            return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
        }, Mu.prototype.fromJSON = function(t) {
            gu.prototype.fromJSON.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push((new wi).fromArray(n))
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, ((Eu.prototype = Object.create(gu.prototype)).constructor = Eu).prototype.isCubicBezierCurve = !0, Eu.prototype.getPoint = function(t, e) {
            var i = e || new pi,
                n = this.v0,
                r = this.v1,
                a = this.v2,
                s = this.v3;
            return i.set(Au(t, n.x, r.x, a.x, s.x), Au(t, n.y, r.y, a.y, s.y)), i
        }, Eu.prototype.copy = function(t) {
            return gu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, Eu.prototype.toJSON = function() {
            var t = gu.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, Eu.prototype.fromJSON = function(t) {
            return gu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, ((Du.prototype = Object.create(gu.prototype)).constructor = Du).prototype.isCubicBezierCurve3 = !0, Du.prototype.getPoint = function(t, e) {
            var i = e || new wi,
                n = this.v0,
                r = this.v1,
                a = this.v2,
                s = this.v3;
            return i.set(Au(t, n.x, r.x, a.x, s.x), Au(t, n.y, r.y, a.y, s.y), Au(t, n.z, r.z, a.z, s.z)), i
        }, Du.prototype.copy = function(t) {
            return gu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, Du.prototype.toJSON = function() {
            var t = gu.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, Du.prototype.fromJSON = function(t) {
            return gu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, ((Pu.prototype = Object.create(gu.prototype)).constructor = Pu).prototype.isLineCurve = !0, Pu.prototype.getPoint = function(t, e) {
            var i = e || new pi;
            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
        }, Pu.prototype.getPointAt = function(t, e) {
            return this.getPoint(t, e)
        }, Pu.prototype.getTangent = function(t, e) {
            var i = e || new pi;
            return i.copy(this.v2).sub(this.v1).normalize(), i
        }, Pu.prototype.copy = function(t) {
            return gu.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Pu.prototype.toJSON = function() {
            var t = gu.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Pu.prototype.fromJSON = function(t) {
            return gu.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, ((Lu.prototype = Object.create(gu.prototype)).constructor = Lu).prototype.isLineCurve3 = !0, Lu.prototype.getPoint = function(t, e) {
            var i = e || new wi;
            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
        }, Lu.prototype.getPointAt = function(t, e) {
            return this.getPoint(t, e)
        }, Lu.prototype.copy = function(t) {
            return gu.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Lu.prototype.toJSON = function() {
            var t = gu.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Lu.prototype.fromJSON = function(t) {
            return gu.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, ((ku.prototype = Object.create(gu.prototype)).constructor = ku).prototype.isQuadraticBezierCurve = !0, ku.prototype.getPoint = function(t, e) {
            var i = e || new pi,
                n = this.v0,
                r = this.v1,
                a = this.v2;
            return i.set(Cu(t, n.x, r.x, a.x), Cu(t, n.y, r.y, a.y)), i
        }, ku.prototype.copy = function(t) {
            return gu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, ku.prototype.toJSON = function() {
            var t = gu.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, ku.prototype.fromJSON = function(t) {
            return gu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, ((Ou.prototype = Object.create(gu.prototype)).constructor = Ou).prototype.isQuadraticBezierCurve3 = !0, Ou.prototype.getPoint = function(t, e) {
            var i = e || new wi,
                n = this.v0,
                r = this.v1,
                a = this.v2;
            return i.set(Cu(t, n.x, r.x, a.x), Cu(t, n.y, r.y, a.y), Cu(t, n.z, r.z, a.z)), i
        }, Ou.prototype.copy = function(t) {
            return gu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Ou.prototype.toJSON = function() {
            var t = gu.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Ou.prototype.fromJSON = function(t) {
            return gu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, ((Fu.prototype = Object.create(gu.prototype)).constructor = Fu).prototype.isSplineCurve = !0, Fu.prototype.getPoint = function(t, e) {
            var i = e || new pi,
                n = this.points,
                r = (n.length - 1) * t,
                a = Math.floor(r),
                s = r - a,
                o = n[0 === a ? a : a - 1],
                l = n[a],
                h = n[a > n.length - 2 ? n.length - 1 : a + 1],
                u = n[a > n.length - 3 ? n.length - 1 : a + 2];
            return i.set(Tu(s, o.x, l.x, h.x, u.x), Tu(s, o.y, l.y, h.y, u.y)), i
        }, Fu.prototype.copy = function(t) {
            gu.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push(n.clone())
            }
            return this
        }, Fu.prototype.toJSON = function() {
            var t = gu.prototype.toJSON.call(this);
            t.points = [];
            for (var e = 0, i = this.points.length; e < i; e++) {
                var n = this.points[e];
                t.points.push(n.toArray())
            }
            return t
        }, Fu.prototype.fromJSON = function(t) {
            gu.prototype.fromJSON.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push((new pi).fromArray(n))
            }
            return this
        };
        var Iu = Object.freeze({
            __proto__: null,
            ArcCurve: yu,
            CatmullRomCurve3: Mu,
            CubicBezierCurve: Eu,
            CubicBezierCurve3: Du,
            EllipseCurve: vu,
            LineCurve: Pu,
            LineCurve3: Lu,
            QuadraticBezierCurve: ku,
            QuadraticBezierCurve3: Ou,
            SplineCurve: Fu
        });

        function Nu() {
            gu.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
        }

        function Bu(t) {
            Nu.call(this), this.type = "Path", this.currentPoint = new pi, t && this.setFromPoints(t)
        }

        function Ru(t) {
            Bu.call(this, t), this.uuid = ci.generateUUID(), this.type = "Shape", this.holes = []
        }

        function zu(t, e) {
            wn.call(this), this.type = "Light", this.color = new Hn(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
        }

        function Gu(t, e, i) {
            zu.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(wn.DefaultUp), this.updateMatrix(), this.groundColor = new Hn(e)
        }

        function Vu(t) {
            this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new pi(512, 512), this.map = null, this.mapPass = null, this.matrix = new Zi, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new aa, this._frameExtents = new pi(1, 1), this._viewportCount = 1, this._viewports = [new yi(0, 0, 1, 1)]
        }

        function Uu() {
            Vu.call(this, new $r(50, 1, .5, 500))
        }

        function ju(t, e, i, n, r, a) {
            zu.call(this, t, e), this.type = "SpotLight", this.position.copy(wn.DefaultUp), this.updateMatrix(), this.target = new wn, Object.defineProperty(this, "power", {
                get: function() {
                    return this.intensity * Math.PI
                },
                set: function(t) {
                    this.intensity = t / Math.PI
                }
            }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Uu
        }

        function Hu() {
            Vu.call(this, new $r(90, 1, .5, 500)), this._frameExtents = new pi(4, 2), this._viewportCount = 6, this._viewports = [new yi(2, 1, 1, 1), new yi(0, 1, 1, 1), new yi(3, 1, 1, 1), new yi(1, 1, 1, 1), new yi(3, 0, 1, 1), new yi(1, 0, 1, 1)], this._cubeDirections = [new wi(1, 0, 0), new wi(-1, 0, 0), new wi(0, 0, 1), new wi(0, 0, -1), new wi(0, 1, 0), new wi(0, -1, 0)], this._cubeUps = [new wi(0, 1, 0), new wi(0, 1, 0), new wi(0, 1, 0), new wi(0, 1, 0), new wi(0, 0, 1), new wi(0, 0, -1)]
        }

        function Wu(t, e, i, n) {
            zu.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function() {
                    return 4 * this.intensity * Math.PI
                },
                set: function(t) {
                    this.intensity = t / (4 * Math.PI)
                }
            }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new Hu
        }

        function qu(t, e, i, n, r, a) {
            Zr.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
        }

        function Xu() {
            Vu.call(this, new qu(-5, 5, 5, -5, .5, 500))
        }

        function Yu(t, e) {
            zu.call(this, t, e), this.type = "DirectionalLight", this.position.copy(wn.DefaultUp), this.updateMatrix(), this.target = new wn, this.shadow = new Xu
        }

        function Ju(t, e) {
            zu.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
        }

        function Zu(t, e, i, n) {
            zu.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
        }
        Nu.prototype = Object.assign(Object.create(gu.prototype), {
            constructor: Nu,
            add: function(t) {
                this.curves.push(t)
            },
            closePath: function() {
                var t = this.curves[0].getPoint(0),
                    e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new Pu(e, t))
            },
            getPoint: function(t) {
                for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) {
                    if (i[n] >= e) {
                        var r = i[n] - e,
                            a = this.curves[n],
                            s = a.getLength(),
                            o = 0 === s ? 0 : 1 - r / s;
                        return a.getPointAt(o)
                    }
                    n++
                }
                return null
            },
            getLength: function() {
                var t = this.getCurveLengths();
                return t[t.length - 1]
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            },
            getCurveLengths: function() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                return this.cacheLengths = t
            },
            getSpacedPoints: function(t) {
                void 0 === t && (t = 40);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return this.autoClose && e.push(e[0]), e
            },
            getPoints: function(t) {
                t = t || 12;
                for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
                    for (var a = r[n], s = a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t, o = a.getPoints(s), l = 0; l < o.length; l++) {
                        var h = o[l];
                        e && e.equals(h) || (i.push(h), e = h)
                    }
                return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
            },
            copy: function(t) {
                gu.prototype.copy.call(this, t), this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) {
                    var n = t.curves[e];
                    this.curves.push(n.clone())
                }
                return this.autoClose = t.autoClose, this
            },
            toJSON: function() {
                var t = gu.prototype.toJSON.call(this);
                t.autoClose = this.autoClose, t.curves = [];
                for (var e = 0, i = this.curves.length; e < i; e++) {
                    var n = this.curves[e];
                    t.curves.push(n.toJSON())
                }
                return t
            },
            fromJSON: function(t) {
                gu.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) {
                    var n = t.curves[e];
                    this.curves.push((new Iu[n.type]).fromJSON(n))
                }
                return this
            }
        }), Bu.prototype = Object.assign(Object.create(Nu.prototype), {
            constructor: Bu,
            setFromPoints: function(t) {
                this.moveTo(t[0].x, t[0].y);
                for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
                return this
            },
            moveTo: function(t, e) {
                return this.currentPoint.set(t, e), this
            },
            lineTo: function(t, e) {
                var i = new Pu(this.currentPoint.clone(), new pi(t, e));
                return this.curves.push(i), this.currentPoint.set(t, e), this
            },
            quadraticCurveTo: function(t, e, i, n) {
                var r = new ku(this.currentPoint.clone(), new pi(t, e), new pi(i, n));
                return this.curves.push(r), this.currentPoint.set(i, n), this
            },
            bezierCurveTo: function(t, e, i, n, r, a) {
                var s = new Eu(this.currentPoint.clone(), new pi(t, e), new pi(i, n), new pi(r, a));
                return this.curves.push(s), this.currentPoint.set(r, a), this
            },
            splineThru: function(t) {
                var e = new Fu([this.currentPoint.clone()].concat(t));
                return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
            },
            arc: function(t, e, i, n, r, a) {
                var s = this.currentPoint.x,
                    o = this.currentPoint.y;
                return this.absarc(t + s, e + o, i, n, r, a), this
            },
            absarc: function(t, e, i, n, r, a) {
                return this.absellipse(t, e, i, i, n, r, a), this
            },
            ellipse: function(t, e, i, n, r, a, s, o) {
                var l = this.currentPoint.x,
                    h = this.currentPoint.y;
                return this.absellipse(t + l, e + h, i, n, r, a, s, o), this
            },
            absellipse: function(t, e, i, n, r, a, s, o) {
                var l, h = new vu(t, e, i, n, r, a, s, o);
                0 < this.curves.length && ((l = h.getPoint(0)).equals(this.currentPoint) || this.lineTo(l.x, l.y)), this.curves.push(h);
                var u = h.getPoint(1);
                return this.currentPoint.copy(u), this
            },
            copy: function(t) {
                return Nu.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
            },
            toJSON: function() {
                var t = Nu.prototype.toJSON.call(this);
                return t.currentPoint = this.currentPoint.toArray(), t
            },
            fromJSON: function(t) {
                return Nu.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
            }
        }), Ru.prototype = Object.assign(Object.create(Bu.prototype), {
            constructor: Ru,
            getPointsHoles: function(t) {
                for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                return e
            },
            extractPoints: function(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            },
            copy: function(t) {
                Bu.prototype.copy.call(this, t), this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) {
                    var n = t.holes[e];
                    this.holes.push(n.clone())
                }
                return this
            },
            toJSON: function() {
                var t = Bu.prototype.toJSON.call(this);
                t.uuid = this.uuid, t.holes = [];
                for (var e = 0, i = this.holes.length; e < i; e++) {
                    var n = this.holes[e];
                    t.holes.push(n.toJSON())
                }
                return t
            },
            fromJSON: function(t) {
                Bu.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) {
                    var n = t.holes[e];
                    this.holes.push((new Bu).fromJSON(n))
                }
                return this
            }
        }), zu.prototype = Object.assign(Object.create(wn.prototype), {
            constructor: zu,
            isLight: !0,
            copy: function(t) {
                return wn.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
            },
            toJSON: function(t) {
                var e = wn.prototype.toJSON.call(this, t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }), Gu.prototype = Object.assign(Object.create(zu.prototype), {
            constructor: Gu,
            isHemisphereLight: !0,
            copy: function(t) {
                return zu.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }), Object.assign(Vu.prototype, {
            _projScreenMatrix: new Zi,
            _lightPositionWorld: new wi,
            _lookTarget: new wi,
            getViewportCount: function() {
                return this._viewportCount
            },
            getFrustum: function() {
                return this._frustum
            },
            updateMatrices: function(t) {
                var e = this.camera,
                    i = this.matrix,
                    n = this._projScreenMatrix,
                    r = this._lookTarget,
                    a = this._lightPositionWorld;
                a.setFromMatrixPosition(t.matrixWorld), e.position.copy(a), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), n.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(n), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(e.projectionMatrix), i.multiply(e.matrixWorldInverse)
            },
            getViewport: function(t) {
                return this._viewports[t]
            },
            getFrameExtents: function() {
                return this._frameExtents
            },
            copy: function(t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                var t = {};
                return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }), Uu.prototype = Object.assign(Object.create(Vu.prototype), {
            constructor: Uu,
            isSpotLightShadow: !0,
            updateMatrices: function(t) {
                var e = this.camera,
                    i = 2 * ci.RAD2DEG * t.angle,
                    n = this.mapSize.width / this.mapSize.height,
                    r = t.distance || e.far;
                i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix()), Vu.prototype.updateMatrices.call(this, t)
            }
        }), ju.prototype = Object.assign(Object.create(zu.prototype), {
            constructor: ju,
            isSpotLight: !0,
            copy: function(t) {
                return zu.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), Hu.prototype = Object.assign(Object.create(Vu.prototype), {
            constructor: Hu,
            isPointLightShadow: !0,
            updateMatrices: function(t, e) {
                void 0 === e && (e = 0);
                var i = this.camera,
                    n = this.matrix,
                    r = this._lightPositionWorld,
                    a = this._lookTarget,
                    s = this._projScreenMatrix;
                r.setFromMatrixPosition(t.matrixWorld), i.position.copy(r), a.copy(i.position), a.add(this._cubeDirections[e]), i.up.copy(this._cubeUps[e]), i.lookAt(a), i.updateMatrixWorld(), n.makeTranslation(-r.x, -r.y, -r.z), s.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s)
            }
        }), Wu.prototype = Object.assign(Object.create(zu.prototype), {
            constructor: Wu,
            isPointLight: !0,
            copy: function(t) {
                return zu.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }), qu.prototype = Object.assign(Object.create(Zr.prototype), {
            constructor: qu,
            isOrthographicCamera: !0,
            copy: function(t, e) {
                return Zr.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            },
            setViewOffset: function(t, e, i, n, r, a) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t, e, i = (this.right - this.left) / (2 * this.zoom),
                    n = (this.top - this.bottom) / (2 * this.zoom),
                    r = (this.right + this.left) / 2,
                    a = (this.top + this.bottom) / 2,
                    s = r - i,
                    o = r + i,
                    l = a + n,
                    h = a - n;
                null !== this.view && this.view.enabled && (t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom, o = (s += t * this.view.offsetX) + t * this.view.width, h = (l -= e * this.view.offsetY) - e * this.view.height), this.projectionMatrix.makeOrthographic(s, o, l, h, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            },
            toJSON: function(t) {
                var e = wn.prototype.toJSON.call(this, t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }), Xu.prototype = Object.assign(Object.create(Vu.prototype), {
            constructor: Xu,
            isDirectionalLightShadow: !0,
            updateMatrices: function(t) {
                Vu.prototype.updateMatrices.call(this, t)
            }
        }), Yu.prototype = Object.assign(Object.create(zu.prototype), {
            constructor: Yu,
            isDirectionalLight: !0,
            copy: function(t) {
                return zu.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), Ju.prototype = Object.assign(Object.create(zu.prototype), {
            constructor: Ju,
            isAmbientLight: !0
        }), Zu.prototype = Object.assign(Object.create(zu.prototype), {
            constructor: Zu,
            isRectAreaLight: !0,
            copy: function(t) {
                return zu.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
            },
            toJSON: function(t) {
                var e = zu.prototype.toJSON.call(this, t);
                return e.object.width = this.width, e.object.height = this.height, e
            }
        });
        var $u = function() {
            function e() {
                V(this, e), Object.defineProperty(this, "isSphericalHarmonics3", {
                    value: !0
                }), this.coefficients = [];
                for (var t = 0; t < 9; t++) this.coefficients.push(new wi)
            }
            return g(e, [{
                key: "set",
                value: function(t) {
                    for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                    return this
                }
            }, {
                key: "zero",
                value: function() {
                    for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                    return this
                }
            }, {
                key: "getAt",
                value: function(t, e) {
                    var i = t.x,
                        n = t.y,
                        r = t.z,
                        a = this.coefficients;
                    return e.copy(a[0]).multiplyScalar(.282095), e.addScaledVector(a[1], .488603 * n), e.addScaledVector(a[2], .488603 * r), e.addScaledVector(a[3], .488603 * i), e.addScaledVector(a[4], i * n * 1.092548), e.addScaledVector(a[5], n * r * 1.092548), e.addScaledVector(a[6], .315392 * (3 * r * r - 1)), e.addScaledVector(a[7], i * r * 1.092548), e.addScaledVector(a[8], .546274 * (i * i - n * n)), e
                }
            }, {
                key: "getIrradianceAt",
                value: function(t, e) {
                    var i = t.x,
                        n = t.y,
                        r = t.z,
                        a = this.coefficients;
                    return e.copy(a[0]).multiplyScalar(.886227), e.addScaledVector(a[1], 1.023328 * n), e.addScaledVector(a[2], 1.023328 * r), e.addScaledVector(a[3], 1.023328 * i), e.addScaledVector(a[4], .858086 * i * n), e.addScaledVector(a[5], .858086 * n * r), e.addScaledVector(a[6], .743125 * r * r - .247708), e.addScaledVector(a[7], .858086 * i * r), e.addScaledVector(a[8], .429043 * (i * i - n * n)), e
                }
            }, {
                key: "add",
                value: function(t) {
                    for (var e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                    return this
                }
            }, {
                key: "addScaledSH",
                value: function(t, e) {
                    for (var i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], e);
                    return this
                }
            }, {
                key: "scale",
                value: function(t) {
                    for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                    return this
                }
            }, {
                key: "lerp",
                value: function(t, e) {
                    for (var i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
                    return this
                }
            }, {
                key: "equals",
                value: function(t) {
                    for (var e = 0; e < 9; e++)
                        if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                    return !0
                }
            }, {
                key: "copy",
                value: function(t) {
                    return this.set(t.coefficients)
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "fromArray",
                value: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var i = this.coefficients, n = 0; n < 9; n++) i[n].fromArray(t, e + 3 * n);
                    return this
                }
            }, {
                key: "toArray",
                value: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    for (var i = this.coefficients, n = 0; n < 9; n++) i[n].toArray(t, e + 3 * n);
                    return t
                }
            }], [{
                key: "getBasisAt",
                value: function(t, e) {
                    var i = t.x,
                        n = t.y,
                        r = t.z;
                    e[0] = .282095, e[1] = .488603 * n, e[2] = .488603 * r, e[3] = .488603 * i, e[4] = 1.092548 * i * n, e[5] = 1.092548 * n * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * i * r, e[8] = .546274 * (i * i - n * n)
                }
            }]), e
        }();

        function Ku(t, e) {
            zu.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new $u
        }

        function Qu(t) {
            ou.call(this, t), this.textures = {}
        }
        i.SphericalHarmonics3 = $u, Ku.prototype = Object.assign(Object.create(zu.prototype), {
            constructor: Ku,
            isLightProbe: !0,
            copy: function(t) {
                return zu.prototype.copy.call(this, t), this.sh.copy(t.sh), this
            },
            fromJSON: function(t) {
                return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
            },
            toJSON: function(t) {
                var e = zu.prototype.toJSON.call(this, t);
                return e.object.sh = this.sh.toArray(), e
            }
        }), Qu.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: Qu,
            load: function(e, i, t, n) {
                var r = this,
                    a = new hu(r.manager);
                a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.load(e, function(t) {
                    try {
                        i(r.parse(JSON.parse(t)))
                    } catch (t) {
                        n && n(t), r.manager.itemError(e)
                    }
                }, t, n)
            },
            parse: function(t) {
                var e = this.textures;

                function i(t) {
                    return e[t], e[t]
                }
                var n, r = new Uh[t.type];
                if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.sheen && (r.sheen = (new Hn).setHex(t.sheen)), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (r.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (r.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (r.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (r.morphNormals = t.morphNormals), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.vertexTangents && (r.vertexTangents = t.vertexTangents), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? r.vertexColors = 0 < t.vertexColors : r.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                    for (var a in t.uniforms) {
                        var s = t.uniforms[a];
                        switch (r.uniforms[a] = {}, s.type) {
                            case "t":
                                r.uniforms[a].value = i(s.value);
                                break;
                            case "c":
                                r.uniforms[a].value = (new Hn).setHex(s.value);
                                break;
                            case "v2":
                                r.uniforms[a].value = (new pi).fromArray(s.value);
                                break;
                            case "v3":
                                r.uniforms[a].value = (new wi).fromArray(s.value);
                                break;
                            case "v4":
                                r.uniforms[a].value = (new yi).fromArray(s.value);
                                break;
                            case "m3":
                                r.uniforms[a].value = (new fi).fromArray(s.value);
                                break;
                            case "m4":
                                r.uniforms[a].value = (new Zi).fromArray(s.value);
                                break;
                            default:
                                r.uniforms[a].value = s.value
                        }
                    }
                if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                    for (var o in t.extensions) r.extensions[o] = t.extensions[o];
                return void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = i(t.map)), void 0 !== t.matcap && (r.matcap = i(t.matcap)), void 0 !== t.alphaMap && (r.alphaMap = i(t.alphaMap)), void 0 !== t.bumpMap && (r.bumpMap = i(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = i(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale && (n = t.normalScale, !1 === Array.isArray(n) && (n = [n, n]), r.normalScale = (new pi).fromArray(n)), void 0 !== t.displacementMap && (r.displacementMap = i(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = i(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = i(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = i(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = i(t.specularMap)), void 0 !== t.envMap && (r.envMap = i(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (r.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (r.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = i(t.gradientMap)), void 0 !== t.clearcoatMap && (r.clearcoatMap = i(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = i(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (r.clearcoatNormalMap = i(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (r.clearcoatNormalScale = (new pi).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (r.transmission = t.transmission), void 0 !== t.transmissionMap && (r.transmissionMap = i(t.transmissionMap)), r
            },
            setTextures: function(t) {
                return this.textures = t, this
            }
        });
        var tc = {
            decodeText: function(t) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (t) {
                    return e
                }
            },
            extractUrlBase: function(t) {
                var e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            }
        };

        function ec() {
            gr.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
        }

        function ic(t, e, i, n) {
            "number" == typeof i && (n = i, i = !1), $n.call(this, t, e, i), this.meshPerAttribute = n || 1
        }

        function nc(t) {
            ou.call(this, t)
        }
        i.LoaderUtils = tc, ec.prototype = Object.assign(Object.create(gr.prototype), {
            constructor: ec,
            isInstancedBufferGeometry: !0,
            copy: function(t) {
                return gr.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                var t = gr.prototype.toJSON.call(this);
                return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
            }
        }), ic.prototype = Object.assign(Object.create($n.prototype), {
            constructor: ic,
            isInstancedBufferAttribute: !0,
            copy: function(t) {
                return $n.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            },
            toJSON: function() {
                var t = $n.prototype.toJSON.call(this);
                return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
            }
        }), nc.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: nc,
            load: function(e, i, t, n) {
                var r = this,
                    a = new hu(r.manager);
                a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.load(e, function(t) {
                    try {
                        i(r.parse(JSON.parse(t)))
                    } catch (t) {
                        n && n(t), r.manager.itemError(e)
                    }
                }, t, n)
            },
            parse: function(t) {
                var a = {},
                    s = {};

                function e(t, e) {
                    if (void 0 !== a[e]) return a[e];
                    var i = t.interleavedBuffers[e],
                        n = function(t, e) {
                            if (void 0 !== s[e]) return s[e];
                            var i = t.arrayBuffers[e],
                                n = new Uint32Array(i).buffer;
                            return s[e] = n
                        }(t, i.buffer),
                        r = new bo(new rc[i.type](n), i.stride);
                    return r.uuid = i.uuid, a[e] = r
                }
                var i, n = new(t.isInstancedBufferGeometry ? ec : gr),
                    r = t.data.index;
                void 0 !== r && (i = new rc[r.type](r.array), n.setIndex(new $n(i, 1)));
                var o = t.data.attributes;
                for (var l in o) {
                    var h, u = o[l],
                        c = void 0;
                    c = u.isInterleavedBufferAttribute ? new wo(e(t.data, u.data), u.itemSize, u.offset, u.normalized) : (h = new rc[u.type](u.array), new(u.isInstancedBufferAttribute ? ic : $n)(h, u.itemSize, u.normalized)), void 0 !== u.name && (c.name = u.name), n.setAttribute(l, c)
                }
                var p = t.data.morphAttributes;
                if (p)
                    for (var d in p) {
                        for (var f = p[d], m = [], g = 0, v = f.length; g < v; g++) {
                            var y = f[g],
                                b = void 0;
                            b = y.isInterleavedBufferAttribute ? new wo(e(t.data, y.data), y.itemSize, y.offset, y.normalized) : new $n(new rc[y.type](y.array), y.itemSize, y.normalized), void 0 !== y.name && (b.name = y.name), m.push(b)
                        }
                        n.morphAttributes[d] = m
                    }
                t.data.morphTargetsRelative && (n.morphTargetsRelative = !0);
                var x = t.data.groups || t.data.drawcalls || t.data.offsets;
                if (void 0 !== x)
                    for (var _ = 0, w = x.length; _ !== w; ++_) {
                        var S = x[_];
                        n.addGroup(S.start, S.count, S.materialIndex)
                    }
                var M, T = t.data.boundingSphere;
                return void 0 !== T && (M = new wi, void 0 !== T.center && M.fromArray(T.center), n.boundingSphere = new Vi(M, T.radius)), t.name && (n.name = t.name), t.userData && (n.userData = t.userData), n
            }
        });
        var rc = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };

        function ac(t) {
            ou.call(this, t)
        }
        ac.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: ac,
            load: function(t, n, e, r) {
                var a = this,
                    i = "" === this.path ? tc.extractUrlBase(t) : this.path;
                this.resourcePath = this.resourcePath || i;
                var s = new hu(a.manager);
                s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.load(t, function(t) {
                    var e = null;
                    try {
                        e = JSON.parse(t)
                    } catch (t) {
                        return void(void 0 !== r && r(t))
                    }
                    var i = e.metadata;
                    void 0 !== i && void 0 !== i.type && "geometry" !== i.type.toLowerCase() && a.parse(e, n)
                }, e, r)
            },
            parse: function(t, e) {
                var i = this.parseShape(t.shapes),
                    n = this.parseGeometries(t.geometries, i),
                    r = this.parseImages(t.images, function() {
                        void 0 !== e && e(o)
                    }),
                    a = this.parseTextures(t.textures, r),
                    s = this.parseMaterials(t.materials, a),
                    o = this.parseObject(t.object, n, s);
                return t.animations && (o.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(o), o
            },
            parseShape: function(t) {
                var e = {};
                if (void 0 !== t)
                    for (var i = 0, n = t.length; i < n; i++) {
                        var r = (new Ru).fromJSON(t[i]);
                        e[r.uuid] = r
                    }
                return e
            },
            parseGeometries: function(t, e) {
                var i, n = {};
                if (void 0 !== t)
                    for (var r = new nc, a = 0, s = t.length; a < s; a++) {
                        var o = void 0,
                            l = t[a];
                        switch (l.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                o = new Lh[l.type](l.width, l.height, l.widthSegments, l.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                o = new Lh[l.type](l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                o = new Lh[l.type](l.radius, l.segments, l.thetaStart, l.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                o = new Lh[l.type](l.radiusTop, l.radiusBottom, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                o = new Lh[l.type](l.radius, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                o = new Lh[l.type](l.radius, l.widthSegments, l.heightSegments, l.phiStart, l.phiLength, l.thetaStart, l.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "DodecahedronBufferGeometry":
                            case "IcosahedronGeometry":
                            case "IcosahedronBufferGeometry":
                            case "OctahedronGeometry":
                            case "OctahedronBufferGeometry":
                            case "TetrahedronGeometry":
                            case "TetrahedronBufferGeometry":
                                o = new Lh[l.type](l.radius, l.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                o = new Lh[l.type](l.innerRadius, l.outerRadius, l.thetaSegments, l.phiSegments, l.thetaStart, l.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                o = new Lh[l.type](l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                o = new Lh[l.type](l.radius, l.tube, l.tubularSegments, l.radialSegments, l.p, l.q);
                                break;
                            case "TubeGeometry":
                            case "TubeBufferGeometry":
                                o = new Lh[l.type]((new Iu[l.path.type]).fromJSON(l.path), l.tubularSegments, l.radius, l.radialSegments, l.closed);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                o = new Lh[l.type](l.points, l.segments, l.phiStart, l.phiLength);
                                break;
                            case "PolyhedronGeometry":
                            case "PolyhedronBufferGeometry":
                                o = new Lh[l.type](l.vertices, l.indices, l.radius, l.details);
                                break;
                            case "ShapeGeometry":
                            case "ShapeBufferGeometry":
                                i = [];
                                for (var h = 0, u = l.shapes.length; h < u; h++) {
                                    var c = e[l.shapes[h]];
                                    i.push(c)
                                }
                                o = new Lh[l.type](i, l.curveSegments);
                                break;
                            case "ExtrudeGeometry":
                            case "ExtrudeBufferGeometry":
                                i = [];
                                for (var p = 0, d = l.shapes.length; p < d; p++) {
                                    var f = e[l.shapes[p]];
                                    i.push(f)
                                }
                                var m = l.options.extrudePath;
                                void 0 !== m && (l.options.extrudePath = (new Iu[m.type]).fromJSON(m)), o = new Lh[l.type](i, l.options);
                                break;
                            case "BufferGeometry":
                            case "InstancedBufferGeometry":
                                o = r.parse(l);
                                break;
                            case "Geometry":
                                break;
                            default:
                                continue
                        }
                        o.uuid = l.uuid, void 0 !== l.name && (o.name = l.name), !0 === o.isBufferGeometry && void 0 !== l.userData && (o.userData = l.userData), n[l.uuid] = o
                    }
                return n
            },
            parseMaterials: function(t, e) {
                var i = {},
                    n = {};
                if (void 0 !== t) {
                    var r = new Qu;
                    r.setTextures(e);
                    for (var a = 0, s = t.length; a < s; a++) {
                        var o = t[a];
                        if ("MultiMaterial" === o.type) {
                            for (var l = [], h = 0; h < o.materials.length; h++) {
                                var u = o.materials[h];
                                void 0 === i[u.uuid] && (i[u.uuid] = r.parse(u)), l.push(i[u.uuid])
                            }
                            n[o.uuid] = l
                        } else void 0 === i[o.uuid] && (i[o.uuid] = r.parse(o)), n[o.uuid] = i[o.uuid]
                    }
                }
                return n
            },
            parseAnimations: function(t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var n = t[i],
                        r = iu.parse(n);
                    void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r)
                }
                return e
            },
            parseImages: function(t, e) {
                var i = this,
                    n = {};

                function r(t) {
                    return i.manager.itemStart(t), a.load(t, function() {
                        i.manager.itemEnd(t)
                    }, void 0, function() {
                        i.manager.itemError(t), i.manager.itemEnd(t)
                    })
                }
                if (void 0 !== t && 0 < t.length) {
                    var a, s = new au(e);
                    (a = new pu(s)).setCrossOrigin(this.crossOrigin);
                    for (var o = 0, l = t.length; o < l; o++) {
                        var h = t[o],
                            u = h.url;
                        if (Array.isArray(u)) {
                            n[h.uuid] = [];
                            for (var c = 0, p = u.length; c < p; c++) {
                                var d = u[c],
                                    f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : i.resourcePath + d;
                                n[h.uuid].push(r(f))
                            }
                        } else {
                            var m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : i.resourcePath + h.url;
                            n[h.uuid] = r(m)
                        }
                    }
                }
                return n
            },
            parseTextures: function(t, e) {
                function i(t, e) {
                    return "number" == typeof t ? t : e[t]
                }
                var n = {};
                if (void 0 !== t)
                    for (var r = 0, a = t.length; r < a; r++) {
                        var s = t[r];
                        s.image, e[s.image];
                        var o = void 0;
                        (o = new(Array.isArray(e[s.image]) ? Aa : vi)(e[s.image])).needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = i(s.mapping, oc)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = i(s.wrap[0], lc), o.wrapT = i(s.wrap[1], lc)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = i(s.minFilter, hc)), void 0 !== s.magFilter && (o.magFilter = i(s.magFilter, hc)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), n[s.uuid] = o
                    }
                return n
            },
            parseObject: function(t, e, a) {
                var i, n;

                function r(t) {
                    return e[t], e[t]
                }

                function s(t) {
                    if (void 0 !== t) {
                        if (Array.isArray(t)) {
                            for (var e = [], i = 0, n = t.length; i < n; i++) {
                                var r = t[i];
                                a[r], e.push(a[r])
                            }
                            return e
                        }
                        return a[t], a[t]
                    }
                }
                switch (t.type) {
                    case "Scene":
                        o = new yo, void 0 !== t.background && Number.isInteger(t.background) && (o.background = new Hn(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? o.fog = new vo(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (o.fog = new go(t.fog.color, t.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        o = new $r(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (o.focus = t.focus), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.filmGauge && (o.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (o.filmOffset = t.filmOffset), void 0 !== t.view && (o.view = Object.assign({}, t.view));
                        break;
                    case "OrthographicCamera":
                        o = new qu(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.view && (o.view = Object.assign({}, t.view));
                        break;
                    case "AmbientLight":
                        o = new Ju(t.color, t.intensity);
                        break;
                    case "DirectionalLight":
                        o = new Yu(t.color, t.intensity);
                        break;
                    case "PointLight":
                        o = new Wu(t.color, t.intensity, t.distance, t.decay);
                        break;
                    case "RectAreaLight":
                        o = new Zu(t.color, t.intensity, t.width, t.height);
                        break;
                    case "SpotLight":
                        o = new ju(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                        break;
                    case "HemisphereLight":
                        o = new Gu(t.color, t.groundColor, t.intensity);
                        break;
                    case "LightProbe":
                        o = (new Ku).fromJSON(t);
                        break;
                    case "SkinnedMesh":
                    case "Mesh":
                        o = new Fr(i = r(t.geometry), n = s(t.material));
                        break;
                    case "InstancedMesh":
                        i = r(t.geometry), n = s(t.material);
                        var o, l = t.count,
                            h = t.instanceMatrix;
                        (o = new el(i, n, l)).instanceMatrix = new $n(new Float32Array(h.array), 16);
                        break;
                    case "LOD":
                        o = new Wo;
                        break;
                    case "Line":
                        o = new ll(r(t.geometry), s(t.material), t.mode);
                        break;
                    case "LineLoop":
                        o = new pl(r(t.geometry), s(t.material));
                        break;
                    case "LineSegments":
                        o = new cl(r(t.geometry), s(t.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        o = new yl(r(t.geometry), s(t.material));
                        break;
                    case "Sprite":
                        o = new No(s(t.material));
                        break;
                    case "Group":
                        o = new ho;
                        break;
                    default:
                        o = new wn
                }
                if (o.uuid = t.uuid, void 0 !== t.name && (o.name = t.name), void 0 !== t.matrix ? (o.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (o.matrixAutoUpdate = t.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== t.position && o.position.fromArray(t.position), void 0 !== t.rotation && o.rotation.fromArray(t.rotation), void 0 !== t.quaternion && o.quaternion.fromArray(t.quaternion), void 0 !== t.scale && o.scale.fromArray(t.scale)), void 0 !== t.castShadow && (o.castShadow = t.castShadow), void 0 !== t.receiveShadow && (o.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (o.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (o.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (o.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && o.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (o.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (o.visible = t.visible), void 0 !== t.frustumCulled && (o.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (o.renderOrder = t.renderOrder), void 0 !== t.userData && (o.userData = t.userData), void 0 !== t.layers && (o.layers.mask = t.layers), void 0 !== t.children)
                    for (var u = t.children, c = 0; c < u.length; c++) o.add(this.parseObject(u[c], e, a));
                if ("LOD" === t.type) {
                    void 0 !== t.autoUpdate && (o.autoUpdate = t.autoUpdate);
                    for (var p = t.levels, d = 0; d < p.length; d++) {
                        var f = p[d],
                            m = o.getObjectByProperty("uuid", f.object);
                        void 0 !== m && o.addLevel(m, f.distance)
                    }
                }
                return o
            }
        });
        var sc, oc = {
                UVMapping: 300,
                CubeReflectionMapping: Pt,
                CubeRefractionMapping: Lt,
                EquirectangularReflectionMapping: c,
                EquirectangularRefractionMapping: p,
                CubeUVReflectionMapping: kt,
                CubeUVRefractionMapping: Ot
            },
            lc = {
                RepeatWrapping: Ft,
                ClampToEdgeWrapping: It,
                MirroredRepeatWrapping: Nt
            },
            hc = {
                NearestFilter: Bt,
                NearestMipmapNearestFilter: Rt,
                NearestMipmapLinearFilter: zt,
                LinearFilter: Gt,
                LinearMipmapNearestFilter: Vt,
                LinearMipmapLinearFilter: Ut
            };

        function uc(t) {
            ou.call(this, t), this.options = {
                premultiplyAlpha: "none"
            }
        }

        function cc() {
            this.type = "ShapePath", this.color = new Hn, this.subPaths = [], this.currentPath = null
        }

        function pc(t) {
            this.type = "Font", this.data = t
        }

        function dc(t) {
            ou.call(this, t)
        }
        uc.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: uc,
            isImageBitmapLoader: !0,
            setOptions: function(t) {
                return this.options = t, this
            },
            load: function(e, i, t, n) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                var r = this,
                    a = ru.get(e);
                if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function() {
                    i && i(a), r.manager.itemEnd(e)
                }, 0), a;
                fetch(e).then(function(t) {
                    return t.blob()
                }).then(function(t) {
                    return createImageBitmap(t, r.options)
                }).then(function(t) {
                    ru.add(e, t), i && i(t), r.manager.itemEnd(e)
                }).catch(function(t) {
                    n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                }), r.manager.itemStart(e)
            }
        }), Object.assign(cc.prototype, {
            moveTo: function(t, e) {
                return this.currentPath = new Bu, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
            },
            lineTo: function(t, e) {
                return this.currentPath.lineTo(t, e), this
            },
            quadraticCurveTo: function(t, e, i, n) {
                return this.currentPath.quadraticCurveTo(t, e, i, n), this
            },
            bezierCurveTo: function(t, e, i, n, r, a) {
                return this.currentPath.bezierCurveTo(t, e, i, n, r, a), this
            },
            splineThru: function(t) {
                return this.currentPath.splineThru(t), this
            },
            toShapes: function(t, e) {
                function i(t) {
                    for (var e = [], i = 0, n = t.length; i < n; i++) {
                        var r = t[i],
                            a = new Ru;
                        a.curves = r.curves, e.push(a)
                    }
                    return e
                }
                var n, r, a, s = sh.isClockWise,
                    o = this.subPaths;
                if (0 === o.length) return [];
                if (!0 === e) return i(o);
                var l = [];
                if (1 === o.length) return r = o[0], (a = new Ru).curves = r.curves, l.push(a), l;
                var h, u = !s(o[0].getPoints()),
                    u = t ? !u : u,
                    c = [],
                    p = [],
                    d = [],
                    f = 0;
                p[f] = void 0, d[f] = [];
                for (var m, g = 0, v = o.length; g < v; g++) n = s(h = (r = o[g]).getPoints()), (n = t ? !n : n) ? (!u && p[f] && f++, p[f] = {
                    s: new Ru,
                    p: h
                }, p[f].s.curves = r.curves, u && f++, d[f] = []) : d[f].push({
                    h: r,
                    p: h[0]
                });
                if (!p[0]) return i(o);
                if (1 < p.length) {
                    for (var y = !1, b = [], x = 0, _ = p.length; x < _; x++) c[x] = [];
                    for (var w = 0, S = p.length; w < S; w++)
                        for (var M = d[w], T = 0; T < M.length; T++) {
                            for (var C = M[T], A = !0, E = 0; E < p.length; E++) ! function(t, e) {
                                for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
                                    var s = e[r],
                                        o = e[a],
                                        l = o.x - s.x,
                                        h = o.y - s.y;
                                    if (Math.abs(h) > Number.EPSILON) {
                                        if (h < 0 && (s = e[a], l = -l, o = e[r], h = -h), t.y < s.y || t.y > o.y) continue;
                                        if (t.y === s.y) {
                                            if (t.x === s.x) return 1
                                        } else {
                                            var u = h * (t.x - s.x) - l * (t.y - s.y);
                                            if (0 == u) return 1;
                                            if (u < 0) continue;
                                            n = !n
                                        }
                                    } else {
                                        if (t.y !== s.y) continue;
                                        if (o.x <= t.x && t.x <= s.x || s.x <= t.x && t.x <= o.x) return 1
                                    }
                                }
                                return n
                            }(C.p, p[E].p) || (w !== E && b.push({
                                froms: w,
                                tos: E,
                                hole: T
                            }), A ? (A = !1, c[E].push(C)) : y = !0);
                            A && c[w].push(C)
                        }
                    0 < b.length && (y || (d = c))
                }
                for (var D = 0, P = p.length; D < P; D++) {
                    a = p[D].s, l.push(a);
                    for (var L = 0, k = (m = d[D]).length; L < k; L++) a.holes.push(m[L].h)
                }
                return l
            }
        }), Object.assign(pc.prototype, {
            isFont: !0,
            generateShapes: function(t, e) {
                void 0 === e && (e = 100);
                for (var i = [], n = function(t, e, i) {
                        for (var n = Array.from ? Array.from(t) : String(t).split(""), r = e / i.resolution, a = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, s = [], o = 0, l = 0, h = 0; h < n.length; h++) {
                            var u, c = n[h];
                            "\n" === c ? (o = 0, l -= a) : (u = function(t, e, i, n, r) {
                                var a = r.glyphs[t] || r.glyphs["?"];
                                if (!a) return;
                                var s, o, l, h, u, c, p, d, f = new cc;
                                if (a.o)
                                    for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, v = m.length; g < v;) {
                                        switch (m[g++]) {
                                            case "m":
                                                s = m[g++] * e + i, o = m[g++] * e + n, f.moveTo(s, o);
                                                break;
                                            case "l":
                                                s = m[g++] * e + i, o = m[g++] * e + n, f.lineTo(s, o);
                                                break;
                                            case "q":
                                                l = m[g++] * e + i, h = m[g++] * e + n, u = m[g++] * e + i, c = m[g++] * e + n, f.quadraticCurveTo(u, c, l, h);
                                                break;
                                            case "b":
                                                l = m[g++] * e + i, h = m[g++] * e + n, u = m[g++] * e + i, c = m[g++] * e + n, p = m[g++] * e + i, d = m[g++] * e + n, f.bezierCurveTo(u, c, p, d, l, h)
                                        }
                                    }
                                return {
                                    offsetX: a.ha * e,
                                    path: f
                                }
                            }(c, r, o, l, i), o += u.offsetX, s.push(u.path))
                        }
                        return s
                    }(t, e, this.data), r = 0, a = n.length; r < a; r++) Array.prototype.push.apply(i, n[r].toShapes());
                return i
            }
        }), dc.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: dc,
            load: function(t, n, e, i) {
                var r = this,
                    a = new hu(this.manager);
                a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.load(t, function(e) {
                    var i;
                    try {
                        i = JSON.parse(e)
                    } catch (t) {
                        i = JSON.parse(e.substring(65, e.length - 2))
                    }
                    var t = r.parse(i);
                    n && n(t)
                }, e, i)
            },
            parse: function(t) {
                return new pc(t)
            }
        });
        var fc = {
            getContext: function() {
                return void 0 === sc && (sc = new(window.AudioContext || window.webkitAudioContext)), sc
            },
            setContext: function(t) {
                sc = t
            }
        };

        function mc(t) {
            ou.call(this, t)
        }

        function gc(t, e, i) {
            Ku.call(this, void 0, i);
            var n = (new Hn).set(t),
                r = (new Hn).set(e),
                a = new wi(n.r, n.g, n.b),
                s = new wi(r.r, r.g, r.b),
                o = Math.sqrt(Math.PI),
                l = o * Math.sqrt(.75);
            this.sh.coefficients[0].copy(a).add(s).multiplyScalar(o), this.sh.coefficients[1].copy(a).sub(s).multiplyScalar(l)
        }

        function vc(t, e) {
            Ku.call(this, void 0, e);
            var i = (new Hn).set(t);
            this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
        }
        i.AudioContext = fc, mc.prototype = Object.assign(Object.create(ou.prototype), {
            constructor: mc,
            load: function(i, n, t, r) {
                var a = this,
                    e = new hu(a.manager);
                e.setResponseType("arraybuffer"), e.setPath(a.path), e.setRequestHeader(a.requestHeader), e.load(i, function(t) {
                    try {
                        var e = t.slice(0);
                        fc.getContext().decodeAudioData(e, function(t) {
                            n(t)
                        })
                    } catch (t) {
                        r && r(t), a.manager.itemError(i)
                    }
                }, t, r)
            }
        }), gc.prototype = Object.assign(Object.create(Ku.prototype), {
            constructor: gc,
            isHemisphereLightProbe: !0,
            copy: function(t) {
                return Ku.prototype.copy.call(this, t), this
            },
            toJSON: function(t) {
                return Ku.prototype.toJSON.call(this, t)
            }
        }), vc.prototype = Object.assign(Object.create(Ku.prototype), {
            constructor: vc,
            isAmbientLightProbe: !0,
            copy: function(t) {
                return Ku.prototype.copy.call(this, t), this
            },
            toJSON: function(t) {
                return Ku.prototype.toJSON.call(this, t)
            }
        });
        var yc = new Zi,
            bc = new Zi;

        function xc() {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new $r, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new $r, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null
            }
        }
        Object.assign(xc.prototype, {
            update: function(t) {
                var e, i, n, r, a, s, o = this._cache;
                o.focus === t.focus && o.fov === t.fov && o.aspect === t.aspect * this.aspect && o.near === t.near && o.far === t.far && o.zoom === t.zoom && o.eyeSep === this.eyeSep || (o.focus = t.focus, o.fov = t.fov, o.aspect = t.aspect * this.aspect, o.near = t.near, o.far = t.far, o.zoom = t.zoom, o.eyeSep = this.eyeSep, e = t.projectionMatrix.clone(), n = (i = o.eyeSep / 2) * o.near / o.focus, r = o.near * Math.tan(ci.DEG2RAD * o.fov * .5) / o.zoom, bc.elements[12] = -i, yc.elements[12] = i, a = -r * o.aspect + n, s = r * o.aspect + n, e.elements[0] = 2 * o.near / (s - a), e.elements[8] = (s + a) / (s - a), this.cameraL.projectionMatrix.copy(e), a = -r * o.aspect - n, s = r * o.aspect - n, e.elements[0] = 2 * o.near / (s - a), e.elements[8] = (s + a) / (s - a), this.cameraR.projectionMatrix.copy(e)), this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(bc), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(yc)
            }
        });
        var _c = function() {
            function e(t) {
                V(this, e), this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            return g(e, [{
                key: "start",
                value: function() {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
            }, {
                key: "stop",
                value: function() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
            }, {
                key: "getElapsedTime",
                value: function() {
                    return this.getDelta(), this.elapsedTime
                }
            }, {
                key: "getDelta",
                value: function() {
                    var t, e = 0;
                    return this.autoStart && !this.running ? (this.start(), 0) : (this.running && (e = ((t = ("undefined" == typeof performance ? Date : performance).now()) - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e), e)
                }
            }]), e
        }();
        i.Clock = _c;
        var wc = new wi,
            Sc = new _i,
            Mc = new wi,
            Tc = new wi,
            Cc = function() {
                d(r, wn);
                var e = y(r);

                function r() {
                    var t;
                    return V(this, r), (t = e.call(this)).type = "AudioListener", t.context = fc.getContext(), t.gain = t.context.createGain(), t.gain.connect(t.context.destination), t.filter = null, t.timeDelta = 0, t._clock = new _c, t
                }
                return g(r, [{
                    key: "getInput",
                    value: function() {
                        return this.gain
                    }
                }, {
                    key: "removeFilter",
                    value: function() {
                        return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                    }
                }, {
                    key: "getFilter",
                    value: function() {
                        return this.filter
                    }
                }, {
                    key: "setFilter",
                    value: function(t) {
                        return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                    }
                }, {
                    key: "getMasterVolume",
                    value: function() {
                        return this.gain.gain.value
                    }
                }, {
                    key: "setMasterVolume",
                    value: function(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                    }
                }, {
                    key: "updateMatrixWorld",
                    value: function(t) {
                        h(f(r.prototype), "updateMatrixWorld", this).call(this, t);
                        var e, i = this.context.listener,
                            n = this.up;
                        this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(wc, Sc, Mc), Tc.set(0, 0, -1).applyQuaternion(Sc), i.positionX ? (e = this.context.currentTime + this.timeDelta, i.positionX.linearRampToValueAtTime(wc.x, e), i.positionY.linearRampToValueAtTime(wc.y, e), i.positionZ.linearRampToValueAtTime(wc.z, e), i.forwardX.linearRampToValueAtTime(Tc.x, e), i.forwardY.linearRampToValueAtTime(Tc.y, e), i.forwardZ.linearRampToValueAtTime(Tc.z, e), i.upX.linearRampToValueAtTime(n.x, e), i.upY.linearRampToValueAtTime(n.y, e), i.upZ.linearRampToValueAtTime(n.z, e)) : (i.setPosition(wc.x, wc.y, wc.z), i.setOrientation(Tc.x, Tc.y, Tc.z, n.x, n.y, n.z))
                    }
                }]), r
            }();
        i.AudioListener = Cc;
        var Ac = function() {
            d(n, wn);
            var i = y(n);

            function n(t) {
                var e;
                return V(this, n), (e = i.call(this)).type = "Audio", e.listener = t, e.context = t.context, e.gain = e.context.createGain(), e.gain.connect(t.getInput()), e.autoplay = !1, e.buffer = null, e.detune = 0, e.loop = !1, e.loopStart = 0, e.loopEnd = 0, e.offset = 0, e.duration = void 0, e.playbackRate = 1, e.isPlaying = !1, e.hasPlaybackControl = !0, e.source = null, e.sourceType = "empty", e._startedAt = 0, e._progress = 0, e._connected = !1, e.filters = [], e
            }
            return g(n, [{
                key: "getOutput",
                value: function() {
                    return this.gain
                }
            }, {
                key: "setNodeSource",
                value: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                }
            }, {
                key: "setMediaElementSource",
                value: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                }
            }, {
                key: "setMediaStreamSource",
                value: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                }
            }, {
                key: "setBuffer",
                value: function(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
            }, {
                key: "play",
                value: function(t) {
                    if (void 0 === t && (t = 0), !0 !== this.isPlaying && !1 !== this.hasPlaybackControl) {
                        this._startedAt = this.context.currentTime + t;
                        var e = this.context.createBufferSource();
                        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                }
            }, {
                key: "pause",
                value: function() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
                }
            }, {
                key: "stop",
                value: function() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this
                }
            }, {
                key: "connect",
                value: function() {
                    if (0 < this.filters.length) {
                        this.source.connect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
            }, {
                key: "disconnect",
                value: function() {
                    if (0 < this.filters.length) {
                        this.source.disconnect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
            }, {
                key: "getFilters",
                value: function() {
                    return this.filters
                }
            }, {
                key: "setFilters",
                value: function(t) {
                    return t = t || [], !0 === this._connected ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
                }
            }, {
                key: "setDetune",
                value: function(t) {
                    if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
            }, {
                key: "getDetune",
                value: function() {
                    return this.detune
                }
            }, {
                key: "getFilter",
                value: function() {
                    return this.getFilters()[0]
                }
            }, {
                key: "setFilter",
                value: function(t) {
                    return this.setFilters(t ? [t] : [])
                }
            }, {
                key: "setPlaybackRate",
                value: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
                }
            }, {
                key: "getPlaybackRate",
                value: function() {
                    return this.playbackRate
                }
            }, {
                key: "onEnded",
                value: function() {
                    this.isPlaying = !1
                }
            }, {
                key: "getLoop",
                value: function() {
                    return !1 !== this.hasPlaybackControl && this.loop
                }
            }, {
                key: "setLoop",
                value: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this
                }
            }, {
                key: "setLoopStart",
                value: function(t) {
                    return this.loopStart = t, this
                }
            }, {
                key: "setLoopEnd",
                value: function(t) {
                    return this.loopEnd = t, this
                }
            }, {
                key: "getVolume",
                value: function() {
                    return this.gain.gain.value
                }
            }, {
                key: "setVolume",
                value: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            }]), n
        }();
        i.Audio = Ac;
        var Ec = new wi,
            Dc = new _i,
            Pc = new wi,
            Lc = new wi,
            kc = function() {
                d(n, Ac);
                var i = y(n);

                function n(t) {
                    var e;
                    return V(this, n), (e = i.call(this, t)).panner = e.context.createPanner(), e.panner.panningModel = "HRTF", e.panner.connect(e.gain), e
                }
                return g(n, [{
                    key: "getOutput",
                    value: function() {
                        return this.panner
                    }
                }, {
                    key: "getRefDistance",
                    value: function() {
                        return this.panner.refDistance
                    }
                }, {
                    key: "setRefDistance",
                    value: function(t) {
                        return this.panner.refDistance = t, this
                    }
                }, {
                    key: "getRolloffFactor",
                    value: function() {
                        return this.panner.rolloffFactor
                    }
                }, {
                    key: "setRolloffFactor",
                    value: function(t) {
                        return this.panner.rolloffFactor = t, this
                    }
                }, {
                    key: "getDistanceModel",
                    value: function() {
                        return this.panner.distanceModel
                    }
                }, {
                    key: "setDistanceModel",
                    value: function(t) {
                        return this.panner.distanceModel = t, this
                    }
                }, {
                    key: "getMaxDistance",
                    value: function() {
                        return this.panner.maxDistance
                    }
                }, {
                    key: "setMaxDistance",
                    value: function(t) {
                        return this.panner.maxDistance = t, this
                    }
                }, {
                    key: "setDirectionalCone",
                    value: function(t, e, i) {
                        return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this
                    }
                }, {
                    key: "updateMatrixWorld",
                    value: function(t) {
                        var e, i;
                        h(f(n.prototype), "updateMatrixWorld", this).call(this, t), !0 === this.hasPlaybackControl && !1 === this.isPlaying || (this.matrixWorld.decompose(Ec, Dc, Pc), Lc.set(0, 0, 1).applyQuaternion(Dc), (e = this.panner).positionX ? (i = this.context.currentTime + this.listener.timeDelta, e.positionX.linearRampToValueAtTime(Ec.x, i), e.positionY.linearRampToValueAtTime(Ec.y, i), e.positionZ.linearRampToValueAtTime(Ec.z, i), e.orientationX.linearRampToValueAtTime(Lc.x, i), e.orientationY.linearRampToValueAtTime(Lc.y, i), e.orientationZ.linearRampToValueAtTime(Lc.z, i)) : (e.setPosition(Ec.x, Ec.y, Ec.z), e.setOrientation(Lc.x, Lc.y, Lc.z)))
                    }
                }]), n
            }();
        i.PositionalAudio = kc;
        var Oc = function() {
            function i(t, e) {
                V(this, i), this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
            }
            return g(i, [{
                key: "getFrequencyData",
                value: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                }
            }, {
                key: "getAverageFrequency",
                value: function() {
                    for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                    return t / e.length
                }
            }]), i
        }();

        function Fc(t, e, i) {
            var n, r, a;
            switch (this.binding = t, this.valueSize = i, e) {
                case "quaternion":
                    n = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    n = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i);
                    break;
                default:
                    n = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i)
            }
            this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
        }
        i.AudioAnalyser = Oc, Object.assign(Fc.prototype, {
            accumulate: function(t, e) {
                var i = this.buffer,
                    n = this.valueSize,
                    r = t * n + n,
                    a = this.cumulativeWeight;
                if (0 === a) {
                    for (var s = 0; s !== n; ++s) i[r + s] = i[s];
                    a = e
                } else {
                    var o = e / (a += e);
                    this._mixBufferRegion(i, r, 0, o, n)
                }
                this.cumulativeWeight = a
            },
            accumulateAdditive: function(t) {
                var e = this.buffer,
                    i = this.valueSize,
                    n = i * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, i), this.cumulativeWeightAdditive += t
            },
            apply: function(t) {
                var e, i = this.valueSize,
                    n = this.buffer,
                    r = t * i + i,
                    a = this.cumulativeWeight,
                    s = this.cumulativeWeightAdditive,
                    o = this.binding;
                this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, a < 1 && (e = i * this._origIndex, this._mixBufferRegion(n, r, e, 1 - a, i)), 0 < s && this._mixBufferRegionAdditive(n, r, this._addIndex * i, 1, i);
                for (var l = i, h = i + i; l !== h; ++l)
                    if (n[l] !== n[l + i]) {
                        o.setValue(n, r);
                        break
                    }
            },
            saveOriginalState: function() {
                var t = this.binding,
                    e = this.buffer,
                    i = this.valueSize,
                    n = i * this._origIndex;
                t.getValue(e, n);
                for (var r = i, a = n; r !== a; ++r) e[r] = e[n + r % i];
                this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
            },
            restoreOriginalState: function() {
                var t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            },
            _setAdditiveIdentityNumeric: function() {
                for (var t = this._addIndex * this.valueSize, e = t + this.valueSize, i = t; i < e; i++) this.buffer[i] = 0
            },
            _setAdditiveIdentityQuaternion: function() {
                this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
            },
            _setAdditiveIdentityOther: function() {
                for (var t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize, i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i]
            },
            _select: function(t, e, i, n, r) {
                if (.5 <= n)
                    for (var a = 0; a !== r; ++a) t[e + a] = t[i + a]
            },
            _slerp: function(t, e, i, n) {
                _i.slerpFlat(t, e, t, e, t, i, n)
            },
            _slerpAdditive: function(t, e, i, n, r) {
                var a = this._workIndex * r;
                _i.multiplyQuaternionsFlat(t, a, t, e, t, i), _i.slerpFlat(t, e, t, e, t, a, n)
            },
            _lerp: function(t, e, i, n, r) {
                for (var a = 1 - n, s = 0; s !== r; ++s) {
                    var o = e + s;
                    t[o] = t[o] * a + t[i + s] * n
                }
            },
            _lerpAdditive: function(t, e, i, n, r) {
                for (var a = 0; a !== r; ++a) {
                    var s = e + a;
                    t[s] = t[s] + t[i + a] * n
                }
            }
        });
        var Ic = "\\[\\]\\.:\\/",
            Nc = new RegExp("[" + Ic + "]", "g"),
            Bc = "[^" + Ic + "]",
            Rc = "[^" + Ic.replace("\\.", "") + "]",
            zc = /((?:WC+[\/:])*)/.source.replace("WC", Bc),
            Gc = /(WCOD+)?/.source.replace("WCOD", Rc),
            Vc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Bc),
            Uc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Bc),
            jc = new RegExp("^" + zc + Gc + Vc + Uc + "$"),
            Hc = ["material", "materials", "bones"];

        function Wc(t, e, i) {
            var n = i || qc.parseTrackName(e);
            this._targetGroup = t, this._bindings = t.subscribe_(e, n)
        }

        function qc(t, e, i) {
            this.path = e, this.parsedPath = i || qc.parseTrackName(e), this.node = qc.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
        }

        function Xc() {
            this.uuid = ci.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var t = {};
            this._indicesByUUID = t;
            for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var n = this;
            this.stats = {
                objects: {
                    get total() {
                        return n._objects.length
                    },
                    get inUse() {
                        return this.total - n.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return n._bindings.length
                }
            }
        }
        Object.assign(Wc.prototype, {
            getValue: function(t, e) {
                this.bind();
                var i = this._targetGroup.nCachedObjects_,
                    n = this._bindings[i];
                void 0 !== n && n.getValue(t, e)
            },
            setValue: function(t, e) {
                for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
            },
            bind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
            },
            unbind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
            }
        }), Object.assign(qc, {
            Composite: Wc,
            create: function(t, e, i) {
                return t && t.isAnimationObjectGroup ? new qc.Composite(t, e, i) : new qc(t, e, i)
            },
            sanitizeNodeName: function(t) {
                return t.replace(/\s/g, "_").replace(Nc, "")
            },
            parseTrackName: function(t) {
                var e = jc.exec(t);
                if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                var i, n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6]
                    },
                    r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r && (i = n.nodeName.substring(r + 1), -1 !== Hc.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)), null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            },
            findNode: function(t, a) {
                if (!a || "" === a || "." === a || -1 === a || a === t.name || a === t.uuid) return t;
                if (t.skeleton) {
                    var e = t.skeleton.getBoneByName(a);
                    if (void 0 !== e) return e
                }
                if (t.children) {
                    var i = function t(e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            if (n.name === a || n.uuid === a) return n;
                            var r = t(n.children);
                            if (r) return r
                        }
                        return null
                    }(t.children);
                    if (i) return i
                }
                return null
            }
        }), Object.assign(qc.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(t, e) {
                t[e] = this.node[this.propertyName]
            }, function(t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
            }, function(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function(t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(t, e) {
                    this.targetObject[this.propertyName] = t[e]
                }, function(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function(t, e) {
                this.bind(), this.getValue(t, e)
            },
            setValue: function(t, e) {
                this.bind(), this.setValue(t, e)
            },
            bind: function() {
                var t = this.node,
                    e = this.parsedPath,
                    i = e.objectName,
                    n = e.propertyName,
                    r = e.propertyIndex;
                if (t || (t = qc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                    if (i) {
                        var a = e.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!t.material) return;
                                if (!t.material.materials) return;
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return;
                                t = t.skeleton.bones;
                                for (var s = 0; s < t.length; s++)
                                    if (t[s].name === a) {
                                        a = s;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === t[i]) return;
                                t = t[i]
                        }
                        if (void 0 !== a) {
                            if (void 0 === t[a]) return;
                            t = t[a]
                        }
                    }
                    var o = t[n];
                    if (void 0 !== o) {
                        var l = this.Versioning.None;
                        void 0 !== (this.targetObject = t).needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                        var h = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === n) {
                                if (!t.geometry) return;
                                if (!t.geometry.isBufferGeometry) return;
                                if (!t.geometry.morphAttributes) return;
                                void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                            }
                            h = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                        } else void 0 !== o.fromArray && void 0 !== o.toArray ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (h = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
                        this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][l]
                    } else e.nodeName
                }
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), Object.assign(qc.prototype, {
            _getValue_unbound: qc.prototype.getValue,
            _setValue_unbound: qc.prototype.setValue
        }), Object.assign(Xc.prototype, {
            isAnimationObjectGroup: !0,
            add: function() {
                for (var t = this._objects, e = this._indicesByUUID, i = this._paths, n = this._parsedPaths, r = this._bindings, a = r.length, s = t.length, o = this.nCachedObjects_, l = 0, h = arguments.length; l !== h; ++l) {
                    var u = arguments[l],
                        c = u.uuid,
                        p = e[c];
                    if (void 0 === p) {
                        p = s++, e[c] = p, t.push(u);
                        for (var d = 0, f = a; d !== f; ++d) r[d].push(new qc(u, i[d], n[d]))
                    } else if (p < o) {
                        t[p];
                        var m = --o,
                            g = t[m];
                        t[e[g.uuid] = p] = g, t[e[c] = m] = u;
                        for (var v = 0, y = a; v !== y; ++v) {
                            var b = r[v],
                                x = b[m],
                                _ = b[p];
                            b[p] = x, void 0 === _ && (_ = new qc(u, i[v], n[v])), b[m] = _
                        }
                    } else t[p]
                }
                this.nCachedObjects_ = o
            },
            remove: function() {
                for (var t = this._objects, e = this._indicesByUUID, i = this._bindings, n = i.length, r = this.nCachedObjects_, a = 0, s = arguments.length; a !== s; ++a) {
                    var o = arguments[a],
                        l = o.uuid,
                        h = e[l];
                    if (void 0 !== h && r <= h) {
                        var u = r++,
                            c = t[u];
                        t[e[c.uuid] = h] = c, t[e[l] = u] = o;
                        for (var p = 0, d = n; p !== d; ++p) {
                            var f = i[p],
                                m = f[u],
                                g = f[h];
                            f[h] = m, f[u] = g
                        }
                    }
                }
                this.nCachedObjects_ = r
            },
            uncache: function() {
                for (var t = this._objects, e = this._indicesByUUID, i = this._bindings, n = i.length, r = this.nCachedObjects_, a = t.length, s = 0, o = arguments.length; s !== o; ++s) {
                    var l = arguments[s].uuid,
                        h = e[l];
                    if (void 0 !== h)
                        if (delete e[l], h < r) {
                            var u = --r,
                                c = t[u],
                                p = --a,
                                d = t[p];
                            t[e[c.uuid] = h] = c, t[e[d.uuid] = u] = d, t.pop();
                            for (var f = 0, m = n; f !== m; ++f) {
                                var g = i[f],
                                    v = g[u],
                                    y = g[p];
                                g[h] = v, g[u] = y, g.pop()
                            }
                        } else {
                            var b = --a,
                                x = t[b];
                            t[e[x.uuid] = h] = x, t.pop();
                            for (var _ = 0, w = n; _ !== w; ++_) {
                                var S = i[_];
                                S[h] = S[b], S.pop()
                            }
                        }
                }
                this.nCachedObjects_ = r
            },
            subscribe_: function(t, e) {
                var i = this._bindingsIndicesByPath,
                    n = i[t],
                    r = this._bindings;
                if (void 0 !== n) return r[n];
                var a = this._paths,
                    s = this._parsedPaths,
                    o = this._objects,
                    l = o.length,
                    h = this.nCachedObjects_,
                    u = new Array(l),
                    n = r.length;
                i[t] = n, a.push(t), s.push(e), r.push(u);
                for (var c = h, p = o.length; c !== p; ++c) {
                    var d = o[c];
                    u[c] = new qc(d, t, e)
                }
                return u
            },
            unsubscribe_: function(t) {
                var e, i, n, r, a, s = this._bindingsIndicesByPath,
                    o = s[t];
                void 0 !== o && (e = this._paths, i = this._parsedPaths, a = (n = this._bindings)[r = n.length - 1], n[s[t[r]] = o] = a, n.pop(), i[o] = i[r], i.pop(), e[o] = e[r], e.pop())
            }
        });
        var Yc = function() {
            function u(t, e, i, n) {
                V(this, u), this._mixer = t, this._clip = e, this._localRoot = i || null, this.blendMode = n || e.blendMode;
                for (var r = e.tracks, a = r.length, s = new Array(a), o = {
                        endingStart: Ge,
                        endingEnd: Ge
                    }, l = 0; l !== a; ++l) {
                    var h = r[l].createInterpolant(null);
                    (s[l] = h).settings = o
                }
                this._interpolantSettings = o, this._interpolants = s, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Be, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }
            return g(u, [{
                key: "play",
                value: function() {
                    return this._mixer._activateAction(this), this
                }
            }, {
                key: "stop",
                value: function() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
            }, {
                key: "reset",
                value: function() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
            }, {
                key: "isRunning",
                value: function() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
            }, {
                key: "isScheduled",
                value: function() {
                    return this._mixer._isActiveAction(this)
                }
            }, {
                key: "startAt",
                value: function(t) {
                    return this._startTime = t, this
                }
            }, {
                key: "setLoop",
                value: function(t, e) {
                    return this.loop = t, this.repetitions = e, this
                }
            }, {
                key: "setEffectiveWeight",
                value: function(t) {
                    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                }
            }, {
                key: "getEffectiveWeight",
                value: function() {
                    return this._effectiveWeight
                }
            }, {
                key: "fadeIn",
                value: function(t) {
                    return this._scheduleFading(t, 0, 1)
                }
            }, {
                key: "fadeOut",
                value: function(t) {
                    return this._scheduleFading(t, 1, 0)
                }
            }, {
                key: "crossFadeFrom",
                value: function(t, e, i) {
                    var n, r, a, s;
                    return t.fadeOut(e), this.fadeIn(e), i && (n = this._clip.duration, a = (r = t._clip.duration) / n, s = n / r, t.warp(1, a, e), this.warp(s, 1, e)), this
                }
            }, {
                key: "crossFadeTo",
                value: function(t, e, i) {
                    return t.crossFadeFrom(this, e, i)
                }
            }, {
                key: "stopFading",
                value: function() {
                    var t = this._weightInterpolant;
                    return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
            }, {
                key: "setEffectiveTimeScale",
                value: function(t) {
                    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                }
            }, {
                key: "getEffectiveTimeScale",
                value: function() {
                    return this._effectiveTimeScale
                }
            }, {
                key: "setDuration",
                value: function(t) {
                    return this.timeScale = this._clip.duration / t, this.stopWarping()
                }
            }, {
                key: "syncWith",
                value: function(t) {
                    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                }
            }, {
                key: "halt",
                value: function(t) {
                    return this.warp(this._effectiveTimeScale, 0, t)
                }
            }, {
                key: "warp",
                value: function(t, e, i) {
                    var n = this._mixer,
                        r = n.time,
                        a = this.timeScale,
                        s = this._timeScaleInterpolant;
                    null === s && (s = n._lendControlInterpolant(), this._timeScaleInterpolant = s);
                    var o = s.parameterPositions,
                        l = s.sampleValues;
                    return o[0] = r, o[1] = r + i, l[0] = t / a, l[1] = e / a, this
                }
            }, {
                key: "stopWarping",
                value: function() {
                    var t = this._timeScaleInterpolant;
                    return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
            }, {
                key: "getMixer",
                value: function() {
                    return this._mixer
                }
            }, {
                key: "getClip",
                value: function() {
                    return this._clip
                }
            }, {
                key: "getRoot",
                value: function() {
                    return this._localRoot || this._mixer._root
                }
            }, {
                key: "_update",
                value: function(t, e, i, n) {
                    if (this.enabled) {
                        var r = this._startTime;
                        if (null !== r) {
                            var a = (t - r) * i;
                            if (a < 0 || 0 === i) return;
                            this._startTime = null, e = i * a
                        }
                        e *= this._updateTimeScale(t);
                        var s = this._updateTime(e),
                            o = this._updateWeight(t);
                        if (0 < o) {
                            var l = this._interpolants,
                                h = this._propertyBindings;
                            switch (this.blendMode) {
                                case 2501:
                                    for (var u = 0, c = l.length; u !== c; ++u) l[u].evaluate(s), h[u].accumulateAdditive(o);
                                    break;
                                case je:
                                default:
                                    for (var p = 0, d = l.length; p !== d; ++p) l[p].evaluate(s), h[p].accumulate(n, o)
                            }
                        }
                    } else this._updateWeight(t)
                }
            }, {
                key: "_updateWeight",
                value: function(t) {
                    var e, i, n = 0;
                    return this.enabled && (n = this.weight, null !== (e = this._weightInterpolant) && (n *= i = e.evaluate(t)[0], t > e.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1)))), this._effectiveWeight = n
                }
            }, {
                key: "_updateTimeScale",
                value: function(t) {
                    var e, i = 0;
                    return this.paused || (i = this.timeScale, null !== (e = this._timeScaleInterpolant) && (i *= e.evaluate(t)[0], t > e.parameterPositions[1] && (this.stopWarping(), 0 === i ? this.paused = !0 : this.timeScale = i))), this._effectiveTimeScale = i
                }
            }, {
                key: "_updateTime",
                value: function(t) {
                    var e, i, n, r = this._clip.duration,
                        a = this.loop,
                        s = this.time + t,
                        o = this._loopCount,
                        l = 2202 === a;
                    if (0 === t) return -1 !== o && l && 1 == (1 & o) ? r - s : s;
                    if (2200 === a) {
                        -1 === o && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        t: {
                            if (r <= s) s = r;
                            else {
                                if (!(s < 0)) {
                                    this.time = s;
                                    break t
                                }
                                s = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = s,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === o && (0 <= t ? (o = 0, this._setEndings(!0, 0 === this.repetitions, l)) : this._setEndings(0 === this.repetitions, !0, l)), r <= s || s < 0 ? (s -= r * (e = Math.floor(s / r)), o += Math.abs(e), (i = this.repetitions - o) <= 0 ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = 0 < t ? r : 0, this.time = s, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: 0 < t ? 1 : -1
                            })) : (1 == i ? (n = t < 0, this._setEndings(n, !n, l)) : this._setEndings(!1, !1, l), this._loopCount = o, this.time = s, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: e
                            }))) : this.time = s, l && 1 == (1 & o)) return r - s
                    }
                    return s
                }
            }, {
                key: "_setEndings",
                value: function(t, e, i) {
                    var n = this._interpolantSettings;
                    i ? (n.endingStart = Ve, n.endingEnd = Ve) : (n.endingStart = t ? this.zeroSlopeAtStart ? Ve : Ge : Ue, n.endingEnd = e ? this.zeroSlopeAtEnd ? Ve : Ge : Ue)
                }
            }, {
                key: "_scheduleFading",
                value: function(t, e, i) {
                    var n = this._mixer,
                        r = n.time,
                        a = this._weightInterpolant;
                    null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
                    var s = a.parameterPositions,
                        o = a.sampleValues;
                    return s[0] = r, o[0] = e, s[1] = r + t, o[1] = i, this
                }
            }]), u
        }();

        function Jc(t) {
            this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
        }
        Jc.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: Jc,
            _bindAction: function(t, e) {
                var i = t._localRoot || this._root,
                    n = t._clip.tracks,
                    r = n.length,
                    a = t._propertyBindings,
                    s = t._interpolants,
                    o = i.uuid,
                    l = this._bindingsByRootAndName,
                    h = l[o];
                void 0 === h && (h = {}, l[o] = h);
                for (var u = 0; u !== r; ++u) {
                    var c = n[u],
                        p = c.name;
                    if (void 0 !== (d = h[p])) a[u] = d;
                    else {
                        if (void 0 !== (d = a[u])) {
                            null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, o, p));
                            continue
                        }
                        var d, f = e && e._propertyBindings[u].binding.parsedPath;
                        ++(d = new Fc(qc.create(i, p, f), c.ValueTypeName, c.getValueSize())).referenceCount, this._addInactiveBinding(d, o, p), a[u] = d
                    }
                    s[u].resultBuffer = d.buffer
                }
            },
            _activateAction: function(t) {
                if (!this._isActiveAction(t)) {
                    var e, i, n;
                    null === t._cacheIndex && (e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i], this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e));
                    for (var r = t._propertyBindings, a = 0, s = r.length; a !== s; ++a) {
                        var o = r[a];
                        0 == o.useCount++ && (this._lendBinding(o), o.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            },
            _deactivateAction: function(t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                        var r = e[i];
                        0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                    }
                    this._takeBackAction(t)
                }
            },
            _initMemoryManager: function() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(t) {
                var e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            },
            _addInactiveAction: function(t, e, i) {
                var n, r = this._actions,
                    a = this._actionsByClip,
                    s = a[e];
                void 0 === s ? (s = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, a[e] = s) : (n = s.knownActions, t._byClipCacheIndex = n.length, n.push(t)), t._cacheIndex = r.length, r.push(t), s.actionByRoot[i] = t
            },
            _removeInactiveAction: function(t) {
                var e = this._actions,
                    i = e[e.length - 1],
                    n = t._cacheIndex;
                e[i._cacheIndex = n] = i, e.pop(), t._cacheIndex = null;
                var r = t._clip.uuid,
                    a = this._actionsByClip,
                    s = a[r],
                    o = s.knownActions,
                    l = o[o.length - 1],
                    h = t._byClipCacheIndex;
                o[l._byClipCacheIndex = h] = l, o.pop(), t._byClipCacheIndex = null, delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete a[r], this._removeInactiveBindingsForAction(t)
            },
            _removeInactiveBindingsForAction: function(t) {
                for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                    var r = e[i];
                    0 == --r.referenceCount && this._removeInactiveBinding(r)
                }
            },
            _lendAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = this._nActiveActions++,
                    r = e[n];
                e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
            },
            _takeBackAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = --this._nActiveActions,
                    r = e[n];
                e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
            },
            _addInactiveBinding: function(t, e, i) {
                var n = this._bindingsByRootAndName,
                    r = this._bindings,
                    a = n[e];
                void 0 === a && (a = {}, n[e] = a), (a[i] = t)._cacheIndex = r.length, r.push(t)
            },
            _removeInactiveBinding: function(t) {
                var e = this._bindings,
                    i = t.binding,
                    n = i.rootNode.uuid,
                    r = i.path,
                    a = this._bindingsByRootAndName,
                    s = a[n],
                    o = e[e.length - 1],
                    l = t._cacheIndex;
                e[o._cacheIndex = l] = o, e.pop(), delete s[r], 0 === Object.keys(s).length && delete a[n]
            },
            _lendBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = this._nActiveBindings++,
                    r = e[n];
                e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
            },
            _takeBackBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = --this._nActiveBindings,
                    r = e[n];
                e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
            },
            _lendControlInterpolant: function() {
                var t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++,
                    i = t[e];
                return void 0 === i && (t[(i = new qh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e] = i), i
            },
            _takeBackControlInterpolant: function(t) {
                var e = this._controlInterpolants,
                    i = t.__cacheIndex,
                    n = --this._nActiveControlInterpolants,
                    r = e[n];
                e[t.__cacheIndex = n] = t, e[r.__cacheIndex = i] = r
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function(t, e, i) {
                var n = e || this._root,
                    r = n.uuid,
                    a = "string" == typeof t ? iu.findByName(n, t) : t,
                    s = null !== a ? a.uuid : t,
                    o = this._actionsByClip[s],
                    l = null;
                if (void 0 === i && (i = null !== a ? a.blendMode : je), void 0 !== o) {
                    var h = o.actionByRoot[r];
                    if (void 0 !== h && h.blendMode === i) return h;
                    l = o.knownActions[0], null === a && (a = l._clip)
                }
                if (null === a) return null;
                var u = new Yc(this, a, e, i);
                return this._bindAction(u, l), this._addInactiveAction(u, s, r), u
            },
            existingAction: function(t, e) {
                var i = e || this._root,
                    n = i.uuid,
                    r = "string" == typeof t ? iu.findByName(i, t) : t,
                    a = r ? r.uuid : t,
                    s = this._actionsByClip[a];
                return void 0 !== s && s.actionByRoot[n] || null
            },
            stopAllAction: function() {
                for (var t = this._actions, e = this._nActiveActions - 1; 0 <= e; --e) t[e].stop();
                return this
            },
            update: function(t) {
                t *= this.timeScale;
                for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, s = 0; s !== i; ++s) {
                    e[s]._update(n, t, r, a)
                }
                for (var o = this._bindings, l = this._nActiveBindings, h = 0; h !== l; ++h) o[h].apply(a);
                return this
            },
            setTime: function(t) {
                for (var e = this.time = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                return this.update(t)
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(t) {
                var e = this._actions,
                    i = t.uuid,
                    n = this._actionsByClip,
                    r = n[i];
                if (void 0 !== r) {
                    for (var a = r.knownActions, s = 0, o = a.length; s !== o; ++s) {
                        var l = a[s];
                        this._deactivateAction(l);
                        var h = l._cacheIndex,
                            u = e[e.length - 1];
                        l._cacheIndex = null, l._byClipCacheIndex = null, e[u._cacheIndex = h] = u, e.pop(), this._removeInactiveBindingsForAction(l)
                    }
                    delete n[i]
                }
            },
            uncacheRoot: function(t) {
                var e = t.uuid,
                    i = this._actionsByClip;
                for (var n in i) {
                    var r = i[n].actionByRoot[e];
                    void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                }
                var a = this._bindingsByRootAndName[e];
                if (void 0 !== a)
                    for (var s in a) {
                        var o = a[s];
                        o.restoreOriginalState(), this._removeInactiveBinding(o)
                    }
            },
            uncacheAction: function(t, e) {
                var i = this.existingAction(t, e);
                null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
        });
        var Zc = function() {
            function e(t) {
                V(this, e), "string" == typeof t && (t = arguments[1]), this.value = t
            }
            return g(e, [{
                key: "clone",
                value: function() {
                    return new e(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }]), e
        }();

        function $c(t, e, i) {
            bo.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function Kc(t, e, i, n, r) {
            this.buffer = t, this.type = e, this.itemSize = i, this.elementSize = n, this.count = r, this.version = 0
        }

        function Qc(t, e, i, n) {
            this.ray = new Ji(t, e), this.near = i || 0, this.far = n || 1 / 0, this.camera = null, this.layers = new ln, this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function() {
                        return this.Points
                    }
                }
            })
        }

        function tp(t, e) {
            return t.distance - e.distance
        }

        function ep(t, e, i, n) {
            if (t.layers.test(e.layers) && t.raycast(e, i), !0 === n)
                for (var r = t.children, a = 0, s = r.length; a < s; a++) ep(r[a], e, i, !0)
        }
        i.Uniform = Zc, $c.prototype = Object.assign(Object.create(bo.prototype), {
            constructor: $c,
            isInstancedInterleavedBuffer: !0,
            copy: function(t) {
                return bo.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            },
            clone: function(t) {
                var e = bo.prototype.clone.call(this, t);
                return e.meshPerAttribute = this.meshPerAttribute, e
            },
            toJSON: function(t) {
                var e = bo.prototype.toJSON.call(this, t);
                return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
            }
        }), Object.defineProperty(Kc.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(Kc.prototype, {
            isGLBufferAttribute: !0,
            setBuffer: function(t) {
                return this.buffer = t, this
            },
            setType: function(t, e) {
                return this.type = t, this.elementSize = e, this
            },
            setItemSize: function(t) {
                return this.itemSize = t, this
            },
            setCount: function(t) {
                return this.count = t, this
            }
        }), Object.assign(Qc.prototype, {
            set: function(t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function(t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera && (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e)
            },
            intersectObject: function(t, e, i) {
                var n = i || [];
                return ep(t, this, n, e), n.sort(tp), n
            },
            intersectObjects: function(t, e, i) {
                var n = i || [];
                if (!1 === Array.isArray(t)) return n;
                for (var r = 0, a = t.length; r < a; r++) ep(t[r], this, n, e);
                return n.sort(tp), n
            }
        });
        var ip = function() {
            function n() {
                var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                    i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return V(this, n), this.radius = t, this.phi = e, this.theta = i, this
            }
            return g(n, [{
                key: "set",
                value: function(t, e, i) {
                    return this.radius = t, this.phi = e, this.theta = i, this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(t) {
                    return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                }
            }, {
                key: "makeSafe",
                value: function() {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                }
            }, {
                key: "setFromVector3",
                value: function(t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z)
                }
            }, {
                key: "setFromCartesianCoords",
                value: function(t, e, i) {
                    return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(ci.clamp(e / this.radius, -1, 1))), this
                }
            }]), n
        }();
        i.Spherical = ip;
        var np = function() {
            function n(t, e, i) {
                return V(this, n), this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
            }
            return g(n, [{
                key: "set",
                value: function(t, e, i) {
                    return this.radius = t, this.theta = e, this.y = i, this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(t) {
                    return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                }
            }, {
                key: "setFromVector3",
                value: function(t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z)
                }
            }, {
                key: "setFromCartesianCoords",
                value: function(t, e, i) {
                    return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this
                }
            }]), n
        }();
        i.Cylindrical = np;
        var rp = new pi,
            ap = function() {
                function i(t, e) {
                    V(this, i), Object.defineProperty(this, "isBox2", {
                        value: !0
                    }), this.min = void 0 !== t ? t : new pi(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new pi(-1 / 0, -1 / 0)
                }
                return g(i, [{
                    key: "set",
                    value: function(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    }
                }, {
                    key: "setFromPoints",
                    value: function(t) {
                        this.makeEmpty();
                        for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                        return this
                    }
                }, {
                    key: "setFromCenterAndSize",
                    value: function(t, e) {
                        var i = rp.copy(e).multiplyScalar(.5);
                        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    }
                }, {
                    key: "makeEmpty",
                    value: function() {
                        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                    }
                }, {
                    key: "isEmpty",
                    value: function() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    }
                }, {
                    key: "getCenter",
                    value: function(t) {
                        return void 0 === t && (t = new pi), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                }, {
                    key: "getSize",
                    value: function(t) {
                        return void 0 === t && (t = new pi), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                    }
                }, {
                    key: "expandByPoint",
                    value: function(t) {
                        return this.min.min(t), this.max.max(t), this
                    }
                }, {
                    key: "expandByVector",
                    value: function(t) {
                        return this.min.sub(t), this.max.add(t), this
                    }
                }, {
                    key: "expandByScalar",
                    value: function(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    }
                }, {
                    key: "containsPoint",
                    value: function(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                    }
                }, {
                    key: "containsBox",
                    value: function(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                    }
                }, {
                    key: "getParameter",
                    value: function(t, e) {
                        return void 0 === e && (e = new pi), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                    }
                }, {
                    key: "intersectsBox",
                    value: function(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                    }
                }, {
                    key: "clampPoint",
                    value: function(t, e) {
                        return void 0 === e && (e = new pi), e.copy(t).clamp(this.min, this.max)
                    }
                }, {
                    key: "distanceToPoint",
                    value: function(t) {
                        return rp.copy(t).clamp(this.min, this.max).sub(t).length()
                    }
                }, {
                    key: "intersect",
                    value: function(t) {
                        return this.min.max(t.min), this.max.min(t.max), this
                    }
                }, {
                    key: "union",
                    value: function(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    }
                }, {
                    key: "translate",
                    value: function(t) {
                        return this.min.add(t), this.max.add(t), this
                    }
                }, {
                    key: "equals",
                    value: function(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }]), i
            }();
        i.Box2 = ap;
        var sp = new wi,
            op = new wi,
            lp = function() {
                function i(t, e) {
                    V(this, i), this.start = void 0 !== t ? t : new wi, this.end = void 0 !== e ? e : new wi
                }
                return g(i, [{
                    key: "set",
                    value: function(t, e) {
                        return this.start.copy(t), this.end.copy(e), this
                    }
                }, {
                    key: "clone",
                    value: function() {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return this.start.copy(t.start), this.end.copy(t.end), this
                    }
                }, {
                    key: "getCenter",
                    value: function(t) {
                        return void 0 === t && (t = new wi), t.addVectors(this.start, this.end).multiplyScalar(.5)
                    }
                }, {
                    key: "delta",
                    value: function(t) {
                        return void 0 === t && (t = new wi), t.subVectors(this.end, this.start)
                    }
                }, {
                    key: "distanceSq",
                    value: function() {
                        return this.start.distanceToSquared(this.end)
                    }
                }, {
                    key: "distance",
                    value: function() {
                        return this.start.distanceTo(this.end)
                    }
                }, {
                    key: "at",
                    value: function(t, e) {
                        return void 0 === e && (e = new wi), this.delta(e).multiplyScalar(t).add(this.start)
                    }
                }, {
                    key: "closestPointToPointParameter",
                    value: function(t, e) {
                        sp.subVectors(t, this.start), op.subVectors(this.end, this.start);
                        var i = op.dot(op),
                            n = op.dot(sp) / i;
                        return e && (n = ci.clamp(n, 0, 1)), n
                    }
                }, {
                    key: "closestPointToPoint",
                    value: function(t, e, i) {
                        var n = this.closestPointToPointParameter(t, e);
                        return void 0 === i && (i = new wi), this.delta(i).multiplyScalar(n).add(this.start)
                    }
                }, {
                    key: "applyMatrix4",
                    value: function(t) {
                        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                    }
                }, {
                    key: "equals",
                    value: function(t) {
                        return t.start.equals(this.start) && t.end.equals(this.end)
                    }
                }]), i
            }();

        function hp(t) {
            wn.call(this), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
        }
        i.Line3 = lp, ((hp.prototype = Object.create(wn.prototype)).constructor = hp).prototype.isImmediateRenderObject = !0;
        var up = new wi,
            cp = function() {
                d(c, wn);
                var u = y(c);

                function c(t, e) {
                    var i;
                    V(this, c), (i = u.call(this)).light = t, i.light.updateMatrixWorld(), i.matrix = t.matrixWorld, i.matrixAutoUpdate = !1, i.color = e;
                    for (var n = new gr, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], a = 0, s = 1; a < 32; a++, s++) {
                        var o = a / 32 * Math.PI * 2,
                            l = s / 32 * Math.PI * 2;
                        r.push(Math.cos(o), Math.sin(o), 1, Math.cos(l), Math.sin(l), 1)
                    }
                    n.setAttribute("position", new ar(r, 3));
                    var h = new il({
                        fog: !1,
                        toneMapped: !1
                    });
                    return i.cone = new cl(n, h), i.add(i.cone), i.update(), i
                }
                return g(c, [{
                    key: "dispose",
                    value: function() {
                        this.cone.geometry.dispose(), this.cone.material.dispose()
                    }
                }, {
                    key: "update",
                    value: function() {
                        this.light.updateMatrixWorld();
                        var t = this.light.distance ? this.light.distance : 1e3,
                            e = t * Math.tan(this.light.angle);
                        this.cone.scale.set(e, e, t), up.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(up), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }]), c
            }();
        i.SpotLightHelper = cp;
        var pp = new wi,
            dp = new Zi,
            fp = new Zi,
            mp = function() {
                d(p, cl);
                var c = y(p);

                function p(t) {
                    V(this, p);
                    for (var e = function t(e) {
                            var i = [];
                            e && e.isBone && i.push(e);
                            for (var n = 0; n < e.children.length; n++) i.push.apply(i, t(e.children[n]));
                            return i
                        }(t), i = new gr, n = [], r = [], a = new Hn(0, 0, 1), s = new Hn(0, 1, 0), o = 0; o < e.length; o++) {
                        var l = e[o];
                        l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(s.r, s.g, s.b))
                    }
                    i.setAttribute("position", new ar(n, 3)), i.setAttribute("color", new ar(r, 3));
                    var h, u = new il({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    });
                    return (h = c.call(this, i, u)).type = "SkeletonHelper", h.isSkeletonHelper = !0, h.root = t, h.bones = e, h.matrix = t.matrixWorld, h.matrixAutoUpdate = !1, h
                }
                return g(p, [{
                    key: "updateMatrixWorld",
                    value: function(t) {
                        var e = this.bones,
                            i = this.geometry,
                            n = i.getAttribute("position");
                        fp.getInverse(this.root.matrixWorld);
                        for (var r = 0, a = 0; r < e.length; r++) {
                            var s = e[r];
                            s.parent && s.parent.isBone && (dp.multiplyMatrices(fp, s.matrixWorld), pp.setFromMatrixPosition(dp), n.setXYZ(a, pp.x, pp.y, pp.z), dp.multiplyMatrices(fp, s.parent.matrixWorld), pp.setFromMatrixPosition(dp), n.setXYZ(a + 1, pp.x, pp.y, pp.z), a += 2)
                        }
                        i.getAttribute("position").needsUpdate = !0, h(f(p.prototype), "updateMatrixWorld", this).call(this, t)
                    }
                }]), p
            }();
        i.SkeletonHelper = mp;
        var gp = function() {
            d(o, Fr);
            var s = y(o);

            function o(t, e, i) {
                V(this, o);
                var n, r = new gh(e, 4, 2),
                    a = new Yn({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    });
                return (n = s.call(this, r, a)).light = t, n.light.updateMatrixWorld(), n.color = i, n.type = "PointLightHelper", n.matrix = n.light.matrixWorld, n.matrixAutoUpdate = !1, n.update(), n
            }
            return g(o, [{
                key: "dispose",
                value: function() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }, {
                key: "update",
                value: function() {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }
            }]), o
        }();
        i.PointLightHelper = gp;
        var vp = new wi,
            yp = new Hn,
            bp = new Hn,
            xp = function() {
                d(l, wn);
                var o = y(l);

                function l(t, e, i) {
                    var n;
                    V(this, l), (n = o.call(this)).light = t, n.light.updateMatrixWorld(), n.matrix = t.matrixWorld, n.matrixAutoUpdate = !1, n.color = i;
                    var r = new kl(e);
                    r.rotateY(.5 * Math.PI), n.material = new Yn({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    }), void 0 === n.color && (n.material.vertexColors = !0);
                    var a = r.getAttribute("position"),
                        s = new Float32Array(3 * a.count);
                    return r.setAttribute("color", new $n(s, 3)), n.add(new Fr(r, n.material)), n.update(), n
                }
                return g(l, [{
                    key: "dispose",
                    value: function() {
                        this.children[0].geometry.dispose(), this.children[0].material.dispose()
                    }
                }, {
                    key: "update",
                    value: function() {
                        var t = this.children[0];
                        if (void 0 !== this.color) this.material.color.set(this.color);
                        else {
                            var e = t.geometry.getAttribute("color");
                            yp.copy(this.light.color), bp.copy(this.light.groundColor);
                            for (var i = 0, n = e.count; i < n; i++) {
                                var r = i < n / 2 ? yp : bp;
                                e.setXYZ(i, r.r, r.g, r.b)
                            }
                            e.needsUpdate = !0
                        }
                        t.lookAt(vp.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }]), l
            }();
        i.HemisphereLightHelper = xp;
        var _p = function() {
            d(v, cl);
            var g = y(v);

            function v(t, e, i, n) {
                V(this, v), t = t || 10, e = e || 10, i = new Hn(void 0 !== i ? i : 4473924), n = new Hn(void 0 !== n ? n : 8947848);
                for (var r = e / 2, a = t / e, s = t / 2, o = [], l = [], h = 0, u = 0, c = -s; h <= e; h++, c += a) {
                    o.push(-s, 0, c, s, 0, c), o.push(c, 0, -s, c, 0, s);
                    var p = h === r ? i : n;
                    p.toArray(l, u), u += 3, p.toArray(l, u), u += 3, p.toArray(l, u), u += 3, p.toArray(l, u), u += 3
                }
                var d = new gr;
                d.setAttribute("position", new ar(o, 3)), d.setAttribute("color", new ar(l, 3));
                var f, m = new il({
                    vertexColors: !0,
                    toneMapped: !1
                });
                return (f = g.call(this, d, m)).type = "GridHelper", f
            }
            return v
        }();
        i.GridHelper = _p;
        var wp = function() {
            d(M, cl);
            var S = y(M);

            function M(t, e, i, n, r, a) {
                V(this, M), t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new Hn(void 0 !== r ? r : 4473924), a = new Hn(void 0 !== a ? a : 8947848);
                for (var s = [], o = [], l = 0; l <= e; l++) {
                    var h = l / e * (2 * Math.PI),
                        u = Math.sin(h) * t,
                        c = Math.cos(h) * t;
                    s.push(0, 0, 0), s.push(u, 0, c);
                    var p = 1 & l ? r : a;
                    o.push(p.r, p.g, p.b), o.push(p.r, p.g, p.b)
                }
                for (var d = 0; d <= i; d++)
                    for (var f = 1 & d ? r : a, m = t - t / i * d, g = 0; g < n; g++) {
                        var v = g / n * (2 * Math.PI),
                            y = Math.sin(v) * m,
                            b = Math.cos(v) * m;
                        s.push(y, 0, b), o.push(f.r, f.g, f.b), v = (g + 1) / n * (2 * Math.PI), y = Math.sin(v) * m, b = Math.cos(v) * m, s.push(y, 0, b), o.push(f.r, f.g, f.b)
                    }
                var x = new gr;
                x.setAttribute("position", new ar(s, 3)), x.setAttribute("color", new ar(o, 3));
                var _, w = new il({
                    vertexColors: !0,
                    toneMapped: !1
                });
                return (_ = S.call(this, x, w)).type = "PolarGridHelper", _
            }
            return M
        }();
        i.PolarGridHelper = wp;
        var Sp = new wi,
            Mp = new wi,
            Tp = new wi,
            Cp = function() {
                d(o, wn);
                var s = y(o);

                function o(t, e, i) {
                    var n;
                    V(this, o), (n = s.call(this)).light = t, n.light.updateMatrixWorld(), n.matrix = t.matrixWorld, n.matrixAutoUpdate = !1, n.color = i, void 0 === e && (e = 1);
                    var r = new gr;
                    r.setAttribute("position", new ar([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                    var a = new il({
                        fog: !1,
                        toneMapped: !1
                    });
                    return n.lightPlane = new ll(r, a), n.add(n.lightPlane), (r = new gr).setAttribute("position", new ar([0, 0, 0, 0, 0, 1], 3)), n.targetLine = new ll(r, a), n.add(n.targetLine), n.update(), n
                }
                return g(o, [{
                    key: "dispose",
                    value: function() {
                        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                    }
                }, {
                    key: "update",
                    value: function() {
                        Sp.setFromMatrixPosition(this.light.matrixWorld), Mp.setFromMatrixPosition(this.light.target.matrixWorld), Tp.subVectors(Mp, Sp), this.lightPlane.lookAt(Mp), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Mp), this.targetLine.scale.z = Tp.length()
                    }
                }]), o
            }();
        i.DirectionalLightHelper = Cp;
        var Ap = new wi,
            Ep = new Zr,
            Dp = function() {
                d(m, cl);
                var f = y(m);

                function m(t) {
                    var e;
                    V(this, m);
                    var i = new gr,
                        n = new il({
                            color: 16777215,
                            vertexColors: !0,
                            toneMapped: !1
                        }),
                        r = [],
                        a = [],
                        s = {},
                        o = new Hn(16755200),
                        l = new Hn(16711680),
                        h = new Hn(43775),
                        u = new Hn(16777215),
                        c = new Hn(3355443);

                    function p(t, e, i) {
                        d(t, i), d(e, i)
                    }

                    function d(t, e) {
                        r.push(0, 0, 0), a.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(r.length / 3 - 1)
                    }
                    return p("n1", "n2", o), p("n2", "n4", o), p("n4", "n3", o), p("n3", "n1", o), p("f1", "f2", o), p("f2", "f4", o), p("f4", "f3", o), p("f3", "f1", o), p("n1", "f1", o), p("n2", "f2", o), p("n3", "f3", o), p("n4", "f4", o), p("p", "n1", l), p("p", "n2", l), p("p", "n3", l), p("p", "n4", l), p("u1", "u2", h), p("u2", "u3", h), p("u3", "u1", h), p("c", "t", u), p("p", "c", c), p("cn1", "cn2", c), p("cn3", "cn4", c), p("cf1", "cf2", c), p("cf3", "cf4", c), i.setAttribute("position", new ar(r, 3)), i.setAttribute("color", new ar(a, 3)), (e = f.call(this, i, n)).type = "CameraHelper", e.camera = t, e.camera.updateProjectionMatrix && e.camera.updateProjectionMatrix(), e.matrix = t.matrixWorld, e.matrixAutoUpdate = !1, e.pointMap = s, e.update(), e
                }
                return g(m, [{
                    key: "update",
                    value: function() {
                        var t = this.geometry,
                            e = this.pointMap;
                        Ep.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Pp("c", e, t, Ep, 0, 0, -1), Pp("t", e, t, Ep, 0, 0, 1), Pp("n1", e, t, Ep, -1, -1, -1), Pp("n2", e, t, Ep, 1, -1, -1), Pp("n3", e, t, Ep, -1, 1, -1), Pp("n4", e, t, Ep, 1, 1, -1), Pp("f1", e, t, Ep, -1, -1, 1), Pp("f2", e, t, Ep, 1, -1, 1), Pp("f3", e, t, Ep, -1, 1, 1), Pp("f4", e, t, Ep, 1, 1, 1), Pp("u1", e, t, Ep, .7, 1.1, -1), Pp("u2", e, t, Ep, -.7, 1.1, -1), Pp("u3", e, t, Ep, 0, 2, -1), Pp("cf1", e, t, Ep, -1, 0, 1), Pp("cf2", e, t, Ep, 1, 0, 1), Pp("cf3", e, t, Ep, 0, -1, 1), Pp("cf4", e, t, Ep, 0, 1, 1), Pp("cn1", e, t, Ep, -1, 0, -1), Pp("cn2", e, t, Ep, 1, 0, -1), Pp("cn3", e, t, Ep, 0, -1, -1), Pp("cn4", e, t, Ep, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                    }
                }]), m
            }();

        function Pp(t, e, i, n, r, a, s) {
            Ap.set(r, a, s).unproject(n);
            var o = e[t];
            if (void 0 !== o)
                for (var l = i.getAttribute("position"), h = 0, u = o.length; h < u; h++) l.setXYZ(o[h], Ap.x, Ap.y, Ap.z)
        }
        i.CameraHelper = Dp;
        var Lp = new Ti,
            kp = function() {
                d(o, cl);
                var s = y(o);

                function o(t) {
                    var e, i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 16776960;
                    V(this, o);
                    var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        r = new Float32Array(24),
                        a = new gr;
                    return a.setIndex(new $n(n, 1)), a.setAttribute("position", new $n(r, 3)), (e = s.call(this, a, new il({
                        color: i,
                        toneMapped: !1
                    }))).object = t, e.type = "BoxHelper", e.matrixAutoUpdate = !1, e.update(), e
                }
                return g(o, [{
                    key: "update",
                    value: function() {
                        var t, e, i, n;
                        void 0 !== this.object && Lp.setFromObject(this.object), Lp.isEmpty() || (t = Lp.min, e = Lp.max, (n = (i = this.geometry.attributes.position).array)[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = t.x, n[4] = e.y, n[5] = e.z, n[6] = t.x, n[7] = t.y, n[8] = e.z, n[9] = e.x, n[10] = t.y, n[11] = e.z, n[12] = e.x, n[13] = e.y, n[14] = t.z, n[15] = t.x, n[16] = e.y, n[17] = t.z, n[18] = t.x, n[19] = t.y, n[20] = t.z, n[21] = e.x, n[22] = t.y, n[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere())
                    }
                }, {
                    key: "setFromObject",
                    value: function(t) {
                        return this.object = t, this.update(), this
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return cl.prototype.copy.call(this, t), this.object = t.object, this
                    }
                }]), o
            }();
        i.BoxHelper = kp;
        var Op = function() {
            d(s, cl);
            var a = y(s);

            function s(t) {
                var e, i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 16776960;
                V(this, s);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new gr;
                return r.setIndex(new $n(n, 1)), r.setAttribute("position", new ar([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), (e = a.call(this, r, new il({
                    color: i,
                    toneMapped: !1
                }))).box = t, e.type = "Box3Helper", e.geometry.computeBoundingSphere(), e
            }
            return g(s, [{
                key: "updateMatrixWorld",
                value: function(t) {
                    var e = this.box;
                    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), h(f(s.prototype), "updateMatrixWorld", this).call(this, t))
                }
            }]), s
        }();
        i.Box3Helper = Op;
        var Fp = function() {
            d(l, ll);
            var o = y(l);

            function l(t, e, i) {
                var n;
                V(this, l);
                var r = void 0 !== i ? i : 16776960,
                    a = new gr;
                a.setAttribute("position", new ar([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), a.computeBoundingSphere(), (n = o.call(this, a, new il({
                    color: r,
                    toneMapped: !1
                }))).type = "PlaneHelper", n.plane = t, n.size = void 0 === e ? 1 : e;
                var s = new gr;
                return s.setAttribute("position", new ar([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), n.add(new Fr(s, new Yn({
                    color: r,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1
                }))), n
            }
            return g(l, [{
                key: "updateMatrixWorld",
                value: function(t) {
                    var e = -this.plane.constant;
                    Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? J : k, this.lookAt(this.plane.normal), h(f(l.prototype), "updateMatrixWorld", this).call(this, t)
                }
            }]), l
        }();
        i.PlaneHelper = Fp;
        var Ip, Np, Bp = new wi,
            Rp = function() {
                d(l, wn);
                var o = y(l);

                function l(t, e, i, n, r, a) {
                    var s;
                    return V(this, l), (s = o.call(this)).type = "ArrowHelper", void 0 === t && (t = new wi(0, 0, 1)), void 0 === e && (e = new wi(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === r && (r = .2 * i), void 0 === a && (a = .2 * r), void 0 === Ip && ((Ip = new gr).setAttribute("position", new ar([0, 0, 0, 0, 1, 0], 3)), (Np = new Ch(0, .5, 1, 5, 1)).translate(0, -.5, 0)), s.position.copy(e), s.line = new ll(Ip, new il({
                        color: n,
                        toneMapped: !1
                    })), s.line.matrixAutoUpdate = !1, s.add(s.line), s.cone = new Fr(Np, new Yn({
                        color: n,
                        toneMapped: !1
                    })), s.cone.matrixAutoUpdate = !1, s.add(s.cone), s.setDirection(t), s.setLength(i, r, a), s
                }
                return g(l, [{
                    key: "setDirection",
                    value: function(t) {
                        var e;
                        .99999 < t.y ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Bp.set(t.z, 0, -t.x).normalize(), e = Math.acos(t.y), this.quaternion.setFromAxisAngle(Bp, e))
                    }
                }, {
                    key: "setLength",
                    value: function(t, e, i) {
                        void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
                    }
                }, {
                    key: "setColor",
                    value: function(t) {
                        this.line.material.color.set(t), this.cone.material.color.set(t)
                    }
                }, {
                    key: "copy",
                    value: function(t) {
                        return h(f(l.prototype), "copy", this).call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
                    }
                }]), l
            }();
        i.ArrowHelper = Rp;
        var zp = function() {
            d(s, cl);
            var a = y(s);

            function s() {
                var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1;
                V(this, s);
                var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    i = new gr;
                i.setAttribute("position", new ar(e, 3)), i.setAttribute("color", new ar([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var n, r = new il({
                    vertexColors: !0,
                    toneMapped: !1
                });
                return (n = a.call(this, i, r)).type = "AxesHelper", n
            }
            return s
        }();
        i.AxesHelper = zp;
        var Gp = Math.pow(2, 8),
            Vp = [.125, .215, .35, .446, .526, .582],
            Up = 5 + Vp.length,
            jp = 20,
            Hp = (W(n = {}, He, 0), W(n, We, 1), W(n, Xe, 2), W(n, Je, 3), W(n, Ze, 4), W(n, $e, 5), W(n, qe, 6), n),
            Wp = new qu,
            qp = function() {
                for (var t = [], e = [], i = [], n = 8, r = 0; r < Up; r++) {
                    var a = Math.pow(2, n);
                    e.push(a);
                    var s = 1 / a;
                    4 < r ? s = Vp[r - 8 + 4 - 1] : 0 == r && (s = 0), i.push(s);
                    for (var o = 1 / (a - 1), l = -o / 2, h = 1 + o / 2, u = [l, l, h, l, h, h, l, l, h, h, l, h], c = new Float32Array(108), p = new Float32Array(72), d = new Float32Array(36), f = 0; f < 6; f++) {
                        var m = f % 3 * 2 / 3 - 1,
                            g = 2 < f ? 0 : -1,
                            v = [m, g, 0, m + 2 / 3, g, 0, m + 2 / 3, 1 + g, 0, m, g, 0, m + 2 / 3, 1 + g, 0, m, 1 + g, 0];
                        c.set(v, 18 * f), p.set(u, 12 * f);
                        var y = [f, f, f, f, f, f];
                        d.set(y, 6 * f)
                    }
                    var b = new gr;
                    b.setAttribute("position", new $n(c, 3)), b.setAttribute("uv", new $n(p, 2)), b.setAttribute("faceIndex", new $n(d, 1)), t.push(b), 4 < n && n--
                }
                return {
                    _lodPlanes: t,
                    _sizeLods: e,
                    _sigmas: i
                }
            }(),
            Xp = qp._lodPlanes,
            Yp = qp._sizeLods,
            Jp = qp._sigmas,
            Zp = null,
            $p = (1 + Math.sqrt(5)) / 2,
            Kp = 1 / $p,
            Qp = [new wi(1, 1, 1), new wi(-1, 1, 1), new wi(1, 1, -1), new wi(-1, 1, -1), new wi(0, $p, Kp), new wi(0, $p, -Kp), new wi(Kp, 0, $p), new wi(-Kp, 0, $p), new wi($p, Kp, 0), new wi(-$p, Kp, 0)],
            td = function() {
                function r(t) {
                    var e, i, n;
                    V(this, r), this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = (e = jp, i = new Float32Array(e), n = new wi(0, 1, 0), new Oh({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: e
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: i
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: n
                            },
                            inputEncoding: {
                                value: Hp[He]
                            },
                            outputEncoding: {
                                value: Hp[He]
                            }
                        },
                        vertexShader: ad(),
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t".concat(sd(), "\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),
                        blending: $,
                        depthTest: !1,
                        depthWrite: !1
                    })), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                }
                return g(r, [{
                    key: "fromScene",
                    value: function(t, e, i, n) {
                        var r = 1 < arguments.length && void 0 !== e ? e : 0,
                            a = 2 < arguments.length && void 0 !== i ? i : .1,
                            s = 3 < arguments.length && void 0 !== n ? n : 100;
                        Zp = this._renderer.getRenderTarget();
                        var o = this._allocateTargets();
                        return this._sceneToCubeUV(t, a, s, o), 0 < r && this._blur(o, 0, 0, r), this._applyPMREM(o), this._cleanup(o), o
                    }
                }, {
                    key: "fromEquirectangular",
                    value: function(t) {
                        return this._fromTexture(t)
                    }
                }, {
                    key: "fromCubemap",
                    value: function(t) {
                        return this._fromTexture(t)
                    }
                }, {
                    key: "compileCubemapShader",
                    value: function() {
                        null === this._cubemapShader && (this._cubemapShader = rd(), this._compileMaterial(this._cubemapShader))
                    }
                }, {
                    key: "compileEquirectangularShader",
                    value: function() {
                        null === this._equirectShader && (this._equirectShader = nd(), this._compileMaterial(this._equirectShader))
                    }
                }, {
                    key: "dispose",
                    value: function() {
                        this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                        for (var t = 0; t < Xp.length; t++) Xp[t].dispose()
                    }
                }, {
                    key: "_cleanup",
                    value: function(t) {
                        this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Zp), t.scissorTest = !1, id(t, 0, 0, t.width, t.height)
                    }
                }, {
                    key: "_fromTexture",
                    value: function(t) {
                        Zp = this._renderer.getRenderTarget();
                        var e = this._allocateTargets(t);
                        return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
                    }
                }, {
                    key: "_allocateTargets",
                    value: function(t) {
                        var e, i = {
                                magFilter: Bt,
                                minFilter: Bt,
                                generateMipmaps: !1,
                                type: jt,
                                format: T,
                                encoding: void 0 === (e = t) || e.type !== jt || e.encoding !== He && e.encoding !== We && e.encoding !== qe ? Xe : t.encoding,
                                depthBuffer: !1
                            },
                            n = ed(i);
                        return n.depthBuffer = !t, this._pingPongRenderTarget = ed(i), n
                    }
                }, {
                    key: "_compileMaterial",
                    value: function(t) {
                        var e = new Fr(Xp[0], t);
                        this._renderer.compile(e, Wp)
                    }
                }, {
                    key: "_sceneToCubeUV",
                    value: function(t, e, i, n) {
                        var r = new $r(90, 1, e, i),
                            a = [1, -1, 1, 1, 1, 1],
                            s = [1, 1, 1, -1, -1, -1],
                            o = this._renderer,
                            l = o.outputEncoding,
                            h = o.toneMapping,
                            u = o.getClearColor(),
                            c = o.getClearAlpha();
                        o.toneMapping = At, o.outputEncoding = He;
                        var p, d, f, m = t.background;
                        m && m.isColor && (m.convertSRGBToLinear(), p = Math.max(m.r, m.g, m.b), d = Math.min(Math.max(Math.ceil(Math.log2(p)), -128), 127), m = m.multiplyScalar(Math.pow(2, -d)), f = (d + 128) / 255, o.setClearColor(m, f), t.background = null);
                        for (var g = 0; g < 6; g++) {
                            var v = g % 3;
                            0 == v ? (r.up.set(0, a[g], 0), r.lookAt(s[g], 0, 0)) : 1 == v ? (r.up.set(0, 0, a[g]), r.lookAt(0, s[g], 0)) : (r.up.set(0, a[g], 0), r.lookAt(0, 0, s[g])), id(n, v * Gp, 2 < g ? Gp : 0, Gp, Gp), o.setRenderTarget(n), o.render(t, r)
                        }
                        o.toneMapping = h, o.outputEncoding = l, o.setClearColor(u, c)
                    }
                }, {
                    key: "_textureToCubeUV",
                    value: function(t, e) {
                        var i = this._renderer;
                        t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = rd()) : null == this._equirectShader && (this._equirectShader = nd());
                        var n = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
                            r = new Fr(Xp[0], n),
                            a = n.uniforms;
                        (a.envMap.value = t).isCubeTexture || a.texelSize.value.set(1 / t.image.width, 1 / t.image.height), a.inputEncoding.value = Hp[t.encoding], a.outputEncoding.value = Hp[e.texture.encoding], id(e, 0, 0, 3 * Gp, 2 * Gp), i.setRenderTarget(e), i.render(r, Wp)
                    }
                }, {
                    key: "_applyPMREM",
                    value: function(t) {
                        var e = this._renderer,
                            i = e.autoClear;
                        e.autoClear = !1;
                        for (var n = 1; n < Up; n++) {
                            var r = Math.sqrt(Jp[n] * Jp[n] - Jp[n - 1] * Jp[n - 1]),
                                a = Qp[(n - 1) % Qp.length];
                            this._blur(t, n - 1, n, r, a)
                        }
                        e.autoClear = i
                    }
                }, {
                    key: "_blur",
                    value: function(t, e, i, n, r) {
                        var a = this._pingPongRenderTarget;
                        this._halfBlur(t, a, e, i, n, "latitudinal", r), this._halfBlur(a, t, i, i, n, "longitudinal", r)
                    }
                }, {
                    key: "_halfBlur",
                    value: function(t, e, i, n, r, a, s) {
                        for (var o = this._renderer, l = this._blurMaterial, h = new Fr(Xp[n], l), u = l.uniforms, c = Yp[i] - 1, p = isFinite(r) ? Math.PI / (2 * c) : 2 * Math.PI / (2 * jp - 1), d = r / p, f = isFinite(r) ? 1 + Math.floor(3 * d) : jp, m = [], g = 0, v = 0; v < jp; ++v) {
                            var y = v / d,
                                b = Math.exp(-y * y / 2);
                            m.push(b), 0 == v ? g += b : v < f && (g += 2 * b)
                        }
                        for (var x = 0; x < m.length; x++) m[x] = m[x] / g;
                        u.envMap.value = t.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === a, s && (u.poleAxis.value = s), u.dTheta.value = p, u.mipInt.value = 8 - i, u.inputEncoding.value = Hp[t.texture.encoding], u.outputEncoding.value = Hp[t.texture.encoding];
                        var _ = Yp[n];
                        id(e, 3 * Math.max(0, Gp - 2 * _), (0 === n ? 0 : 2 * Gp) + 2 * _ * (4 < n ? n - 8 + 4 : 0), 3 * _, 2 * _), o.setRenderTarget(e), o.render(h, Wp)
                    }
                }]), r
            }();

        function ed(t) {
            var e = new bi(3 * Gp, 3 * Gp, t);
            return e.texture.mapping = kt, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
        }

        function id(t, e, i, n, r) {
            t.viewport.set(e, i, n, r), t.scissor.set(e, i, n, r)
        }

        function nd() {
            return new Oh({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    texelSize: {
                        value: new pi(1, 1)
                    },
                    inputEncoding: {
                        value: Hp[He]
                    },
                    outputEncoding: {
                        value: Hp[He]
                    }
                },
                vertexShader: ad(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t".concat(sd(), "\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),
                blending: $,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function rd() {
            return new Oh({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    inputEncoding: {
                        value: Hp[He]
                    },
                    outputEncoding: {
                        value: Hp[He]
                    }
                },
                vertexShader: ad(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t".concat(sd(), "\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),
                blending: $,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function ad() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }

        function sd() {
            return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
        }
        i.PMREMGenerator = td;
        i.LineStrip = 0;
        i.LinePieces = 1;
        i.NoColors = 0;
        i.FaceColors = 1;

        function od(t) {
            Mu.call(this, t), this.type = "catmullrom", this.closed = !0
        }

        function ld(t) {
            Mu.call(this, t), this.type = "catmullrom"
        }

        function hd(t) {
            Mu.call(this, t), this.type = "catmullrom"
        }
        i.VertexColors = 2, gu.create = function(t, e) {
            return t.prototype = Object.create(gu.prototype), (t.prototype.constructor = t).prototype.getPoint = e, t
        }, Object.assign(Nu.prototype, {
            createPointsGeometry: function(t) {
                var e = this.getPoints(t);
                return this.createGeometry(e)
            },
            createSpacedPointsGeometry: function(t) {
                var e = this.getSpacedPoints(t);
                return this.createGeometry(e)
            },
            createGeometry: function(t) {
                for (var e = new Vr, i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.vertices.push(new wi(r.x, r.y, r.z || 0))
                }
                return e
            }
        }), Object.assign(Bu.prototype, {
            fromPoints: function(t) {
                return this.setFromPoints(t)
            }
        }), od.prototype = Object.create(Mu.prototype), ld.prototype = Object.create(Mu.prototype), hd.prototype = Object.create(Mu.prototype), Object.assign(hd.prototype, {
            initFromArray: function() {},
            getControlPointsArray: function() {},
            reparametrizeByArcLength: function() {}
        }), _p.prototype.setColors = function() {}, mp.prototype.update = function() {}, Object.assign(ou.prototype, {
            extractUrlBase: function(t) {
                return tc.extractUrlBase(t)
            }
        }), ou.Handlers = {
            add: function() {},
            get: function() {}
        }, Object.assign(ac.prototype, {
            setTexturePath: function(t) {
                return this.setResourcePath(t)
            }
        }), Object.assign(ap.prototype, {
            center: function(t) {
                return this.getCenter(t)
            },
            empty: function() {
                return this.isEmpty()
            },
            isIntersectionBox: function(t) {
                return this.intersectsBox(t)
            },
            size: function(t) {
                return this.getSize(t)
            }
        }), Object.assign(Ti.prototype, {
            center: function(t) {
                return this.getCenter(t)
            },
            empty: function() {
                return this.isEmpty()
            },
            isIntersectionBox: function(t) {
                return this.intersectsBox(t)
            },
            isIntersectionSphere: function(t) {
                return this.intersectsSphere(t)
            },
            size: function(t) {
                return this.getSize(t)
            }
        }), Object.assign(Vi.prototype, {
            empty: function() {
                return this.isEmpty()
            }
        }), aa.prototype.setFromMatrix = function(t) {
            return this.setFromProjectionMatrix(t)
        }, lp.prototype.center = function(t) {
            return this.getCenter(t)
        }, Object.assign(ci, {
            random16: function() {
                return Math.random()
            },
            nearestPowerOfTwo: function(t) {
                return ci.floorPowerOfTwo(t)
            },
            nextPowerOfTwo: function(t) {
                return ci.ceilPowerOfTwo(t)
            }
        }), Object.assign(fi.prototype, {
            flattenToArrayOffset: function(t, e) {
                return this.toArray(t, e)
            },
            multiplyVector3: function(t) {
                return t.applyMatrix3(this)
            },
            multiplyVector3Array: function() {},
            applyToBufferAttribute: function(t) {
                return t.applyMatrix3(this)
            },
            applyToVector3Array: function() {}
        }), Object.assign(Zi.prototype, {
            extractPosition: function(t) {
                return this.copyPosition(t)
            },
            flattenToArrayOffset: function(t, e) {
                return this.toArray(t, e)
            },
            getPosition: function() {
                return (new wi).setFromMatrixColumn(this, 3)
            },
            setRotationFromQuaternion: function(t) {
                return this.makeRotationFromQuaternion(t)
            },
            multiplyToArray: function() {},
            multiplyVector3: function(t) {
                return t.applyMatrix4(this)
            },
            multiplyVector4: function(t) {
                return t.applyMatrix4(this)
            },
            multiplyVector3Array: function() {},
            rotateAxis: function(t) {
                t.transformDirection(this)
            },
            crossVector: function(t) {
                return t.applyMatrix4(this)
            },
            translate: function() {},
            rotateX: function() {},
            rotateY: function() {},
            rotateZ: function() {},
            rotateByAxis: function() {},
            applyToBufferAttribute: function(t) {
                return t.applyMatrix4(this)
            },
            applyToVector3Array: function() {},
            makeFrustum: function(t, e, i, n, r, a) {
                return this.makePerspective(t, e, n, i, r, a)
            }
        }), Cn.prototype.isIntersectionLine = function(t) {
            return this.intersectsLine(t)
        }, _i.prototype.multiplyVector3 = function(t) {
            return t.applyQuaternion(this)
        }, Object.assign(Ji.prototype, {
            isIntersectionBox: function(t) {
                return this.intersectsBox(t)
            },
            isIntersectionPlane: function(t) {
                return this.intersectsPlane(t)
            },
            isIntersectionSphere: function(t) {
                return this.intersectsSphere(t)
            }
        }), Object.assign(Bn.prototype, {
            area: function() {
                return this.getArea()
            },
            barycoordFromPoint: function(t, e) {
                return this.getBarycoord(t, e)
            },
            midpoint: function(t) {
                return this.getMidpoint(t)
            },
            normal: function(t) {
                return this.getNormal(t)
            },
            plane: function(t) {
                return this.getPlane(t)
            }
        }), Object.assign(Bn, {
            barycoordFromPoint: function(t, e, i, n, r) {
                return Bn.getBarycoord(t, e, i, n, r)
            },
            normal: function(t, e, i, n) {
                return Bn.getNormal(t, e, i, n)
            }
        }), Object.assign(Ru.prototype, {
            extractAllPoints: function(t) {
                return this.extractPoints(t)
            },
            extrude: function(t) {
                return new hh(this, t)
            },
            makeGeometry: function(t) {
                return new _h(this, t)
            }
        }), Object.assign(pi.prototype, {
            fromAttribute: function(t, e, i) {
                return this.fromBufferAttribute(t, e, i)
            },
            distanceToManhattan: function(t) {
                return this.manhattanDistanceTo(t)
            },
            lengthManhattan: function() {
                return this.manhattanLength()
            }
        }), Object.assign(wi.prototype, {
            setEulerFromRotationMatrix: function() {},
            setEulerFromQuaternion: function() {},
            getPositionFromMatrix: function(t) {
                return this.setFromMatrixPosition(t)
            },
            getScaleFromMatrix: function(t) {
                return this.setFromMatrixScale(t)
            },
            getColumnFromMatrix: function(t, e) {
                return this.setFromMatrixColumn(e, t)
            },
            applyProjection: function(t) {
                return this.applyMatrix4(t)
            },
            fromAttribute: function(t, e, i) {
                return this.fromBufferAttribute(t, e, i)
            },
            distanceToManhattan: function(t) {
                return this.manhattanDistanceTo(t)
            },
            lengthManhattan: function() {
                return this.manhattanLength()
            }
        }), Object.assign(yi.prototype, {
            fromAttribute: function(t, e, i) {
                return this.fromBufferAttribute(t, e, i)
            },
            lengthManhattan: function() {
                return this.manhattanLength()
            }
        }), Object.assign(Vr.prototype, {
            computeTangents: function() {},
            computeLineDistances: function() {},
            applyMatrix: function(t) {
                return this.applyMatrix4(t)
            }
        }), Object.assign(wn.prototype, {
            getChildByName: function(t) {
                return this.getObjectByName(t)
            },
            renderDepth: function() {},
            translate: function(t, e) {
                return this.translateOnAxis(e, t)
            },
            getWorldRotation: function() {},
            applyMatrix: function(t) {
                return this.applyMatrix4(t)
            }
        }), Object.defineProperties(wn.prototype, {
            eulerOrder: {
                get: function() {
                    return this.rotation.order
                },
                set: function(t) {
                    this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function() {},
                set: function() {}
            }
        }), Object.assign(Fr.prototype, {
            setDrawMode: function() {}
        }), Object.defineProperties(Fr.prototype, {
            drawMode: {
                get: function() {
                    return 0
                },
                set: function() {}
            }
        }), Object.defineProperties(Wo.prototype, {
            objects: {
                get: function() {
                    return this.levels
                }
            }
        }), Object.defineProperty(Jo.prototype, "useVertexTexture", {
            get: function() {},
            set: function() {}
        }), qo.prototype.initBones = function() {}, Object.defineProperty(gu.prototype, "__arcLengthDivisions", {
            get: function() {
                return this.arcLengthDivisions
            },
            set: function(t) {
                this.arcLengthDivisions = t
            }
        }), $r.prototype.setLens = function(t, e) {
            void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(zu.prototype, {
            onlyShadow: {
                set: function() {}
            },
            shadowCameraFov: {
                set: function(t) {
                    this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function() {}
            },
            shadowBias: {
                set: function(t) {
                    this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function() {}
            },
            shadowMapWidth: {
                set: function(t) {
                    this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties($n.prototype, {
            length: {
                get: function() {
                    return this.array.length
                }
            },
            dynamic: {
                get: function() {
                    return this.usage === ai
                },
                set: function() {
                    this.setUsage(ai)
                }
            }
        }), Object.assign($n.prototype, {
            setDynamic: function(t) {
                return this.setUsage(!0 === t ? ai : ri), this
            },
            copyIndicesArray: function() {},
            setArray: function() {}
        }), Object.assign(gr.prototype, {
            addIndex: function(t) {
                this.setIndex(t)
            },
            addAttribute: function(t, e, i) {
                return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (this.setIndex(e), this) : this.setAttribute(t, e) : this.setAttribute(t, new $n(e, i))
            },
            addDrawCall: function(t, e) {
                this.addGroup(t, e)
            },
            clearDrawCalls: function() {
                this.clearGroups()
            },
            computeTangents: function() {},
            computeOffsets: function() {},
            removeAttribute: function(t) {
                return this.deleteAttribute(t)
            },
            applyMatrix: function(t) {
                return this.applyMatrix4(t)
            }
        }), Object.defineProperties(gr.prototype, {
            drawcalls: {
                get: function() {
                    return this.groups
                }
            },
            offsets: {
                get: function() {
                    return this.groups
                }
            }
        }), Object.defineProperties(ec.prototype, {
            maxInstancedCount: {
                get: function() {
                    return this.instanceCount
                },
                set: function(t) {
                    this.instanceCount = t
                }
            }
        }), Object.defineProperties(Qc.prototype, {
            linePrecision: {
                get: function() {
                    return this.params.Line.threshold
                },
                set: function(t) {
                    this.params.Line.threshold = t
                }
            }
        }), Object.defineProperties(bo.prototype, {
            dynamic: {
                get: function() {
                    return this.usage === ai
                },
                set: function(t) {
                    this.setUsage(t)
                }
            }
        }), Object.assign(bo.prototype, {
            setDynamic: function(t) {
                return this.setUsage(!0 === t ? ai : ri), this
            },
            setArray: function() {}
        }), Object.assign(uh.prototype, {
            getArrays: function() {},
            addShapeList: function() {},
            addShape: function() {}
        }), Object.assign(yo.prototype, {
            dispose: function() {}
        }), Object.defineProperties(Zc.prototype, {
            dynamic: {
                set: function() {}
            },
            onUpdate: {
                value: function() {
                    return this
                }
            }
        }), Object.defineProperties(Xn.prototype, {
            wrapAround: {
                get: function() {},
                set: function() {}
            },
            overdraw: {
                get: function() {},
                set: function() {}
            },
            wrapRGB: {
                get: function() {
                    return new Hn
                }
            },
            shading: {
                get: function() {},
                set: function(t) {
                    this.flatShading = 1 === t
                }
            },
            stencilMask: {
                get: function() {
                    return this.stencilFuncMask
                },
                set: function(t) {
                    this.stencilFuncMask = t
                }
            }
        }), Object.defineProperties(Nh.prototype, {
            metal: {
                get: function() {
                    return !1
                },
                set: function() {}
            }
        }), Object.defineProperties(Ih.prototype, {
            transparency: {
                get: function() {
                    return this.transmission
                },
                set: function(t) {
                    this.transmission = t
                }
            }
        }), Object.defineProperties(Jr.prototype, {
            derivatives: {
                get: function() {
                    return this.extensions.derivatives
                },
                set: function(t) {
                    this.extensions.derivatives = t
                }
            }
        }), Object.assign(fo.prototype, {
            clearTarget: function(t, e, i, n) {
                this.setRenderTarget(t), this.clear(e, i, n)
            },
            animate: function(t) {
                this.setAnimationLoop(t)
            },
            getCurrentRenderTarget: function() {
                return this.getRenderTarget()
            },
            getMaxAnisotropy: function() {
                return this.capabilities.getMaxAnisotropy()
            },
            getPrecision: function() {
                return this.capabilities.precision
            },
            resetGLState: function() {
                return this.state.reset()
            },
            supportsFloatTextures: function() {
                return this.extensions.get("OES_texture_float")
            },
            supportsHalfFloatTextures: function() {
                return this.extensions.get("OES_texture_half_float")
            },
            supportsStandardDerivatives: function() {
                return this.extensions.get("OES_standard_derivatives")
            },
            supportsCompressedTextureS3TC: function() {
                return this.extensions.get("WEBGL_compressed_texture_s3tc")
            },
            supportsCompressedTexturePVRTC: function() {
                return this.extensions.get("WEBGL_compressed_texture_pvrtc")
            },
            supportsBlendMinMax: function() {
                return this.extensions.get("EXT_blend_minmax")
            },
            supportsVertexTextures: function() {
                return this.capabilities.vertexTextures
            },
            supportsInstancedArrays: function() {
                return this.extensions.get("ANGLE_instanced_arrays")
            },
            enableScissorTest: function(t) {
                this.setScissorTest(t)
            },
            initMaterial: function() {},
            addPrePlugin: function() {},
            addPostPlugin: function() {},
            updateShadowMap: function() {},
            setFaceCulling: function() {},
            allocTextureUnit: function() {},
            setTexture: function() {},
            setTexture2D: function() {},
            setTextureCube: function() {},
            getActiveMipMapLevel: function() {
                return this.getActiveMipmapLevel()
            }
        }), Object.defineProperties(fo.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {},
                set: function() {}
            },
            context: {
                get: function() {
                    return this.getContext()
                }
            },
            vr: {
                get: function() {
                    return this.xr
                }
            },
            gammaInput: {
                get: function() {
                    return !1
                },
                set: function() {}
            },
            gammaOutput: {
                get: function() {
                    return !1
                },
                set: function(t) {
                    this.outputEncoding = !0 === t ? We : He
                }
            },
            toneMappingWhitePoint: {
                get: function() {
                    return 1
                },
                set: function() {}
            }
        }), Object.defineProperties(ro.prototype, {
            cullFace: {
                get: function() {},
                set: function() {}
            },
            renderReverseSided: {
                get: function() {},
                set: function() {}
            },
            renderSingleSided: {
                get: function() {},
                set: function() {}
            }
        }), Object.defineProperties(bi.prototype, {
            wrapS: {
                get: function() {
                    return this.texture.wrapS
                },
                set: function(t) {
                    this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return this.texture.wrapT
                },
                set: function(t) {
                    this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return this.texture.magFilter
                },
                set: function(t) {
                    this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return this.texture.minFilter
                },
                set: function(t) {
                    this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return this.texture.anisotropy
                },
                set: function(t) {
                    this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return this.texture.offset
                },
                set: function(t) {
                    this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return this.texture.repeat
                },
                set: function(t) {
                    this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return this.texture.format
                },
                set: function(t) {
                    this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return this.texture.type
                },
                set: function(t) {
                    this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return this.texture.generateMipmaps
                },
                set: function(t) {
                    this.texture.generateMipmaps = t
                }
            }
        }), Object.defineProperties(Ac.prototype, {
            load: {
                value: function(t) {
                    var e = this;
                    return (new mc).load(t, function(t) {
                        e.setBuffer(t)
                    }), this
                }
            },
            startTime: {
                set: function() {}
            }
        }), Oc.prototype.getData = function() {
            return this.getFrequencyData()
        }, ta.prototype.updateCubeMap = function(t, e) {
            return this.update(t, e)
        };
        var ud = {
            merge: function(t, e, i) {
                var n;
                e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, i)
            },
            center: function(t) {
                return t.center()
            }
        };
        i.GeometryUtils = ud, mi.crossOrigin = void 0, mi.loadTexture = function(t, e, i, n) {
            var r = new mu;
            r.setCrossOrigin(this.crossOrigin);
            var a = r.load(t, i, void 0, n);
            return e && (a.mapping = e), a
        }, mi.loadTextureCube = function(t, e, i, n) {
            var r = new du;
            r.setCrossOrigin(this.crossOrigin);
            var a = r.load(t, i, void 0, n);
            return e && (a.mapping = e), a
        }, mi.loadCompressedTexture = function() {}, mi.loadCompressedTextureCube = function() {};
        var cd = {
            createMultiMaterialObject: function() {},
            detach: function() {},
            attach: function() {}
        };
        i.SceneUtils = cd, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: "120"
            }
        }))
    }, {}],
    5: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.ClearMaskPass = i.MaskPass = void 0;

        function n(t, e) {
            r.Pass.call(this), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
        }
        var r = t("../postprocessing/Pass.js");
        (i.MaskPass = n).prototype = Object.assign(Object.create(r.Pass.prototype), {
            constructor: n,
            render: function(t, e, i) {
                var n, r, a = t.getContext(),
                    s = t.state;
                s.buffers.color.setMask(!1), s.buffers.depth.setMask(!1), s.buffers.color.setLocked(!0), s.buffers.depth.setLocked(!0), r = this.inverse ? (n = 0, 1) : (n = 1, 0), s.buffers.stencil.setTest(!0), s.buffers.stencil.setOp(a.REPLACE, a.REPLACE, a.REPLACE), s.buffers.stencil.setFunc(a.ALWAYS, n, 4294967295), s.buffers.stencil.setClear(r), s.buffers.stencil.setLocked(!0), t.setRenderTarget(i), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), s.buffers.color.setLocked(!1), s.buffers.depth.setLocked(!1), s.buffers.stencil.setLocked(!1), s.buffers.stencil.setFunc(a.EQUAL, 1, 4294967295), s.buffers.stencil.setOp(a.KEEP, a.KEEP, a.KEEP), s.buffers.stencil.setLocked(!0)
            }
        });

        function a() {
            r.Pass.call(this), this.needsSwap = !1
        }(i.ClearMaskPass = a).prototype = Object.create(r.Pass.prototype), Object.assign(a.prototype, {
            render: function(t) {
                t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
            }
        })
    }, {
        "../postprocessing/Pass.js": 6
    }],
    6: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.Pass = s;
        var n, r, a = t("../../../build/three.module.js");

        function s() {
            this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
        }

        function o(t) {
            this._mesh = new a.Mesh(r, t)
        }
        Object.assign(s.prototype, {
            setSize: function() {},
            render: function() {}
        }), s.FullScreenQuad = (n = new a.OrthographicCamera(-1, 1, 1, -1, 0, 1), r = new a.PlaneBufferGeometry(2, 2), Object.defineProperty(o.prototype, "material", {
            get: function() {
                return this._mesh.material
            },
            set: function(t) {
                this._mesh.material = t
            }
        }), Object.assign(o.prototype, {
            dispose: function() {
                this._mesh.geometry.dispose()
            },
            render: function(t) {
                t.render(this._mesh, n)
            }
        }), o)
    }, {
        "../../../build/three.module.js": 4
    }],
    7: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.triggerDatepickerEvent = function(t, e) {
            var i = {
                date: t.getDate(),
                viewDate: new Date(t.picker.viewDate),
                viewId: t.picker.currentView.id,
                datepicker: t
            };
            t.element.dispatchEvent(new CustomEvent(e, {
                detail: i
            }))
        }, i.goToPrevOrNext = function(t, e) {
            var i, n = t.config,
                r = n.minDate,
                a = n.maxDate,
                s = t.picker,
                o = s.currentView,
                l = s.viewDate;
            switch (o.id) {
                case 0:
                    i = (0, u.addMonths)(l, e);
                    break;
                case 1:
                    i = (0, u.addYears)(l, e);
                    break;
                default:
                    i = (0, u.addYears)(l, e * o.navStep)
            }
            i = (0, h.limitToRange)(i, r, a), t.picker.changeFocus(i).render()
        }, i.switchView = function(t) {
            var e = t.picker.currentView.id;
            if (e === t.config.maxView) return;
            t.picker.changeView(e + 1).render()
        }, i.unfocus = function(t) {
            t.config.updateOnBlur ? t.update({
                autohide: !0
            }) : (t.refresh("input"), t.hide())
        };
        var h = t("../lib/utils.js"),
            u = t("../lib/date.js")
    }, {
        "../lib/date.js": 13,
        "../lib/utils.js": 16
    }],
    8: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.onKeydown = function(t, e) {
            if ("Tab" === e.key) return void(0, s.unfocus)(t);
            var i = t.picker,
                n = i.currentView,
                r = n.id,
                a = n.isMinView;
            if (i.active)
                if (t.editMode) switch (e.key) {
                    case "Escape":
                        i.hide();
                        break;
                    case "Enter":
                        t.exitEditMode({
                            update: !0,
                            autohide: t.config.autohide
                        });
                        break;
                    default:
                        return
                } else switch (e.key) {
                    case "Escape":
                        i.hide();
                        break;
                    case "ArrowLeft":
                        if (e.ctrlKey || e.metaKey)(0, s.goToPrevOrNext)(t, -1);
                        else {
                            if (e.shiftKey) return void t.enterEditMode();
                            o(t, e, -1, !1)
                        }
                        break;
                    case "ArrowRight":
                        if (e.ctrlKey || e.metaKey)(0, s.goToPrevOrNext)(t, 1);
                        else {
                            if (e.shiftKey) return void t.enterEditMode();
                            o(t, e, 1, !1)
                        }
                        break;
                    case "ArrowUp":
                        if (e.ctrlKey || e.metaKey)(0, s.switchView)(t);
                        else {
                            if (e.shiftKey) return void t.enterEditMode();
                            o(t, e, -1, !0)
                        }
                        break;
                    case "ArrowDown":
                        if (e.shiftKey && !e.ctrlKey && !e.metaKey) return void t.enterEditMode();
                        o(t, e, 1, !0);
                        break;
                    case "Enter":
                        a ? t.setDate(i.viewDate) : i.changeView(r - 1).render();
                        break;
                    case "Backspace":
                    case "Delete":
                        return void t.enterEditMode();
                    default:
                        return void(1 !== e.key.length || e.ctrlKey || e.metaKey || t.enterEditMode())
                } else switch (e.key) {
                    case "ArrowDown":
                    case "Escape":
                        i.show();
                        break;
                    case "Enter":
                        t.update();
                        break;
                    default:
                        return
                }
            e.preventDefault(), e.stopPropagation()
        }, i.onFocus = function(t) {
            t.config.showOnFocus && t.show()
        }, i.onMousedown = function(t, e) {
            var i = e.target;
            (t.picker.active || t.config.showOnClick) && (i._active = i === document.activeElement, i._clicking = setTimeout(function() {
                delete i._active, delete i._clicking
            }, 2e3))
        }, i.onClickInput = function(t, e) {
            var i = e.target;
            if (!i._clicking) return;
            clearTimeout(i._clicking), delete i._clicking, i._active && t.enterEditMode();
            delete i._active, t.config.showOnClick && t.show()
        }, i.onPaste = function(t, e) {
            e.clipboardData.types.includes("text/plain") && t.enterEditMode()
        };
        var u = t("../lib/utils.js"),
            c = t("../lib/date.js"),
            s = t("./functions.js");

        function o(t, e, i, n) {
            var r, a, s = t.picker,
                o = s.currentView,
                l = o.step || 1,
                h = s.viewDate;
            switch (o.id) {
                case 0:
                    h = n ? (0, c.addDays)(h, 7 * i) : (e.ctrlKey || e.metaKey ? (0, c.addYears) : (0, c.addDays))(h, i), r = c.addDays, a = function(t) {
                        return o.disabled.includes(t)
                    };
                    break;
                case 1:
                    h = (0, c.addMonths)(h, n ? 4 * i : i), r = c.addMonths, a = function(t) {
                        var e = new Date(t),
                            i = o.year,
                            n = o.disabled;
                        return e.getFullYear() === i && n.includes(e.getMonth())
                    };
                    break;
                default:
                    h = (0, c.addYears)(h, i * (n ? 4 : 1) * l), r = c.addYears, a = function(t) {
                        return o.disabled.includes((0, c.startOfYearPeriod)(t, l))
                    }
            }
            void 0 !== (h = function t(e, i, n, r, a, s) {
                if ((0, u.isInRange)(e, a, s)) return r(e) ? t(i(e, n), i, n, r, a, s) : e
            }(h, r, i < 0 ? -l : l, a, o.minDate, o.maxDate)) && s.changeFocus(h).render()
        }
    }, {
        "../lib/date.js": 13,
        "../lib/utils.js": 16,
        "./functions.js": 7
    }],
    9: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.onClickOutside = function(t, e) {
            var i = t.element;
            if (i !== document.activeElement) return;
            var n = t.picker.element;
            if ((0, r.findElementInEventPath)(e, function(t) {
                    return t === i || t === n
                })) return;
            (0, a.unfocus)(t)
        };
        var r = t("../lib/event.js"),
            a = t("./functions.js")
    }, {
        "../lib/event.js": 15,
        "./functions.js": 7
    }],
    10: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.onClickTodayBtn = function(t) {
            var e = t.picker,
                i = (0, s.today)();
            if (1 === t.config.todayBtnMode) {
                if (t.config.autohide) return void t.setDate(i);
                t.setDate(i, {
                    render: !1
                }), e.update()
            }
            e.viewDate !== i && e.changeFocus(i);
            e.changeView(0).render()
        }, i.onClickClearBtn = function(t) {
            t.setDate({
                clear: !0
            })
        }, i.onClickViewSwitch = function(t) {
            (0, n.switchView)(t)
        }, i.onClickPrevBtn = function(t) {
            (0, n.goToPrevOrNext)(t, -1)
        }, i.onClickNextBtn = function(t) {
            (0, n.goToPrevOrNext)(t, 1)
        }, i.onClickView = function(t, e) {
            var i = (0, a.findElementInEventPath)(e, ".datepicker-cell");
            if (!i || i.classList.contains("disabled")) return;
            var n = t.picker.currentView,
                r = n.id;
            n.isMinView ? t.setDate(Number(i.dataset.date)) : o(t, 1 === r ? Number(i.dataset.month) : Number(i.dataset.year))
        }, i.onClickPicker = function(t) {
            t.inline || t.config.disableTouchKeyboard || t.inputField.focus()
        };
        var s = t("../lib/date.js"),
            a = t("../lib/event.js"),
            n = t("./functions.js");

        function o(t, e) {
            var i = t.picker,
                n = new Date(i.viewDate),
                r = i.currentView.id,
                a = 1 === r ? (0, s.addMonths)(n, e - n.getMonth()) : (0, s.addYears)(n, e - n.getFullYear());
            i.changeFocus(a).changeView(r - 1).render()
        }
    }, {
        "../lib/date.js": 13,
        "../lib/event.js": 15,
        "./functions.js": 7
    }],
    11: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.locales = void 0;
        i.locales = {
            en: {
                days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                today: "Today",
                clear: "Clear",
                titleFormat: "MM y"
            }
        }
    }, {}],
    12: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.parseDate = function(t, e, i) {
            if (t instanceof Date || "number" == typeof t) {
                var n = (0, o.stripTime)(t);
                return isNaN(n) ? void 0 : n
            }
            if (!t) return;
            if ("today" === t) return (0, o.today)();
            if (e && e.toValue) {
                var r = e.toValue(t, e, i);
                return isNaN(r) ? void 0 : (0, o.stripTime)(r)
            }
            return s(e).parser(t, i)
        }, i.formatDate = function(t, e, i) {
            if (isNaN(t) || !t && 0 !== t) return "";
            var n = "number" == typeof t ? new Date(t) : t;
            if (e.toDisplay) return e.toDisplay(n, e, i);
            return s(e).formatter(n, i)
        }, i.reNonDateParts = i.reFormatTokens = void 0;
        var o = t("./date.js"),
            l = t("./utils.js"),
            n = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
        i.reFormatTokens = n;
        var h = /[\s!-/:-@[-`{-~年月日]+/;
        i.reNonDateParts = h;
        var r = {},
            u = {
                y: function(t, e) {
                    return new Date(t).setFullYear(parseInt(e, 10))
                },
                m: function(t, e, i) {
                    var n = new Date(t),
                        r = parseInt(e, 10) - 1;
                    if (isNaN(r)) {
                        if (!e) return NaN;
                        var a = e.toLowerCase(),
                            s = function(t) {
                                return t.toLowerCase().startsWith(a)
                            };
                        if ((r = i.monthsShort.findIndex(s)) < 0 && (r = i.months.findIndex(s)), r < 0) return NaN
                    }
                    return n.setMonth(r), n.getMonth() !== function t(e) {
                        return -1 < e ? e % 12 : t(e + 12)
                    }(r) ? n.setDate(0) : n.getTime()
                },
                d: function(t, e) {
                    return new Date(t).setDate(parseInt(e, 10))
                }
            },
            c = {
                d: function(t) {
                    return t.getDate()
                },
                dd: function(t) {
                    return a(t.getDate(), 2)
                },
                D: function(t, e) {
                    return e.daysShort[t.getDay()]
                },
                DD: function(t, e) {
                    return e.days[t.getDay()]
                },
                m: function(t) {
                    return t.getMonth() + 1
                },
                mm: function(t) {
                    return a(t.getMonth() + 1, 2)
                },
                M: function(t, e) {
                    return e.monthsShort[t.getMonth()]
                },
                MM: function(t, e) {
                    return e.months[t.getMonth()]
                },
                y: function(t) {
                    return t.getFullYear()
                },
                yy: function(t) {
                    return a(t.getFullYear(), 2).slice(-2)
                },
                yyyy: function(t) {
                    return a(t.getFullYear(), 4)
                }
            };

        function a(t, e) {
            return t.toString().padStart(e, "0")
        }

        function s(t) {
            if ("string" != typeof t) throw new Error("Invalid date format.");
            if (t in r) return r[t];
            var a = t.split(n),
                s = t.match(new RegExp(n, "g"));
            if (0 === a.length || !s) throw new Error("Invalid date format.");
            var e = s.map(function(t) {
                    return c[t]
                }),
                i = Object.keys(u).reduce(function(t, e) {
                    return s.find(function(t) {
                        return "D" !== t[0] && t[0].toLowerCase() === e
                    }) && t.push(e), t
                }, []);
            return r[t] = {
                parser: function(t, n) {
                    var r = t.split(h).reduce(function(t, e, i) {
                        var n;
                        return 0 < e.length && s[i] && ("M" === (n = s[i][0]) ? t.m = e : "D" !== n && (t[n] = e)), t
                    }, {});
                    return i.reduce(function(t, e) {
                        var i = u[e](t, r[e], n);
                        return isNaN(i) ? t : i
                    }, (0, o.today)())
                },
                formatter: function(n, r) {
                    return e.reduce(function(t, e, i) {
                        return t + "".concat(a[i]).concat(e(n, r))
                    }, "") + (0, l.lastItemOf)(a)
                }
            }
        }
    }, {
        "./date.js": 13,
        "./utils.js": 16
    }],
    13: [function(t, e, i) {
        "use strict";

        function n(t) {
            return new Date(t).setHours(0, 0, 0, 0)
        }

        function r() {
            return (new Date).setHours(0, 0, 0, 0)
        }

        function a(t, e) {
            var i = new Date(t);
            return i.setDate(i.getDate() + e)
        }

        function s(t, e) {
            return (t - e + 7) % 7
        }

        function o(t, e) {
            var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                n = new Date(t).getDay();
            return a(t, s(e, i) - s(n, i))
        }
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.stripTime = n, i.today = r, i.dateValue = function() {
            switch (arguments.length) {
                case 0:
                    return r();
                case 1:
                    return n(arguments.length <= 0 ? void 0 : arguments[0])
            }
            var t = new Date(0);
            return t.setFullYear.apply(t, arguments), t.setHours(0, 0, 0, 0)
        }, i.addDays = a, i.addWeeks = function(t, e) {
            return a(t, 7 * e)
        }, i.addMonths = function(t, e) {
            var i = new Date(t),
                n = i.getMonth() + e,
                r = n % 12;
            r < 0 && (r += 12);
            var a = i.setMonth(n);
            return i.getMonth() !== r ? i.setDate(0) : a
        }, i.addYears = function(t, e) {
            var i = new Date(t),
                n = i.getMonth(),
                r = i.setFullYear(i.getFullYear() + e);
            return 1 === n && 2 === i.getMonth() ? i.setDate(0) : r
        }, i.dayOfTheWeekOf = o, i.getWeek = function(t) {
            var e = o(t, 4, 1),
                i = o(new Date(e).setMonth(0, 4), 4, 1);
            return Math.round((e - i) / 6048e5) + 1
        }, i.startOfYearPeriod = function(t, e) {
            var i = new Date(t).getFullYear();
            return Math.floor(i / e) * e
        }
    }, {}],
    14: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.parseHTML = r, i.isVisible = function(t) {
            return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
        }, i.hideElement = function(t) {
            if ("none" === t.style.display) return;
            t.style.display && (t.dataset.styleDisplay = t.style.display);
            t.style.display = "none"
        }, i.showElement = function(t) {
            if ("none" !== t.style.display) return;
            t.dataset.styleDisplay ? (t.style.display = t.dataset.styleDisplay, delete t.dataset.styleDisplay) : t.style.display = ""
        }, i.emptyChildNodes = a, i.replaceChildNodes = function(e, t) {
            a(e), t instanceof DocumentFragment ? e.appendChild(t) : "string" == typeof t ? e.appendChild(r(t)) : "function" == typeof t.forEach && t.forEach(function(t) {
                e.appendChild(t)
            })
        };
        var n = document.createRange();

        function r(t) {
            return n.createContextualFragment(t)
        }

        function a(t) {
            t.firstChild && (t.removeChild(t.firstChild), a(t))
        }
    }, {}],
    15: [function(t, e, i) {
        "use strict";

        function n(t) {
            return function(t) {
                if (Array.isArray(t)) return r(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return r(t, e);
                var i = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === i && t.constructor && (i = t.constructor.name);
                if ("Map" === i || "Set" === i) return Array.from(t);
                if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return r(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function r(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.registerListeners = function(t, e) {
            var i = a.get(t);
            i || (i = [], a.set(t, i));
            e.forEach(function(t) {
                o.call.apply(o, n(t)), i.push(t)
            })
        }, i.unregisterListeners = function(t) {
            var e = a.get(t);
            if (!e) return;
            e.forEach(function(t) {
                l.call.apply(l, n(t))
            }), a.delete(t)
        }, i.findElementInEventPath = function(t, e) {
            var i = "function" == typeof e ? e : function(t) {
                return t.matches(e)
            };
            return function t(e, i, n) {
                var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
                var a = e[r]; {
                    if (i(a)) return a;
                    if (a === n || !a.parentElement) return
                }
                return t(e, i, n, r + 1)
            }(t.composedPath(), i, t.currentTarget)
        };
        var a = new WeakMap,
            s = EventTarget.prototype,
            o = s.addEventListener,
            l = s.removeEventListener;
        Event.prototype.composedPath || (Event.prototype.composedPath = function() {
            return function t(e, i) {
                var n, r = 1 < arguments.length && void 0 !== i ? i : [];
                return r.push(e), e.parentNode ? n = e.parentNode : e.host ? n = e.host : e.defaultView && (n = e.defaultView), n ? t(n, r) : r
            }(this.target)
        })
    }, {}],
    16: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.hasProperty = function(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        }, i.lastItemOf = function(t) {
            return t[t.length - 1]
        }, i.pushUnique = function(e) {
            for (var t = arguments.length, i = new Array(1 < t ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];
            return i.forEach(function(t) {
                e.includes(t) || e.push(t)
            }), e
        }, i.stringToArray = function(t, e) {
            return t ? t.split(e) : []
        }, i.isInRange = function(t, e, i) {
            var n = void 0 === e || e <= t,
                r = void 0 === i || t <= i;
            return n && r
        }, i.limitToRange = function(t, e, i) {
            if (t < e) return e;
            if (i < t) return i;
            return t
        }, i.createTagRepeat = function t(e, i) {
            var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
            var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
            var a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : "";
            var s = Object.keys(n).reduce(function(t, e) {
                var i = n[e];
                return "function" == typeof i && (i = i(r)), "".concat(t, " ").concat(e, '="').concat(i, '"')
            }, e);
            a += "<".concat(s, "></").concat(e, ">");
            var o = r + 1;
            return o < i ? t(e, i, n, o, a) : a
        }, i.optimizeTemplateHTML = function(t) {
            return t.replace(/>\s+/g, ">").replace(/\s+</, "<")
        }
    }, {}],
    17: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        });
        var n = {
            autohide: !1,
            beforeShowDay: null,
            beforeShowDecade: null,
            beforeShowMonth: null,
            beforeShowYear: null,
            calendarWeeks: !1,
            clearBtn: !1,
            dateDelimiter: ",",
            datesDisabled: [],
            daysOfWeekDisabled: [],
            daysOfWeekHighlighted: [],
            defaultViewDate: i.default = void 0,
            disableTouchKeyboard: !1,
            format: "mm/dd/yyyy",
            language: "en",
            maxDate: null,
            maxNumberOfDates: 1,
            maxView: 3,
            minDate: null,
            nextArrow: "»",
            orientation: "auto",
            pickLevel: 0,
            prevArrow: "«",
            showDaysOfWeek: !0,
            showOnClick: !0,
            showOnFocus: !0,
            startView: 0,
            title: "",
            todayBtn: !1,
            todayBtnMode: 0,
            todayHighlight: !1,
            updateOnBlur: !0,
            weekStart: 0
        };
        i.default = n
    }, {}],
    18: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = function(t, e) {
            var i, n = Object.assign({}, t),
                r = {},
                a = e.constructor.locales,
                s = e.config || {},
                o = s.format,
                l = s.language,
                h = s.locale,
                u = s.maxDate,
                c = s.maxView,
                p = s.minDate,
                d = s.pickLevel,
                f = s.startView,
                m = s.weekStart; {
                var g;
                n.language && (n.language !== l && (a[n.language] ? i = n.language : (i = n.language.split("-")[0], void 0 === a[i] && (i = !1))), delete n.language, i && (l = r.language = i, g = h || a[N], h = Object.assign({
                    format: B,
                    weekStart: R
                }, a[N]), l !== N && Object.assign(h, a[l]), r.locale = h, o === g.format && (o = r.format = h.format), m === g.weekStart && (m = r.weekStart = h.weekStart, r.weekEnd = G(h.weekStart))))
            } {
                var v, y, b;
                n.format && (v = "function" == typeof n.format.toDisplay, y = "function" == typeof n.format.toValue, b = O.reFormatTokens.test(n.format), (v && y || b) && (o = r.format = n.format), delete n.format)
            }
            var x = p,
                _ = u;
            void 0 !== n.minDate && (x = null === n.minDate ? (0, k.dateValue)(0, 0, 1) : V(n.minDate, o, h, x), delete n.minDate);
            void 0 !== n.maxDate && (_ = null === n.maxDate ? void 0 : V(n.maxDate, o, h, _), delete n.maxDate);
            _ < x ? (p = r.minDate = _, u = r.maxDate = x) : (p !== x && (p = r.minDate = x), u !== _ && (u = r.maxDate = _));
            n.datesDisabled && (r.datesDisabled = n.datesDisabled.reduce(function(t, e) {
                var i = (0, O.parseDate)(e, o, h);
                return void 0 !== i ? (0, L.pushUnique)(t, i) : t
            }, []), delete n.datesDisabled); {
                var w;
                void 0 !== n.defaultViewDate && (void 0 !== (w = (0, O.parseDate)(n.defaultViewDate, o, h)) && (r.defaultViewDate = w), delete n.defaultViewDate)
            } {
                var S;
                void 0 !== n.weekStart && (S = Number(n.weekStart) % 7, isNaN(S) || (m = r.weekStart = S, r.weekEnd = G(S)), delete n.weekStart)
            }
            n.daysOfWeekDisabled && (r.daysOfWeekDisabled = n.daysOfWeekDisabled.reduce(z, []), delete n.daysOfWeekDisabled);
            n.daysOfWeekHighlighted && (r.daysOfWeekHighlighted = n.daysOfWeekHighlighted.reduce(z, []), delete n.daysOfWeekHighlighted); {
                var M;
                void 0 !== n.maxNumberOfDates && (0 <= (M = parseInt(n.maxNumberOfDates, 10)) && (r.maxNumberOfDates = M, r.multidate = 1 !== M), delete n.maxNumberOfDates)
            }
            n.dateDelimiter && (r.dateDelimiter = String(n.dateDelimiter), delete n.dateDelimiter);
            var T = d;
            void 0 !== n.pickLevel && (T = U(n.pickLevel, 2), delete n.pickLevel);
            T !== d && (d = r.pickLevel = T);
            var C = c;
            void 0 !== n.maxView && (C = U(n.maxView, c), delete n.maxView);
            (C = C < d ? d : C) !== c && (c = r.maxView = C);
            var A = f;
            void 0 !== n.startView && (A = U(n.startView, A), delete n.startView);
            A < d ? A = d : c < A && (A = c);
            A !== f && (r.startView = A); {
                var E;
                n.prevArrow && (0 < (E = (0, F.parseHTML)(n.prevArrow)).childNodes.length && (r.prevArrow = E.childNodes), delete n.prevArrow)
            } {
                var D;
                n.nextArrow && (0 < (D = (0, F.parseHTML)(n.nextArrow)).childNodes.length && (r.nextArrow = D.childNodes), delete n.nextArrow)
            }
            void 0 !== n.disableTouchKeyboard && (r.disableTouchKeyboard = "ontouchstart" in document && !!n.disableTouchKeyboard, delete n.disableTouchKeyboard); {
                var P;
                n.orientation && (P = n.orientation.toLowerCase().split(/\s+/g), r.orientation = {
                    x: P.find(function(t) {
                        return "left" === t || "right" === t
                    }) || "auto",
                    y: P.find(function(t) {
                        return "top" === t || "bottom" === t
                    }) || "auto"
                }, delete n.orientation)
            }
            if (void 0 !== n.todayBtnMode) {
                switch (n.todayBtnMode) {
                    case 0:
                    case 1:
                        r.todayBtnMode = n.todayBtnMode
                }
                delete n.todayBtnMode
            }
            return Object.keys(n).forEach(function(t) {
                void 0 !== n[t] && (0, L.hasProperty)(I.default, t) && (r[t] = n[t])
            }), r
        };
        var n, L = t("../lib/utils.js"),
            k = t("../lib/date.js"),
            O = t("../lib/date-format.js"),
            F = t("../lib/dom.js"),
            I = (n = t("./defaultOptions.js")) && n.__esModule ? n : {
                default: n
            };
        var N = I.default.language,
            B = I.default.format,
            R = I.default.weekStart;

        function z(t, e) {
            return t.length < 6 && 0 <= e && e < 7 ? (0, L.pushUnique)(t, e) : t
        }

        function G(t) {
            return (t + 6) % 7
        }

        function V(t, e, i, n) {
            var r = (0, O.parseDate)(t, e, i);
            return void 0 !== r ? r : n
        }

        function U(t, e, i) {
            var n = 2 < arguments.length && void 0 !== i ? i : 3,
                r = parseInt(t, 10);
            return 0 <= r && r <= n ? r : e
        }
    }, {
        "../lib/date-format.js": 12,
        "../lib/date.js": 13,
        "../lib/dom.js": 14,
        "../lib/utils.js": 16,
        "./defaultOptions.js": 17
    }],
    19: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = void 0;
        var o = t("../lib/utils.js"),
            l = t("../lib/date.js"),
            g = t("../lib/dom.js"),
            v = t("../lib/event.js"),
            y = n(t("./templates/pickerTemplate.js")),
            b = n(t("./views/DaysView.js")),
            x = n(t("./views/MonthsView.js")),
            _ = n(t("./views/YearsView.js")),
            u = t("../events/functions.js"),
            w = t("../events/pickerListeners.js");

        function n(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }

        function S(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t
            }(t) || function(t, e) {
                if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t))) return;
                var i = [],
                    n = !0,
                    r = !1,
                    a = void 0;
                try {
                    for (var s, o = t[Symbol.iterator](); !(n = (s = o.next()).done) && (i.push(s.value), !e || i.length !== e); n = !0);
                } catch (t) {
                    r = !0, a = t
                } finally {
                    try {
                        n || null == o.return || o.return()
                    } finally {
                        if (r) throw a
                    }
                }
                return i
            }(t, e) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return r(t, e);
                var i = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === i && t.constructor && (i = t.constructor.name);
                if ("Map" === i || "Set" === i) return Array.from(t);
                if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return r(t, e)
            }(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function r(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }

        function a(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        function M(t, e) {
            var i, n, r, a, s;
            void 0 !== e.title && (e.title ? (t.controls.title.textContent = e.title, (0, g.showElement)(t.controls.title)) : (t.controls.title.textContent = "", g.hideElement)(t.controls.title)), e.prevArrow && (i = t.controls.prevBtn, (0, g.emptyChildNodes)(i), e.prevArrow.forEach(function(t) {
                i.appendChild(t.cloneNode(!0))
            })), e.nextArrow && (n = t.controls.nextBtn, (0, g.emptyChildNodes)(n), e.nextArrow.forEach(function(t) {
                n.appendChild(t.cloneNode(!0))
            })), e.locale && (t.controls.todayBtn.textContent = e.locale.today, t.controls.clearBtn.textContent = e.locale.clear), void 0 !== e.todayBtn && (e.todayBtn ? (0, g.showElement) : (0, g.hideElement))(t.controls.todayBtn), ((0, o.hasProperty)(e, "minDate") || (0, o.hasProperty)(e, "maxDate")) && (a = (r = t.datepicker.config).minDate, s = r.maxDate, t.controls.todayBtn.disabled = !(0, o.isInRange)((0, l.today)(), a, s)), void 0 !== e.clearBtn && (e.clearBtn ? (0, g.showElement) : (0, g.hideElement))(t.controls.clearBtn)
        }

        function T(t) {
            var e = t.dates,
                i = t.config,
                n = 0 < e.length ? (0, o.lastItemOf)(e) : i.defaultViewDate;
            return (0, o.limitToRange)(n, i.minDate, i.maxDate)
        }

        function s(t, e) {
            var i = new Date(t.viewDate),
                n = new Date(e),
                r = t.currentView,
                a = r.id,
                s = r.year,
                o = r.first,
                l = r.last,
                h = n.getFullYear();
            switch (t.viewDate = e, h !== i.getFullYear() && (0, u.triggerDatepickerEvent)(t.datepicker, "changeYear"), n.getMonth() !== i.getMonth() && (0, u.triggerDatepickerEvent)(t.datepicker, "changeMonth"), a) {
                case 0:
                    return e < o || l < e;
                case 1:
                    return h !== s;
                default:
                    return h < o || l < h
            }
        }

        function C(t) {
            return window.getComputedStyle(t).direction
        }
        var h = function() {
            function m(t) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, m), this.datepicker = t;
                var e = y.default.replace(/%buttonClass%/g, t.config.buttonClass),
                    i = this.element = (0, g.parseHTML)(e).firstChild,
                    n = S(i.firstChild.children, 3),
                    r = n[0],
                    a = n[1],
                    s = n[2],
                    o = r.firstElementChild,
                    l = S(r.lastElementChild.children, 3),
                    h = l[0],
                    u = l[1],
                    c = l[2],
                    p = S(s.firstChild.children, 2),
                    d = {
                        title: o,
                        prevBtn: h,
                        viewSwitch: u,
                        nextBtn: c,
                        todayBtn: p[0],
                        clearBtn: p[1]
                    };
                this.main = a, this.controls = d;
                var f = t.inline ? "inline" : "dropdown";
                i.classList.add("datepicker-".concat(f)), M(this, t.config), this.viewDate = T(t), (0, v.registerListeners)(t, [
                    [i, "click", w.onClickPicker.bind(null, t), {
                        capture: !0
                    }],
                    [a, "click", w.onClickView.bind(null, t)],
                    [d.viewSwitch, "click", w.onClickViewSwitch.bind(null, t)],
                    [d.prevBtn, "click", w.onClickPrevBtn.bind(null, t)],
                    [d.nextBtn, "click", w.onClickNextBtn.bind(null, t)],
                    [d.todayBtn, "click", w.onClickTodayBtn.bind(null, t)],
                    [d.clearBtn, "click", w.onClickClearBtn.bind(null, t)]
                ]), this.views = [new b.default(this), new x.default(this), new _.default(this, {
                    id: 2,
                    name: "years",
                    cellClass: "year",
                    step: 1
                }), new _.default(this, {
                    id: 3,
                    name: "decades",
                    cellClass: "decade",
                    step: 10
                })], this.currentView = this.views[t.config.startView], this.currentView.render(), this.main.appendChild(this.currentView.element), t.config.container.appendChild(this.element)
            }
            var t, e, i;
            return t = m, (e = [{
                key: "setOptions",
                value: function(e) {
                    M(this, e), this.views.forEach(function(t) {
                        t.init(e, !1)
                    }), this.currentView.render()
                }
            }, {
                key: "detach",
                value: function() {
                    this.datepicker.config.container.removeChild(this.element)
                }
            }, {
                key: "show",
                value: function() {
                    var t, e;
                    this.active || (this.element.classList.add("active"), this.active = !0, (t = this.datepicker).inline || ((e = C(t.inputField)) !== C(t.config.container) ? this.element.dir = e : this.element.dir && this.element.removeAttribute("dir"), this.place(), t.config.disableTouchKeyboard && t.inputField.blur()), (0, u.triggerDatepickerEvent)(t, "show"))
                }
            }, {
                key: "hide",
                value: function() {
                    this.active && (this.datepicker.exitEditMode(), this.element.classList.remove("active"), (this.active = !1, u.triggerDatepickerEvent)(this.datepicker, "hide"))
                }
            }, {
                key: "place",
                value: function() {
                    var t, e, i = this.element,
                        n = i.classList,
                        r = i.style,
                        a = this.datepicker,
                        s = a.config,
                        o = a.inputField,
                        l = s.container,
                        h = this.element.getBoundingClientRect(),
                        u = h.width,
                        c = h.height,
                        p = l.getBoundingClientRect(),
                        d = p.left,
                        f = p.top,
                        m = p.width,
                        g = o.getBoundingClientRect(),
                        v = g.left,
                        y = g.top,
                        b = g.width,
                        x = g.height,
                        _ = s.orientation,
                        w = _.x,
                        S = _.y,
                        M = l === document.body ? (t = window.scrollY, e = v + window.scrollX, y + t) : (e = v - d, y - f + (t = l.scrollTop));
                    "auto" === w && (e < 0 ? (w = "left", e = 10) : w = m < e + u || "rtl" === C(o) ? "right" : "left"), "right" === w && (e -= u - b), "auto" === S && (S = M - c < t ? "bottom" : "top"), "top" === S ? M -= c : M += x, n.remove("datepicker-orient-top", "datepicker-orient-bottom", "datepicker-orient-right", "datepicker-orient-left"), n.add("datepicker-orient-".concat(S), "datepicker-orient-".concat(w)), r.top = M ? "".concat(M, "px") : M, r.left = e ? "".concat(e, "px") : e
                }
            }, {
                key: "setViewSwitchLabel",
                value: function(t) {
                    this.controls.viewSwitch.textContent = t
                }
            }, {
                key: "setPrevBtnDisabled",
                value: function(t) {
                    this.controls.prevBtn.disabled = t
                }
            }, {
                key: "setNextBtnDisabled",
                value: function(t) {
                    this.controls.nextBtn.disabled = t
                }
            }, {
                key: "changeView",
                value: function(t) {
                    var e = this.currentView,
                        i = this.views[t];
                    return i.id !== e.id && (this.currentView = i, this._renderMethod = "render", (0, u.triggerDatepickerEvent)(this.datepicker, "changeView"), this.main.replaceChild(i.element, e.element)), this
                }
            }, {
                key: "changeFocus",
                value: function(t) {
                    return this._renderMethod = s(this, t) ? "render" : "refreshFocus", this.views.forEach(function(t) {
                        t.updateFocus()
                    }), this
                }
            }, {
                key: "update",
                value: function() {
                    var t = T(this.datepicker);
                    return this._renderMethod = s(this, t) ? "render" : "refresh", this.views.forEach(function(t) {
                        t.updateFocus(), t.updateSelection()
                    }), this
                }
            }, {
                key: "render",
                value: function(t) {
                    var e = (!(0 < arguments.length && void 0 !== t) || t) && this._renderMethod || "render";
                    delete this._renderMethod, this.currentView[e]()
                }
            }]) && a(t.prototype, e), i && a(t, i), m
        }();
        i.default = h
    }, {
        "../events/functions.js": 7,
        "../events/pickerListeners.js": 10,
        "../lib/date.js": 13,
        "../lib/dom.js": 14,
        "../lib/event.js": 15,
        "../lib/utils.js": 16,
        "./templates/pickerTemplate.js": 22,
        "./views/DaysView.js": 23,
        "./views/MonthsView.js": 24,
        "./views/YearsView.js": 26
    }],
    20: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = void 0;
        var n = t("../../lib/utils.js"),
            r = (0, n.optimizeTemplateHTML)('<div class="calendar-weeks">\n  <div class="days-of-week"><span class="dow"></span></div>\n  <div class="weeks">'.concat((0, n.createTagRepeat)("span", 6, {
                class: "week"
            }), "</div>\n</div>"));
        i.default = r
    }, {
        "../../lib/utils.js": 16
    }],
    21: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = void 0;
        var n = t("../../lib/utils.js"),
            r = (0, n.optimizeTemplateHTML)('<div class="days">\n  <div class="days-of-week">'.concat((0, n.createTagRepeat)("span", 7, {
                class: "dow"
            }), '</div>\n  <div class="datepicker-grid">').concat((0, n.createTagRepeat)("span", 42), "</div>\n</div>"));
        i.default = r
    }, {
        "../../lib/utils.js": 16
    }],
    22: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        });
        var n = (i.default = void 0, t("../../lib/utils.js").optimizeTemplateHTML)('<div class="datepicker">\n  <div class="datepicker-picker">\n    <div class="datepicker-header">\n      <div class="datepicker-title"></div>\n      <div class="datepicker-controls">\n        <button type="button" class="%buttonClass% prev-btn"></button>\n        <button type="button" class="%buttonClass% view-switch"></button>\n        <button type="button" class="%buttonClass% next-btn"></button>\n      </div>\n    </div>\n    <div class="datepicker-main"></div>\n    <div class="datepicker-footer">\n      <div class="datepicker-controls">\n        <button type="button" class="%buttonClass% today-btn"></button>\n        <button type="button" class="%buttonClass% clear-btn"></button>\n      </div>\n    </div>\n  </div>\n</div>');
        i.default = n
    }, {
        "../../lib/utils.js": 16
    }],
    23: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = void 0;
        var u = t("../../lib/utils.js"),
            c = t("../../lib/date.js"),
            a = t("../../lib/date-format.js"),
            s = t("../../lib/dom.js"),
            o = n(t("../templates/daysTemplate.js")),
            l = n(t("../templates/calendarWeeksTemplate.js")),
            h = n(t("./View.js"));

        function n(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }

        function p(t) {
            return (p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function d(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t
            }(t) || function(t, e) {
                if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t))) return;
                var i = [],
                    n = !0,
                    r = !1,
                    a = void 0;
                try {
                    for (var s, o = t[Symbol.iterator](); !(n = (s = o.next()).done) && (i.push(s.value), !e || i.length !== e); n = !0);
                } catch (t) {
                    r = !0, a = t
                } finally {
                    try {
                        n || null == o.return || o.return()
                    } finally {
                        if (r) throw a
                    }
                }
                return i
            }(t, e) || r(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function f(t) {
            return function(t) {
                if (Array.isArray(t)) return m(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || r(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function r(t, e) {
            if (t) {
                if ("string" == typeof t) return m(t, e);
                var i = Object.prototype.toString.call(t).slice(8, -1);
                return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? m(t, e) : void 0
            }
        }

        function m(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }

        function g(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        function v(t, e, i) {
            return (v = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, i) {
                var n = function(t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = x(t)););
                    return t
                }(t, e);
                if (n) {
                    var r = Object.getOwnPropertyDescriptor(n, e);
                    return r.get ? r.get.call(i) : r.value
                }
            })(t, e, i || t)
        }

        function y(t, e) {
            return (y = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function b(a) {
            var s = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var t, e, i, n, r = x(a);
                return e = s ? (t = x(this).constructor, Reflect.construct(r, arguments, t)) : r.apply(this, arguments), i = this, !(n = e) || "object" !== p(n) && "function" != typeof n ? function(t) {
                    if (void 0 !== t) return t;
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
                }(i) : n
            }
        }

        function x(t) {
            return (x = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }
        var _ = function() {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && y(t, e)
            }(r, h.default);
            var t, e, i, n = b(r);

            function r(t) {
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, r), n.call(this, t, {
                    id: 0,
                    name: "days",
                    cellClass: "day"
                })
            }
            return t = r, (e = [{
                key: "init",
                value: function(t, e) {
                    var i;
                    1 < arguments.length && void 0 !== e && !e || (i = (0, s.parseHTML)(o.default).firstChild, this.dow = i.firstChild, this.grid = i.lastChild, this.element.appendChild(i)), v(x(r.prototype), "init", this).call(this, t)
                }
            }, {
                key: "setOptions",
                value: function(t) {
                    var e, i, n, r = this;
                    (0, u.hasProperty)(t, "minDate") && (this.minDate = t.minDate), (0, u.hasProperty)(t, "maxDate") && (this.maxDate = t.maxDate), t.datesDisabled && (this.datesDisabled = t.datesDisabled), t.daysOfWeekDisabled && (this.daysOfWeekDisabled = t.daysOfWeekDisabled, e = !0), t.daysOfWeekHighlighted && (this.daysOfWeekHighlighted = t.daysOfWeekHighlighted), void 0 !== t.todayHighlight && (this.todayHighlight = t.todayHighlight), void 0 !== t.weekStart && (this.weekStart = t.weekStart, this.weekEnd = t.weekEnd, e = !0), t.locale && (i = this.locale = t.locale, this.dayNames = i.daysMin, this.switchLabelFormat = i.titleFormat, e = !0), void 0 !== t.beforeShowDay && (this.beforeShow = "function" == typeof t.beforeShowDay ? t.beforeShowDay : void 0), void 0 !== t.calendarWeeks && (t.calendarWeeks && !this.calendarWeeks ? (n = (0, s.parseHTML)(l.default).firstChild, this.calendarWeeks = {
                        element: n,
                        dow: n.firstChild,
                        weeks: n.lastChild
                    }, this.element.insertBefore(n, this.element.firstChild)) : this.calendarWeeks && !t.calendarWeeks && (this.element.removeChild(this.calendarWeeks.element), this.calendarWeeks = null)), void 0 !== t.showDaysOfWeek && (t.showDaysOfWeek ? ((0, s.showElement)(this.dow), this.calendarWeeks && (0, s.showElement)(this.calendarWeeks.dow)) : ((0, s.hideElement)(this.dow), this.calendarWeeks && (0, s.hideElement)(this.calendarWeeks.dow))), e && Array.from(this.dow.children).forEach(function(t, e) {
                        var i = (r.weekStart + e) % 7;
                        t.textContent = r.dayNames[i], t.className = r.daysOfWeekDisabled.includes(i) ? "dow disabled" : "dow"
                    })
                }
            }, {
                key: "updateFocus",
                value: function() {
                    var t = new Date(this.picker.viewDate),
                        e = t.getFullYear(),
                        i = t.getMonth(),
                        n = (0, c.dateValue)(e, i, 1),
                        r = (0, c.dayOfTheWeekOf)(n, this.weekStart, this.weekStart);
                    this.first = n, this.last = (0, c.dateValue)(e, i + 1, 0), this.start = r, this.focused = this.picker.viewDate
                }
            }, {
                key: "updateSelection",
                value: function() {
                    var t = this.picker.datepicker,
                        e = t.dates,
                        i = t.rangepicker;
                    this.selected = e, i && (this.range = i.dates)
                }
            }, {
                key: "render",
                value: function() {
                    var h = this;
                    this.today = this.todayHighlight ? (0, c.today)() : void 0, this.disabled = f(this.datesDisabled);
                    var i, t = (0, a.formatDate)(this.focused, this.switchLabelFormat, this.locale);
                    this.picker.setViewSwitchLabel(t), this.picker.setPrevBtnDisabled(this.first <= this.minDate), this.picker.setNextBtnDisabled(this.last >= this.maxDate), this.calendarWeeks && (i = (0, c.dayOfTheWeekOf)(this.first, 1, 1), Array.from(this.calendarWeeks.weeks.children).forEach(function(t, e) {
                        t.textContent = (0, c.getWeek)((0, c.addWeeks)(i, e))
                    })), Array.from(this.grid.children).forEach(function(t, e) {
                        var i, n, r, a = t.classList,
                            s = (0, c.addDays)(h.start, e),
                            o = new Date(s),
                            l = o.getDay();
                        t.className = "datepicker-cell ".concat(h.cellClass), t.dataset.date = s, t.textContent = o.getDate(), s < h.first ? a.add("prev") : s > h.last && a.add("next"), h.today === s && a.add("today"), (s < h.minDate || s > h.maxDate || h.disabled.includes(s)) && a.add("disabled"), h.daysOfWeekDisabled.includes(l) && (a.add("disabled"), (0, u.pushUnique)(h.disabled, s)), h.daysOfWeekHighlighted.includes(l) && a.add("highlighted"), h.range && (n = (i = d(h.range, 2))[0], r = i[1], n < s && s < r && a.add("range"), s === n && a.add("range-start"), s === r && a.add("range-end")), h.selected.includes(s) && a.add("selected"), s === h.focused && a.add("focused"), h.beforeShow && h.performBeforeHook(t, s, s)
                    })
                }
            }, {
                key: "refresh",
                value: function() {
                    var n = this,
                        t = d(this.range || [], 2),
                        r = t[0],
                        a = t[1];
                    this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(t) {
                        t.classList.remove("range", "range-start", "range-end", "selected", "focused")
                    }), Array.from(this.grid.children).forEach(function(t) {
                        var e = Number(t.dataset.date),
                            i = t.classList;
                        r < e && e < a && i.add("range"), e === r && i.add("range-start"), e === a && i.add("range-end"), n.selected.includes(e) && i.add("selected"), e === n.focused && i.add("focused")
                    })
                }
            }, {
                key: "refreshFocus",
                value: function() {
                    var t = Math.round((this.focused - this.start) / 864e5);
                    this.grid.querySelectorAll(".focused").forEach(function(t) {
                        t.classList.remove("focused")
                    }), this.grid.children[t].classList.add("focused")
                }
            }]) && g(t.prototype, e), i && g(t, i), r
        }();
        i.default = _
    }, {
        "../../lib/date-format.js": 12,
        "../../lib/date.js": 13,
        "../../lib/dom.js": 14,
        "../../lib/utils.js": 16,
        "../templates/calendarWeeksTemplate.js": 20,
        "../templates/daysTemplate.js": 21,
        "./View.js": 25
    }],
    24: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = void 0;
        var n, a = t("../../lib/utils.js"),
            d = t("../../lib/date.js"),
            s = t("../../lib/dom.js"),
            o = (n = t("./View.js")) && n.__esModule ? n : {
                default: n
            };

        function l(t) {
            return (l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function h(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        function u(t, e, i) {
            return (u = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, i) {
                var n = function(t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t)););
                    return t
                }(t, e);
                if (n) {
                    var r = Object.getOwnPropertyDescriptor(n, e);
                    return r.get ? r.get.call(i) : r.value
                }
            })(t, e, i || t)
        }

        function c(t, e) {
            return (c = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function p(a) {
            var s = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var t, e, i, n, r = f(a);
                return e = s ? (t = f(this).constructor, Reflect.construct(r, arguments, t)) : r.apply(this, arguments), i = this, !(n = e) || "object" !== l(n) && "function" != typeof n ? function(t) {
                    if (void 0 !== t) return t;
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
                }(i) : n
            }
        }

        function f(t) {
            return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }

        function m(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t
            }(t) || function(t, e) {
                if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t))) return;
                var i = [],
                    n = !0,
                    r = !1,
                    a = void 0;
                try {
                    for (var s, o = t[Symbol.iterator](); !(n = (s = o.next()).done) && (i.push(s.value), !e || i.length !== e); n = !0);
                } catch (t) {
                    r = !0, a = t
                } finally {
                    try {
                        n || null == o.return || o.return()
                    } finally {
                        if (r) throw a
                    }
                }
                return i
            }(t, e) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return r(t, e);
                var i = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === i && t.constructor && (i = t.constructor.name);
                if ("Map" === i || "Set" === i) return Array.from(t);
                if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return r(t, e)
            }(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function r(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }

        function g(t, e) {
            if (t && t[0] && t[1]) {
                var i = m(t, 2),
                    n = m(i[0], 2),
                    r = n[0],
                    a = n[1],
                    s = m(i[1], 2),
                    o = s[0],
                    l = s[1];
                if (!(e < r || o < e)) return [r === e ? a : -1, o === e ? l : 12]
            }
        }
        var v = function() {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && c(t, e)
            }(r, o.default);
            var t, e, i, n = p(r);

            function r(t) {
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, r), n.call(this, t, {
                    id: 1,
                    name: "months",
                    cellClass: "month"
                })
            }
            return t = r, (e = [{
                key: "init",
                value: function(t, e) {
                    1 < arguments.length && void 0 !== e && !e || (this.grid = this.element, this.element.classList.add("months", "datepicker-grid"), this.grid.appendChild((0, s.parseHTML)((0, a.createTagRepeat)("span", 12, {
                        "data-month": function(t) {
                            return t
                        }
                    })))), u(f(r.prototype), "init", this).call(this, t)
                }
            }, {
                key: "setOptions",
                value: function(t) {
                    var e, i;
                    t.locale && (this.monthNames = t.locale.monthsShort), (0, a.hasProperty)(t, "minDate") && (void 0 === t.minDate ? this.minYear = this.minMonth = this.minDate = void 0 : (e = new Date(t.minDate), this.minYear = e.getFullYear(), this.minMonth = e.getMonth(), this.minDate = e.setDate(1))), (0, a.hasProperty)(t, "maxDate") && (void 0 === t.maxDate ? this.maxYear = this.maxMonth = this.maxDate = void 0 : (i = new Date(t.maxDate), this.maxYear = i.getFullYear(), this.maxMonth = i.getMonth(), this.maxDate = (0, d.dateValue)(this.maxYear, this.maxMonth + 1, 0))), void 0 !== t.beforeShowMonth && (this.beforeShow = "function" == typeof t.beforeShowMonth ? t.beforeShowMonth : void 0)
                }
            }, {
                key: "updateFocus",
                value: function() {
                    var t = new Date(this.picker.viewDate);
                    this.year = t.getFullYear(), this.focused = t.getMonth()
                }
            }, {
                key: "updateSelection",
                value: function() {
                    var t = this.picker.datepicker,
                        e = t.dates,
                        i = t.rangepicker;
                    this.selected = e.reduce(function(t, e) {
                        var i = new Date(e),
                            n = i.getFullYear(),
                            r = i.getMonth();
                        return void 0 === t[n] ? t[n] = [r] : (0, a.pushUnique)(t[n], r), t
                    }, {}), i && i.dates && (this.range = i.dates.map(function(t) {
                        var e = new Date(t);
                        return isNaN(e) ? void 0 : [e.getFullYear(), e.getMonth()]
                    }))
                }
            }, {
                key: "render",
                value: function() {
                    var o = this;
                    this.disabled = [], this.picker.setViewSwitchLabel(this.year), this.picker.setPrevBtnDisabled(this.year <= this.minYear), this.picker.setNextBtnDisabled(this.year >= this.maxYear);
                    var l = this.selected[this.year] || [],
                        h = this.year < this.minYear || this.year > this.maxYear,
                        u = this.year === this.minYear,
                        c = this.year === this.maxYear,
                        p = g(this.range, this.year);
                    Array.from(this.grid.children).forEach(function(t, e) {
                        var i, n, r, a = t.classList,
                            s = (0, d.dateValue)(o.year, e, 1);
                        t.className = "datepicker-cell ".concat(o.cellClass), o.isMinView && (t.dataset.date = s), t.textContent = o.monthNames[e], (h || u && e < o.minMonth || c && e > o.maxMonth) && a.add("disabled"), p && (n = (i = m(p, 2))[0], r = i[1], n < e && e < r && a.add("range"), e === n && a.add("range-start"), e === r && a.add("range-end")), l.includes(e) && a.add("selected"), e === o.focused && a.add("focused"), o.beforeShow && o.performBeforeHook(t, e, s)
                    })
                }
            }, {
                key: "refresh",
                value: function() {
                    var n = this,
                        r = this.selected[this.year] || [],
                        t = m(g(this.range, this.year) || [], 2),
                        a = t[0],
                        s = t[1];
                    this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(t) {
                        t.classList.remove("range", "range-start", "range-end", "selected", "focused")
                    }), Array.from(this.grid.children).forEach(function(t, e) {
                        var i = t.classList;
                        a < e && e < s && i.add("range"), e === a && i.add("range-start"), e === s && i.add("range-end"), r.includes(e) && i.add("selected"), e === n.focused && i.add("focused")
                    })
                }
            }, {
                key: "refreshFocus",
                value: function() {
                    this.grid.querySelectorAll(".focused").forEach(function(t) {
                        t.classList.remove("focused")
                    }), this.grid.children[this.focused].classList.add("focused")
                }
            }]) && h(t.prototype, e), i && h(t, i), r
        }();
        i.default = v
    }, {
        "../../lib/date.js": 13,
        "../../lib/dom.js": 14,
        "../../lib/utils.js": 16,
        "./View.js": 25
    }],
    25: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = void 0;
        var s = t("../../lib/utils.js"),
            o = t("../../lib/dom.js");

        function l(t) {
            return function(t) {
                if (Array.isArray(t)) return n(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || function(t, e) {
                if (!t) return;
                if ("string" == typeof t) return n(t, e);
                var i = Object.prototype.toString.call(t).slice(8, -1);
                "Object" === i && t.constructor && (i = t.constructor.name);
                if ("Map" === i || "Set" === i) return Array.from(t);
                if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return n(t, e)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function n(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }

        function h(t) {
            return (h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function r(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }
        var a = function() {
            function i(t, e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, i), Object.assign(this, e, {
                    picker: t,
                    element: (0, o.parseHTML)('<div class="datepicker-view"></div>').firstChild,
                    selected: []
                }), this.init(this.picker.datepicker.config)
            }
            var t, e, n;
            return t = i, (e = [{
                key: "init",
                value: function(t) {
                    void 0 !== t.pickLevel && (this.isMinView = this.id === t.pickLevel), this.setOptions(t), this.updateFocus(), this.updateSelection()
                }
            }, {
                key: "performBeforeHook",
                value: function(t, e, i) {
                    var n, r, a = this.beforeShow(new Date(i));
                    switch (h(a)) {
                        case "boolean":
                            a = {
                                enabled: a
                            };
                            break;
                        case "string":
                            a = {
                                classes: a
                            }
                    }
                    a && (!1 === a.enabled && (t.classList.add("disabled"), (0, s.pushUnique)(this.disabled, e)), a.classes && (r = a.classes.split(/\s+/), (n = t.classList).add.apply(n, l(r)), r.includes("disabled") && (0, s.pushUnique)(this.disabled, e)), a.content && (0, o.replaceChildNodes)(t, a.content))
                }
            }]) && r(t.prototype, e), n && r(t, n), i
        }();
        i.default = a
    }, {
        "../../lib/dom.js": 14,
        "../../lib/utils.js": 16
    }],
    26: [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = void 0;
        var n, a = t("../../lib/utils.js"),
            h = t("../../lib/date.js"),
            s = t("../../lib/dom.js"),
            o = (n = t("./View.js")) && n.__esModule ? n : {
                default: n
            };

        function l(t) {
            return (l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function u(t, e) {
            return function(t) {
                if (Array.isArray(t)) return t
            }(t) || function(t, e) {
                if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t))) return;
                var i = [],
                    n = !0,
                    r = !1,
                    a = void 0;
                try {
                    for (var s, o = t[Symbol.iterator](); !(n = (s = o.next()).done) && (i.push(s.value), !e || i.length !== e); n = !0);
                } catch (t) {
                    r = !0, a = t
                } finally {
                    try {
                        n || null == o.return || o.return()
                    } finally {
                        if (r) throw a
                    }
                }
                return i
            }(t, e) || r(t, e) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function c(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        function p(t, e, i) {
            return (p = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, i) {
                var n = function(t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = m(t)););
                    return t
                }(t, e);
                if (n) {
                    var r = Object.getOwnPropertyDescriptor(n, e);
                    return r.get ? r.get.call(i) : r.value
                }
            })(t, e, i || t)
        }

        function d(t, e) {
            return (d = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function f(a) {
            var s = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var t, e, i, n, r = m(a);
                return e = s ? (t = m(this).constructor, Reflect.construct(r, arguments, t)) : r.apply(this, arguments), i = this, !(n = e) || "object" !== l(n) && "function" != typeof n ? function(t) {
                    if (void 0 !== t) return t;
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
                }(i) : n
            }
        }

        function m(t) {
            return (m = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }

        function g(t) {
            return function(t) {
                if (Array.isArray(t)) return v(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
            }(t) || r(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function r(t, e) {
            if (t) {
                if ("string" == typeof t) return v(t, e);
                var i = Object.prototype.toString.call(t).slice(8, -1);
                return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? v(t, e) : void 0
            }
        }

        function v(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }
        var y = function() {
            ! function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && d(t, e)
            }(r, o.default);
            var t, e, i, n = f(r);

            function r(t, e) {
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, r), n.call(this, t, e)
            }
            return t = r, (e = [{
                key: "init",
                value: function(t, e) {
                    1 < arguments.length && void 0 !== e && !e || (this.navStep = 10 * this.step, this.beforeShowOption = "beforeShow".concat(g(this.cellClass).reduce(function(t, e, i) {
                        return t + (i ? e : e.toUpperCase())
                    }, "")), this.grid = this.element, this.element.classList.add(this.name, "datepicker-grid"), this.grid.appendChild((0, s.parseHTML)((0, a.createTagRepeat)("span", 12)))), p(m(r.prototype), "init", this).call(this, t)
                }
            }, {
                key: "setOptions",
                value: function(t) {
                    var e;
                    (0, a.hasProperty)(t, "minDate") && (void 0 === t.minDate ? this.minYear = this.minDate = void 0 : (this.minYear = (0, h.startOfYearPeriod)(t.minDate, this.step), this.minDate = (0, h.dateValue)(this.minYear, 0, 1))), (0, a.hasProperty)(t, "maxDate") && (void 0 === t.maxDate ? this.maxYear = this.maxDate = void 0 : (this.maxYear = (0, h.startOfYearPeriod)(t.maxDate, this.step), this.maxDate = (0, h.dateValue)(this.maxYear, 11, 31))), void 0 !== t[this.beforeShowOption] && (e = t[this.beforeShowOption], this.beforeShow = "function" == typeof e ? e : void 0)
                }
            }, {
                key: "updateFocus",
                value: function() {
                    var t = new Date(this.picker.viewDate),
                        e = (0, h.startOfYearPeriod)(t, this.navStep),
                        i = e + 9 * this.step;
                    this.first = e, this.last = i, this.start = e - this.step, this.focused = (0, h.startOfYearPeriod)(t, this.step)
                }
            }, {
                key: "updateSelection",
                value: function() {
                    var i = this,
                        t = this.picker.datepicker,
                        e = t.dates,
                        n = t.rangepicker;
                    this.selected = e.reduce(function(t, e) {
                        return (0, a.pushUnique)(t, (0, h.startOfYearPeriod)(e, i.step))
                    }, []), n && n.dates && (this.range = n.dates.map(function(t) {
                        if (void 0 !== t) return (0, h.startOfYearPeriod)(t, i.step)
                    }))
                }
            }, {
                key: "render",
                value: function() {
                    var l = this;
                    this.disabled = [], this.picker.setViewSwitchLabel("".concat(this.first, "-").concat(this.last)), this.picker.setPrevBtnDisabled(this.first <= this.minYear), this.picker.setNextBtnDisabled(this.last >= this.maxYear), Array.from(this.grid.children).forEach(function(t, e) {
                        var i, n, r, a = t.classList,
                            s = l.start + e * l.step,
                            o = (0, h.dateValue)(s, 0, 1);
                        t.className = "datepicker-cell ".concat(l.cellClass), l.isMinView && (t.dataset.date = o), t.textContent = t.dataset.year = s, 0 === e ? a.add("prev") : 11 === e && a.add("next"), (s < l.minYear || s > l.maxYear) && a.add("disabled"), l.range && (n = (i = u(l.range, 2))[0], r = i[1], n < s && s < r && a.add("range"), s === n && a.add("range-start"), s === r && a.add("range-end")), l.selected.includes(s) && a.add("selected"), s === l.focused && a.add("focused"), l.beforeShow && l.performBeforeHook(t, s, o)
                    })
                }
            }, {
                key: "refresh",
                value: function() {
                    var n = this,
                        t = u(this.range || [], 2),
                        r = t[0],
                        a = t[1];
                    this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(t) {
                        t.classList.remove("range", "range-start", "range-end", "selected", "focused")
                    }), Array.from(this.grid.children).forEach(function(t) {
                        var e = Number(t.textContent),
                            i = t.classList;
                        r < e && e < a && i.add("range"), e === r && i.add("range-start"), e === a && i.add("range-end"), n.selected.includes(e) && i.add("selected"), e === n.focused && i.add("focused")
                    })
                }
            }, {
                key: "refreshFocus",
                value: function() {
                    var t = Math.round((this.focused - this.start) / this.step);
                    this.grid.querySelectorAll(".focused").forEach(function(t) {
                        t.classList.remove("focused")
                    }), this.grid.children[t].classList.add("focused")
                }
            }]) && c(t.prototype, e), i && c(t, i), r
        }();
        i.default = y
    }, {
        "../../lib/date.js": 13,
        "../../lib/dom.js": 14,
        "../../lib/utils.js": 16,
        "./View.js": 25
    }],
    add2calendar: [function(t, e, i) {
        "use strict";
        void 0 !== e && null != e.exports && (e.exports = function(t) {
            this.hasClass = function(t, e) {
                return -1 < (" " + t.className + " ").indexOf(" " + e + " ")
            }, this.mergeObj = function(t, e) {
                var i = {};
                for (var n in t) i[n] = t[n];
                for (var r in e) i[r] = e[r];
                return i
            }, this.pad = function(t, e) {
                for (var i = t.toString(); i.length < e;) i = "0" + i;
                return i
            }, this.formatTime = function(t) {
                return t.toISOString().replace(/-|:|\.\d+/g, "")
            }, this.formatTime2 = function(t) {
                return this.pad(t.getFullYear(), 4) + this.pad(t.getMonth() + 1, 2) + this.pad(t.getDate(), 2)
            }, this.isValidEventData = function(t) {
                return !!this.isSingleEvent || 0 < t.length
            }, this.isObjectType = function(t, e) {
                return Object.prototype.toString.call(t) === "[object " + e + "]"
            }, this.isDateObject = function(t) {
                return this.isObjectType(t, "Date")
            }, this.isArray = function(t) {
                return this.isObjectType(t, "Array")
            }, this.isFunc = function(t) {
                return this.isObjectType(t, "Function")
            }, this.serialize = function(t) {
                var e = [];
                for (var i in t) t.hasOwnProperty(i) && e.push(encodeURIComponent(i) + "=" + encodeURIComponent(t[i]));
                return e.join("&")
            }, this.replaceSpecialCharacterAndSpaceWithHyphen = function(t) {
                return t.replace(/([~!@#$%^&*()_+=`{}\[\]\|\\:;'<>,.\/? ])+/g, "-").replace(/^(-)+|(-)+$/g, "")
            }, this.getLinkHtml = function(t, e, i, n, r) {
                void 0 === n && (n = !1), void 0 === r && (r = this.getCurrentUtcTimestamp());
                var a = "";
                return n && (a = ' download="' + ("add2Calendar-" + this.replaceSpecialCharacterAndSpaceWithHyphen(t).toLowerCase() + "-" + r) + '" '), "<a " + a + ' class="' + i + '" target="_blank" href="' + e + '">' + t + "</a>"
            }, this.getLiHtml = function(t, e, i, n, r) {
                var a = "",
                    s = !1;
                return e && ("ical" === i || "outlook" === i || e.length <= 2e4) && (s = !0), s && (a = '<li class="a2cldr-item a2cldr-' + i + '">' + this.getLinkHtml(t, e, "icon-" + i, n, r) + "</li>"), a
            }, this.getCurrentUtcTimestamp = function() {
                return Date.now()
            }, this.updateGoogleUrl = function() {
                var t, e, i;
                return this.isSingleEvent && (t = this.eventData.isAllDay ? this.formatTime2(new Date(this.eventData.start)) : this.formatTime(new Date(this.eventData.start)), e = this.eventData.isAllDay ? this.formatTime2(new Date(this.eventData.end)) : this.formatTime(new Date(this.eventData.end)), i = {
                    text: this.eventData.title || "",
                    dates: t + "/" + e,
                    location: this.eventData.location || "",
                    details: this.eventData.description || "",
                    ctz: this.eventData.timezone || "",
                    locale: this.eventData.locale || "",
                    sprop: ""
                }, this.googleUrl = "https://www.google.com/calendar/render?action=TEMPLATE&" + this.serialize(i)), this.googleUrl
            }, this.getGoogleUrl = function() {
                return this.googleUrl
            }, this.getGoogleLiHtml = function() {
                return this.getLiHtml("Google", this.googleUrl, "google")
            }, this.openGoogle = function() {
                window.open(this.googleUrl)
            }, this.updateICalUrl = function() {
                var t = "undefined" != typeof document ? document.URL : "",
                    e = "",
                    i = "";
                if (this.isSingleEvent) e = this.eventData.isAllDay ? this.formatTime2(new Date(this.eventData.start)) : this.formatTime(new Date(this.eventData.start)), i = this.eventData.isAllDay ? this.formatTime2(new Date(this.eventData.end)) : this.formatTime(new Date(this.eventData.end)), this.iCalUrl = encodeURI("data:text/calendar;charset=utf8," + ["BEGIN:VCALENDAR", "VERSION:2.0", "BEGIN:VEVENT", "URL:" + t, "DTSTART:" + e, "DTEND:" + i, "SUMMARY:" + (this.eventData.title || ""), "DESCRIPTION:" + (this.eventData.description || ""), "LOCATION:" + (this.eventData.location || ""), "END:VEVENT", "END:VCALENDAR"].join("\n"));
                else {
                    for (var n = 0, r = this.eventData.length, a = [], n = 0; n < r; n++) var s = this.eventData[n],
                        o = ["BEGIN:VEVENT", "URL:" + t, "DTSTART:" + (e = this.eventData.isAllDay ? this.formatTime2(new Date(s.start)) : this.formatTime(new Date(s.start))), "DTEND:" + (i = this.eventData.isAllDay ? this.formatTime2(new Date(s.end)) : this.formatTime(new Date(s.end))), "SUMMARY:" + (s.title || ""), "DESCRIPTION:" + (s.description || ""), "LOCATION:" + (s.location || ""), "END:VEVENT"],
                        a = a.concat(o);
                    a = ["BEGIN:VCALENDAR", "VERSION:2.0"].concat(a, ["END:VCALENDAR"]).join("\n"), this.iCalUrl = encodeURI("data:text/calendar;charset=utf8," + a)
                }
                return this.iCalUrl = this.iCalUrl.replace(/#/g, "%23"), this.iCalUrl
            }, this.getICalUrl = function() {
                return this.iCalUrl
            }, this.getICalLiHtml = function() {
                return this.getLiHtml("iCal", this.iCalUrl, "ical", !0)
            }, this.openICal = function() {
                window.open(this.iCalUrl)
            }, this.getOutlookUrl = function() {
                return this.iCalUrl
            }, this.getOutlookLiHtml = function() {
                return this.getLiHtml("Outlook", this.iCalUrl, "outlook", !0)
            }, this.openOutlook = function() {
                window.open(this.iCalUrl)
            }, this.updateOutlookOnlineUrl = function() {
                var t, e, i, n, r;
                return this.isSingleEvent && (t = new Date(this.eventData.start), e = new Date(this.eventData.end), i = t.getTimezoneOffset(), t.setMinutes(t.getMinutes() - 2 * i), n = e.getTimezoneOffset(), e.setMinutes(e.getMinutes() - n), t = this.formatTime(t).slice(0, -1), e = this.formatTime(e).slice(0, -1), r = {
                    summary: this.eventData.title || "",
                    dtstart: t,
                    dtend: e,
                    location: this.eventData.location || "",
                    description: this.eventData.description || ""
                }, this.outlookOnlineUrl = "http://calendar.live.com/calendar/calendar.aspx?rru=addevent&" + this.serialize(r)), this.outlookOnlineUrl
            }, this.getOutlookOnlineUrl = function() {
                return this.outlookOnlineUrl
            }, this.getOutlookOnlineLiHtml = function() {
                return this.getLiHtml("Outlook Online", this.outlookOnlineUrl, "outlook-online")
            }, this.openOutlookOnline = function() {
                window.open(this.outlookOnlineUrl)
            }, this.updateYahooUrl = function() {
                var t, e, i, n, r;
                return this.isSingleEvent && (t = this.eventData.isAllDay ? this.formatTime2(new Date(this.eventData.start)) : this.formatTime(new Date(this.eventData.start)), i = (e = new Date(this.eventData.end)).getTimezoneOffset(), e.setMinutes(e.getMinutes() - i), n = this.eventData.isAllDay ? this.formatTime2(e) : this.formatTime(e), r = {
                    view: "d",
                    type: "20",
                    title: this.eventData.title || "",
                    st: t,
                    et: n,
                    in_loc: this.eventData.location || "",
                    desc: this.eventData.description || ""
                }, this.yahooUrl = "https://calendar.yahoo.com/?v=60&" + this.serialize(r)), this.yahooUrl
            }, this.getYahooUrl = function() {
                return this.yahooUrl
            }, this.getYahooLiHtml = function() {
                return this.getLiHtml("Yahoo!", this.yahooUrl, "yahoo")
            }, this.openYahoo = function() {
                window.open(this.yahooUrl)
            }, this.getEventListHtml = function() {
                var t = '<ul class="a2cldr-list">';
                return t += this.getEventListItemsHtml(), t += "</ul>"
            }, this.getEventListItemsHtml = function() {
                var t = "";
                return t += this.getGoogleLiHtml(), t += this.getICalLiHtml(), t += this.getOutlookLiHtml(), t += this.getOutlookOnlineLiHtml(), t += this.getYahooLiHtml()
            }, this.getEventNotFoundListHtml = function() {
                var t = '<ul class="a2cldr-list">';
                return t += this.getEventNotFoundListItemsHtml(), t += "</ul>"
            }, this.getEventNotFoundListItemsHtml = function() {
                return '<li class="a2cldr-item a2cldr-not-found"><span class="not-found" href="javascript:;">Not Found</span></li>'
            }, this.getWidgetNode = function() {
                var t = '<button class="a2cldr-btn" type="button">';
                t += this.getWidgetBtnText(), t += "</button>", t += this.getEventListHtml();
                var e = document.createElement("div");
                return e.innerHTML = t, e.className = this.textDomain, e
            }, this.getWidgetBtnText = function() {
                return this.option.buttonText ? this.option.buttonText : this.add2calendarBtnTextMap[this.option.lang]
            }, this.createWidget = function(t, e) {
                this.selector = t, this.eWidget = document.querySelector(t);
                var i = this.getWidgetNode();
                this.eWidget.appendChild(i), this.eButton = document.querySelector(t + " > .a2cldr > .a2cldr-btn"), this.bindClickEvent(), this.isFunc(e) && e()
            }, this.bindClickEvent = function() {
                var e = "active",
                    i = this,
                    n = this.eButton;
                n.onclick = function() {
                    var t = n.parentNode;
                    i.hasClass(t, e) ? t.classList.remove(e) : t.classList.add(e)
                }
            }, this.unBindClickEvent = function() {
                this.eButton && this.eButton.onclick && (this.eButton.onclick = null)
            }, this.setOption = function(t) {
                this.userOption = t, this.option = this.mergeObj(this.defaultOption, this.userOption)
            }, this.resetOption = function() {
                this.option = this.defaultOption
            }, this.update = function(t) {
                this.init(t)
            }, this.updateWidget = function(t, e) {
                this.update(t), document.querySelector(this.selector + " .a2cldr-list").innerHTML = this.getEventListItemsHtml(), this.isFunc(e) && e()
            }, this.textDomain = "a2cldr", this.add2calendarBtnTextMap = {
                en: "Add to Calendar",
                th: "เพิ่มเข้าปฏิทิน",
                jp: "カレンダーに追加",
                kr: "캘린더에 추가",
                ja: "カレンダーに追加",
                cn: "添加到日历",
                de: "In den Kalender",
                es: "Añadir al Calendario",
                fr: "Ajouter au calendrier",
                ru: "Добавить в календарь"
            }, this.isSingleEvent, this.eventData, this.selector, this.eWidget, this.defaultOption, this.userOption, this.option, this.googleUrl, this.iCalUrl, this.yahooUrl, this.outlookOnlineUrl, this.updateAllCalendars = function() {
                this.updateGoogleUrl(), this.updateICalUrl(), this.updateYahooUrl()
            }, this.init = function(t) {
                if (this.isSingleEvent = !this.isArray(t), !this.isValidEventData(t)) return !1;
                this.eventData = t, this.selector = "", this.eWidget = null, this.eButton = null, this.defaultOption = {
                    lang: "en",
                    buttonText: ""
                }, this.option = this.defaultOption, this.googleUrl = "", this.iCalUrl = "", this.yahooUrl = "", this.outlookOnlineUrl = "", this.updateAllCalendars()
            }, this.init(t)
        })
    }, {}],
    "gsap/CSSPlugin": [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.checkPrefix = i._createElement = i._getBBox = i.default = i.CSSPlugin = void 0;
        var R = t("./gsap-core.js");

        function z(t) {
            return (z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function G(t, e) {
            return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        }

        function V(t, e) {
            return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        }

        function U(t, e) {
            return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
        }

        function j(t, e) {
            var i = e.s + e.c * t;
            e.set(e.t, e.p, ~~(i + (i < 0 ? -.5 : .5)) + e.u, e)
        }

        function _(t, e) {
            return e.set(e.t, e.p, t ? e.e : e.b, e)
        }

        function w(t, e) {
            return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
        }

        function r(t, e, i) {
            return t.style[e] = i
        }

        function a(t, e, i) {
            return t.style.setProperty(e, i)
        }

        function s(t, e, i) {
            return t._gsap[e] = i
        }

        function o(t, e, i) {
            return t._gsap.scaleX = t._gsap.scaleY = i
        }

        function l(t, e, i, n, r) {
            var a = t._gsap;
            a.scaleX = a.scaleY = i, a.renderTransform(r, a)
        }

        function h(t, e, i, n, r) {
            var a = t._gsap;
            a[e] = i, a.renderTransform(r, a)
        }

        function u(t, e) {
            var i = Q.createElementNS ? Q.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Q.createElement(t);
            return i.style ? i : Q.createElement(t)
        }

        function B(t, e, i) {
            var n = getComputedStyle(t);
            return n[e] || n.getPropertyValue(e.replace(y, "-$1").toLowerCase()) || n.getPropertyValue(e) || !i && B(t, ct(e) || e, 1) || ""
        }

        function H() {
            "undefined" != typeof window && window.document && (m = (Q = window.document).documentElement, g = u("div") || {
                style: {}
            }, et = u("div"), ht = ct(ht), ut = ht + "Origin", g.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", it = !!ct("perspective"), tt = 1)
        }

        function c(t) {
            var e, i = u("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                n = this.parentNode,
                r = this.nextSibling,
                a = this.style.cssText;
            if (m.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                e = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = c
            } catch (t) {} else this._gsapBBox && (e = this._gsapBBox());
            return n && (r ? n.insertBefore(this, r) : n.appendChild(this)), m.removeChild(i), this.style.cssText = a, e
        }

        function n(t, e) {
            for (var i = e.length; i--;)
                if (t.hasAttribute(e[i])) return t.getAttribute(e[i])
        }

        function M(e) {
            var i;
            try {
                i = e.getBBox()
            } catch (t) {
                i = c.call(e, !0)
            }
            return i && (i.width || i.height) || e.getBBox === c || (i = c.call(e, !0)), !i || i.width || i.x || i.y ? i : {
                x: +n(e, ["x", "cx", "x1"]) || 0,
                y: +n(e, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            }
        }

        function W(t) {
            return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !M(t))
        }

        function p(t, e) {
            var i;
            e && (i = t.style, e in nt && e !== ut && (e = ht), i.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), i.removeProperty(e.replace(y, "-$1").toLowerCase())) : i.removeAttribute(e))
        }

        function q(t, e, i, n, r, a) {
            var s = new R.PropTween(t._pt, e, i, 0, 1, a ? w : _);
            return (t._pt = s).b = n, s.e = r, t._props.push(i), s
        }

        function X(t, e, i, n) {
            var r, a, s, o, l = parseFloat(i) || 0,
                h = (i + "").trim().substr((l + "").length) || "px",
                u = g.style,
                c = b.test(e),
                p = "svg" === t.tagName.toLowerCase(),
                d = (p ? "client" : "offset") + (c ? "Width" : "Height"),
                f = "px" === n,
                m = "%" === n;
            return n === h || !l || S[n] || S[h] ? l : ("px" === h || f || (l = X(t, e, i, "px")), o = t.getCTM && W(t), m && (nt[e] || ~e.indexOf("adius")) ? (0, R._round)(l / (o ? t.getBBox()[c ? "width" : "height"] : t[d]) * 100) : (u[c ? "width" : "height"] = 100 + (f ? h : n), a = ~e.indexOf("adius") || "em" === n && t.appendChild && !p ? t : t.parentNode, o && (a = (t.ownerSVGElement || {}).parentNode), a && a !== Q && a.appendChild || (a = Q.body), (s = a._gsap) && m && s.width && c && s.time === R._ticker.time ? (0, R._round)(l / s.width * 100) : (!m && "%" !== h || (u.position = B(t, "position")), a === t && (u.position = "static"), a.appendChild(g), r = g[d], a.removeChild(g), u.position = "absolute", c && m && ((s = (0, R._getCache)(a)).time = R._ticker.time, s.width = a[d]), (0, R._round)(f ? r * l / 100 : r && l ? 100 / r * l : 0))))
        }

        function Y(t, e, i, n) {
            var r;
            return tt || H(), e in lt && "transform" !== e && ~(e = lt[e]).indexOf(",") && (e = e.split(",")[0]), nt[e] && "transform" !== e ? (r = gt(t, n), r = "transformOrigin" !== e ? r[e] : vt(B(t, ut)) + " " + r.zOrigin + "px") : (r = t.style[e]) && "auto" !== r && !n && !~(r + "").indexOf("calc(") || (r = dt[e] && dt[e](t, e, i) || B(t, e) || (0, R._getProperty)(t, e) || ("opacity" === e ? 1 : 0)), i && !~(r + "").indexOf(" ") ? X(t, e, r, i) + i : r
        }

        function J(t, e, i, n) {
            var r, a;
            i && "none" !== i || ((a = (r = ct(e, t, 1)) && B(t, r, 1)) && a !== i ? (e = r, i = a) : "borderColor" === e && (i = B(t, "borderTopColor")));
            var s, o, l, h, u, c, p, d, f, m, g, v, y = new R.PropTween(this._pt, t.style, e, 0, 1, R._renderComplexString),
                b = 0,
                x = 0;
            if (y.b = i, y.e = n, i += "", "auto" === (n += "") && (t.style[e] = n, n = B(t, e) || n, t.style[e] = i), s = [i, n], (0, R._colorStringFilter)(s), n = s[1], l = (i = s[0]).match(R._numWithUnitExp) || [], (n.match(R._numWithUnitExp) || []).length) {
                for (; o = R._numWithUnitExp.exec(n);) p = o[0], f = n.substring(b, o.index), u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1), p !== (c = l[x++] || "") && (h = parseFloat(c) || 0, g = c.substr((h + "").length), (v = "=" === p.charAt(1) ? +(p.charAt(0) + "1") : 0) && (p = p.substr(2)), d = parseFloat(p), m = p.substr((d + "").length), b = R._numWithUnitExp.lastIndex - m.length, m || (m = m || R._config.units[e] || g, b === n.length && (n += m, y.e += m)), g !== m && (h = X(t, e, c, m) || 0), y._pt = {
                    _next: y._pt,
                    p: f || 1 === x ? f : ",",
                    s: h,
                    c: v ? v * d : d - h,
                    m: u && u < 4 ? Math.round : 0
                });
                y.c = b < n.length ? n.substring(b, n.length) : ""
            } else y.r = "display" === e && "none" === n ? w : _;
            return R._relExp.test(n) && (y.e = 0), this._pt = y
        }

        function d(t, e) {
            if (e.tween && e.tween._time === e.tween._dur) {
                var i, n, r, a = e.t,
                    s = a.style,
                    o = e.u,
                    l = a._gsap;
                if ("all" === o || !0 === o) s.cssText = "", n = 1;
                else
                    for (r = (o = o.split(",")).length; - 1 < --r;) i = o[r], nt[i] && (n = 1, i = "transformOrigin" === i ? ut : ht), p(a, i);
                n && (p(a, ht), l && (l.svg && a.removeAttribute("transform"), gt(a, 1), l.uncache = 1))
            }
        }

        function Z(t) {
            return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
        }

        function f(t) {
            var e = B(t, ht);
            return Z(e) ? ft : e.substr(7).match(R._numExp).map(R._round)
        }

        function $(t, e) {
            var i, n, r, a, s = t._gsap || (0, R._getCache)(t),
                o = t.style,
                l = f(t);
            return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? ft : l : (l !== ft || t.offsetParent || t === m || s.svg || (r = o.display, o.display = "block", (i = t.parentNode) && t.offsetParent || (a = 1, n = t.nextSibling, m.appendChild(t)), l = f(t), r ? o.display = r : p(t, "display"), a && (n ? i.insertBefore(t, n) : i ? i.appendChild(t) : m.removeChild(t))), e && 6 < l.length ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
        }

        function K(t, e, i, n, r, a) {
            var s, o, l, h = t._gsap,
                u = r || $(t, !0),
                c = h.xOrigin || 0,
                p = h.yOrigin || 0,
                d = h.xOffset || 0,
                f = h.yOffset || 0,
                m = u[0],
                g = u[1],
                v = u[2],
                y = u[3],
                b = u[4],
                x = u[5],
                _ = e.split(" "),
                w = parseFloat(_[0]) || 0,
                S = parseFloat(_[1]) || 0;
            i ? u !== ft && (o = m * y - g * v) && (l = w * (-g / o) + S * (m / o) - (m * x - g * b) / o, w = w * (y / o) + S * (-v / o) + (v * x - y * b) / o, S = l) : (w = (s = M(t)).x + (~_[0].indexOf("%") ? w / 100 * s.width : w), S = s.y + (~(_[1] || _[0]).indexOf("%") ? S / 100 * s.height : S)), n || !1 !== n && h.smooth ? (b = w - c, x = S - p, h.xOffset = d + (b * m + x * v) - b, h.yOffset = f + (b * g + x * y) - x) : h.xOffset = h.yOffset = 0, h.xOrigin = w, h.yOrigin = S, h.smooth = !!n, h.origin = e, h.originIsAbsolute = !!i, t.style[ut] = "0px 0px", a && (q(a, h, "xOrigin", c, w), q(a, h, "yOrigin", p, S), q(a, h, "xOffset", d, h.xOffset), q(a, h, "yOffset", f, h.yOffset)), t.setAttribute("data-svg-origin", w + " " + S)
        }

        function T(t, e, i) {
            var n = (0, R.getUnit)(e);
            return (0, R._round)(parseFloat(e) + parseFloat(X(t, "x", i + "px", n))) + n
        }
        var Q, m, tt, g, et, v, it, nt = {},
            rt = 180 / Math.PI,
            at = Math.PI / 180,
            st = Math.atan2,
            y = /([A-Z])/g,
            b = /(?:left|right|width|margin|padding|x)/i,
            ot = /[\s,\(]\S/,
            lt = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            },
            ht = "transform",
            ut = ht + "Origin",
            x = "O,Moz,ms,Ms,Webkit".split(","),
            ct = function(t, e, i) {
                var n = (e || g).style,
                    r = 5;
                if (t in n && !i) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(x[r] + t in n););
                return r < 0 ? null : (3 === r ? "ms" : 0 <= r ? x[r] : "") + t
            },
            S = {
                deg: 1,
                rad: 1,
                turn: 1
            },
            pt = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            },
            dt = {
                clearProps: function(t, e, i, n, r) {
                    if ("isFromStart" !== r.data) {
                        var a = t._pt = new R.PropTween(t._pt, e, i, 0, 0, d);
                        return a.u = n, a.pr = -10, a.tween = r, t._props.push(i), 1
                    }
                }
            },
            ft = [1, 0, 0, 1, 0, 0],
            mt = {},
            gt = function(t, e) {
                var i = t._gsap || new R.GSCache(t);
                if ("x" in i && !e && !i.uncache) return i;
                var n, r, a, s, o, l, h, u, c, p, d, f, m, g, v, y, b, x, _, w, S, M, T, C, A, E, D, P, L, k = t.style,
                    O = i.scaleX < 0,
                    F = B(t, ut) || "0",
                    I = n = r = s = o = l = h = u = 0,
                    N = a = 1;
                return i.svg = !(!t.getCTM || !W(t)), d = $(t, i.svg), i.svg && (S = !i.uncache && t.getAttribute("data-svg-origin"), K(t, S || F, !!S || i.originIsAbsolute, !1 !== i.smooth, d)), c = i.xOrigin || 0, p = i.yOrigin || 0, d !== ft && (v = d[0], y = d[1], b = d[2], x = d[3], I = _ = d[4], n = w = d[5], 6 === d.length ? (N = Math.sqrt(v * v + y * y), a = Math.sqrt(x * x + b * b), s = v || y ? st(y, v) * rt : 0, (h = b || x ? st(b, x) * rt + s : 0) && (a *= Math.cos(h * at)), i.svg && (I -= c - (c * v + p * b), n -= p - (c * y + p * x))) : (L = d[6], D = d[7], C = d[8], A = d[9], E = d[10], P = d[11], I = d[12], n = d[13], r = d[14], o = (f = st(L, E)) * rt, f && (S = _ * (m = Math.cos(-f)) + C * (g = Math.sin(-f)), M = w * m + A * g, T = L * m + E * g, C = _ * -g + C * m, A = w * -g + A * m, E = L * -g + E * m, P = D * -g + P * m, _ = S, w = M, L = T), l = (f = st(-b, E)) * rt, f && (m = Math.cos(-f), P = x * (g = Math.sin(-f)) + P * m, v = S = v * m - C * g, y = M = y * m - A * g, b = T = b * m - E * g), s = (f = st(y, v)) * rt, f && (S = v * (m = Math.cos(f)) + y * (g = Math.sin(f)), M = _ * m + w * g, y = y * m - v * g, w = w * m - _ * g, v = S, _ = M), o && 359.9 < Math.abs(o) + Math.abs(s) && (o = s = 0, l = 180 - l), N = (0, R._round)(Math.sqrt(v * v + y * y + b * b)), a = (0, R._round)(Math.sqrt(w * w + L * L)), f = st(_, w), h = 2e-4 < Math.abs(f) ? f * rt : 0, u = P ? 1 / (P < 0 ? -P : P) : 0), i.svg && (S = t.getAttribute("transform"), i.forceCSS = t.setAttribute("transform", "") || !Z(B(t, ht)), S && t.setAttribute("transform", S))), 90 < Math.abs(h) && Math.abs(h) < 270 && (O ? (N *= -1, h += s <= 0 ? 180 : -180, s += s <= 0 ? 180 : -180) : (a *= -1, h += h <= 0 ? 180 : -180)), i.x = ((i.xPercent = I && Math.round(t.offsetWidth / 2) === Math.round(-I) ? -50 : 0) ? 0 : I) + "px", i.y = ((i.yPercent = n && Math.round(t.offsetHeight / 2) === Math.round(-n) ? -50 : 0) ? 0 : n) + "px", i.z = r + "px", i.scaleX = (0, R._round)(N), i.scaleY = (0, R._round)(a), i.rotation = (0, R._round)(s) + "deg", i.rotationX = (0, R._round)(o) + "deg", i.rotationY = (0, R._round)(l) + "deg", i.skewX = h + "deg", i.skewY = "0deg", i.transformPerspective = u + "px", (i.zOrigin = parseFloat(F.split(" ")[2]) || 0) && (k[ut] = vt(F)), i.xOffset = i.yOffset = 0, i.force3D = R._config.force3D, i.renderTransform = i.svg ? xt : it ? bt : yt, i.uncache = 0, i
            },
            vt = function(t) {
                return (t = t.split(" "))[0] + " " + t[1]
            },
            yt = function(t, e) {
                e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, bt(t, e)
            },
            C = "0deg",
            bt = function(t, e) {
                var i, n, r, a, s = e || this,
                    o = s.xPercent,
                    l = s.yPercent,
                    h = s.x,
                    u = s.y,
                    c = s.z,
                    p = s.rotation,
                    d = s.rotationY,
                    f = s.rotationX,
                    m = s.skewX,
                    g = s.skewY,
                    v = s.scaleX,
                    y = s.scaleY,
                    b = s.transformPerspective,
                    x = s.force3D,
                    _ = s.target,
                    w = s.zOrigin,
                    S = "",
                    M = "auto" === x && t && 1 !== t || !0 === x;
                !w || f === C && d === C || (r = parseFloat(d) * at, i = Math.sin(r), n = Math.cos(r), r = parseFloat(f) * at, a = Math.cos(r), h = T(_, h, i * a * -w), u = T(_, u, -Math.sin(r) * -w), c = T(_, c, n * a * -w + w)), "0px" !== b && (S += "perspective(" + b + ") "), (o || l) && (S += "translate(" + o + "%, " + l + "%) "), !M && "0px" === h && "0px" === u && "0px" === c || (S += "0px" !== c || M ? "translate3d(" + h + ", " + u + ", " + c + ") " : "translate(" + h + ", " + u + ") "), p !== C && (S += "rotate(" + p + ") "), d !== C && (S += "rotateY(" + d + ") "), f !== C && (S += "rotateX(" + f + ") "), m === C && g === C || (S += "skew(" + m + ", " + g + ") "), 1 === v && 1 === y || (S += "scale(" + v + ", " + y + ") "), _.style[ht] = S || "translate(0, 0)"
            },
            xt = function(t, e) {
                var i, n, r, a, s, o = e || this,
                    l = o.xPercent,
                    h = o.yPercent,
                    u = o.x,
                    c = o.y,
                    p = o.rotation,
                    d = o.skewX,
                    f = o.skewY,
                    m = o.scaleX,
                    g = o.scaleY,
                    v = o.target,
                    y = o.xOrigin,
                    b = o.yOrigin,
                    x = o.xOffset,
                    _ = o.yOffset,
                    w = o.forceCSS,
                    S = parseFloat(u),
                    M = parseFloat(c),
                    p = parseFloat(p),
                    d = parseFloat(d);
                (f = parseFloat(f)) && (d += f = parseFloat(f), p += f), p || d ? (p *= at, d *= at, i = Math.cos(p) * m, n = Math.sin(p) * m, r = Math.sin(p - d) * -g, a = Math.cos(p - d) * g, d && (f *= at, s = Math.tan(d - f), r *= s = Math.sqrt(1 + s * s), a *= s, f && (s = Math.tan(f), i *= s = Math.sqrt(1 + s * s), n *= s)), i = (0, R._round)(i), n = (0, R._round)(n), r = (0, R._round)(r), a = (0, R._round)(a)) : (i = m, a = g, n = r = 0), (S && !~(u + "").indexOf("px") || M && !~(c + "").indexOf("px")) && (S = X(v, "x", u, "px"), M = X(v, "y", c, "px")), (y || b || x || _) && (S = (0, R._round)(S + y - (y * i + b * r) + x), M = (0, R._round)(M + b - (y * n + b * a) + _)), (l || h) && (s = v.getBBox(), S = (0, R._round)(S + l / 100 * s.width), M = (0, R._round)(M + h / 100 * s.height)), s = "matrix(" + i + "," + n + "," + r + "," + a + "," + S + "," + M + ")", v.setAttribute("transform", s), w && (v.style[ht] = s)
            };
        i._getBBox = M, i.checkPrefix = ct, i._createElement = u, (0, R._forEachName)("padding,margin,Width,Radius", function(e, i) {
            var t = "Bottom",
                o = (i < 3 ? ["Top", "Right", t, "Left"] : ["TopLeft", "TopRight", t + "Right", t + "Left"]).map(function(t) {
                    return i < 2 ? e + t : "border" + t + e
                });
            dt[1 < i ? "border" + e : e] = function(e, t, i, n, r) {
                var a, s;
                if (arguments.length < 4) return a = o.map(function(t) {
                    return Y(e, t, i)
                }), 5 === (s = a.join(" ")).split(a[0]).length ? a[0] : s;
                a = (n + "").split(" "), s = {}, o.forEach(function(t, e) {
                    return s[t] = a[e] = a[e] || a[(e - 1) / 2 | 0]
                }), e.init(t, s, r)
            }
        });
        var A, E, D, P = {
            name: "css",
            register: H,
            targetTest: function(t) {
                return t.style && t.nodeType
            },
            init: function(t, e, i, n, r) {
                var a, s, o, l, h, u, c, p, d, f, m, g, v, y, b, x, _, w, S, M, T, C, A, E, D, P, L, k, O, F, I, N = this._props,
                    B = t.style;
                for (c in tt || H(), e)
                    if ("autoRound" !== c && (s = e[c], !R._plugins[c] || !(0, R._checkPlugin)(c, e, i, n, t, r)))
                        if (h = z(s), u = dt[c], "function" === h && (h = z(s = s.call(i, n, t, r))), "string" === h && ~s.indexOf("random(") && (s = (0, R._replaceRandom)(s)), u) u(this, t, c, s, i) && (b = 1);
                        else if ("--" === c.substr(0, 2)) this.add(B, "setProperty", getComputedStyle(t).getPropertyValue(c) + "", s + "", n, r, 0, 0, c);
                else if ("undefined" !== h) {
                    if (a = Y(t, c), l = parseFloat(a), (f = "string" === h && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)), o = parseFloat(s), c in lt && ("autoAlpha" === c && (1 === l && "hidden" === Y(t, "visibility") && o && (l = 0), q(this, B, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== c && "transform" !== c && ~(c = lt[c]).indexOf(",") && (c = c.split(",")[0])), m = c in nt)
                        if (g || ((v = t._gsap).renderTransform || gt(t), y = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new R.PropTween(this._pt, B, ht, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === c) this._pt = new R.PropTween(this._pt, v, "scaleY", v.scaleY, f ? f * o : o - v.scaleY), N.push("scaleY", c), c += "X";
                        else {
                            if ("transformOrigin" === c) {
                                I = F = O = void 0, O = (k = s).split(" "), F = O[0], I = O[1] || "50%", "top" !== F && "bottom" !== F && "left" !== I && "right" !== I || (k = F, F = I, I = k), O[0] = pt[F] || F, O[1] = pt[I] || I, s = O.join(" "), v.svg ? K(t, s, 0, y, 0, this) : ((d = parseFloat(s.split(" ")[2]) || 0) !== v.zOrigin && q(this, v, "zOrigin", v.zOrigin, d), q(this, B, c, vt(a), vt(s)));
                                continue
                            }
                            if ("svgOrigin" === c) {
                                K(t, s, 1, y, 0, this);
                                continue
                            }
                            if (c in mt) {
                                x = this, _ = v, w = c, S = l, M = s, T = f, E = (P = A = C = void 0, R._isString)(M), D = parseFloat(M) * (E && ~M.indexOf("rad") ? rt : 1), L = S + (P = T ? D * T : D - S) + "deg", E && ("short" === (C = M.split("_")[1]) && (P %= 360) != P % 180 && (P += P < 0 ? 360 : -360), "cw" === C && P < 0 ? P = (P + 36e9) % 360 - 360 * ~~(P / 360) : "ccw" === C && 0 < P && (P = (P - 36e9) % 360 - 360 * ~~(P / 360))), x._pt = A = new R.PropTween(x._pt, _, w, S, P, V), A.e = L, A.u = "deg", x._props.push(w);
                                continue
                            }
                            if ("smoothOrigin" === c) {
                                q(this, v, "smooth", v.smooth, s);
                                continue
                            }
                            if ("force3D" === c) {
                                v[c] = s;
                                continue
                            }
                            if ("transform" === c) {
                                ! function(t, e, i) {
                                    var n, r, a, s, o, l, h, u = et.style,
                                        c = i._gsap;
                                    for (r in u.cssText = getComputedStyle(i).cssText + ";position:absolute;display:block;", u[ht] = e, Q.body.appendChild(et), n = gt(et, 1), nt)(a = c[r]) !== (s = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = (0, R.getUnit)(a) !== (h = (0, R.getUnit)(s)) ? X(i, r, a, h) : parseFloat(a), l = parseFloat(s), t._pt = new R.PropTween(t._pt, c, r, o, l - o, G), t._pt.u = h || 0, t._props.push(r));
                                    Q.body.removeChild(et)
                                }(this, s, t);
                                continue
                            }
                        }
                    else c in B || (c = ct(c) || c);
                    if (m || (o || 0 === o) && (l || 0 === l) && !ot.test(s) && c in B) o = o || 0, (p = (a + "").substr((l + "").length)) !== (d = (0, R.getUnit)(s) || (c in R._config.units ? R._config.units[c] : p)) && (l = X(t, c, a, d)), this._pt = new R.PropTween(this._pt, m ? v : B, c, l, f ? f * o : o - l, "px" !== d || !1 === e.autoRound || m ? G : j), this._pt.u = d || 0, p !== d && (this._pt.b = a, this._pt.r = U);
                    else if (c in B) J.call(this, t, c, a, s);
                    else {
                        if (!(c in t)) {
                            (0, R._missingPlugin)(c, s);
                            continue
                        }
                        this.add(t, c, t[c], s, n, r)
                    }
                    N.push(c)
                }
                b && (0, R._sortPropTweensByPriority)(this)
            },
            get: Y,
            aliases: lt,
            getSetter: function(t, e, i) {
                var n = lt[e];
                return n && n.indexOf(",") < 0 && (e = n), e in nt && e !== ut && (t._gsap.x || Y(t, "x")) ? i && v === i ? "scale" === e ? o : s : (v = i || {}) && ("scale" === e ? l : h) : t.style && !(0, R._isUndefined)(t.style[e]) ? r : ~e.indexOf("-") ? a : (0, R._getSetter)(t, e)
            },
            core: {
                _removeProperty: p,
                _getMatrix: $
            }
        };
        i.default = i.CSSPlugin = P, R.gsap.utils.checkPrefix = ct, A = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent", E = "rotation,rotationX,rotationY,skewX,skewY", D = (0, R._forEachName)(A + "," + E + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function(t) {
            nt[t] = 1
        }), (0, R._forEachName)(E, function(t) {
            R._config.units[t] = "deg", mt[t] = 1
        }), lt[D[13]] = A + "," + E, (0, R._forEachName)("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function(t) {
            var e = t.split(":");
            lt[e[1]] = D[e[0]]
        }), (0, R._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(t) {
            R._config.units[t] = "px"
        }), R.gsap.registerPlugin(P)
    }, {
        "./gsap-core.js": 1
    }],
    "gsap/ScrollToPlugin": [function(t, e, i) {
        "use strict";

        function s(t) {
            return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = i.ScrollToPlugin = void 0;

        function n() {
            return "undefined" != typeof window
        }

        function r() {
            return c || n() && (c = window.gsap) && c.registerPlugin && c
        }

        function o(t) {
            return "string" == typeof t
        }

        function f(t, e) {
            var i = "x" === e ? "Width" : "Height",
                n = "scroll" + i,
                r = "client" + i;
            return t === m || t === d || t === g ? Math.max(d[n], g[n]) - (m["inner" + i] || d[r] || g[r]) : t[n] - t["offset" + i]
        }

        function l(t, e) {
            var i = "scroll" + ("x" === e ? "Left" : "Top");
            return t === m && (null != t.pageXOffset ? i = "page" + e.toUpperCase() + "Offset" : t = null != d[i] ? d : g),
                function() {
                    return t[i]
                }
        }

        function a(t, e) {
            var i = v(t)[0].getBoundingClientRect(),
                n = !e || e === m || e === g,
                r = n ? {
                    top: d.clientTop - (m.pageYOffset || d.scrollTop || g.scrollTop || 0),
                    left: d.clientLeft - (m.pageXOffset || d.scrollLeft || g.scrollLeft || 0)
                } : e.getBoundingClientRect(),
                a = {
                    x: i.left - r.left,
                    y: i.top - r.top
                };
            return !n && e && (a.x += l(e, "x")(), a.y += l(e, "y")()), a
        }

        function h(t, e, i, n, r) {
            return isNaN(t) || "object" === s(t) ? o(t) && "=" === t.charAt(1) ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + n - r : "max" === t ? f(e, i) - r : Math.min(f(e, i), a(t, e)[i] - r) : parseFloat(t) - r
        }

        function u() {
            c = r(), n() && c && document.body && (m = window, g = document.body, d = document.documentElement, v = c.utils.toArray, c.config({
                autoKillThreshold: 7
            }), y = c.config(), p = 1)
        }
        var c, p, m, d, g, v, y, b = {
            version: "3.5.1",
            name: "scrollTo",
            rawVars: 1,
            register: function(t) {
                c = t, u()
            },
            init: function(t, e, i, n, r) {
                p || u();
                var a = this;
                a.isWin = t === m, a.target = t, a.tween = i, "object" !== s(e) ? o((e = {
                    y: e
                }).y) && "max" !== e.y && "=" !== e.y.charAt(1) && (e.x = e.y) : e.nodeType && (e = {
                    y: e,
                    x: e
                }), a.vars = e, a.autoKill = !!e.autoKill, a.getX = l(t, "x"), a.getY = l(t, "y"), a.x = a.xPrev = a.getX(), a.y = a.yPrev = a.getY(), null != e.x ? (a.add(a, "x", a.x, h(e.x, t, "x", a.x, e.offsetX || 0), n, r, Math.round), a._props.push("scrollTo_x")) : a.skipX = 1, null != e.y ? (a.add(a, "y", a.y, h(e.y, t, "y", a.y, e.offsetY || 0), n, r, Math.round), a._props.push("scrollTo_y")) : a.skipY = 1
            },
            render: function(t, e) {
                for (var i, n, r, a, s, o = e._pt, l = e.target, h = e.tween, u = e.autoKill, c = e.xPrev, p = e.yPrev, d = e.isWin; o;) o.r(t, o.d), o = o._next;
                i = d || !e.skipX ? e.getX() : c, r = (n = d || !e.skipY ? e.getY() : p) - p, a = i - c, s = y.autoKillThreshold, e.x < 0 && (e.x = 0), e.y < 0 && (e.y = 0), u && (!e.skipX && (s < a || a < -s) && i < f(l, "x") && (e.skipX = 1), !e.skipY && (s < r || r < -s) && n < f(l, "y") && (e.skipY = 1), e.skipX && e.skipY && (h.kill(), e.vars.onAutoKill && e.vars.onAutoKill.apply(h, e.vars.onAutoKillParams || []))), d ? m.scrollTo(e.skipX ? i : e.x, e.skipY ? n : e.y) : (e.skipY || (l.scrollTop = e.y), e.skipX || (l.scrollLeft = e.x)), e.xPrev = e.x, e.yPrev = e.y
            },
            kill: function(t) {
                var e = "scrollTo" === t;
                !e && "scrollTo_x" !== t || (this.skipX = 1), !e && "scrollTo_y" !== t || (this.skipY = 1)
            }
        };
        i.default = i.ScrollToPlugin = b, b.max = f, b.getOffset = a, b.buildGetter = l, r() && c.registerPlugin(b)
    }, {}],
    "gsap/ScrollTrigger": [function(t, e, i) {
        "use strict";

        function n(t) {
            return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = i.ScrollTrigger = void 0;

        function Tt(t) {
            return t
        }

        function r() {
            return "undefined" != typeof window
        }

        function a() {
            return Zt || r() && (Zt = window.gsap) && Zt.registerPlugin && Zt
        }

        function Ct(t) {
            return !!~d.indexOf(t)
        }

        function At(t, e) {
            return ~ce.indexOf(t) && ce[ce.indexOf(t) + 1][e]
        }

        function Et(e, t) {
            var i = t.s,
                n = t.sc,
                r = S.indexOf(e),
                a = n === Ae.sc ? 1 : 2;
            return ~r || (r = S.push(e) - 1), S[r + a] || (S[r + a] = At(e, i) || (Ct(e) ? n : function(t) {
                return arguments.length ? e[i] = t : e[i]
            }))
        }

        function Dt(t) {
            return At(t, "getBoundingClientRect") || (Ct(t) ? function() {
                return Ie.width = $t.innerWidth, Ie.height = $t.innerHeight, Ie
            } : function() {
                return Ee(t)
            })
        }

        function Pt(t, e) {
            var i = e.s,
                n = e.d2,
                r = e.d,
                a = e.a;
            return (i = "scroll" + n) && (a = At(t, i)) ? a() - Dt(t)()[r] : Ct(t) ? Math.max(Qt[i], te[i]) - ($t["inner" + n] || Qt["client" + n] || te["client" + n]) : t[i] - t["offset" + n]
        }

        function s(t, e) {
            for (var i = 0; i < _.length; i += 3) e && !~e.indexOf(_[i + 1]) || t(_[i], _[i + 1], _[i + 2])
        }

        function Lt(t) {
            return "string" == typeof t
        }

        function kt(t) {
            return "function" == typeof t
        }

        function Ot(t) {
            return "number" == typeof t
        }

        function Ft(t) {
            return "object" === n(t)
        }

        function o(t) {
            return kt(t) && t()
        }

        function l(i, n) {
            return function() {
                var t = o(i),
                    e = o(n);
                return function() {
                    o(t), o(e)
                }
            }
        }

        function It(t) {
            return $t.getComputedStyle(t)
        }

        function Nt(t, e) {
            for (var i in e) i in t || (t[i] = e[i]);
            return t
        }

        function Bt(t, e) {
            var i = e.d2;
            return t["offset" + i] || t["client" + i] || 0
        }

        function h(e, i, t, n) {
            return t.split(",").forEach(function(t) {
                return e(i, t, n)
            })
        }

        function Rt(t, e, i) {
            return t.addEventListener(e, i, {
                passive: !0
            })
        }

        function zt(t, e, i) {
            return t.removeEventListener(e, i)
        }

        function Gt(t, e) {
            var i, n;
            return Lt(t) && ((n = ~(i = t.indexOf("=")) ? (t.charAt(i - 1) + 1) * parseFloat(t.substr(i + 1)) : 0) && (t.indexOf("%") > i && (n *= e / 100), t = t.substr(0, i - 1)), t = n + (t in P ? P[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)), t
        }

        function Vt(t, e, i, n, r, a, s) {
            var o = r.startColor,
                l = r.endColor,
                h = r.fontSize,
                u = r.indent,
                c = r.fontWeight,
                p = Kt.createElement("div"),
                d = Ct(i) || "fixed" === At(i, "pinType"),
                f = -1 !== t.indexOf("scroller"),
                m = d ? te : i,
                g = -1 !== t.indexOf("start"),
                v = g ? o : l,
                y = "border-color:" + v + ";font-size:" + h + ";color:" + v + ";font-weight:" + c + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            return y += "position:" + (f && d ? "fixed;" : "absolute;"), !f && d || (y += (n === Ae ? A : E) + ":" + (a + parseFloat(u)) + "px;"), s && (y += "box-sizing:border-box;text-align:left;width:" + s.offsetWidth + "px;"), p._isStart = g, p.setAttribute("class", "gsap-marker-" + t), p.style.cssText = y, p.innerText = e || 0 === e ? t + "-" + e : t, m.insertBefore(p, m.children[0]), p._offset = p["offset" + n.op.d2], L(p, 0, n, g), p
        }

        function u() {
            return g = g || m(V)
        }

        function Ut() {
            g || (g = m(V), de || I("scrollStart"), de = pe())
        }

        function jt() {
            return !re && f.restart(!0)
        }

        function c(t) {
            var e, i = Zt.ticker.frame,
                n = [],
                r = 0;
            if (w !== i || ue) {
                for (R(); r < F.length; r += 4)(e = $t.matchMedia(F[r]).matches) !== F[r + 3] && ((F[r + 3] = e) ? n.push(r) : R(1, F[r]) || kt(F[r + 2]) && F[r + 2]());
                for (B(), r = 0; r < n.length; r++) e = n[r], he = F[e], F[e + 2] = F[e + 1](t);
                z(he = 0, 1), w = i, I("matchMedia")
            }
        }

        function Ht() {
            return zt(q, "scrollEnd", Ht) || z(!0)
        }

        function Wt(t, e, i, n) {
            if (t.parentNode !== e) {
                for (var r, a = U.length, s = e.style, o = t.style; a--;) s[r = U[a]] = i[r];
                s.position = "absolute" === i.position ? "absolute" : "relative", "inline" === i.display && (s.display = "inline-block"), o[E] = o[A] = "auto", s.overflow = "visible", s.boxSizing = "border-box", s[ge] = Bt(t, Ce) + Te, s[ve] = Bt(t, Ae) + Te, s[we] = o[Se] = o.top = o.left = "0", Fe(n), o[ge] = o.maxWidth = i[ge], o[ve] = o.maxHeight = i[ve], o[we] = i[we], t.parentNode.insertBefore(e, t), e.appendChild(t)
            }
        }

        function qt(t) {
            for (var e = j.length, i = t.style, n = [], r = 0; r < e; r++) n.push(j[r], i[j[r]]);
            return n.t = t, n
        }

        function Xt(t, e, i, n, r, a, s, o, l, h, u, c) {
            var p, d, f, m, g, v, y, b;
            return kt(t) && (t = t(o)), Lt(t) && "max" === t.substr(0, 3) && (t = c + ("=" === t.charAt(4) ? Gt("0" + t.substr(3), i) : 0)), Ot(t) ? s && L(s, i, n, !0) : (kt(e) && (e = e(o)), p = ee(e)[0] || te, d = Ee(p) || {}, f = t.split(" "), d && (d.left || d.top) || "none" !== It(p).display || (v = p.style.display, p.style.display = "block", d = Ee(p), v ? p.style.display = v : p.style.removeProperty("display")), m = Gt(f[0], d[n.d]), g = Gt(f[1] || "0", i), t = d[n.p] - l[n.p] - h + m + r - g, s && L(s, g, n, i - g < 20 || s._isStart && 20 < g), i -= i - g), a && (y = t + i, b = a._isStart, c = "scroll" + n.d2, L(a, y, n, b && 20 < y || !b && (u ? Math.max(te[c], Qt[c]) : a.parentNode[c]) <= y + 1), u && (l = Ee(s), u && (a.style[n.op.p] = l[n.op.p] - n.op.m - a._offset + Te))), Math.round(t)
        }

        function Yt(t, e, i, n) {
            if (t.parentNode !== e) {
                var r, a, s = t.style;
                if (e === te) {
                    for (r in t._stOrig = s.cssText, a = It(t)) + r || W.test(r) || !a[r] || "string" != typeof s[r] || "0" === r || (s[r] = a[r]);
                    s.top = i, s.left = n
                } else s.cssText = t._stOrig;
                Zt.core.getCache(t).uncache = 1, e.appendChild(t)
            }
        }

        function Jt(h, t) {
            var u, c, p = Et(h, t),
                d = "_scroll" + t.p2;
            return h[d] = p,
                function e(t, i, n, r, a) {
                    var s = e.tween,
                        o = i.onComplete,
                        l = {};
                    return s && s.kill(), u = Math.round(n), i[d] = t, (i.modifiers = l)[d] = function(t) {
                        return (t = Math.round(p())) !== u && t !== c ? (s.kill(), e.tween = 0) : t = n + r * s.ratio + a * s.ratio * s.ratio, c = u, u = Math.round(t)
                    }, i.onComplete = function() {
                        e.tween = 0, o && o.call(s)
                    }, s = e.tween = Zt.to(h, i)
                }
        }
        var Zt, p, $t, Kt, Qt, te, d, f, m, g, ee, ie, ne, v, re, ae, y, se, b, x, _, oe, le, he, w, ue = 1,
            ce = [],
            S = [],
            pe = Date.now,
            M = pe(),
            de = 0,
            fe = 1,
            me = Math.abs,
            T = "scrollLeft",
            C = "scrollTop",
            A = "right",
            E = "bottom",
            ge = "width",
            ve = "height",
            ye = "Right",
            be = "Left",
            xe = "Top",
            _e = "Bottom",
            we = "padding",
            Se = "margin",
            Me = "Width",
            D = "Height",
            Te = "px",
            Ce = {
                s: T,
                p: "left",
                p2: be,
                os: A,
                os2: ye,
                d: ge,
                d2: Me,
                a: "x",
                sc: function(t) {
                    return arguments.length ? $t.scrollTo(t, Ae.sc()) : $t.pageXOffset || Kt[T] || Qt[T] || te[T] || 0
                }
            },
            Ae = {
                s: C,
                p: "top",
                p2: xe,
                os: E,
                os2: _e,
                d: ve,
                d2: D,
                a: "y",
                op: Ce,
                sc: function(t) {
                    return arguments.length ? $t.scrollTo(Ce.sc(), t) : $t.pageYOffset || Kt[C] || Qt[C] || te[C] || 0
                }
            },
            Ee = function(t, e) {
                var i = e && "matrix(1, 0, 0, 1, 0, 0)" !== It(t)[y] && Zt.to(t, {
                        x: 0,
                        y: 0,
                        xPercent: 0,
                        yPercent: 0,
                        rotation: 0,
                        rotationX: 0,
                        rotationY: 0,
                        scale: 1,
                        skewX: 0,
                        skewY: 0
                    }).progress(1),
                    n = t.getBoundingClientRect();
                return i && i.progress(0).kill(), n
            },
            De = {
                startColor: "green",
                endColor: "red",
                indent: 0,
                fontSize: "16px",
                fontWeight: "normal"
            },
            Pe = {
                toggleActions: "play",
                anticipatePin: 0
            },
            P = {
                top: 0,
                left: 0,
                center: .5,
                bottom: 1,
                right: 1
            },
            L = function(t, e, i, n) {
                var r = {
                        display: "block"
                    },
                    a = i[n ? "os2" : "p2"],
                    s = i[n ? "p2" : "os2"];
                t._isFlipped = n, r[i.a + "Percent"] = n ? -100 : 0, r[i.a] = n ? 1 : 0, r["border" + a + Me] = 1, r["border" + s + Me] = 0, r[i.p] = e, Zt.set(t, r)
            },
            Le = [],
            ke = {},
            k = {},
            O = [],
            F = [],
            I = function(t) {
                return k[t] && k[t].map(function(t) {
                    return t()
                }) || O
            },
            N = [],
            B = function(t) {
                for (var e = 0; e < N.length; e += 4) t && N[e + 3] !== t || (N[e].style.cssText = N[e + 1], N[e + 2].uncache = 1)
            },
            R = function(t, e) {
                var i;
                for (se = 0; se < Le.length; se++) i = Le[se], e && i.media !== e || (t ? i.kill(1) : (i.scroll.rec || (i.scroll.rec = i.scroll()), i.revert()));
                B(e), e || I("revert")
            },
            z = function(t, e) {
                if (!de || t) {
                    var i = I("refreshInit");
                    for (oe && q.sort(), e || R(), se = 0; se < Le.length; se++) Le[se].refresh();
                    for (i.forEach(function(t) {
                            return t && t.render && t.render(-1)
                        }), se = Le.length; se--;) Le[se].scroll.rec = 0;
                    f.pause(), I("refresh")
                } else Rt(q, "scrollEnd", Ht)
            },
            G = 0,
            Oe = 1,
            V = function() {
                var t = Le.length,
                    e = pe(),
                    i = 50 <= e - M,
                    n = t && Le[0].scroll();
                if (Oe = n < G ? -1 : 1, G = n, i && (de && !ae && 200 < e - de && (de = 0, I("scrollEnd")), ne = M, M = e), Oe < 0) {
                    for (se = t; se--;) Le[se] && Le[se].update(0, i);
                    Oe = 1
                } else
                    for (se = 0; se < t; se++) Le[se] && Le[se].update(0, i);
                g = 0
            },
            U = ["left", "top", E, A, Se + _e, Se + ye, Se + xe, Se + be, "display", "flexShrink", "float"],
            j = U.concat([ge, ve, "boxSizing", "max" + Me, "max" + D, "position", Se, we, we + xe, we + ye, we + _e, we + be]),
            H = /([A-Z])/g,
            Fe = function(t) {
                if (t)
                    for (var e, i, n = t.t.style, r = t.length, a = 0; a < r; a += 2) i = t[a + 1], e = t[a], i ? n[e] = i : n[e] && n.removeProperty(e.replace(H, "-$1").toLowerCase())
            },
            Ie = {
                left: 0,
                top: 0
            },
            W = /(?:webkit|moz|length|cssText)/i;
        Ce.op = Ae;
        var q = function() {
            function Mt(t, e) {
                p || Mt.register(Zt), this.init(t, e)
            }
            return Mt.prototype.init = function(b, x) {
                var _, d, f, n, m, w, t, S, M, T, C, g, e, l, v, y, A, E, D, i, P, L, k, O, r, F, I, a, N, B, R, s, h, z, G, V, U, j, H, W, q, X, o, Y, J, Z, $, K, u, Q, tt, et, it, nt, rt, at, st, c, ot, lt, ht, p, ut, ct, pt, dt, ft, mt, gt, vt, yt, bt, xt, _t, wt, St;
                this.progress = 0, this.vars && this.kill(1), fe ? (_ = (b = Nt(Lt(b) || Ot(b) || b.nodeType ? {
                    trigger: b
                } : b, Pe)).horizontal ? Ce : Ae, d = b.onUpdate, f = b.toggleClass, n = b.id, m = b.onToggle, w = b.onRefresh, t = b.scrub, S = b.trigger, M = b.pin, T = b.pinSpacing, C = b.invalidateOnRefresh, g = b.anticipatePin, e = b.onScrubComplete, l = b.onSnapComplete, v = b.once, y = b.snap, A = b.pinReparent, E = !t && 0 !== t, D = ee(b.scroller || $t)[0], i = Zt.core.getCache(D), P = Ct(D), L = "pinType" in b ? "fixed" === b.pinType : P || "fixed" === At(D, "pinType"), k = [b.onEnter, b.onLeave, b.onEnterBack, b.onLeaveBack], O = E && b.toggleActions.split(" "), r = "markers" in b ? b.markers : Pe.markers, F = !P && parseFloat(It(D)["border" + _.p2 + Me]) || 0, I = this, a = b.onRefreshInit && function() {
                    return b.onRefreshInit(I)
                }, gt = D, vt = P, bt = (yt = _).d, xt = yt.d2, _t = yt.a, N = (_t = At(gt, "getBoundingClientRect")) ? function() {
                    return _t()[bt]
                } : function() {
                    return (vt ? $t["inner" + xt] : gt["client" + xt]) || 0
                }, mt = D, B = !P || ~ce.indexOf(mt) ? Dt(mt) : function() {
                    return Ie
                }, I.media = he, g *= 45, Le.push(I), I.scroller = D, I.scroll = Et(D, _), G = I.scroll(), I.vars = b, x = x || b.animation, "refreshPriority" in b && (oe = 1), i.tweenScroll = i.tweenScroll || {
                    top: Jt(D, Ae),
                    left: Jt(D, Ce)
                }, I.tweenTo = R = i.tweenScroll[_.p], x && (x.vars.lazy = !1, x._initted || !1 !== x.vars.immediateRender && !1 !== b.immediateRender && x.render(0, !0, !0), I.animation = x.pause(), x.scrollTrigger = I, (p = Ot(t) && t) && (ht = Zt.to(x, {
                    ease: "power3",
                    duration: p,
                    onComplete: function() {
                        return e && e(I)
                    }
                })), ot = 0, n = n || x.vars.id), y && (Ft(y) || (y = {
                    snapTo: y
                }), Zt.set(P ? [te, Qt] : D, {
                    scrollBehavior: "auto"
                }), h = kt(y.snapTo) ? y.snapTo : "labels" === y.snapTo ? (wt = x, function(t) {
                    var e, i = [],
                        n = wt.labels,
                        r = wt.duration();
                    for (e in n) i.push(n[e] / r);
                    return Zt.utils.snap(i, t)
                }) : Zt.utils.snap(y.snapTo), ut = y.duration || {
                    min: .1,
                    max: 2
                }, ut = Ft(ut) ? ie(ut.min, ut.max) : ie(ut, ut), ct = Zt.delayedCall(y.delay || p / 2 || .1, function() {
                    if (Math.abs(I.getVelocity()) < 10 && !ae) {
                        var t = x && !E ? x.totalProgress() : I.progress,
                            e = (t - lt) / (pe() - ne) * 1e3 || 0,
                            i = me(e / 2) * e / .185,
                            n = t + i,
                            r = ie(0, 1, h(n, I)),
                            a = I.scroll(),
                            s = Math.round(U + r * Y),
                            o = R.tween;
                        if (a <= j && U <= a && s !== a) {
                            if (o && !o._initted && o.data <= Math.abs(s - a)) return;
                            R(s, {
                                duration: ut(me(.185 * Math.max(me(n - t), me(r - t)) / e / .05 || 0)),
                                ease: y.ease || "power3",
                                data: Math.abs(s - a),
                                onComplete: function() {
                                    ot = lt = x && !E ? x.totalProgress() : I.progress, l && l(I)
                                }
                            }, a, i * Y, s - a - i * Y)
                        }
                    } else I.isActive && ct.restart(!0)
                }).pause()), n && (ke[n] = I), S = I.trigger = ee(S || M)[0], M = !0 === M ? S : ee(M)[0], Lt(f) && (f = {
                    targets: S,
                    className: f
                }), M && (!1 === T || T === Se || (T = !(!T && "flex" === It(M.parentNode).display) && we), I.pin = M, !1 !== b.force3D && Zt.set(M, {
                    force3D: !0
                }), (s = Zt.core.getCache(M)).spacer ? J = s.pinState : (s.spacer = K = Kt.createElement("div"), K.setAttribute("class", "pin-spacer" + (n ? " pin-spacer-" + n : "")), s.pinState = J = qt(M)), I.spacer = K = s.spacer, c = It(M), nt = c[T + _.os2], Q = Zt.getProperty(M), tt = Zt.quickSetter(M, _.a, Te), Wt(M, K, c), $ = qt(M)), r && (o = Ft(r) ? Nt(r, De) : De, q = Vt("scroller-start", n, D, _, o, 0), X = Vt("scroller-end", n, D, _, o, 0, q), u = q["offset" + _.op.d2], H = Vt("start", n, D, _, o, u), W = Vt("end", n, D, _, o, u), L || ((St = D).style.position = "absolute" === It(St).position ? "absolute" : "relative", Zt.set([q, X], {
                    force3D: !0
                }), at = Zt.quickSetter(q, _.a, Te), st = Zt.quickSetter(X, _.a, Te))), I.revert = function(t) {
                    var e, i, n, r = !1 !== t || !I.enabled,
                        a = re;
                    r !== z && (r && (dt = Math.max(I.scroll(), I.scroll.rec || 0), pt = I.progress, ft = x && x.progress()), H && [H, W, q, X].forEach(function(t) {
                        return t.style.display = r ? "none" : "block"
                    }), r && (re = 1), I.update(r), re = a, M && (r ? (e = M, i = K, Fe(J), e.parentNode !== i || (n = i.parentNode) && (n.insertBefore(e, i), n.removeChild(i))) : A && I.isActive || Wt(M, K, It(M), rt)), z = r)
                }, I.refresh = function(t) {
                    if (!re && I.enabled)
                        if (M && t && de) Rt(Mt, "scrollEnd", Ht);
                        else {
                            re = 1, ht && ht.kill(), C && x && x.progress(0).invalidate(), z || I.revert();
                            for (var e, i, n, r, a, s, o, l, h = N(), u = B(), c = Pt(D, _), p = 0, d = 0, f = b.end, m = b.endTrigger || S, g = b.start || (0 === b.start ? 0 : M || !S ? "0 0" : "0 100%"), v = S && Math.max(0, Le.indexOf(I)) || 0, y = v; y--;) !(o = Le[y].pin) || o !== S && o !== M || Le[y].revert();
                            for (U = Xt(g, S, h, _, I.scroll(), H, q, I, u, F, L, c) || (M ? -.001 : 0), kt(f) && (f = f(I)), Lt(f) && !f.indexOf("+=") && (~f.indexOf(" ") ? f = (Lt(g) ? g.split(" ")[0] : "") + f : (p = Gt(f.substr(2), h), f = Lt(g) ? g : U + p, m = S)), j = Math.max(U, Xt(f || (m ? "100% 0" : c), m, h, _, I.scroll() + p, W, X, I, u, F, L, c)) || -.001, Y = j - U || (U -= .01) && .001, p = 0, y = v; y--;)(o = (s = Le[y]).pin) && s.start - s._pinPush < U && (e = s.end - s.start, o === S && (p += e), o === M && (d += e));
                            if (U += p, j += p, I._pinPush = d, H && p && ((e = {})[_.a] = "+=" + p, Zt.set([H, W], e)), M) e = It(M), r = _ === Ae, n = I.scroll(), et = parseFloat(Q(_.a)) + d, !c && 1 < j && ((P ? te : D).style["overflow-" + _.a] = "scroll"), Wt(M, K, e), $ = qt(M), i = Ee(M, !0), l = L && Et(D, r ? Ce : Ae)(), T && ((rt = [T + _.os2, Y + d + Te]).t = K, (y = T === we ? Bt(M, _) + Y + d : 0) && rt.push(_.d, y + Te), Fe(rt), L && I.scroll(dt)), L && ((a = {
                                top: i.top + (r ? n - U : l) + Te,
                                left: i.left + (r ? l : n - U) + Te,
                                boxSizing: "border-box",
                                position: "fixed"
                            })[ge] = a.maxWidth = Math.ceil(i.width) + Te, a[ve] = a.maxHeight = Math.ceil(i.height) + Te, a[Se] = a[Se + xe] = a[Se + ye] = a[Se + _e] = a[Se + be] = "0", a[we] = e[we], a[we + xe] = e[we + xe], a[we + ye] = e[we + ye], a[we + _e] = e[we + _e], a[we + be] = e[we + be], Z = function(t, e, i) {
                                for (var n, r = [], a = t.length, s = i ? 8 : 0; s < a; s += 2) n = t[s], r.push(n, n in e ? e[n] : t[s + 1]);
                                return r.t = t.t, r
                            }(J, a, A)), x ? (x.progress(1, !0), it = Q(_.a) - et + Y + d, Y !== it && Z.splice(Z.length - 2, 2), x.progress(0, !0)) : it = Y;
                            else if (S && I.scroll())
                                for (i = S.parentNode; i && i !== te;) i._pinOffset && (U -= i._pinOffset, j -= i._pinOffset), i = i.parentNode;
                            for (y = 0; y < v; y++) !(s = Le[y].pin) || s !== S && s !== M || Le[y].revert(!1);
                            I.start = U, I.end = j, (G = V = I.scroll()) < dt && I.scroll(dt), I.revert(!1), re = 0, ft && E && x.progress(ft, !0), pt !== I.progress && (ht && x.totalProgress(pt, !0), I.progress = pt, I.update()), M && T && (K._pinOffset = Math.round(I.progress * it)), w && w(I)
                        }
                }, I.getVelocity = function() {
                    return (I.scroll() - V) / (pe() - ne) * 1e3 || 0
                }, I.update = function(t, e) {
                    var i, n, r, a, s, o, l, h = I.scroll(),
                        u = t ? 0 : (h - U) / Y,
                        c = u < 0 ? 0 : 1 < u ? 1 : u || 0,
                        p = I.progress;
                    e && (V = G, G = h, y && (lt = ot, ot = x && !E ? x.totalProgress() : c)), g && !c && M && !re && !ue && de && U < h + (h - V) / (pe() - ne) * g && (c = 1e-4), c !== p && I.enabled && (l = (o = (s = I.isActive = !!c && c < 1) != (!!p && p < 1)) || !!c != !!p, I.direction = p < c ? 1 : -1, I.progress = c, E || (!ht || re || ue ? x && x.totalProgress(c, !!re) : (ht.vars.totalProgress = c, ht.invalidate().restart())), M && (t && T && (K.style[T + _.os2] = nt), L ? l && (a = !t && p < c && h < j + 1 && h + 1 >= Pt(D, _), A && (t || !s && !a ? Yt(M, K) : (n = Ee(M, !0), r = h - U, Yt(M, te, n.top + (_ === Ae ? r : 0) + Te, n.left + (_ === Ae ? 0 : r) + Te))), Fe(s || a ? Z : $), it !== Y && c < 1 && s || tt(et + (1 !== c || a ? 0 : it))) : tt(et + it * c)), !y || R.tween || re || ue || ct.restart(!0), f && (o || v && c && (c < 1 || !le)) && ee(f.targets).forEach(function(t) {
                        return t.classList[s || v ? "add" : "remove"](f.className)
                    }), !d || E || t || d(I), l && !re ? (i = c && !p ? 0 : 1 === c ? 1 : 1 === p ? 2 : 3, E && (a = !o && "none" !== O[i + 1] && O[i + 1] || O[i], x && ("complete" === a || "reset" === a || a in x) && ("complete" === a ? x.pause().totalProgress(1) : "reset" === a ? x.restart(!0).pause() : x[a]()), d && d(I)), !o && le || (m && o && m(I), k[i] && k[i](I), v && (1 === c ? I.kill(!1, 1) : k[i] = 0), o || k[i = 1 === c ? 1 : 3] && k[i](I))) : E && d && !re && d(I)), st && (at(h + (q._isFlipped ? 1 : 0)), st(h))
                }, I.enable = function() {
                    I.enabled || (I.enabled = !0, Rt(D, "resize", jt), Rt(D, "scroll", Ut), a && Rt(Mt, "refreshInit", a), x && x.add ? Zt.delayedCall(.01, function() {
                        return U || j || I.refresh()
                    }) && (Y = .01) && (U = j = 0) : I.refresh())
                }, I.disable = function(t, e) {
                    if (I.enabled && (!1 !== t && I.revert(), I.enabled = I.isActive = !1, e || ht && ht.pause(), dt = 0, s && (s.uncache = 1), a && zt(Mt, "refreshInit", a), ct && (ct.pause(), R.tween && R.tween.kill() && (R.tween = 0)), !P)) {
                        for (var i = Le.length; i--;)
                            if (Le[i].scroller === D && Le[i] !== I) return;
                        zt(D, "resize", jt), zt(D, "scroll", Ut)
                    }
                }, I.kill = function(t, e) {
                    I.disable(t, e), n && delete ke[n];
                    var i = Le.indexOf(I);
                    Le.splice(i, 1), i === se && 0 < Oe && se--, x && (x.scrollTrigger = null, t && x.render(-1), e || x.kill()), H && [H, W, q, X].forEach(function(t) {
                        return t.parentNode.removeChild(t)
                    }), s && (s.uncache = 1)
                }, I.enable()) : this.update = this.refresh = this.kill = Tt
            }, Mt.register = function(t) {
                var e, i, n;
                return p || (Zt = t || a(), r() && window.document && ($t = window, Kt = document, Qt = Kt.documentElement, te = Kt.body), Zt && (ee = Zt.utils.toArray, ie = Zt.utils.clamp, Zt.core.globals("ScrollTrigger", Mt), te && (m = $t.requestAnimationFrame || function(t) {
                    return setTimeout(t, 16)
                }, Rt($t, "mousewheel", Ut), d = [$t, Kt, Qt, te], Rt(Kt, "scroll", Ut), i = (e = te.style).borderTop, e.borderTop = "1px solid #000", n = Ee(te), Ae.m = Math.round(n.top + Ae.sc()) || 0, Ce.m = Math.round(n.left + Ce.sc()) || 0, i ? e.borderTop = i : e.removeProperty("border-top"), v = setInterval(u, 200), Zt.delayedCall(.5, function() {
                    return ue = 0
                }), Rt(Kt, "touchcancel", Tt), Rt(te, "touchstart", Tt), h(Rt, Kt, "pointerdown,touchstart,mousedown", function() {
                    return ae = 1
                }), h(Rt, Kt, "pointerup,touchend,mouseup", function() {
                    return ae = 0
                }), y = Zt.utils.checkPrefix("transform"), j.push(y), p = pe(), f = Zt.delayedCall(.2, z).pause(), _ = [Kt, "visibilitychange", function() {
                    var t = $t.innerWidth,
                        e = $t.innerHeight;
                    Kt.hidden ? (b = t, x = e) : b === t && x === e || jt()
                }, Kt, "DOMContentLoaded", z, $t, "load", function() {
                    return de || z()
                }, $t, "resize", jt], s(Rt)))), p
            }, Mt.defaults = function(t) {
                for (var e in t) Pe[e] = t[e]
            }, Mt.kill = function() {
                fe = 0, Le.slice(0).forEach(function(t) {
                    return t.kill(1)
                })
            }, Mt.config = function(t) {
                "limitCallbacks" in t && (le = !!t.limitCallbacks);
                var e = t.syncInterval;
                e && clearInterval(v) || (v = e) && setInterval(u, e), "autoRefreshEvents" in t && (s(zt), s(Rt, t.autoRefreshEvents || "none"))
            }, Mt.scrollerProxy = function(t, e) {
                var i = ee(t)[0];
                Ct(i) ? ce.unshift($t, e, te, e, Qt, e) : ce.unshift(i, e)
            }, Mt.matchMedia = function(t) {
                var e, i, n, r, a;
                for (i in t) n = F.indexOf(i), r = t[i], "all" === (he = i) ? r() : (e = $t.matchMedia(i)) && (e.matches && (a = r()), ~n ? (F[n + 1] = l(F[n + 1], r), F[n + 2] = l(F[n + 2], a)) : (n = F.length, F.push(i, r, a), e.addListener ? e.addListener(c) : e.addEventListener("change", c)), F[n + 3] = e.matches), he = 0;
                return F
            }, Mt.clearMatchMedia = function(t) {
                t || (F.length = 0), 0 <= (t = F.indexOf(t)) && F.splice(t, 4)
            }, Mt
        }();
        i.default = i.ScrollTrigger = q, q.version = "3.5.1", q.saveStyles = function(t) {
            return t ? ee(t).forEach(function(t) {
                var e = N.indexOf(t);
                0 <= e && N.splice(e, 4), N.push(t, t.style.cssText, Zt.core.getCache(t), he)
            }) : N
        }, q.revert = function(t, e) {
            return R(!t, e)
        }, q.create = function(t, e) {
            return new q(t, e)
        }, q.refresh = function(t) {
            return t ? jt() : z(!0)
        }, q.update = V, q.maxScroll = function(t, e) {
            return Pt(t, e ? Ce : Ae)
        }, q.getScrollFunc = function(t, e) {
            return Et(ee(t)[0], e ? Ce : Ae)
        }, q.getById = function(t) {
            return ke[t]
        }, q.getAll = function() {
            return Le.slice(0)
        }, q.isScrolling = function() {
            return !!de
        }, q.addEventListener = function(t, e) {
            var i = k[t] || (k[t] = []);
            ~i.indexOf(e) || i.push(e)
        }, q.removeEventListener = function(t, e) {
            var i = k[t],
                n = i && i.indexOf(e);
            0 <= n && i.splice(n, 1)
        }, q.batch = function(t, e) {
            var i, n = [],
                r = {},
                a = e.interval || .016,
                s = e.batchMax || 1e9;
            for (i in e) r[i] = "on" === i.substr(0, 2) && kt(e[i]) && "onRefreshInit" !== i ? function(t) {
                var e = [],
                    i = [],
                    n = Zt.delayedCall(a, function() {
                        t(e, i), e = [], i = []
                    }).pause();
                return function(t) {
                    e.length || n.restart(!0), e.push(t.trigger), i.push(t), s <= e.length && n.progress(1)
                }
            }(e[i]) : e[i];
            return kt(s) && (s = s(), Rt(q, "refresh", function() {
                return s = e.batchMax()
            })), ee(t).forEach(function(t) {
                var e = {};
                for (i in r) e[i] = r[i];
                e.trigger = t, n.push(q.create(e))
            }), n
        }, q.sort = function(t) {
            return Le.sort(t || function(t, e) {
                return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0))
            })
        }, a() && Zt.registerPlugin(q)
    }, {}],
    "gsap/SplitText": [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = i.SplitText = void 0;
        var w = t("./utils/strings.js");

        function n(t) {
            return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function V(t) {
            return r.getComputedStyle(t)
        }

        function U(t, e) {
            var i;
            return s(t) ? t : "string" === (i = n(t)) && !e && t ? o.call(Y.querySelectorAll(t), 0) : t && "object" === i && "length" in t ? o.call(t, 0) : t ? [t] : []
        }

        function j(t) {
            return "absolute" === t.position || !0 === t.absolute
        }

        function S(t, e) {
            for (var i, n = e.length; - 1 < --n;)
                if (i = e[n], t.substr(0, i.length) === i) return i.length
        }

        function l(t, e) {
            void 0 === t && (t = "");
            var i = ~t.indexOf("++"),
                n = 1;
            return i && (t = t.split("++").join("")),
                function() {
                    return "<" + e + " style='position:relative;display:inline-block;'" + (t ? " class='" + t + (i ? n++ : "") + "'>" : ">")
                }
        }

        function H(t, e, i) {
            var n = t.nodeType;
            if (1 === n || 9 === n || 11 === n)
                for (t = t.firstChild; t; t = t.nextSibling) H(t, e, i);
            else 3 !== n && 4 !== n || (t.nodeValue = t.nodeValue.split(e).join(i))
        }

        function W(t, e) {
            for (var i = e.length; - 1 < --i;) t.push(e[i])
        }

        function q(t, e, i) {
            for (var n; t && t !== e;) {
                if (n = t._next || t.nextSibling) return n.textContent.charAt(0) === i;
                t = t.parentNode || t._parent
            }
        }

        function X(t, e) {
            return parseFloat(e[t]) || 0
        }

        function h(t, e, i, n, r, a, s) {
            var o, l, h, u, c, p, d, f, m, g, v, y, b = V(t),
                x = X("paddingLeft", b),
                _ = -999,
                w = X("borderBottomWidth", b) + X("borderTopWidth", b),
                S = X("borderLeftWidth", b) + X("borderRightWidth", b),
                M = X("paddingTop", b) + X("paddingBottom", b),
                T = X("paddingLeft", b) + X("paddingRight", b),
                C = X("fontSize", b) * (e.lineThreshold || .2),
                A = b.textAlign,
                E = [],
                D = [],
                P = [],
                L = e.wordDelimiter || " ",
                k = e.tag ? e.tag : e.span ? "span" : "div",
                O = e.type || e.split || "chars,words,lines",
                F = r && ~O.indexOf("lines") ? [] : null,
                I = ~O.indexOf("words"),
                N = ~O.indexOf("chars"),
                B = j(e),
                R = e.linesClass,
                z = ~(R || "").indexOf("++"),
                G = [];
            for (z && (R = R.split("++").join("")), h = (l = t.getElementsByTagName("*")).length, c = [], o = 0; o < h; o++) c[o] = l[o];
            if (F || B)
                for (o = 0; o < h; o++)((p = (u = c[o]).parentNode === t) || B || N && !I) && (y = u.offsetTop, F && p && Math.abs(y - _) > C && ("BR" !== u.nodeName || 0 === o) && (d = [], F.push(d), _ = y), B && (u._x = u.offsetLeft, u._y = y, u._w = u.offsetWidth, u._h = u.offsetHeight), F && ((u._isSplit && p || !N && p || I && p || !I && u.parentNode.parentNode === t && !u.parentNode._isSplit) && (d.push(u), u._x -= x, q(u, t, L) && (u._wordEnd = !0)), "BR" === u.nodeName && (u.nextSibling && "BR" === u.nextSibling.nodeName || 0 === o) && F.push([])));
            for (o = 0; o < h; o++) p = (u = c[o]).parentNode === t, "BR" !== u.nodeName ? (B && (m = u.style, I || p || (u._x += u.parentNode._x, u._y += u.parentNode._y), m.left = u._x + "px", m.top = u._y + "px", m.position = "absolute", m.display = "block", m.width = u._w + 1 + "px", m.height = u._h + "px"), !I && N ? u._isSplit ? (u._next = u.nextSibling, u.parentNode.appendChild(u)) : u.parentNode._isSplit ? (u._parent = u.parentNode, !u.previousSibling && u.firstChild && (u.firstChild._isFirst = !0), u.nextSibling && " " === u.nextSibling.textContent && !u.nextSibling.nextSibling && G.push(u.nextSibling), u._next = u.nextSibling && u.nextSibling._isFirst ? null : u.nextSibling, u.parentNode.removeChild(u), c.splice(o--, 1), h--) : p || (y = !u.nextSibling && q(u.parentNode, t, L), u.parentNode._parent && u.parentNode._parent.appendChild(u), y && u.parentNode.appendChild(Y.createTextNode(" ")), "span" === k && (u.style.display = "inline"), E.push(u)) : u.parentNode._isSplit && !u._isSplit && "" !== u.innerHTML ? D.push(u) : N && !u._isSplit && ("span" === k && (u.style.display = "inline"), E.push(u))) : F || B ? (u.parentNode && u.parentNode.removeChild(u), c.splice(o--, 1), h--) : I || t.appendChild(u);
            for (o = G.length; - 1 < --o;) G[o].parentNode.removeChild(G[o]);
            if (F) {
                for (B && (g = Y.createElement(k), t.appendChild(g), v = g.offsetWidth + "px", y = g.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(g)), m = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;) t.removeChild(t.firstChild);
                for (f = " " === L && (!B || !I && !N), o = 0; o < F.length; o++) {
                    for (d = F[o], (g = Y.createElement(k)).style.cssText = "display:block;text-align:" + A + ";position:" + (B ? "absolute;" : "relative;"), R && (g.className = R + (z ? o + 1 : "")), P.push(g), h = d.length, l = 0; l < h; l++) "BR" !== d[l].nodeName && (u = d[l], g.appendChild(u), f && u._wordEnd && g.appendChild(Y.createTextNode(" ")), B && (0 === l && (g.style.top = u._y + "px", g.style.left = x + y + "px"), u.style.top = "0px", y && (u.style.left = u._x - y + "px")));
                    0 === h ? g.innerHTML = "&nbsp;" : I || N || (function t(e) {
                        for (var i, n = U(e.childNodes), r = n.length, a = 0; a < r; a++)(i = n[a])._isSplit ? t(i) : (a && 3 === i.previousSibling.nodeType ? i.previousSibling.nodeValue += 3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue : 3 !== i.nodeType && e.insertBefore(i.firstChild, i), e.removeChild(i))
                    }(g), H(g, String.fromCharCode(160), " ")), B && (g.style.width = v, g.style.height = u._h + "px"), t.appendChild(g)
                }
                t.style.cssText = m
            }
            B && (s > t.clientHeight && (t.style.height = s - M + "px", t.clientHeight < s && (t.style.height = s + w + "px")), a > t.clientWidth && (t.style.width = a - T + "px", t.clientWidth < a && (t.style.width = a + S + "px"))), W(i, E), I && W(n, D), W(r, P)
        }

        function u(t, e, i, n) {
            var r, a, s = U(t.childNodes),
                o = s.length,
                l = j(e);
            if (3 !== t.nodeType || 1 < o) {
                for (e.absolute = !1, r = 0; r < o; r++) 3 === (a = s[r]).nodeType && !/\S+/.test(a.nodeValue) || (l && 3 !== a.nodeType && "inline" === V(a).display && (a.style.display = "inline-block", a.style.position = "relative"), a._isSplit = !0, u(a, e, i, n));
                return e.absolute = l, void(t._isSplit = !0)
            }! function(t, e, i, n) {
                var r, a, s, o, l, h, u, c, p = e.tag ? e.tag : e.span ? "span" : "div",
                    d = ~(e.type || e.split || "chars,words,lines").indexOf("chars"),
                    f = j(e),
                    m = e.wordDelimiter || " ",
                    g = " " !== m ? "" : f ? "&#173; " : " ",
                    v = "</" + p + ">",
                    y = 1,
                    b = e.specialChars ? "function" == typeof e.specialChars ? e.specialChars : S : null,
                    x = Y.createElement("div"),
                    _ = t.parentNode;
                for (_.insertBefore(x, t), x.textContent = t.nodeValue, _.removeChild(t), t = x, u = -1 !== (r = (0, w.getText)(t)).indexOf("<"), !1 !== e.reduceWhiteSpace && (r = r.replace(T, " ").replace(M, "")), u && (r = r.split("<").join("{{LT}}")), l = r.length, a = (" " === r.charAt(0) ? g : "") + i(), s = 0; s < l; s++)
                    if (h = r.charAt(s), b && (c = b(r.substr(s), e.specialChars))) h = r.substr(s, c || 1), a += d && " " !== h ? n() + h + "</" + p + ">" : h, s += c - 1;
                    else if (h === m && r.charAt(s - 1) !== m && s) {
                    for (a += y ? v : "", y = 0; r.charAt(s + 1) === m;) a += g, s++;
                    s === l - 1 ? a += g : ")" !== r.charAt(s + 1) && (a += g + i(), y = 1)
                } else "{" === h && "{{LT}}" === r.substr(s, 6) ? (a += d ? n() + "{{LT}}</" + p + ">" : "{{LT}}", s += 5) : 55296 <= h.charCodeAt(0) && h.charCodeAt(0) <= 56319 || 65024 <= r.charCodeAt(s + 1) && r.charCodeAt(s + 1) <= 65039 ? (o = ((r.substr(s, 12).split(w.emojiExp) || [])[1] || "").length || 2, a += d && " " !== h ? n() + r.substr(s, o) + "</" + p + ">" : r.substr(s, o), s += o - 1) : a += d && " " !== h ? n() + h + "</" + p + ">" : h;
                t.outerHTML = a + (y ? v : ""), u && H(_, "{{LT}}", "<")
            }(t, e, i, n)
        }
        var Y, r, a, M = /(?:\r|\n|\t\t)/g,
            T = /(?:\s\s+)/g,
            s = Array.isArray,
            o = [].slice,
            c = function() {
                function i(t, e) {
                    a || (Y = document, r = window, a = 1), this.elements = U(t), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = e || {}, this.split(e)
                }
                var t = i.prototype;
                return t.split = function(t) {
                    this.isSplit && this.revert(), this.vars = t = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                    for (var e, i, n, r = this.elements.length, a = t.tag ? t.tag : t.span ? "span" : "div", s = l(t.wordsClass, a), o = l(t.charsClass, a); - 1 < --r;) n = this.elements[r], this._originals[r] = n.innerHTML, e = n.clientHeight, i = n.clientWidth, u(n, t, s, o), h(n, t, this.chars, this.words, this.lines, i, e);
                    return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
                }, t.revert = function() {
                    var i = this._originals;
                    if (!i) throw "revert() call wasn't scoped properly.";
                    return this.elements.forEach(function(t, e) {
                        return t.innerHTML = i[e]
                    }), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
                }, i.create = function(t, e) {
                    return new i(t, e)
                }, i
            }();
        i.default = i.SplitText = c, c.version = "3.5.1"
    }, {
        "./utils/strings.js": 2
    }],
    gsap: [function(t, e, i) {
        "use strict";

        function Bn(t) {
            return (Bn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        var n, r;
        r = function(t) {
            function i(t, e) {
                t.prototype = Object.create(e.prototype), (t.prototype.constructor = t).__proto__ = e
            }

            function C(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }

            function R(t) {
                return "string" == typeof t
            }

            function d(t) {
                return "function" == typeof t
            }

            function A(t) {
                return "number" == typeof t
            }

            function r(t) {
                return void 0 === t
            }

            function E(t) {
                return "object" === Bn(t)
            }

            function I(t) {
                return !1 !== t
            }

            function e() {
                return "undefined" != typeof window
            }

            function D(t) {
                return d(t) || R(t)
            }

            function n(t) {
                return (te = he(t, Qt)) && ai
            }

            function P(t, e) {
                return !e && void 0
            }

            function s(t, e) {
                return t && (Qt[t] = e) && te && (te[t] = e) || Qt
            }

            function L() {
                return 0
            }

            function N(t) {
                var e, i, n = t[0];
                if (E(n) || d(n) || (t = [t]), !(e = (n._gsap || {}).harness)) {
                    for (i = oe.length; i-- && !oe[i].targetTest(n););
                    e = oe[i]
                }
                for (i = t.length; i--;) t[i] && (t[i]._gsap || (t[i]._gsap = new Pe(t[i], e))) || t.splice(i, 1);
                return t
            }

            function B(t) {
                return t._gsap || N(fe(t))[0]._gsap
            }

            function a(t, e, i) {
                return (i = t[e]) && d(i) ? t[e]() : r(i) && t.getAttribute && t.getAttribute(e) || i
            }

            function f(t, e) {
                return (t = t.split(",")).forEach(e) || t
            }

            function z(t) {
                return Math.round(1e5 * t) / 1e5 || 0
            }

            function o(t, e, i) {
                var n, r = A(t[1]),
                    a = (r ? 2 : 1) + (e < 2 ? 0 : 1),
                    s = t[a];
                if (r && (s.duration = t[1]), s.parent = i, e) {
                    for (n = s; i && !("immediateRender" in n);) n = i.vars.defaults || {}, i = I(i.vars.inherit) && i.parent;
                    s.immediateRender = I(n.immediateRender), e < 2 ? s.runBackwards = 1 : s.startAt = t[a - 1]
                }
                return s
            }

            function G() {
                var t, e, i = ie.length,
                    n = ie.slice(0);
                for (ne = {}, t = ie.length = 0; t < i; t++)(e = n[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
            }

            function l(t, e, i, n) {
                ie.length && G(), t.render(e, i, n), ie.length && G()
            }

            function h(t) {
                var e = parseFloat(t);
                return (e || 0 === e) && (t + "").match(Kt).length < 2 ? e : R(t) ? t.trim() : t
            }

            function u(t) {
                return t
            }

            function V(t, e) {
                for (var i in e) i in t || (t[i] = e[i]);
                return t
            }

            function c(t, e) {
                for (var i in e) i in t || "duration" === i || "ease" === i || (t[i] = e[i])
            }

            function p(t, e) {
                for (var i in e) t[i] = E(e[i]) ? p(t[i] || (t[i] = {}), e[i]) : e[i];
                return t
            }

            function U(t, e) {
                var i, n = {};
                for (i in t) i in e || (n[i] = t[i]);
                return n
            }

            function k(t) {
                var e = t.parent || dt,
                    i = t.keyframes ? c : V;
                if (I(t.inherit))
                    for (; e;) i(t, e.vars.defaults), e = e.parent || e._dp;
                return t
            }

            function m(t, e, i, n) {
                void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
                var r = e._prev,
                    a = e._next;
                r ? r._next = a : t[i] === e && (t[i] = a), a ? a._prev = r : t[n] === e && (t[n] = r), e._next = e._prev = e.parent = null
            }

            function j(t, e) {
                !t.parent || e && !t.parent.autoRemoveChildren || t.parent.remove(t), t._act = 0
            }

            function g(t, e) {
                if (t && (!e || e._end > t._dur || e._start < 0))
                    for (var i = t; i;) i._dirty = 1, i = i.parent;
                return t
            }

            function v(t) {
                return t._repeat ? ue(t._tTime, t = t.duration() + t._rDelay) * t : 0
            }

            function y(t, e) {
                return (t - e._start) * e._ts + (0 <= e._ts ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            }

            function S(t) {
                return t._end = z(t._start + (t._tDur / Math.abs(t._ts || t._rts || Rt) || 0))
            }

            function b(t, e) {
                var i = t._dp;
                return i && i.smoothChildTiming && t._ts && (t._start = z(t._dp._time - (0 < t._ts ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), S(t), i._dirty || g(i, t)), t
            }

            function O(t, e) {
                var i;
                if ((e._time || e._initted && !e._dur) && (i = y(t.rawTime(), e), (!e._dur || pe(0, e.totalDuration(), i) - e._tTime > Rt) && e.render(i, !0)), g(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                    if (t._dur < t.duration())
                        for (i = t; i._dp;) 0 <= i.rawTime() && i.totalTime(i._tTime), i = i._dp;
                    t._zTime = -Rt
                }
            }

            function x(t, e, i, n) {
                return e.parent && j(e), e._start = z(i + e._delay), e._end = z(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
                    function(t, e, i, n, r) {
                        void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
                        var a, s = t[n];
                        if (r)
                            for (a = e[r]; s && s[r] > a;) s = s._prev;
                        s ? (e._next = s._next, s._next = e) : (e._next = t[i], t[i] = e), e._next ? e._next._prev = e : t[n] = e, e._prev = s, e.parent = e._dp = t
                    }(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, n || O(t, e), t
            }

            function F(t, e) {
                return Qt.ScrollTrigger ? Qt.ScrollTrigger.create(e, t) : void 0
            }

            function _(t, e, i, n) {
                return Be(t, e), t._initted ? !i && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && yt !== xe.frame ? (ie.push(t), t._lazy = [e, n]) : void 0 : 1
            }

            function w(t, e, i, n) {
                var r = t._repeat,
                    a = z(e) || 0,
                    s = t._tTime / t._tDur;
                return s && !n && (t._time *= a / t._dur), t._dur = a, t._tDur = r ? r < 0 ? 1e10 : z(a * (r + 1) + t._rDelay * r) : a, s && !n ? b(t, t._tTime = t._tDur * s) : t.parent && S(t), i || g(t.parent, t), t
            }

            function M(t) {
                return t instanceof Oe ? g(t) : w(t, t._dur)
            }

            function T(t, e) {
                var i, n, r = t.labels,
                    a = t._recent || ce,
                    s = 1e8 <= t.duration() ? a.endTime(!1) : t._dur;
                return R(e) && (isNaN(e) || e in r) ? "<" === (i = e.charAt(0)) || ">" === i ? ("<" === i ? a._start : a.endTime(0 <= a._repeat)) + (parseFloat(e.substr(1)) || 0) : (i = e.indexOf("=")) < 0 ? (e in r || (r[e] = s), r[e]) : (n = +(e.charAt(i - 1) + e.substr(i + 1)), 1 < i ? T(t, e.substr(0, i - 1)) + n : s + n) : null == e ? s : +e
            }

            function H(t, e) {
                return t || 0 === t ? e(t) : e
            }

            function W(t) {
                return (t = (t + "").substr((parseFloat(t) + "").length)) && isNaN(t) ? t : ""
            }

            function q(t, e) {
                return t && E(t) && "length" in t && (!e && !t.length || t.length - 1 in t && E(t[0])) && !t.nodeType && t !== ft
            }

            function X(t) {
                return t.sort(function() {
                    return .5 - Math.random()
                })
            }

            function Y(t) {
                if (d(t)) return t;
                var f = E(t) ? t : {
                        each: t
                    },
                    m = Ce(f.ease),
                    g = f.from || 0,
                    v = parseFloat(f.base) || 0,
                    y = {},
                    e = 0 < g && g < 1,
                    b = isNaN(g) || e,
                    x = f.axis,
                    _ = g,
                    w = g;
                return R(g) ? _ = w = {
                        center: .5,
                        edges: .5,
                        end: 1
                    }[g] || 0 : !e && b && (_ = g[0], w = g[1]),
                    function(t, e, i) {
                        var n, r, a, s, o, l, h, u, c, p = (i || f).length,
                            d = y[p];
                        if (!d) {
                            if (!(c = "auto" === f.grid ? 0 : (f.grid || [1, 1e8])[1])) {
                                for (h = -1e8; h < (h = i[c++].getBoundingClientRect().left) && c < p;);
                                c--
                            }
                            for (d = y[p] = [], n = b ? Math.min(c, p) * _ - .5 : g % c, r = b ? p * w / c - .5 : g / c | 0, u = 1e8, l = h = 0; l < p; l++) a = l % c - n, s = r - (l / c | 0), d[l] = o = x ? Math.abs("y" === x ? s : a) : Ut(a * a + s * s), h < o && (h = o), o < u && (u = o);
                            "random" === g && X(d), d.max = h - u, d.min = u, d.v = p = (parseFloat(f.amount) || parseFloat(f.each) * (p < c ? p - 1 : x ? "y" === x ? p / c : c : Math.max(c, p / c)) || 0) * ("edges" === g ? -1 : 1), d.b = p < 0 ? v - p : v, d.u = W(f.amount || f.each) || 0, m = m && p < 0 ? Te(m) : m
                        }
                        return p = (d[t] - d.min) / d.max || 0, z(d.b + (m ? m(p) : p) * d.v) + d.u
                    }
            }

            function J(e) {
                var i = e < 1 ? Math.pow(10, (e + "").length - 2) : 1;
                return function(t) {
                    return Math.floor(Math.round(parseFloat(t) / e) * e * i) / i + (A(t) ? 0 : W(t))
                }
            }

            function Z(l, t) {
                var h, u, e = qt(l);
                return !e && E(l) && (h = e = l.radius || 1e8, l.values ? (l = fe(l.values), (u = !A(l[0])) && (h *= h)) : l = J(l.increment)), H(t, e ? d(l) ? function(t) {
                    return u = l(t), Math.abs(u - t) <= h ? u : t
                } : function(t) {
                    for (var e, i, n = parseFloat(u ? t.x : t), r = parseFloat(u ? t.y : 0), a = 1e8, s = 0, o = l.length; o--;)(e = u ? (e = l[o].x - n) * e + (i = l[o].y - r) * i : Math.abs(l[o] - n)) < a && (a = e, s = o);
                    return s = !h || a <= h ? l[s] : t, u || s === t || A(t) ? s : s + W(t)
                } : J(l))
            }

            function $(t, e, i, n) {
                return H(qt(t) ? !e : !0 === i ? !!(i = 0) : !n, function() {
                    return qt(t) ? t[~~(Math.random() * t.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((t + Math.random() * (e - t)) / i) * i * n) / n
                })
            }

            function K(e, i, t) {
                return H(t, function(t) {
                    return e[~~i(t)]
                })
            }

            function Q(t) {
                for (var e, i, n, r, a = 0, s = ""; ~(e = t.indexOf("random(", a));) n = t.indexOf(")", e), r = "[" === t.charAt(e + 7), i = t.substr(e + 7, n - e - 7).match(r ? Kt : Xt), s += t.substr(a, e - a) + $(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5), a = n + 1;
                return s + t.substr(a, t.length - a)
            }

            function tt(t, e, i) {
                var n, r, a, s = t.labels,
                    o = 1e8;
                for (n in s)(r = s[n] - e) < 0 == !!i && r && o > (r = Math.abs(r)) && (a = n, o = r);
                return a
            }

            function et(t) {
                return j(t), t.progress() < 1 && ge(t, "onInterrupt"), t
            }

            function it(t, e, i) {
                return 255 * (6 * (t = t < 0 ? t + 1 : 1 < t ? t - 1 : t) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
            }

            function nt(t, e, i) {
                var n, r, a, s, o, l, h, u, c, p, d = t ? A(t) ? [t >> 16, t >> 8 & 255, 255 & t] : 0 : ve.black;
                if (!d) {
                    if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), ve[t]) d = ve[t];
                    else if ("#" === t.charAt(0)) 4 === t.length && (t = "#" + (n = t.charAt(1)) + n + (r = t.charAt(2)) + r + (a = t.charAt(3)) + a), d = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                    else if ("hsl" === t.substr(0, 3))
                        if (d = p = t.match(Xt), e) {
                            if (~t.indexOf("=")) return d = t.match(Yt), i && d.length < 4 && (d[3] = 1), d
                        } else s = +d[0] % 360 / 360, o = d[1] / 100, n = 2 * (l = d[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), 3 < d.length && (d[3] *= 1), d[0] = it(s + 1 / 3, n, r), d[1] = it(s, n, r), d[2] = it(s - 1 / 3, n, r);
                    else d = t.match(Xt) || ve.transparent;
                    d = d.map(Number)
                }
                return e && !p && (n = d[0] / 255, r = d[1] / 255, a = d[2] / 255, l = ((h = Math.max(n, r, a)) + (u = Math.min(n, r, a))) / 2, h === u ? s = o = 0 : (c = h - u, o = .5 < l ? c / (2 - h - u) : c / (h + u), s = h === n ? (r - a) / c + (r < a ? 6 : 0) : h === r ? (a - n) / c + 2 : (n - r) / c + 4, s *= 60), d[0] = ~~(s + .5), d[1] = ~~(100 * o + .5), d[2] = ~~(100 * l + .5)), i && d.length < 4 && (d[3] = 1), d
            }

            function rt(t) {
                var i = [],
                    n = [],
                    r = -1;
                return t.split(ye).forEach(function(t) {
                    var e = t.match(Jt) || [];
                    i.push.apply(i, e), n.push(r += e.length + 1)
                }), i.c = n, i
            }

            function at(t, e, i) {
                var n, r, a, s, o = "",
                    l = (t + o).match(ye),
                    h = e ? "hsla(" : "rgba(",
                    u = 0;
                if (!l) return t;
                if (l = l.map(function(t) {
                        return (t = nt(t, e, 1)) && h + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                    }), i && (a = rt(t), (n = i.c).join(o) !== a.c.join(o)))
                    for (s = (r = t.replace(ye, "1").split(Jt)).length - 1; u < s; u++) o += r[u] + (~n.indexOf(u) ? l.shift() || h + "0,0,0,0)" : (a.length ? a : l.length ? l : i).shift());
                if (!r)
                    for (s = (r = t.split(ye)).length - 1; u < s; u++) o += r[u] + l[u];
                return o + r[s]
            }

            function st(t) {
                var e, i = t.join(" ");
                if (ye.lastIndex = 0, ye.test(i)) return e = be.test(i), t[1] = at(t[1], e), t[0] = at(t[0], e, rt(t[1])), !0
            }

            function ot(t) {
                var e, i, n, r, a = (t + "").split("("),
                    s = we[a[0]];
                return s && 1 < a.length && s.config ? s.config.apply(null, ~t.indexOf("{") ? [function(t) {
                    for (var e, i, n, r = {}, a = t.substr(1, t.length - 3).split(":"), s = a[0], o = 1, l = a.length; o < l; o++) i = a[o], e = o !== l - 1 ? i.lastIndexOf(",") : i.length, n = i.substr(0, e), r[s] = isNaN(n) ? n.replace(Me, "").trim() : +n, s = i.substr(e + 1).trim();
                    return r
                }(a[1])] : (i = (e = t).indexOf("(") + 1, n = e.indexOf(")"), r = e.indexOf("(", i), e.substring(i, ~r && r < n ? e.indexOf(")", n + 1) : n).split(",").map(h))) : we._CE && Se.test(t) ? we._CE("", t) : s
            }

            function lt(t, e) {
                for (var i, n = t._first; n;) n instanceof Oe ? lt(n, e) : !n.vars.yoyoEase || n._yoyo && n._repeat || n._yoyo === e || (n.timeline ? lt(n.timeline, e) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = e)), n = n._next
            }

            function ht(t, e, i, n) {
                void 0 === i && (i = function(t) {
                    return 1 - e(1 - t)
                }), void 0 === n && (n = function(t) {
                    return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                });
                var r, a = {
                    easeIn: e,
                    easeOut: i,
                    easeInOut: n
                };
                return f(t, function(t) {
                    for (var e in we[t] = Qt[t] = a, we[r = t.toLowerCase()] = i, a) we[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = we[t + "." + e] = a[e]
                }), 1
            }

            function ut(e) {
                return function(t) {
                    return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
                }
            }

            function ct(i, t, e) {
                function n(t) {
                    return 1 === t ? 1 : r * Math.pow(2, -10 * t) * Ht((t - a) * o) + 1
                }
                var r = 1 <= t ? t : 1,
                    a = (o = (e || (i ? .3 : .45)) / (t < 1 ? t : 1)) / zt * (Math.asin(1 / r) || 0),
                    s = "out" === i ? n : "in" === i ? function(t) {
                        return 1 - n(1 - t)
                    } : ut(n),
                    o = zt / o;
                return s.config = function(t, e) {
                    return ct(i, t, e)
                }, s
            }

            function pt(e, i) {
                function n(t) {
                    return t ? --t * t * ((i + 1) * t + i) + 1 : 0
                }
                void 0 === i && (i = 1.70158);
                var t = "out" === e ? n : "in" === e ? function(t) {
                    return 1 - n(1 - t)
                } : ut(n);
                return t.config = function(t) {
                    return pt(e, t)
                }, t
            }
            var dt, ft, mt, gt, vt, yt, bt, xt, _t, wt, St, Mt, Tt, Ct, At, Et, Dt, Pt, Lt, kt, Ot, Ft, It, Nt = {
                    autoSleep: 120,
                    force3D: "auto",
                    nullTargetWarn: 1,
                    units: {
                        lineHeight: ""
                    }
                },
                Bt = {
                    duration: .5,
                    overwrite: !1,
                    delay: 0
                },
                Rt = 1e-8,
                zt = 2 * Math.PI,
                Gt = zt / 4,
                Vt = 0,
                Ut = Math.sqrt,
                jt = Math.cos,
                Ht = Math.sin,
                Wt = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
                qt = Array.isArray,
                Xt = /(?:-?\.?\d|\.)+/gi,
                Yt = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
                Jt = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                Zt = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
                $t = /[+-]=-?[\.\d]+/,
                Kt = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
                Qt = {},
                te = {},
                ee = {},
                ie = [],
                ne = {},
                re = {},
                ae = {},
                se = 30,
                oe = [],
                le = "",
                he = function(t, e) {
                    for (var i in e) t[i] = e[i];
                    return t
                },
                ue = function(t, e) {
                    return (t /= e) && ~~t === t ? ~~t - 1 : ~~t
                },
                ce = {
                    _start: 0,
                    endTime: L
                },
                pe = function(t, e, i) {
                    return i < t ? t : e < i ? e : i
                },
                de = [].slice,
                fe = function(t, e) {
                    return !R(t) || e || !mt && _e() ? qt(t) ? (i = e, void 0 === n && (n = []), t.forEach(function(t) {
                        return R(t) && !i || q(t, 1) ? n.push.apply(n, fe(t)) : n.push(t)
                    }) || n) : q(t) ? de.call(t, 0) : t ? [t] : [] : de.call(gt.querySelectorAll(t), 0);
                    var i, n
                },
                me = function(e, t, i, n, r) {
                    var a = t - e,
                        s = n - i;
                    return H(r, function(t) {
                        return i + ((t - e) / a * s || 0)
                    })
                },
                ge = function(t, e, i) {
                    var n, r, a = t.vars,
                        s = a[e];
                    if (s) return n = a[e + "Params"], r = a.callbackScope || t, i && ie.length && G(), n ? s.apply(r, n) : s.call(r)
                },
                ve = {
                    aqua: [0, 255, 255],
                    lime: [0, 255, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, 255],
                    navy: [0, 0, 128],
                    white: [255, 255, 255],
                    olive: [128, 128, 0],
                    yellow: [255, 255, 0],
                    orange: [255, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [255, 0, 0],
                    pink: [255, 192, 203],
                    cyan: [0, 255, 255],
                    transparent: [255, 255, 255, 0]
                },
                ye = function() {
                    var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                    for (t in ve) e += "|" + t + "\\b";
                    return new RegExp(e + ")", "gi")
                }(),
                be = /hsl[a]?\(/,
                xe = (Ct = Date.now, At = 500, Et = 33, Dt = Ct(), Pt = Dt, kt = Lt = 1e3 / 240, Ft = {
                    time: 0,
                    frame: 0,
                    tick: function() {
                        Ae(!0)
                    },
                    deltaRatio: function(t) {
                        return Mt / (1e3 / (t || 60))
                    },
                    wake: function() {
                        vt && (!mt && e() && (ft = mt = window, gt = ft.document || {}, Qt.gsap = ai, (ft.gsapVersions || (ft.gsapVersions = [])).push(ai.version), n(te || ft.GreenSockGlobals || !ft.gsap && ft || {}), St = ft.requestAnimationFrame), _t && Ft.sleep(), wt = St || function(t) {
                            return setTimeout(t, kt - 1e3 * Ft.time + 1 | 0)
                        }, xt = 1, Ae(2))
                    },
                    sleep: function() {
                        (St ? ft.cancelAnimationFrame : clearTimeout)(_t), xt = 0, wt = L
                    },
                    lagSmoothing: function(t, e) {
                        At = t || 1e8, Et = Math.min(e, At, 0)
                    },
                    fps: function(t) {
                        Lt = 1e3 / (t || 240), kt = 1e3 * Ft.time + Lt
                    },
                    add: function(t) {
                        Ot.indexOf(t) < 0 && Ot.push(t), _e()
                    },
                    remove: function(t) {
                        var e;
                        ~(e = Ot.indexOf(t)) && Ot.splice(e, 1) && e <= Tt && Tt--
                    },
                    _listeners: Ot = []
                }),
                _e = function() {
                    return !xt && xe.wake()
                },
                we = {},
                Se = /^[\d.\-M][\d.\-,\s]/,
                Me = /["']/g,
                Te = function(e) {
                    return function(t) {
                        return 1 - e(1 - t)
                    }
                },
                Ce = function(t, e) {
                    return t && (d(t) ? t : we[t] || ot(t)) || e
                };

            function Ae(t) {
                var e, i, n, r, a = Ct() - Pt,
                    s = !0 === t;
                if (At < a && (Dt += a - Et), (0 < (e = (n = (Pt += a) - Dt) - kt) || s) && (r = ++Ft.frame, Mt = n - 1e3 * Ft.time, Ft.time = n /= 1e3, kt += e + (Lt <= e ? 4 : Lt - e), i = 1), s || (_t = wt(Ae)), i)
                    for (Tt = 0; Tt < Ot.length; Tt++) Ot[Tt](n, Mt, r, t)
            }

            function Ee(t) {
                return t < 1 / 2.75 ? It * t * t : t < 1 / 2.75 * 2 ? It * Math.pow(t - 1.5 / 2.75, 2) + .75 : t < 1 / 2.75 * 2.5 ? It * (t -= 2.25 / 2.75) * t + .9375 : It * Math.pow(t - 2.625 / 2.75, 2) + .984375
            }
            f("Linear,Quad,Cubic,Quart,Quint,Strong", function(t, e) {
                var i = e < 5 ? e + 1 : e;
                ht(t + ",Power" + (i - 1), e ? function(t) {
                    return Math.pow(t, i)
                } : function(t) {
                    return t
                }, function(t) {
                    return 1 - Math.pow(1 - t, i)
                }, function(t) {
                    return t < .5 ? Math.pow(2 * t, i) / 2 : 1 - Math.pow(2 * (1 - t), i) / 2
                })
            }), we.Linear.easeNone = we.none = we.Linear.easeIn, ht("Elastic", ct("in"), ct("out"), ct()), It = 7.5625, ht("Bounce", function(t) {
                return 1 - Ee(1 - t)
            }, Ee), ht("Expo", function(t) {
                return t ? Math.pow(2, 10 * (t - 1)) : 0
            }), ht("Circ", function(t) {
                return -(Ut(1 - t * t) - 1)
            }), ht("Sine", function(t) {
                return 1 === t ? 1 : 1 - jt(t * Gt)
            }), ht("Back", pt("in"), pt("out"), pt()), we.SteppedEase = we.steps = Qt.SteppedEase = {
                config: function(t, e) {
                    void 0 === t && (t = 1);
                    var i = 1 / t,
                        n = t + (e ? 0 : 1),
                        r = e ? 1 : 0;
                    return function(t) {
                        return ((n * pe(0, .99999999, t) | 0) + r) * i
                    }
                }
            }, Bt.ease = we["quad.out"], f("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(t) {
                return le += t + "," + t + "Params,"
            });
            var De, Pe = function(t, e) {
                    this.id = Vt++, (t._gsap = this).target = t, this.harness = e, this.get = e ? e.get : a, this.set = e ? e.getSetter : Xe
                },
                Le = ((De = ke.prototype).delay = function(t) {
                    return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                }, De.duration = function(t) {
                    return arguments.length ? this.totalDuration(0 < this._repeat ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                }, De.totalDuration = function(t) {
                    return arguments.length ? (this._dirty = 0, w(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }, De.totalTime = function(t, e) {
                    if (_e(), !arguments.length) return this._tTime;
                    var i = this._dp;
                    if (i && i.smoothChildTiming && this._ts) {
                        for (b(this, t); i.parent;) i.parent._time !== i._start + (0 <= i._ts ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0), i = i.parent;
                        !this.parent && this._dp.autoRemoveChildren && (0 < this._ts && t < this._tDur || this._ts < 0 && 0 < t || !this._tDur && !t) && x(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === Rt || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), l(this, t, e)), this
                }, De.time = function(t, e) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + v(this)) % this._dur || (t ? this._dur : 0), e) : this._time
                }, De.totalProgress = function(t, e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                }, De.progress = function(t, e) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + v(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                }, De.iteration = function(t, e) {
                    var i = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (t - 1) * i, e) : this._repeat ? ue(this._tTime, i) + 1 : 1
                }, De.timeScale = function(t) {
                    if (!arguments.length) return this._rts === -Rt ? 0 : this._rts;
                    if (this._rts === t) return this;
                    var e = this.parent && this._ts ? y(this.parent._time, this) : this._tTime;
                    return this._rts = +t || 0, this._ts = this._ps || t === -Rt ? 0 : this._rts,
                        function(t) {
                            for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                            return t
                        }(this.totalTime(pe(-this._delay, this._tDur, e), !0))
                }, De.paused = function(t) {
                    return arguments.length ? (this._ps !== t && ((this._ps = t) ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (_e(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= Rt) && Math.abs(this._zTime) !== Rt))), this) : this._ps
                }, De.startTime = function(t) {
                    if (arguments.length) {
                        this._start = t;
                        var e = this.parent || this._dp;
                        return !e || !e._sort && this.parent || x(e, this, t - this._delay), this
                    }
                    return this._start
                }, De.endTime = function(t) {
                    return this._start + (I(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
                }, De.rawTime = function(t) {
                    var e = this.parent || this._dp;
                    return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? y(e.rawTime(t), this) : this._tTime : this._tTime
                }, De.globalTime = function(t) {
                    for (var e = this, i = arguments.length ? t : e.rawTime(); e;) i = e._start + i / (e._ts || 1), e = e._dp;
                    return i
                }, De.repeat = function(t) {
                    return arguments.length ? (this._repeat = t, M(this)) : this._repeat
                }, De.repeatDelay = function(t) {
                    return arguments.length ? (this._rDelay = t, M(this)) : this._rDelay
                }, De.yoyo = function(t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, De.seek = function(t, e) {
                    return this.totalTime(T(this, t), I(e))
                }, De.restart = function(t, e) {
                    return this.play().totalTime(t ? -this._delay : 0, I(e))
                }, De.play = function(t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, De.reverse = function(t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, De.pause = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, De.resume = function() {
                    return this.paused(!1)
                }, De.reversed = function(t) {
                    return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -Rt : 0)), this) : this._rts < 0
                }, De.invalidate = function() {
                    return this._initted = 0, this._zTime = -Rt, this
                }, De.isActive = function() {
                    var t, e = this.parent || this._dp,
                        i = this._start;
                    return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= i && t < this.endTime(!0) - Rt))
                }, De.eventCallback = function(t, e, i) {
                    var n = this.vars;
                    return 1 < arguments.length ? (e ? (n[t] = e, i && (n[t + "Params"] = i), "onUpdate" === t && (this._onUpdate = e)) : delete n[t], this) : n[t]
                }, De.then = function(n) {
                    var r = this;
                    return new Promise(function(e) {
                        function t() {
                            var t = r.then;
                            r.then = null, d(i) && (i = i(r)) && (i.then || i === r) && (r.then = t), e(i), r.then = t
                        }
                        var i = d(n) ? n : u;
                        r._initted && 1 === r.totalProgress() && 0 <= r._ts || !r._tTime && r._ts < 0 ? t() : r._prom = t
                    })
                }, De.kill = function() {
                    et(this)
                }, ke);

            function ke(t, e) {
                var i = t.parent || dt;
                this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, w(this, +t.duration, 1, 1), this.data = t.data, xt || xe.wake(), i && x(i, this, e || 0 === e ? e : i._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0)
            }
            V(Le.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: null,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -Rt,
                _prom: 0,
                _ps: !1,
                _rts: 1
            });
            var Oe = function(n) {
                function t(t, e) {
                    var i;
                    return void 0 === t && (t = {}), (i = n.call(this, t, e) || this).labels = {}, i.smoothChildTiming = !!t.smoothChildTiming, i.autoRemoveChildren = !!t.autoRemoveChildren, i._sort = I(t.sortChildren), i.parent && O(i.parent, C(i)), t.scrollTrigger && F(C(i), t.scrollTrigger), i
                }
                i(t, n);
                var e = t.prototype;
                return e.to = function(t, e, i, n) {
                    return new Ve(t, o(arguments, 0, this), T(this, A(e) ? n : i)), this
                }, e.from = function(t, e, i, n) {
                    return new Ve(t, o(arguments, 1, this), T(this, A(e) ? n : i)), this
                }, e.fromTo = function(t, e, i, n, r) {
                    return new Ve(t, o(arguments, 2, this), T(this, A(e) ? r : n)), this
                }, e.set = function(t, e, i) {
                    return e.duration = 0, e.parent = this, k(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Ve(t, e, T(this, i), 1), this
                }, e.call = function(t, e, i) {
                    return x(this, Ve.delayedCall(0, t, e), T(this, i))
                }, e.staggerTo = function(t, e, i, n, r, a, s) {
                    return i.duration = e, i.stagger = i.stagger || n, i.onComplete = a, i.onCompleteParams = s, i.parent = this, new Ve(t, i, T(this, r)), this
                }, e.staggerFrom = function(t, e, i, n, r, a, s) {
                    return i.runBackwards = 1, k(i).immediateRender = I(i.immediateRender), this.staggerTo(t, e, i, n, r, a, s)
                }, e.staggerFromTo = function(t, e, i, n, r, a, s, o) {
                    return n.startAt = i, k(n).immediateRender = I(n.immediateRender), this.staggerTo(t, e, n, r, a, s, o)
                }, e.render = function(t, e, i) {
                    var n, r, a, s, o, l, h, u, c, p, d, f, m = this._time,
                        g = this._dirty ? this.totalDuration() : this._tDur,
                        v = this._dur,
                        y = this !== dt && g - Rt < t && 0 <= t ? g : t < Rt ? 0 : t,
                        b = this._zTime < 0 != t < 0 && (this._initted || !v);
                    if (y !== this._tTime || i || b) {
                        if (m !== this._time && v && (y += this._time - m, t += this._time - m), n = y, c = this._start, l = !(u = this._ts), b && (v || (m = this._zTime), !t && e || (this._zTime = t)), this._repeat && (d = this._yoyo, o = v + this._rDelay, n = z(y % o), y === g ? (s = this._repeat, n = v) : ((s = ~~(y / o)) && s === y / o && (n = v, s--), v < n && (n = v)), p = ue(this._tTime, o), !m && this._tTime && p !== s && (p = s), d && 1 & s && (n = v - n, f = 1), s !== p && !this._lock)) {
                            var x = d && 1 & p,
                                _ = x === (d && 1 & s);
                            if (s < p && (x = !x), m = x ? 0 : v, this._lock = 1, this.render(m || (f ? 0 : z(s * o)), e, !v)._lock = 0, !e && this.parent && ge(this, "onRepeat"), this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1), m !== this._time || l != !this._ts) return this;
                            if (v = this._dur, g = this._tDur, _ && (this._lock = 2, m = x ? v : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !f && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                            lt(this, f)
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (h = function(t, e, i) {
                                var n;
                                if (e < i)
                                    for (n = t._first; n && n._start <= i;) {
                                        if (!n._dur && "isPause" === n.data && n._start > e) return n;
                                        n = n._next
                                    } else
                                        for (n = t._last; n && n._start >= i;) {
                                            if (!n._dur && "isPause" === n.data && n._start < e) return n;
                                            n = n._prev
                                        }
                            }(this, z(m), z(n))) && (y -= n - (n = h._start)), this._tTime = y, this._time = n, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t), m || !n || e || ge(this, "onStart"), m <= n && 0 <= t)
                            for (r = this._first; r;) {
                                if (a = r._next, (r._act || n >= r._start) && r._ts && h !== r) {
                                    if (r.parent !== this) return this.render(t, e, i);
                                    if (r.render(0 < r._ts ? (n - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (n - r._start) * r._ts, e, i), n !== this._time || !this._ts && !l) {
                                        h = 0, a && (y += this._zTime = -Rt);
                                        break
                                    }
                                }
                                r = a
                            } else {
                                r = this._last;
                                for (var w = t < 0 ? t : n; r;) {
                                    if (a = r._prev, (r._act || w <= r._end) && r._ts && h !== r) {
                                        if (r.parent !== this) return this.render(t, e, i);
                                        if (r.render(0 < r._ts ? (w - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (w - r._start) * r._ts, e, i), n !== this._time || !this._ts && !l) {
                                            h = 0, a && (y += this._zTime = w ? -Rt : Rt);
                                            break
                                        }
                                    }
                                    r = a
                                }
                            }
                        if (h && !e && (this.pause(), h.render(m <= n ? 0 : -Rt)._zTime = m <= n ? 1 : -1, this._ts)) return this._start = c, S(this), this.render(t, e, i);
                        this._onUpdate && !e && ge(this, "onUpdate", !0), (y === g && g >= this.totalDuration() || !y && m) && (c !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || (!t && v || !(y === g && 0 < this._ts || !y && this._ts < 0) || j(this, 1), e || t < 0 && !m || !y && !m || (ge(this, y === g ? "onComplete" : "onReverseComplete", !0), !this._prom || y < g && 0 < this.timeScale() || this._prom())))
                    }
                    return this
                }, e.add = function(t, e) {
                    var i = this;
                    if (A(e) || (e = T(this, e)), !(t instanceof Le)) {
                        if (qt(t)) return t.forEach(function(t) {
                            return i.add(t, e)
                        }), this;
                        if (R(t)) return this.addLabel(t, e);
                        if (!d(t)) return this;
                        t = Ve.delayedCall(0, t)
                    }
                    return this !== t ? x(this, t, e) : this
                }, e.getChildren = function(t, e, i, n) {
                    void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = -1e8);
                    for (var r = [], a = this._first; a;) a._start >= n && (a instanceof Ve ? e && r.push(a) : (i && r.push(a), t && r.push.apply(r, a.getChildren(!0, e, i)))), a = a._next;
                    return r
                }, e.getById = function(t) {
                    for (var e = this.getChildren(1, 1, 1), i = e.length; i--;)
                        if (e[i].vars.id === t) return e[i]
                }, e.remove = function(t) {
                    return R(t) ? this.removeLabel(t) : d(t) ? this.killTweensOf(t) : (m(this, t), t === this._recent && (this._recent = this._last), g(this))
                }, e.totalTime = function(t, e) {
                    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = z(xe.time - (0 < this._ts ? t / this._ts : (this.totalDuration() - t) / -this._ts))), n.prototype.totalTime.call(this, t, e), this._forcing = 0, this) : this._tTime
                }, e.addLabel = function(t, e) {
                    return this.labels[t] = T(this, e), this
                }, e.removeLabel = function(t) {
                    return delete this.labels[t], this
                }, e.addPause = function(t, e, i) {
                    var n = Ve.delayedCall(0, e || L, i);
                    return n.data = "isPause", this._hasPause = 1, x(this, n, T(this, t))
                }, e.removePause = function(t) {
                    var e = this._first;
                    for (t = T(this, t); e;) e._start === t && "isPause" === e.data && j(e), e = e._next
                }, e.killTweensOf = function(t, e, i) {
                    for (var n = this.getTweensOf(t, i), r = n.length; r--;) Ie !== n[r] && n[r].kill(t, e);
                    return this
                }, e.getTweensOf = function(t, e) {
                    for (var i, n = [], r = fe(t), a = this._first, s = A(e); a;) a instanceof Ve ? function(t, e) {
                        for (var i = e.length, n = 0; t.indexOf(e[n]) < 0 && ++n < i;);
                        return n < i
                    }(a._targets, r) && (s ? (!Ie || a._initted && a._ts) && a.globalTime(0) <= e && a.globalTime(a.totalDuration()) > e : !e || a.isActive()) && n.push(a) : (i = a.getTweensOf(r, e)).length && n.push.apply(n, i), a = a._next;
                    return n
                }, e.tweenTo = function(t, e) {
                    e = e || {};
                    var i = this,
                        n = T(i, t),
                        r = e.startAt,
                        a = e.onStart,
                        s = e.onStartParams,
                        o = Ve.to(i, V(e, {
                            ease: "none",
                            lazy: !1,
                            time: n,
                            overwrite: "auto",
                            duration: e.duration || Math.abs((n - (r && "time" in r ? r.time : i._time)) / i.timeScale()) || Rt,
                            onStart: function() {
                                i.pause();
                                var t = e.duration || Math.abs((n - i._time) / i.timeScale());
                                o._dur !== t && w(o, t, 0, 1).render(o._time, !0, !0), a && a.apply(o, s || [])
                            }
                        }));
                    return o
                }, e.tweenFromTo = function(t, e, i) {
                    return this.tweenTo(e, V({
                        startAt: {
                            time: T(this, t)
                        }
                    }, i))
                }, e.recent = function() {
                    return this._recent
                }, e.nextLabel = function(t) {
                    return void 0 === t && (t = this._time), tt(this, T(this, t))
                }, e.previousLabel = function(t) {
                    return void 0 === t && (t = this._time), tt(this, T(this, t), 1)
                }, e.currentLabel = function(t) {
                    return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + Rt)
                }, e.shiftChildren = function(t, e, i) {
                    void 0 === i && (i = 0);
                    for (var n, r = this._first, a = this.labels; r;) r._start >= i && (r._start += t, r._end += t), r = r._next;
                    if (e)
                        for (n in a) a[n] >= i && (a[n] += t);
                    return g(this)
                }, e.invalidate = function() {
                    var t = this._first;
                    for (this._lock = 0; t;) t.invalidate(), t = t._next;
                    return n.prototype.invalidate.call(this)
                }, e.clear = function(t) {
                    void 0 === t && (t = !0);
                    for (var e, i = this._first; i;) e = i._next, this.remove(i), i = e;
                    return this._time = this._tTime = this._pTime = 0, t && (this.labels = {}), g(this)
                }, e.totalDuration = function(t) {
                    var e, i, n, r = 0,
                        a = this,
                        s = a._last,
                        o = 1e8;
                    if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t));
                    if (a._dirty) {
                        for (n = a.parent; s;) e = s._prev, s._dirty && s.totalDuration(), o < (i = s._start) && a._sort && s._ts && !a._lock ? (a._lock = 1, x(a, s, i - s._delay, 1)._lock = 0) : o = i, i < 0 && s._ts && (r -= i, (!n && !a._dp || n && n.smoothChildTiming) && (a._start += i / a._ts, a._time -= i, a._tTime -= i), a.shiftChildren(-i, !1, -Infinity), o = 0), s._end > r && s._ts && (r = s._end), s = e;
                        w(a, a === dt && a._time > r ? a._time : r, 1, 1), a._dirty = 0
                    }
                    return a._tDur
                }, t.updateRoot = function(t) {
                    if (dt._ts && (l(dt, y(t, dt)), yt = xe.frame), xe.frame >= se) {
                        se += Nt.autoSleep || 120;
                        var e = dt._first;
                        if ((!e || !e._ts) && Nt.autoSleep && xe._listeners.length < 2) {
                            for (; e && !e._ts;) e = e._next;
                            e || xe.sleep()
                        }
                    }
                }, t
            }(Le);
            V(Oe.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });

            function Fe(t, e, i, n, r, a) {
                var s, o, l, h;
                if (re[t] && !1 !== (s = new re[t]).init(r, s.rawVars ? e[t] : function(t, e, i, n, r) {
                        if (d(t) && (t = Re(t, r, e, i, n)), !E(t) || t.style && t.nodeType || qt(t) || Wt(t)) return R(t) ? Re(t, r, e, i, n) : t;
                        var a, s = {};
                        for (a in t) s[a] = Re(t[a], r, e, i, n);
                        return s
                    }(e[t], n, r, a, i), i, n, a) && (i._pt = o = new ei(i._pt, r, t, 0, 1, s.render, s, 0, s.priority), i !== bt))
                    for (l = i._ptLookup[i._targets.indexOf(r)], h = s._props.length; h--;) l[s._props[h]] = o;
                return s
            }
            var Ie, Ne = function(t, e, i, n, r, a, s, o, l) {
                    d(n) && (n = n(r || 0, t, a));
                    var h, u = t[e],
                        c = "get" !== i ? i : d(u) ? l ? t[e.indexOf("set") || !d(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u,
                        p = d(u) ? l ? qe : We : He;
                    if (R(n) && (~n.indexOf("random(") && (n = Q(n)), "=" === n.charAt(1) && (n = parseFloat(c) + parseFloat(n.substr(2)) * ("-" === n.charAt(0) ? -1 : 1) + (W(c) || 0))), c !== n) return isNaN(c * n) ? function(t, e, i, n, r, a, s) {
                        var o, l, h, u, c, p, d, f, m = new ei(this._pt, t, e, 0, 1, Ze, null, r),
                            g = 0,
                            v = 0;
                        for (m.b = i, m.e = n, i += "", (d = ~(n += "").indexOf("random(")) && (n = Q(n)), a && (a(f = [i, n], t, e), i = f[0], n = f[1]), l = i.match(Zt) || []; o = Zt.exec(n);) u = o[0], c = n.substring(g, o.index), h ? h = (h + 1) % 5 : "rgba(" === c.substr(-5) && (h = 1), u !== l[v++] && (p = parseFloat(l[v - 1]) || 0, m._pt = {
                            _next: m._pt,
                            p: c || 1 === v ? c : ",",
                            s: p,
                            c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - p,
                            m: h && h < 4 ? Math.round : 0
                        }, g = Zt.lastIndex);
                        return m.c = g < n.length ? n.substring(g, n.length) : "", m.fp = s, ($t.test(n) || d) && (m.e = 0), this._pt = m
                    }.call(this, t, e, c, n, p, o || Nt.stringFilter, l) : (h = new ei(this._pt, t, e, +c || 0, n - (c || 0), "boolean" == typeof u ? Je : Ye, 0, p), l && (h.fp = l), s && h.modifier(s, this, t), this._pt = h)
                },
                Be = function t(e, i) {
                    var n, r, a, s, o, l, h, u, c, p, d, f, m, g = e.vars,
                        v = g.ease,
                        y = g.startAt,
                        b = g.immediateRender,
                        x = g.lazy,
                        _ = g.onUpdate,
                        w = g.onUpdateParams,
                        S = g.callbackScope,
                        M = g.runBackwards,
                        T = g.yoyoEase,
                        C = g.keyframes,
                        A = g.autoRevert,
                        E = e._dur,
                        D = e._startAt,
                        P = e._targets,
                        L = e.parent,
                        k = L && "nested" === L.data ? L.parent._targets : P,
                        O = "auto" === e._overwrite,
                        F = e.timeline;
                    if (!F || C && v || (v = "none"), e._ease = Ce(v, Bt.ease), e._yEase = T ? Te(Ce(!0 === T ? v : T, Bt.ease)) : 0, T && e._yoyo && !e._repeat && (T = e._yEase, e._yEase = e._ease, e._ease = T), !F) {
                        if (f = (u = P[0] ? B(P[0]).harness : 0) && g[u.prop], n = U(g, ee), D && D.render(-1, !0).kill(), y) {
                            if (j(e._startAt = Ve.set(P, V({
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: L,
                                    immediateRender: !0,
                                    lazy: I(x),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: _,
                                    onUpdateParams: w,
                                    callbackScope: S,
                                    stagger: 0
                                }, y))), b)
                                if (0 < i) A || (e._startAt = 0);
                                else if (E && !(i < 0 && D)) return void(i && (e._zTime = i))
                        } else if (M && E)
                            if (D) A || (e._startAt = 0);
                            else if (i && (b = !1), a = V({
                                overwrite: !1,
                                data: "isFromStart",
                                lazy: b && I(x),
                                immediateRender: b,
                                stagger: 0,
                                parent: L
                            }, n), f && (a[u.prop] = f), j(e._startAt = Ve.set(P, a)), b) {
                            if (!i) return
                        } else t(e._startAt, Rt);
                        for (e._pt = 0, x = E && I(x) || x && !E, r = 0; r < P.length; r++) {
                            if (h = (o = P[r])._gsap || N(P)[r]._gsap, e._ptLookup[r] = p = {}, ne[h.id] && ie.length && G(), d = k === P ? r : k.indexOf(o), u && !1 !== (c = new u).init(o, f || n, e, d, k) && (e._pt = s = new ei(e._pt, o, c.name, 0, 1, c.render, c, 0, c.priority), c._props.forEach(function(t) {
                                    p[t] = s
                                }), c.priority && (l = 1)), !u || f)
                                for (a in n) re[a] && (c = Fe(a, n, e, d, o, k)) ? c.priority && (l = 1) : p[a] = s = Ne.call(e, o, a, "get", n[a], d, k, 0, g.stringFilter);
                            e._op && e._op[r] && e.kill(o, e._op[r]), O && e._pt && (Ie = e, dt.killTweensOf(o, p, e.globalTime(0)), m = !e.parent, Ie = 0), e._pt && x && (ne[h.id] = 1)
                        }
                        l && ti(e), e._onInit && e._onInit(e)
                    }
                    e._from = !F && !!g.runBackwards, e._onUpdate = _, e._initted = (!e._op || e._pt) && !m
                },
                Re = function(t, e, i, n, r) {
                    return d(t) ? t.call(e, i, n, r) : R(t) && ~t.indexOf("random(") ? Q(t) : t
                },
                ze = le + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
                Ge = (ze + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
                Ve = function(T) {
                    function r(t, e, i, n) {
                        var r;
                        "number" == typeof e && (i.duration = e, e = i, i = null);
                        var a, s, o, l, h, u, c, p, d = (r = T.call(this, n ? e : k(e), i) || this).vars,
                            f = d.duration,
                            m = d.delay,
                            g = d.immediateRender,
                            v = d.stagger,
                            y = d.overwrite,
                            b = d.keyframes,
                            x = d.defaults,
                            _ = d.scrollTrigger,
                            w = d.yoyoEase,
                            S = r.parent,
                            M = (qt(t) || Wt(t) ? A(t[0]) : "length" in e) ? [t] : fe(t);
                        if (r._targets = M.length ? N(M) : P(0, !Nt.nullTargetWarn) || [], r._ptLookup = [], r._overwrite = y, b || v || D(f) || D(m)) {
                            if (e = r.vars, (a = r.timeline = new Oe({
                                    data: "nested",
                                    defaults: x || {}
                                })).kill(), a.parent = C(r), b) V(a.vars.defaults, {
                                ease: "none"
                            }), b.forEach(function(t) {
                                return a.to(M, t, ">")
                            });
                            else {
                                if (l = M.length, c = v ? Y(v) : L, E(v))
                                    for (h in v) ~ze.indexOf(h) && ((p = p || {})[h] = v[h]);
                                for (s = 0; s < l; s++) {
                                    for (h in o = {}, e) Ge.indexOf(h) < 0 && (o[h] = e[h]);
                                    o.stagger = 0, w && (o.yoyoEase = w), p && he(o, p), u = M[s], o.duration = +Re(f, C(r), s, u, M), o.delay = (+Re(m, C(r), s, u, M) || 0) - r._delay, !v && 1 === l && o.delay && (r._delay = m = o.delay, r._start += m, o.delay = 0), a.to(u, o, c(s, u, M))
                                }
                                a.duration() ? f = m = 0 : r.timeline = 0
                            }
                            f || r.duration(f = a.duration())
                        } else r.timeline = 0;
                        return !0 === y && (Ie = C(r), dt.killTweensOf(M), Ie = 0), S && O(S, C(r)), (g || !f && !b && r._start === z(S._time) && I(g) && function t(e) {
                            return !e || e._ts && t(e.parent)
                        }(C(r)) && "nested" !== S.data) && (r._tTime = -Rt, r.render(Math.max(0, -m))), _ && F(C(r), _), r
                    }
                    i(r, T);
                    var t = r.prototype;
                    return t.render = function(t, e, i) {
                        var n, r, a, s, o, l, h, u, c, p = this._time,
                            d = this._tDur,
                            f = this._dur,
                            m = d - Rt < t && 0 <= t ? d : t < Rt ? 0 : t;
                        if (f) {
                            if (m !== this._tTime || !t || i || this._startAt && this._zTime < 0 != t < 0) {
                                if (n = m, u = this.timeline, this._repeat) {
                                    if (s = f + this._rDelay, n = z(m % s), m === d ? (a = this._repeat, n = f) : ((a = ~~(m / s)) && a === m / s && (n = f, a--), f < n && (n = f)), (l = this._yoyo && 1 & a) && (c = this._yEase, n = f - n), o = ue(this._tTime, s), n === p && !i && this._initted) return this;
                                    a !== o && (u && this._yEase && lt(u, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = i = 1, this.render(z(s * a), !0).invalidate()._lock = 0))
                                }
                                if (!this._initted) {
                                    if (_(this, t < 0 ? t : n, i, e)) return this._tTime = 0, this;
                                    if (f !== this._dur) return this.render(t, e, i)
                                }
                                for (this._tTime = m, this._time = n, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = h = (c || this._ease)(n / f), this._from && (this.ratio = h = 1 - h), !n || p || e || ge(this, "onStart"), r = this._pt; r;) r.r(h, r.d), r = r._next;
                                u && u.render(t < 0 ? t : !n && l ? -Rt : u._dur * h, e, i) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, i), ge(this, "onUpdate")), this._repeat && a !== o && this.vars.onRepeat && !e && this.parent && ge(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), !t && f || !(m === this._tDur && 0 < this._ts || !m && this._ts < 0) || j(this, 1), e || t < 0 && !p || !m && !p || (ge(this, m === d ? "onComplete" : "onReverseComplete", !0), !this._prom || m < d && 0 < this.timeScale() || this._prom()))
                            }
                        } else ! function(t, e, i, n) {
                            var r, a, s = t.ratio,
                                o = e < 0 || !e && s && !t._start && t._zTime > Rt && !t._dp._lock || (t._ts < 0 || t._dp._ts < 0) && "isFromStart" !== t.data && "isStart" !== t.data ? 0 : 1,
                                l = t._rDelay,
                                h = 0;
                            if (l && t._repeat && (h = pe(0, t._tDur, e), ue(h, l) !== (a = ue(t._tTime, l)) && (s = 1 - o, t.vars.repeatRefresh && t._initted && t.invalidate())), o !== s || n || t._zTime === Rt || !e && t._zTime) {
                                if (!t._initted && _(t, e, n, i)) return;
                                for (a = t._zTime, t._zTime = e || (i ? Rt : 0), i = i || e && !a, t.ratio = o, t._from && (o = 1 - o), t._time = 0, t._tTime = h, i || ge(t, "onStart"), r = t._pt; r;) r.r(o, r.d), r = r._next;
                                t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !i && ge(t, "onUpdate"), h && t._repeat && !i && t.parent && ge(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === o && (o && j(t, 1), i || (ge(t, o ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                            } else t._zTime || (t._zTime = e)
                        }(this, t, e, i);
                        return this
                    }, t.targets = function() {
                        return this._targets
                    }, t.invalidate = function() {
                        return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), T.prototype.invalidate.call(this)
                    }, t.kill = function(t, e) {
                        if (void 0 === e && (e = "all"), !(t || e && "all" !== e) && (this._lazy = 0, this.parent)) return et(this);
                        if (this.timeline) {
                            var i = this.timeline.totalDuration();
                            return this.timeline.killTweensOf(t, e, Ie && !0 !== Ie.vars.overwrite)._first || et(this), this.parent && i !== this.timeline.totalDuration() && w(this, this._dur * this.timeline._tDur / i, 0, 1), this
                        }
                        var n, r, a, s, o, l, h, u = this._targets,
                            c = t ? fe(t) : u,
                            p = this._ptLookup,
                            d = this._pt;
                        if ((!e || "all" === e) && function(t, e) {
                                for (var i = t.length, n = i === e.length; n && i-- && t[i] === e[i];);
                                return i < 0
                            }(u, c)) return "all" === e && (this._pt = 0), et(this);
                        for (n = this._op = this._op || [], "all" !== e && (R(e) && (o = {}, f(e, function(t) {
                                return o[t] = 1
                            }), e = o), e = function(t, e) {
                                var i, n, r, a, s = t[0] ? B(t[0]).harness : 0,
                                    o = s && s.aliases;
                                if (!o) return e;
                                for (n in i = he({}, e), o)
                                    if (n in i)
                                        for (r = (a = o[n].split(",")).length; r--;) i[a[r]] = i[n];
                                return i
                            }(u, e)), h = u.length; h--;)
                            if (~c.indexOf(u[h]))
                                for (o in r = p[h], "all" === e ? (n[h] = e, s = r, a = {}) : (a = n[h] = n[h] || {}, s = e), s)(l = r && r[o]) && ("kill" in l.d && !0 !== l.d.kill(o) || m(this, l, "_pt"), delete r[o]), "all" !== a && (a[o] = 1);
                        return this._initted && !this._pt && d && et(this), this
                    }, r.to = function(t, e, i) {
                        return new r(t, e, i)
                    }, r.from = function(t, e) {
                        return new r(t, o(arguments, 1))
                    }, r.delayedCall = function(t, e, i, n) {
                        return new r(e, 0, {
                            immediateRender: !1,
                            lazy: !1,
                            overwrite: !1,
                            delay: t,
                            onComplete: e,
                            onReverseComplete: e,
                            onCompleteParams: i,
                            onReverseCompleteParams: i,
                            callbackScope: n
                        })
                    }, r.fromTo = function(t, e, i) {
                        return new r(t, o(arguments, 2))
                    }, r.set = function(t, e) {
                        return e.duration = 0, e.repeatDelay || (e.repeat = 0), new r(t, e)
                    }, r.killTweensOf = function(t, e, i) {
                        return dt.killTweensOf(t, e, i)
                    }, r
                }(Le);
            V(Ve.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }), f("staggerTo,staggerFrom,staggerFromTo", function(i) {
                Ve[i] = function() {
                    var t = new Oe,
                        e = de.call(arguments, 0);
                    return e.splice("staggerFromTo" === i ? 5 : 4, 0, 0), t[i].apply(t, e)
                }
            });

            function Ue(t, e, i) {
                return t.setAttribute(e, i)
            }

            function je(t, e, i, n) {
                n.mSet(t, e, n.m.call(n.tween, i, n.mt), n)
            }
            var He = function(t, e, i) {
                    return t[e] = i
                },
                We = function(t, e, i) {
                    return t[e](i)
                },
                qe = function(t, e, i, n) {
                    return t[e](n.fp, i)
                },
                Xe = function(t, e) {
                    return d(t[e]) ? We : r(t[e]) && t.setAttribute ? Ue : He
                },
                Ye = function(t, e) {
                    return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e)
                },
                Je = function(t, e) {
                    return e.set(e.t, e.p, !!(e.s + e.c * t), e)
                },
                Ze = function(t, e) {
                    var i = e._pt,
                        n = "";
                    if (!t && e.b) n = e.b;
                    else if (1 === t && e.e) n = e.e;
                    else {
                        for (; i;) n = i.p + (i.m ? i.m(i.s + i.c * t) : Math.round(1e4 * (i.s + i.c * t)) / 1e4) + n, i = i._next;
                        n += e.c
                    }
                    e.set(e.t, e.p, n, e)
                },
                $e = function(t, e) {
                    for (var i = e._pt; i;) i.r(t, i.d), i = i._next
                },
                Ke = function(t, e, i, n) {
                    for (var r, a = this._pt; a;) r = a._next, a.p === n && a.modifier(t, e, i), a = r
                },
                Qe = function(t) {
                    for (var e, i, n = this._pt; n;) i = n._next, n.p === t && !n.op || n.op === t ? m(this, n, "_pt") : n.dep || (e = 1), n = i;
                    return !e
                },
                ti = function(t) {
                    for (var e, i, n, r, a = t._pt; a;) {
                        for (e = a._next, i = n; i && i.pr > a.pr;) i = i._next;
                        (a._prev = i ? i._prev : r) ? a._prev._next = a: n = a, (a._next = i) ? i._prev = a : r = a, a = e
                    }
                    t._pt = n
                },
                ei = (ii.prototype.modifier = function(t, e, i) {
                    this.mSet = this.mSet || this.set, this.set = je, this.m = t, this.mt = i, this.tween = e
                }, ii);

            function ii(t, e, i, n, r, a, s, o, l) {
                this.t = e, this.s = n, this.c = r, this.p = i, this.r = a || Ye, this.d = s || this, this.set = o || He, this.pr = l || 0, (this._next = t) && (t._prev = this)
            }
            f(le + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(t) {
                return ee[t] = 1
            }), Qt.TweenMax = Qt.TweenLite = Ve, Qt.TimelineLite = Qt.TimelineMax = Oe, dt = new Oe({
                sortChildren: !1,
                defaults: Bt,
                autoRemoveChildren: !0,
                id: "root",
                smoothChildTiming: !0
            }), Nt.stringFilter = st;
            var ni = {
                registerPlugin: function() {
                    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                    e.forEach(function(t) {
                        var e = (t = !t.name && t.default || t).name,
                            i = d(t),
                            n = e && !i && t.init ? function() {
                                this._props = []
                            } : t,
                            r = {
                                init: L,
                                render: $e,
                                add: Ne,
                                kill: Qe,
                                modifier: Ke,
                                rawVars: 0
                            },
                            a = {
                                targetTest: 0,
                                get: 0,
                                getSetter: Xe,
                                aliases: {},
                                register: 0
                            };
                        if (_e(), t !== n) {
                            if (re[e]) return;
                            V(n, V(U(t, r), a)), he(n.prototype, he(r, U(t, a))), re[n.prop = e] = n, t.targetTest && (oe.push(n), ee[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                        }
                        s(e, n), t.register && t.register(ai, n, ei)
                    })
                },
                timeline: function(t) {
                    return new Oe(t)
                },
                getTweensOf: function(t, e) {
                    return dt.getTweensOf(t, e)
                },
                getProperty: function(n, t, e, i) {
                    R(n) && (n = fe(n)[0]);
                    var r = B(n || {}).get,
                        a = e ? u : h;
                    return "native" === e && (e = ""), n ? t ? a((re[t] && re[t].get || r)(n, t, e, i)) : function(t, e, i) {
                        return a((re[t] && re[t].get || r)(n, t, e, i))
                    } : n
                },
                quickSetter: function(i, e, n) {
                    if (1 < (i = fe(i)).length) {
                        var r = i.map(function(t) {
                                return ai.quickSetter(t, e, n)
                            }),
                            a = r.length;
                        return function(t) {
                            for (var e = a; e--;) r[e](t)
                        }
                    }
                    i = i[0] || {};
                    var s = re[e],
                        o = B(i),
                        l = o.harness && (o.harness.aliases || {})[e] || e,
                        h = s ? function(t) {
                            var e = new s;
                            bt._pt = 0, e.init(i, n ? t + n : t, bt, 0, [i]), e.render(1, e), bt._pt && $e(1, bt)
                        } : o.set(i, l);
                    return s ? h : function(t) {
                        return h(i, l, n ? t + n : t, o, 1)
                    }
                },
                isTweening: function(t) {
                    return 0 < dt.getTweensOf(t, !0).length
                },
                defaults: function(t) {
                    return t && t.ease && (t.ease = Ce(t.ease, Bt.ease)), p(Bt, t || {})
                },
                config: function(t) {
                    return p(Nt, t || {})
                },
                registerEffect: function(t) {
                    var n = t.name,
                        r = t.effect,
                        e = t.plugins,
                        a = t.defaults,
                        i = t.extendTimeline;
                    (e || "").split(",").forEach(function(t) {
                        return t && !re[t] && !Qt[t] && P()
                    }), ae[n] = function(t, e, i) {
                        return r(fe(t), V(e || {}, a), i)
                    }, i && (Oe.prototype[n] = function(t, e, i) {
                        return this.add(ae[n](t, E(e) ? e : (i = e) && {}, this), i)
                    })
                },
                registerEase: function(t, e) {
                    we[t] = Ce(e)
                },
                parseEase: function(t, e) {
                    return arguments.length ? Ce(t, e) : we
                },
                getById: function(t) {
                    return dt.getById(t)
                },
                exportRoot: function(t, e) {
                    void 0 === t && (t = {});
                    var i, n, r = new Oe(t);
                    for (r.smoothChildTiming = I(t.smoothChildTiming), dt.remove(r), r._dp = 0, r._time = r._tTime = dt._time, i = dt._first; i;) n = i._next, !e && !i._dur && i instanceof Ve && i.vars.onComplete === i._targets[0] || x(r, i, i._start - i._delay), i = n;
                    return x(dt, r, 0), r
                },
                utils: {
                    wrap: function t(e, i, n) {
                        var r = i - e;
                        return qt(e) ? K(e, t(0, e.length), i) : H(n, function(t) {
                            return (r + (t - e) % r) % r + e
                        })
                    },
                    wrapYoyo: function t(e, i, n) {
                        var r = i - e,
                            a = 2 * r;
                        return qt(e) ? K(e, t(0, e.length - 1), i) : H(n, function(t) {
                            return e + (r < (t = (a + (t - e) % a) % a || 0) ? a - t : t)
                        })
                    },
                    distribute: Y,
                    random: $,
                    snap: Z,
                    normalize: function(t, e, i) {
                        return me(t, e, 0, 1, i)
                    },
                    getUnit: W,
                    clamp: function(e, i, t) {
                        return H(t, function(t) {
                            return pe(e, i, t)
                        })
                    },
                    splitColor: nt,
                    toArray: fe,
                    mapRange: me,
                    pipe: function() {
                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                        return function(t) {
                            return e.reduce(function(t, e) {
                                return e(t)
                            }, t)
                        }
                    },
                    unitize: function(e, i) {
                        return function(t) {
                            return e(parseFloat(t)) + (i || W(t))
                        }
                    },
                    interpolate: function t(e, i, n, r) {
                        var a = isNaN(e + i) ? 0 : function(t) {
                            return (1 - t) * e + t * i
                        };
                        if (!a) {
                            var s, o, l, h, u, c = R(e),
                                p = {};
                            if (!0 === n && (r = 1) && (n = null), c) e = {
                                p: e
                            }, i = {
                                p: i
                            };
                            else if (qt(e) && !qt(i)) {
                                for (l = [], h = e.length, u = h - 2, o = 1; o < h; o++) l.push(t(e[o - 1], e[o]));
                                h--, a = function(t) {
                                    t *= h;
                                    var e = Math.min(u, ~~t);
                                    return l[e](t - e)
                                }, n = i
                            } else r || (e = he(qt(e) ? [] : {}, e));
                            if (!l) {
                                for (s in i) Ne.call(p, e, s, "get", i[s]);
                                a = function(t) {
                                    return $e(t, p) || (c ? e.p : e)
                                }
                            }
                        }
                        return H(n, a)
                    },
                    shuffle: X
                },
                install: n,
                effects: ae,
                ticker: xe,
                updateRoot: Oe.updateRoot,
                plugins: re,
                globalTimeline: dt,
                core: {
                    PropTween: ei,
                    globals: s,
                    Tween: Ve,
                    Timeline: Oe,
                    Animation: Le,
                    getCache: B,
                    _removeLinkedListItem: m
                }
            };
            f("to,from,fromTo,delayedCall,set,killTweensOf", function(t) {
                return ni[t] = Ve[t]
            }), xe.add(Oe.updateRoot), bt = ni.to({}, {
                duration: 0
            });

            function ri(t, r) {
                return {
                    name: t,
                    rawVars: 1,
                    init: function(t, n, e) {
                        e._onInit = function(t) {
                            var e, i;
                            if (R(n) && (e = {}, f(n, function(t) {
                                    return e[t] = 1
                                }), n = e), r) {
                                for (i in e = {}, n) e[i] = r(n[i]);
                                n = e
                            }! function(t, e) {
                                var i, n, r, a = t._targets;
                                for (i in e)
                                    for (n = a.length; n--;)(r = (r = t._ptLookup[n][i]) && r.d) && (r._pt && (r = function(t, e) {
                                        for (var i = t._pt; i && i.p !== e && i.op !== e && i.fp !== e;) i = i._next;
                                        return i
                                    }(r, i)), r && r.modifier && r.modifier(e[i], t, a[n], i))
                            }(t, n)
                        }
                    }
                }
            }
            var ai = ni.registerPlugin({
                name: "attr",
                init: function(t, e, i, n, r) {
                    var a, s;
                    for (a in e)(s = this.add(t, "setAttribute", (t.getAttribute(a) || 0) + "", e[a], n, r, 0, 0, a)) && (s.op = a), this._props.push(a)
                }
            }, {
                name: "endArray",
                init: function(t, e) {
                    for (var i = e.length; i--;) this.add(t, i, t[i] || 0, e[i])
                }
            }, ri("roundProps", J), ri("modifiers"), ri("snap", Z)) || ni;
            Ve.version = Oe.version = ai.version = "3.5.1", vt = 1, e() && _e();

            function si(t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            }

            function oi(t, e) {
                return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            }

            function li(t, e) {
                return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
            }

            function hi(t, e) {
                var i = e.s + e.c * t;
                e.set(e.t, e.p, ~~(i + (i < 0 ? -.5 : .5)) + e.u, e)
            }

            function ui(t, e) {
                return e.set(e.t, e.p, t ? e.e : e.b, e)
            }

            function ci(t, e) {
                return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
            }

            function pi(t, e, i) {
                return t.style[e] = i
            }

            function di(t, e, i) {
                return t.style.setProperty(e, i)
            }

            function fi(t, e, i) {
                return t._gsap[e] = i
            }

            function mi(t, e, i) {
                return t._gsap.scaleX = t._gsap.scaleY = i
            }

            function gi(t, e, i, n, r) {
                var a = t._gsap;
                a.scaleX = a.scaleY = i, a.renderTransform(r, a)
            }

            function vi(t, e, i, n, r) {
                var a = t._gsap;
                a[e] = i, a.renderTransform(r, a)
            }

            function yi(t, e) {
                var i = Ni.createElementNS ? Ni.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Ni.createElement(t);
                return i.style ? i : Ni.createElement(t)
            }

            function bi(t, e, i) {
                var n = getComputedStyle(t);
                return n[e] || n.getPropertyValue(e.replace(pn, "-$1").toLowerCase()) || n.getPropertyValue(e) || !i && bi(t, bn(e) || e, 1) || ""
            }

            function xi() {
                "undefined" != typeof window && window.document && (Bi = (Ni = window.document).documentElement, zi = yi("div") || {
                    style: {}
                }, Gi = yi("div"), gn = bn(gn), vn = gn + "Origin", zi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Ui = !!bn("perspective"), Ri = 1)
            }

            function _i(t) {
                var e, i = yi("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    n = this.parentNode,
                    r = this.nextSibling,
                    a = this.style.cssText;
                if (Bi.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                    e = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = _i
                } catch (t) {} else this._gsapBBox && (e = this._gsapBBox());
                return n && (r ? n.insertBefore(this, r) : n.appendChild(this)), Bi.removeChild(i), this.style.cssText = a, e
            }

            function wi(t, e) {
                for (var i = e.length; i--;)
                    if (t.hasAttribute(e[i])) return t.getAttribute(e[i])
            }

            function Si(e) {
                var i;
                try {
                    i = e.getBBox()
                } catch (t) {
                    i = _i.call(e, !0)
                }
                return i && (i.width || i.height) || e.getBBox === _i || (i = _i.call(e, !0)), !i || i.width || i.x || i.y ? i : {
                    x: +wi(e, ["x", "cx", "x1"]) || 0,
                    y: +wi(e, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            }

            function Mi(t) {
                return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Si(t))
            }

            function Ti(t, e) {
                var i;
                e && (i = t.style, e in ln && e !== vn && (e = gn), i.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), i.removeProperty(e.replace(pn, "-$1").toLowerCase())) : i.removeAttribute(e))
            }

            function Ci(t, e, i, n, r, a) {
                var s = new ei(t._pt, e, i, 0, 1, a ? ci : ui);
                return (t._pt = s).b = n, s.e = r, t._props.push(i), s
            }

            function Ai(t, e, i, n) {
                var r, a, s, o, l = parseFloat(i) || 0,
                    h = (i + "").trim().substr((l + "").length) || "px",
                    u = zi.style,
                    c = dn.test(e),
                    p = "svg" === t.tagName.toLowerCase(),
                    d = (p ? "client" : "offset") + (c ? "Width" : "Height"),
                    f = "px" === n,
                    m = "%" === n;
                return n === h || !l || xn[n] || xn[h] ? l : ("px" === h || f || (l = Ai(t, e, i, "px")), o = t.getCTM && Mi(t), m && (ln[e] || ~e.indexOf("adius")) ? z(l / (o ? t.getBBox()[c ? "width" : "height"] : t[d]) * 100) : (u[c ? "width" : "height"] = 100 + (f ? h : n), a = ~e.indexOf("adius") || "em" === n && t.appendChild && !p ? t : t.parentNode, o && (a = (t.ownerSVGElement || {}).parentNode), a && a !== Ni && a.appendChild || (a = Ni.body), (s = a._gsap) && m && s.width && c && s.time === xe.time ? z(l / s.width * 100) : (!m && "%" !== h || (u.position = bi(t, "position")), a === t && (u.position = "static"), a.appendChild(zi), r = zi[d], a.removeChild(zi), u.position = "absolute", c && m && ((s = B(a)).time = xe.time, s.width = a[d]), z(f ? r * l / 100 : r && l ? 100 / r * l : 0))))
            }

            function Ei(t, e, i, n) {
                var r;
                return Ri || xi(), e in mn && "transform" !== e && ~(e = mn[e]).indexOf(",") && (e = e.split(",")[0]), ln[e] && "transform" !== e ? (r = Tn(t, n), r = "transformOrigin" !== e ? r[e] : Cn(bi(t, vn)) + " " + r.zOrigin + "px") : (r = t.style[e]) && "auto" !== r && !n && !~(r + "").indexOf("calc(") || (r = wn[e] && wn[e](t, e, i) || bi(t, e) || a(t, e) || ("opacity" === e ? 1 : 0)), i && !~(r + "").indexOf(" ") ? Ai(t, e, r, i) + i : r
            }

            function Di(t, e, i, n) {
                var r, a;
                i && "none" !== i || ((a = (r = bn(e, t, 1)) && bi(t, r, 1)) && a !== i ? (e = r, i = a) : "borderColor" === e && (i = bi(t, "borderTopColor")));
                var s, o, l, h, u, c, p, d, f, m, g, v, y = new ei(this._pt, t.style, e, 0, 1, Ze),
                    b = 0,
                    x = 0;
                if (y.b = i, y.e = n, i += "", "auto" === (n += "") && (t.style[e] = n, n = bi(t, e) || n, t.style[e] = i), st(s = [i, n]), n = s[1], l = (i = s[0]).match(Jt) || [], (n.match(Jt) || []).length) {
                    for (; o = Jt.exec(n);) p = o[0], f = n.substring(b, o.index), u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1), p !== (c = l[x++] || "") && (h = parseFloat(c) || 0, g = c.substr((h + "").length), (v = "=" === p.charAt(1) ? +(p.charAt(0) + "1") : 0) && (p = p.substr(2)), d = parseFloat(p), m = p.substr((d + "").length), b = Jt.lastIndex - m.length, m || (m = m || Nt.units[e] || g, b === n.length && (n += m, y.e += m)), g !== m && (h = Ai(t, e, c, m) || 0), y._pt = {
                        _next: y._pt,
                        p: f || 1 === x ? f : ",",
                        s: h,
                        c: v ? v * d : d - h,
                        m: u && u < 4 ? Math.round : 0
                    });
                    y.c = b < n.length ? n.substring(b, n.length) : ""
                } else y.r = "display" === e && "none" === n ? ci : ui;
                return $t.test(n) && (y.e = 0), this._pt = y
            }

            function Pi(t, e) {
                if (e.tween && e.tween._time === e.tween._dur) {
                    var i, n, r, a = e.t,
                        s = a.style,
                        o = e.u,
                        l = a._gsap;
                    if ("all" === o || !0 === o) s.cssText = "", n = 1;
                    else
                        for (r = (o = o.split(",")).length; - 1 < --r;) i = o[r], ln[i] && (n = 1, i = "transformOrigin" === i ? vn : gn), Ti(a, i);
                    n && (Ti(a, gn), l && (l.svg && a.removeAttribute("transform"), Tn(a, 1), l.uncache = 1))
                }
            }

            function Li(t) {
                return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
            }

            function ki(t) {
                var e = bi(t, gn);
                return Li(e) ? Sn : e.substr(7).match(Yt).map(z)
            }

            function Oi(t, e) {
                var i, n, r, a, s = t._gsap || B(t),
                    o = t.style,
                    l = ki(t);
                return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Sn : l : (l !== Sn || t.offsetParent || t === Bi || s.svg || (r = o.display, o.display = "block", (i = t.parentNode) && t.offsetParent || (a = 1, n = t.nextSibling, Bi.appendChild(t)), l = ki(t), r ? o.display = r : Ti(t, "display"), a && (n ? i.insertBefore(t, n) : i ? i.appendChild(t) : Bi.removeChild(t))), e && 6 < l.length ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
            }

            function Fi(t, e, i, n, r, a) {
                var s, o, l, h = t._gsap,
                    u = r || Oi(t, !0),
                    c = h.xOrigin || 0,
                    p = h.yOrigin || 0,
                    d = h.xOffset || 0,
                    f = h.yOffset || 0,
                    m = u[0],
                    g = u[1],
                    v = u[2],
                    y = u[3],
                    b = u[4],
                    x = u[5],
                    _ = e.split(" "),
                    w = parseFloat(_[0]) || 0,
                    S = parseFloat(_[1]) || 0;
                i ? u !== Sn && (o = m * y - g * v) && (l = w * (-g / o) + S * (m / o) - (m * x - g * b) / o, w = w * (y / o) + S * (-v / o) + (v * x - y * b) / o, S = l) : (w = (s = Si(t)).x + (~_[0].indexOf("%") ? w / 100 * s.width : w), S = s.y + (~(_[1] || _[0]).indexOf("%") ? S / 100 * s.height : S)), n || !1 !== n && h.smooth ? (b = w - c, x = S - p, h.xOffset = d + (b * m + x * v) - b, h.yOffset = f + (b * g + x * y) - x) : h.xOffset = h.yOffset = 0, h.xOrigin = w, h.yOrigin = S, h.smooth = !!n, h.origin = e, h.originIsAbsolute = !!i, t.style[vn] = "0px 0px", a && (Ci(a, h, "xOrigin", c, w), Ci(a, h, "yOrigin", p, S), Ci(a, h, "xOffset", d, h.xOffset), Ci(a, h, "yOffset", f, h.yOffset)), t.setAttribute("data-svg-origin", w + " " + S)
            }

            function Ii(t, e, i) {
                var n = W(e);
                return z(parseFloat(e) + parseFloat(Ai(t, "x", i + "px", n))) + n
            }
            var Ni, Bi, Ri, zi, Gi, Vi, Ui, ji = we.Power0,
                Hi = we.Power1,
                Wi = we.Power2,
                qi = we.Power3,
                Xi = we.Power4,
                Yi = we.Linear,
                Ji = we.Quad,
                Zi = we.Cubic,
                $i = we.Quart,
                Ki = we.Quint,
                Qi = we.Strong,
                tn = we.Elastic,
                en = we.Back,
                nn = we.SteppedEase,
                rn = we.Bounce,
                an = we.Sine,
                sn = we.Expo,
                on = we.Circ,
                ln = {},
                hn = 180 / Math.PI,
                un = Math.PI / 180,
                cn = Math.atan2,
                pn = /([A-Z])/g,
                dn = /(?:left|right|width|margin|padding|x)/i,
                fn = /[\s,\(]\S/,
                mn = {
                    autoAlpha: "opacity,visibility",
                    scale: "scaleX,scaleY",
                    alpha: "opacity"
                },
                gn = "transform",
                vn = gn + "Origin",
                yn = "O,Moz,ms,Ms,Webkit".split(","),
                bn = function(t, e, i) {
                    var n = (e || zi).style,
                        r = 5;
                    if (t in n && !i) return t;
                    for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(yn[r] + t in n););
                    return r < 0 ? null : (3 === r ? "ms" : 0 <= r ? yn[r] : "") + t
                },
                xn = {
                    deg: 1,
                    rad: 1,
                    turn: 1
                },
                _n = {
                    top: "0%",
                    bottom: "100%",
                    left: "0%",
                    right: "100%",
                    center: "50%"
                },
                wn = {
                    clearProps: function(t, e, i, n, r) {
                        if ("isFromStart" !== r.data) {
                            var a = t._pt = new ei(t._pt, e, i, 0, 0, Pi);
                            return a.u = n, a.pr = -10, a.tween = r, t._props.push(i), 1
                        }
                    }
                },
                Sn = [1, 0, 0, 1, 0, 0],
                Mn = {},
                Tn = function(t, e) {
                    var i = t._gsap || new Pe(t);
                    if ("x" in i && !e && !i.uncache) return i;
                    var n, r, a, s, o, l, h, u, c, p, d, f, m, g, v, y, b, x, _, w, S, M, T, C, A, E, D, P, L, k = t.style,
                        O = i.scaleX < 0,
                        F = bi(t, vn) || "0",
                        I = n = r = s = o = l = h = u = 0,
                        N = a = 1;
                    return i.svg = !(!t.getCTM || !Mi(t)), d = Oi(t, i.svg), i.svg && (S = !i.uncache && t.getAttribute("data-svg-origin"), Fi(t, S || F, !!S || i.originIsAbsolute, !1 !== i.smooth, d)), c = i.xOrigin || 0, p = i.yOrigin || 0, d !== Sn && (v = d[0], y = d[1], b = d[2], x = d[3], I = _ = d[4], n = w = d[5], 6 === d.length ? (N = Math.sqrt(v * v + y * y), a = Math.sqrt(x * x + b * b), s = v || y ? cn(y, v) * hn : 0, (h = b || x ? cn(b, x) * hn + s : 0) && (a *= Math.cos(h * un)), i.svg && (I -= c - (c * v + p * b), n -= p - (c * y + p * x))) : (L = d[6], D = d[7], C = d[8], A = d[9], E = d[10], P = d[11], I = d[12], n = d[13], r = d[14], o = (f = cn(L, E)) * hn, f && (S = _ * (m = Math.cos(-f)) + C * (g = Math.sin(-f)), M = w * m + A * g, T = L * m + E * g, C = _ * -g + C * m, A = w * -g + A * m, E = L * -g + E * m, P = D * -g + P * m, _ = S, w = M, L = T), l = (f = cn(-b, E)) * hn, f && (m = Math.cos(-f), P = x * (g = Math.sin(-f)) + P * m, v = S = v * m - C * g, y = M = y * m - A * g, b = T = b * m - E * g), s = (f = cn(y, v)) * hn, f && (S = v * (m = Math.cos(f)) + y * (g = Math.sin(f)), M = _ * m + w * g, y = y * m - v * g, w = w * m - _ * g, v = S, _ = M), o && 359.9 < Math.abs(o) + Math.abs(s) && (o = s = 0, l = 180 - l), N = z(Math.sqrt(v * v + y * y + b * b)), a = z(Math.sqrt(w * w + L * L)), f = cn(_, w), h = 2e-4 < Math.abs(f) ? f * hn : 0, u = P ? 1 / (P < 0 ? -P : P) : 0), i.svg && (S = t.getAttribute("transform"), i.forceCSS = t.setAttribute("transform", "") || !Li(bi(t, gn)), S && t.setAttribute("transform", S))), 90 < Math.abs(h) && Math.abs(h) < 270 && (O ? (N *= -1, h += s <= 0 ? 180 : -180, s += s <= 0 ? 180 : -180) : (a *= -1, h += h <= 0 ? 180 : -180)), i.x = ((i.xPercent = I && Math.round(t.offsetWidth / 2) === Math.round(-I) ? -50 : 0) ? 0 : I) + "px", i.y = ((i.yPercent = n && Math.round(t.offsetHeight / 2) === Math.round(-n) ? -50 : 0) ? 0 : n) + "px", i.z = r + "px", i.scaleX = z(N), i.scaleY = z(a), i.rotation = z(s) + "deg", i.rotationX = z(o) + "deg", i.rotationY = z(l) + "deg", i.skewX = h + "deg", i.skewY = "0deg", i.transformPerspective = u + "px", (i.zOrigin = parseFloat(F.split(" ")[2]) || 0) && (k[vn] = Cn(F)), i.xOffset = i.yOffset = 0, i.force3D = Nt.force3D, i.renderTransform = i.svg ? Pn : Ui ? Dn : An, i.uncache = 0, i
                },
                Cn = function(t) {
                    return (t = t.split(" "))[0] + " " + t[1]
                },
                An = function(t, e) {
                    e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, Dn(t, e)
                },
                En = "0deg",
                Dn = function(t, e) {
                    var i, n, r, a, s = e || this,
                        o = s.xPercent,
                        l = s.yPercent,
                        h = s.x,
                        u = s.y,
                        c = s.z,
                        p = s.rotation,
                        d = s.rotationY,
                        f = s.rotationX,
                        m = s.skewX,
                        g = s.skewY,
                        v = s.scaleX,
                        y = s.scaleY,
                        b = s.transformPerspective,
                        x = s.force3D,
                        _ = s.target,
                        w = s.zOrigin,
                        S = "",
                        M = "auto" === x && t && 1 !== t || !0 === x;
                    !w || f === En && d === En || (r = parseFloat(d) * un, i = Math.sin(r), n = Math.cos(r), r = parseFloat(f) * un, a = Math.cos(r), h = Ii(_, h, i * a * -w), u = Ii(_, u, -Math.sin(r) * -w), c = Ii(_, c, n * a * -w + w)), "0px" !== b && (S += "perspective(" + b + ") "), (o || l) && (S += "translate(" + o + "%, " + l + "%) "), !M && "0px" === h && "0px" === u && "0px" === c || (S += "0px" !== c || M ? "translate3d(" + h + ", " + u + ", " + c + ") " : "translate(" + h + ", " + u + ") "), p !== En && (S += "rotate(" + p + ") "), d !== En && (S += "rotateY(" + d + ") "), f !== En && (S += "rotateX(" + f + ") "), m === En && g === En || (S += "skew(" + m + ", " + g + ") "), 1 === v && 1 === y || (S += "scale(" + v + ", " + y + ") "), _.style[gn] = S || "translate(0, 0)"
                },
                Pn = function(t, e) {
                    var i, n, r, a, s, o = e || this,
                        l = o.xPercent,
                        h = o.yPercent,
                        u = o.x,
                        c = o.y,
                        p = o.rotation,
                        d = o.skewX,
                        f = o.skewY,
                        m = o.scaleX,
                        g = o.scaleY,
                        v = o.target,
                        y = o.xOrigin,
                        b = o.yOrigin,
                        x = o.xOffset,
                        _ = o.yOffset,
                        w = o.forceCSS,
                        S = parseFloat(u),
                        M = parseFloat(c),
                        p = parseFloat(p),
                        d = parseFloat(d);
                    (f = parseFloat(f)) && (d += f = parseFloat(f), p += f), p || d ? (p *= un, d *= un, i = Math.cos(p) * m, n = Math.sin(p) * m, r = Math.sin(p - d) * -g, a = Math.cos(p - d) * g, d && (f *= un, s = Math.tan(d - f), r *= s = Math.sqrt(1 + s * s), a *= s, f && (s = Math.tan(f), i *= s = Math.sqrt(1 + s * s), n *= s)), i = z(i), n = z(n), r = z(r), a = z(a)) : (i = m, a = g, n = r = 0), (S && !~(u + "").indexOf("px") || M && !~(c + "").indexOf("px")) && (S = Ai(v, "x", u, "px"), M = Ai(v, "y", c, "px")), (y || b || x || _) && (S = z(S + y - (y * i + b * r) + x), M = z(M + b - (y * n + b * a) + _)), (l || h) && (s = v.getBBox(), S = z(S + l / 100 * s.width), M = z(M + h / 100 * s.height)), s = "matrix(" + i + "," + n + "," + r + "," + a + "," + S + "," + M + ")", v.setAttribute("transform", s), w && (v.style[gn] = s)
                };
            f("padding,margin,Width,Radius", function(e, i) {
                var t = "Bottom",
                    o = (i < 3 ? ["Top", "Right", t, "Left"] : ["TopLeft", "TopRight", t + "Right", t + "Left"]).map(function(t) {
                        return i < 2 ? e + t : "border" + t + e
                    });
                wn[1 < i ? "border" + e : e] = function(e, t, i, n, r) {
                    var a, s;
                    if (arguments.length < 4) return a = o.map(function(t) {
                        return Ei(e, t, i)
                    }), 5 === (s = a.join(" ")).split(a[0]).length ? a[0] : s;
                    a = (n + "").split(" "), s = {}, o.forEach(function(t, e) {
                        return s[t] = a[e] = a[e] || a[(e - 1) / 2 | 0]
                    }), e.init(t, s, r)
                }
            });
            var Ln, kn, On, Fn = {
                name: "css",
                register: xi,
                targetTest: function(t) {
                    return t.style && t.nodeType
                },
                init: function(t, e, i, n, r) {
                    var a, s, o, l, h, u, c, p, d, f, m, g, v, y, b, x, _, w, S, M, T, C, A, E, D, P, L, k, O, F, I, N = this._props,
                        B = t.style;
                    for (c in Ri || xi(), e)
                        if ("autoRound" !== c && (s = e[c], !re[c] || !Fe(c, e, i, n, t, r)))
                            if (h = Bn(s), u = wn[c], "function" === h && (h = Bn(s = s.call(i, n, t, r))), "string" === h && ~s.indexOf("random(") && (s = Q(s)), u) u(this, t, c, s, i) && (b = 1);
                            else if ("--" === c.substr(0, 2)) this.add(B, "setProperty", getComputedStyle(t).getPropertyValue(c) + "", s + "", n, r, 0, 0, c);
                    else if ("undefined" !== h) {
                        if (a = Ei(t, c), l = parseFloat(a), (f = "string" === h && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)), o = parseFloat(s), c in mn && ("autoAlpha" === c && (1 === l && "hidden" === Ei(t, "visibility") && o && (l = 0), Ci(this, B, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== c && "transform" !== c && ~(c = mn[c]).indexOf(",") && (c = c.split(",")[0])), m = c in ln)
                            if (g || ((v = t._gsap).renderTransform || Tn(t), y = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new ei(this._pt, B, gn, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === c) this._pt = new ei(this._pt, v, "scaleY", v.scaleY, f ? f * o : o - v.scaleY), N.push("scaleY", c), c += "X";
                            else {
                                if ("transformOrigin" === c) {
                                    I = F = O = void 0, O = (k = s).split(" "), F = O[0], I = O[1] || "50%", "top" !== F && "bottom" !== F && "left" !== I && "right" !== I || (k = F, F = I, I = k), O[0] = _n[F] || F, O[1] = _n[I] || I, s = O.join(" "), v.svg ? Fi(t, s, 0, y, 0, this) : ((d = parseFloat(s.split(" ")[2]) || 0) !== v.zOrigin && Ci(this, v, "zOrigin", v.zOrigin, d), Ci(this, B, c, Cn(a), Cn(s)));
                                    continue
                                }
                                if ("svgOrigin" === c) {
                                    Fi(t, s, 1, y, 0, this);
                                    continue
                                }
                                if (c in Mn) {
                                    x = this, _ = v, w = c, S = l, T = f, P = A = C = void 0, E = R(M = s), D = parseFloat(M) * (E && ~M.indexOf("rad") ? hn : 1), L = S + (P = T ? D * T : D - S) + "deg", E && ("short" === (C = M.split("_")[1]) && (P %= 360) != P % 180 && (P += P < 0 ? 360 : -360), "cw" === C && P < 0 ? P = (P + 36e9) % 360 - 360 * ~~(P / 360) : "ccw" === C && 0 < P && (P = (P - 36e9) % 360 - 360 * ~~(P / 360))), x._pt = A = new ei(x._pt, _, w, S, P, oi), A.e = L, A.u = "deg", x._props.push(w);
                                    continue
                                }
                                if ("smoothOrigin" === c) {
                                    Ci(this, v, "smooth", v.smooth, s);
                                    continue
                                }
                                if ("force3D" === c) {
                                    v[c] = s;
                                    continue
                                }
                                if ("transform" === c) {
                                    ! function(t, e, i) {
                                        var n, r, a, s, o, l, h, u = Gi.style,
                                            c = i._gsap;
                                        for (r in u.cssText = getComputedStyle(i).cssText + ";position:absolute;display:block;", u[gn] = e, Ni.body.appendChild(Gi), n = Tn(Gi, 1), ln)(a = c[r]) !== (s = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = W(a) !== (h = W(s)) ? Ai(i, r, a, h) : parseFloat(a), l = parseFloat(s), t._pt = new ei(t._pt, c, r, o, l - o, si), t._pt.u = h || 0, t._props.push(r));
                                        Ni.body.removeChild(Gi)
                                    }(this, s, t);
                                    continue
                                }
                            }
                        else c in B || (c = bn(c) || c);
                        if (m || (o || 0 === o) && (l || 0 === l) && !fn.test(s) && c in B) o = o || 0, (p = (a + "").substr((l + "").length)) !== (d = W(s) || (c in Nt.units ? Nt.units[c] : p)) && (l = Ai(t, c, a, d)), this._pt = new ei(this._pt, m ? v : B, c, l, f ? f * o : o - l, "px" !== d || !1 === e.autoRound || m ? si : hi), this._pt.u = d || 0, p !== d && (this._pt.b = a, this._pt.r = li);
                        else if (c in B) Di.call(this, t, c, a, s);
                        else {
                            if (!(c in t)) continue;
                            this.add(t, c, t[c], s, n, r)
                        }
                        N.push(c)
                    }
                    b && ti(this)
                },
                get: Ei,
                aliases: mn,
                getSetter: function(t, e, i) {
                    var n = mn[e];
                    return n && n.indexOf(",") < 0 && (e = n), e in ln && e !== vn && (t._gsap.x || Ei(t, "x")) ? i && Vi === i ? "scale" === e ? mi : fi : (Vi = i || {}) && ("scale" === e ? gi : vi) : t.style && !r(t.style[e]) ? pi : ~e.indexOf("-") ? di : Xe(t, e)
                },
                core: {
                    _removeProperty: Ti,
                    _getMatrix: Oi
                }
            };
            ai.utils.checkPrefix = bn, On = f((Ln = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (kn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function(t) {
                ln[t] = 1
            }), f(kn, function(t) {
                Nt.units[t] = "deg", Mn[t] = 1
            }), mn[On[13]] = Ln + "," + kn, f("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function(t) {
                var e = t.split(":");
                mn[e[1]] = On[e[0]]
            }), f("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(t) {
                Nt.units[t] = "px"
            }), ai.registerPlugin(Fn);
            var In = ai.registerPlugin(Fn) || ai,
                Nn = In.core.Tween;
            t.Back = en, t.Bounce = rn, t.CSSPlugin = Fn, t.Circ = on, t.Cubic = Zi, t.Elastic = tn, t.Expo = sn, t.Linear = Yi, t.Power0 = ji, t.Power1 = Hi, t.Power2 = Wi, t.Power3 = qi, t.Power4 = Xi, t.Quad = Ji, t.Quart = $i, t.Quint = Ki, t.Sine = an, t.SteppedEase = nn, t.Strong = Qi, t.TimelineLite = Oe, t.TimelineMax = Oe, t.TweenLite = Ve, t.TweenMax = Nn, t.default = In, t.gsap = In, "undefined" == typeof window || window !== t ? Object.defineProperty(t, "__esModule", {
                value: !0
            }) : delete window.default
        }, "object" === ((n = void 0) === i ? "undefined" : Bn(i)) && void 0 !== e ? r(i) : "function" == typeof define && define.amd ? define(["exports"], r) : r((n = n || self).window = n.window || {})
    }, {}],
    is_js: [function(t, e, i) {
        (function(w) {
            "use strict";

            function S(t) {
                return (S = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                })(t)
            }
            var t;
            t = function() {
                var a = {
                        VERSION: "0.8.0",
                        not: {},
                        all: {},
                        any: {}
                    },
                    n = Object.prototype.toString,
                    i = Array.prototype.slice,
                    r = Object.prototype.hasOwnProperty;

                function s(t) {
                    return function() {
                        return !t.apply(null, i.call(arguments))
                    }
                }
                var o = {
                    "<": function(t, e) {
                        return t < e
                    },
                    "<=": function(t, e) {
                        return t <= e
                    },
                    ">": function(t, e) {
                        return e < t
                    },
                    ">=": function(t, e) {
                        return e <= t
                    }
                };

                function l(t, e) {
                    var i = e + "",
                        n = +(i.match(/\d+/) || NaN),
                        r = i.match(/^[<>]=?|/)[0];
                    return o[r] ? o[r](t, n) : t == n || n != n
                }

                function h(t) {
                    var e = i.call(t);
                    return 1 === e.length && a.array(e[0]) && (e = e[0]), e
                }
                a.arguments = function(t) {
                    return "[object Arguments]" === n.call(t) || null != t && "object" === S(t) && "callee" in t
                }, a.array = Array.isArray || function(t) {
                    return "[object Array]" === n.call(t)
                }, a.boolean = function(t) {
                    return !0 === t || !1 === t || "[object Boolean]" === n.call(t)
                }, a.char = function(t) {
                    return a.string(t) && 1 === t.length
                }, a.date = function(t) {
                    return "[object Date]" === n.call(t)
                }, a.domNode = function(t) {
                    return a.object(t) && 0 < t.nodeType
                }, a.error = function(t) {
                    return "[object Error]" === n.call(t)
                }, a.function = function(t) {
                    return "[object Function]" === n.call(t) || "function" == typeof t
                }, a.json = function(t) {
                    return "[object Object]" === n.call(t)
                }, a.nan = function(t) {
                    return t != t
                }, a.null = function(t) {
                    return null === t
                }, a.number = function(t) {
                    return a.not.nan(t) && "[object Number]" === n.call(t)
                }, a.object = function(t) {
                    return Object(t) === t
                }, a.regexp = function(t) {
                    return "[object RegExp]" === n.call(t)
                }, a.sameType = function(t, e) {
                    var i = n.call(t);
                    return i === n.call(e) && ("[object Number]" !== i || (!a.any.nan(t, e) || a.all.nan(t, e)))
                }, a.sameType.api = ["not"], a.string = function(t) {
                    return "[object String]" === n.call(t)
                }, a.undefined = function(t) {
                    return void 0 === t
                }, a.windowObject = function(t) {
                    return null != t && "object" === S(t) && "setInterval" in t
                }, a.empty = function(t) {
                    if (a.object(t)) {
                        var e = Object.getOwnPropertyNames(t).length;
                        return 0 === e || 1 === e && a.array(t) || 2 === e && a.arguments(t) ? !0 : !1
                    }
                    return "" === t
                }, a.existy = function(t) {
                    return null != t
                }, a.falsy = function(t) {
                    return !t
                }, a.truthy = s(a.falsy), a.above = function(t, e) {
                    return a.all.number(t, e) && e < t
                }, a.above.api = ["not"], a.decimal = function(t) {
                    return a.number(t) && t % 1 != 0
                }, a.equal = function(t, e) {
                    return a.all.number(t, e) ? t === e && 1 / t == 1 / e : a.all.string(t, e) || a.all.regexp(t, e) ? "" + t == "" + e : !!a.all.boolean(t, e) && t === e
                }, a.equal.api = ["not"], a.even = function(t) {
                    return a.number(t) && t % 2 == 0
                }, a.finite = isFinite || function(t) {
                    return a.not.infinite(t) && a.not.nan(t)
                }, a.infinite = function(t) {
                    return t === 1 / 0 || t === -1 / 0
                }, a.integer = function(t) {
                    return a.number(t) && t % 1 == 0
                }, a.negative = function(t) {
                    return a.number(t) && t < 0
                }, a.odd = function(t) {
                    return a.number(t) && t % 2 == 1
                }, a.positive = function(t) {
                    return a.number(t) && 0 < t
                }, a.under = function(t, e) {
                    return a.all.number(t, e) && t < e
                }, a.under.api = ["not"], a.within = function(t, e, i) {
                    return a.all.number(t, e, i) && e < t && t < i
                }, a.within.api = ["not"];
                var u = {
                    affirmative: /^(?:1|t(?:rue)?|y(?:es)?|ok(?:ay)?)$/,
                    alphaNumeric: /^[A-Za-z0-9]+$/,
                    caPostalCode: /^(?!.*[DFIOQU])[A-VXY][0-9][A-Z]\s?[0-9][A-Z][0-9]$/,
                    creditCard: /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/,
                    dateString: /^(1[0-2]|0?[1-9])([\/-])(3[01]|[12][0-9]|0?[1-9])(?:\2)(?:[0-9]{2})?[0-9]{2}$/,
                    email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i,
                    eppPhone: /^\+[0-9]{1,3}\.[0-9]{4,14}(?:x.+)?$/,
                    hexadecimal: /^(?:0x)?[0-9a-fA-F]+$/,
                    hexColor: /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/,
                    ipv4: /^(?:(?:\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\.){3}(?:\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])$/,
                    ipv6: /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i,
                    nanpPhone: /^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/,
                    socialSecurityNumber: /^(?!000|666)[0-8][0-9]{2}-?(?!00)[0-9]{2}-?(?!0000)[0-9]{4}$/,
                    timeString: /^(2[0-3]|[01]?[0-9]):([0-5]?[0-9]):([0-5]?[0-9])$/,
                    ukPostCode: /^[A-Z]{1,2}[0-9RCHNQ][0-9A-Z]?\s?[0-9][ABD-HJLNP-UW-Z]{2}$|^[A-Z]{2}-?[0-9]{4}$/,
                    url: /^(?:(?:https?|ftp):\/\/)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/\S*)?$/i,
                    usZipCode: /^[0-9]{5}(?:-[0-9]{4})?$/
                };
                for (var t in u) u.hasOwnProperty(t) && function(e, i) {
                    a[e] = function(t) {
                        return i[e].test(t)
                    }
                }(t, u);
                a.ip = function(t) {
                    return a.ipv4(t) || a.ipv6(t)
                }, a.capitalized = function(t) {
                    if (a.not.string(t)) return !1;
                    for (var e = t.split(" "), i = 0; i < e.length; i++) {
                        var n = e[i];
                        if (n.length) {
                            var r = n.charAt(0);
                            if (r !== r.toUpperCase()) return !1
                        }
                    }
                    return !0
                }, a.endWith = function(t, e) {
                    if (a.not.string(t)) return !1;
                    e += "";
                    var i = t.length - e.length;
                    return 0 <= i && t.indexOf(e, i) === i
                }, a.endWith.api = ["not"], a.include = function(t, e) {
                    return -1 < t.indexOf(e)
                }, a.include.api = ["not"], a.lowerCase = function(t) {
                    return a.string(t) && t === t.toLowerCase()
                }, a.palindrome = function(t) {
                    if (a.not.string(t)) return !1;
                    for (var e = (t = t.replace(/[^a-zA-Z0-9]+/g, "").toLowerCase()).length - 1, i = 0, n = Math.floor(e / 2); i <= n; i++)
                        if (t.charAt(i) !== t.charAt(e - i)) return !1;
                    return !0
                }, a.space = function(t) {
                    if (a.not.char(t)) return !1;
                    var e = t.charCodeAt(0);
                    return 8 < e && e < 14 || 32 === e
                }, a.startWith = function(t, e) {
                    return a.string(t) && 0 === t.indexOf(e)
                }, a.startWith.api = ["not"], a.upperCase = function(t) {
                    return a.string(t) && t === t.toUpperCase()
                };
                var c = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"],
                    p = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
                a.day = function(t, e) {
                    return a.date(t) && e.toLowerCase() === c[t.getDay()]
                }, a.day.api = ["not"], a.dayLightSavingTime = function(t) {
                    var e = new Date(t.getFullYear(), 0, 1),
                        i = new Date(t.getFullYear(), 6, 1),
                        n = Math.max(e.getTimezoneOffset(), i.getTimezoneOffset());
                    return t.getTimezoneOffset() < n
                }, a.future = function(t) {
                    var e = new Date;
                    return a.date(t) && t.getTime() > e.getTime()
                }, a.inDateRange = function(t, e, i) {
                    if (a.not.date(t) || a.not.date(e) || a.not.date(i)) return !1;
                    var n = t.getTime();
                    return n > e.getTime() && n < i.getTime()
                }, a.inDateRange.api = ["not"], a.inLastMonth = function(t) {
                    return a.inDateRange(t, new Date((new Date).setMonth((new Date).getMonth() - 1)), new Date)
                }, a.inLastWeek = function(t) {
                    return a.inDateRange(t, new Date((new Date).setDate((new Date).getDate() - 7)), new Date)
                }, a.inLastYear = function(t) {
                    return a.inDateRange(t, new Date((new Date).setFullYear((new Date).getFullYear() - 1)), new Date)
                }, a.inNextMonth = function(t) {
                    return a.inDateRange(t, new Date, new Date((new Date).setMonth((new Date).getMonth() + 1)))
                }, a.inNextWeek = function(t) {
                    return a.inDateRange(t, new Date, new Date((new Date).setDate((new Date).getDate() + 7)))
                }, a.inNextYear = function(t) {
                    return a.inDateRange(t, new Date, new Date((new Date).setFullYear((new Date).getFullYear() + 1)))
                }, a.leapYear = function(t) {
                    return a.number(t) && (t % 4 == 0 && t % 100 != 0 || t % 400 == 0)
                }, a.month = function(t, e) {
                    return a.date(t) && e.toLowerCase() === p[t.getMonth()]
                }, a.month.api = ["not"], a.past = function(t) {
                    var e = new Date;
                    return a.date(t) && t.getTime() < e.getTime()
                }, a.quarterOfYear = function(t, e) {
                    return a.date(t) && a.number(e) && e === Math.floor((t.getMonth() + 3) / 3)
                }, a.quarterOfYear.api = ["not"], a.today = function(t) {
                    var e = (new Date).toDateString();
                    return a.date(t) && t.toDateString() === e
                }, a.tomorrow = function(t) {
                    var e = new Date,
                        i = new Date(e.setDate(e.getDate() + 1)).toDateString();
                    return a.date(t) && t.toDateString() === i
                }, a.weekend = function(t) {
                    return a.date(t) && (6 === t.getDay() || 0 === t.getDay())
                }, a.weekday = s(a.weekend), a.year = function(t, e) {
                    return a.date(t) && a.number(e) && e === t.getFullYear()
                }, a.year.api = ["not"], a.yesterday = function(t) {
                    var e = new Date,
                        i = new Date(e.setDate(e.getDate() - 1)).toDateString();
                    return a.date(t) && t.toDateString() === i
                };
                var e = a.windowObject("object" == (void 0 === w ? "undefined" : S(w)) && w) && w,
                    d = a.windowObject("object" == ("undefined" == typeof self ? "undefined" : S(self)) && self) && self,
                    f = a.windowObject("object" == S(this) && this) && this,
                    m = e || d || f || Function("return this")(),
                    g = d && d.document,
                    v = m.is,
                    y = d && d.navigator,
                    b = (y && y.appVersion || "").toLowerCase(),
                    x = (y && y.userAgent || "").toLowerCase(),
                    _ = (y && y.vendor || "").toLowerCase();
                return a.android = function() {
                        return /android/.test(x)
                    }, a.android.api = ["not"], a.androidPhone = function() {
                        return /android/.test(x) && /mobile/.test(x)
                    }, a.androidPhone.api = ["not"], a.androidTablet = function() {
                        return /android/.test(x) && !/mobile/.test(x)
                    }, a.androidTablet.api = ["not"], a.blackberry = function() {
                        return /blackberry/.test(x) || /bb10/.test(x)
                    }, a.blackberry.api = ["not"], a.chrome = function(t) {
                        var e = /google inc/.test(_) ? x.match(/(?:chrome|crios)\/(\d+)/) : null;
                        return null !== e && l(e[1], t)
                    }, a.chrome.api = ["not"], a.desktop = function() {
                        return a.not.mobile() && a.not.tablet()
                    }, a.desktop.api = ["not"], a.edge = function(t) {
                        var e = x.match(/edge\/(\d+)/);
                        return null !== e && l(e[1], t)
                    }, a.edge.api = ["not"], a.firefox = function(t) {
                        var e = x.match(/(?:firefox|fxios)\/(\d+)/);
                        return null !== e && l(e[1], t)
                    }, a.firefox.api = ["not"], a.ie = function(t) {
                        var e = x.match(/(?:msie |trident.+?; rv:)(\d+)/);
                        return null !== e && l(e[1], t)
                    }, a.ie.api = ["not"], a.ios = function() {
                        return a.iphone() || a.ipad() || a.ipod()
                    }, a.ios.api = ["not"], a.ipad = function(t) {
                        var e = x.match(/ipad.+?os (\d+)/);
                        return null !== e && l(e[1], t)
                    }, a.ipad.api = ["not"], a.iphone = function(t) {
                        var e = x.match(/iphone(?:.+?os (\d+))?/);
                        return null !== e && l(e[1] || 1, t)
                    }, a.iphone.api = ["not"], a.ipod = function(t) {
                        var e = x.match(/ipod.+?os (\d+)/);
                        return null !== e && l(e[1], t)
                    }, a.ipod.api = ["not"], a.linux = function() {
                        return /linux/.test(b)
                    }, a.linux.api = ["not"], a.mac = function() {
                        return /mac/.test(b)
                    }, a.mac.api = ["not"], a.mobile = function() {
                        return a.iphone() || a.ipod() || a.androidPhone() || a.blackberry() || a.windowsPhone()
                    }, a.mobile.api = ["not"], a.offline = s(a.online), a.offline.api = ["not"], a.online = function() {
                        return !y || !0 === y.onLine
                    }, a.online.api = ["not"], a.opera = function(t) {
                        var e = x.match(/(?:^opera.+?version|opr)\/(\d+)/);
                        return null !== e && l(e[1], t)
                    }, a.opera.api = ["not"], a.phantom = function(t) {
                        var e = x.match(/phantomjs\/(\d+)/);
                        return null !== e && l(e[1], t)
                    }, a.phantom.api = ["not"], a.safari = function(t) {
                        var e = x.match(/version\/(\d+).+?safari/);
                        return null !== e && l(e[1], t)
                    }, a.safari.api = ["not"], a.tablet = function() {
                        return a.ipad() || a.androidTablet() || a.windowsTablet()
                    }, a.tablet.api = ["not"], a.touchDevice = function() {
                        return !!g && ("ontouchstart" in d || "DocumentTouch" in d && g instanceof DocumentTouch)
                    }, a.touchDevice.api = ["not"], a.windows = function() {
                        return /win/.test(b)
                    }, a.windows.api = ["not"], a.windowsPhone = function() {
                        return a.windows() && /phone/.test(x)
                    }, a.windowsPhone.api = ["not"], a.windowsTablet = function() {
                        return a.windows() && a.not.windowsPhone() && /touch/.test(x)
                    }, a.windowsTablet.api = ["not"], a.propertyCount = function(t, e) {
                        if (a.not.object(t) || a.not.number(e)) return !1;
                        var i = 0;
                        for (var n in t)
                            if (r.call(t, n) && ++i > e) return !1;
                        return i === e
                    }, a.propertyCount.api = ["not"], a.propertyDefined = function(t, e) {
                        return a.object(t) && a.string(e) && e in t
                    }, a.propertyDefined.api = ["not"], a.inArray = function(t, e) {
                        if (a.not.array(e)) return !1;
                        for (var i = 0; i < e.length; i++)
                            if (e[i] === t) return !0;
                        return !1
                    }, a.inArray.api = ["not"], a.sorted = function(t, e) {
                        if (a.not.array(t)) return !1;
                        for (var i = o[e] || o[">="], n = 1; n < t.length; n++)
                            if (!i(t[n], t[n - 1])) return !1;
                        return !0
                    },
                    function() {
                        var t = a;
                        for (var e in t)
                            if (r.call(t, e) && a.function(t[e]))
                                for (var i = t[e].api || ["not", "all", "any"], n = 0; n < i.length; n++) "not" === i[n] && (a.not[e] = s(a[e])), "all" === i[n] && (a.all[e] = function(n) {
                                    return function() {
                                        for (var t = h(arguments), e = t.length, i = 0; i < e; i++)
                                            if (!n.call(null, t[i])) return !1;
                                        return !0
                                    }
                                }(a[e])), "any" === i[n] && (a.any[e] = function(n) {
                                    return function() {
                                        for (var t = h(arguments), e = t.length, i = 0; i < e; i++)
                                            if (n.call(null, t[i])) return !0;
                                        return !1
                                    }
                                }(a[e]))
                    }(), a.setNamespace = function() {
                        return m.is = v, this
                    }, a.setRegexp = function(t, e) {
                        for (var i in u) r.call(u, i) && e === i && (u[i] = t)
                    }, a
            }, "function" == typeof define && define.amd ? define(function() {
                return (void 0).is = t()
            }) : "object" === (void 0 === i ? "undefined" : S(i)) ? e.exports = t() : (void 0).is = t()
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    "js-cookie": [function(t, e, i) {
        "use strict";

        function n(t) {
            return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        var r, a, s, o;
        r = function() {
            function o() {
                for (var t = 0, e = {}; t < arguments.length; t++) {
                    var i = arguments[t];
                    for (var n in i) e[n] = i[n]
                }
                return e
            }

            function h(t) {
                return t.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent)
            }
            return function t(l) {
                function s() {}

                function i(t, e, i) {
                    if ("undefined" != typeof document) {
                        "number" == typeof(i = o({
                            path: "/"
                        }, s.defaults, i)).expires && (i.expires = new Date(+new Date + 864e5 * i.expires)), i.expires = i.expires ? i.expires.toUTCString() : "";
                        try {
                            var n = JSON.stringify(e);
                            /^[\{\[]/.test(n) && (e = n)
                        } catch (t) {}
                        e = l.write ? l.write(e, t) : encodeURIComponent(String(e)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), t = encodeURIComponent(String(t)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
                        var r = "";
                        for (var a in i) i[a] && (r += "; " + a, !0 !== i[a] && (r += "=" + i[a].split(";")[0]));
                        return document.cookie = t + "=" + e + r
                    }
                }

                function e(t, e) {
                    if ("undefined" != typeof document) {
                        for (var i = {}, n = document.cookie ? document.cookie.split("; ") : [], r = 0; r < n.length; r++) {
                            var a = n[r].split("="),
                                s = a.slice(1).join("=");
                            e || '"' !== s.charAt(0) || (s = s.slice(1, -1));
                            try {
                                var o = h(a[0]),
                                    s = (l.read || l)(s, o) || h(s);
                                if (e) try {
                                    s = JSON.parse(s)
                                } catch (t) {}
                                if (i[o] = s, t === o) break
                            } catch (t) {}
                        }
                        return t ? i[t] : i
                    }
                }
                return s.set = i, s.get = function(t) {
                    return e(t, !1)
                }, s.getJSON = function(t) {
                    return e(t, !0)
                }, s.remove = function(t, e) {
                    i(t, "", o(e, {
                        expires: -1
                    }))
                }, s.defaults = {}, s.withConverter = t, s
            }(function() {})
        }, "function" == typeof define && define.amd && (define(r), a = !0), "object" === (void 0 === i ? "undefined" : n(i)) && (e.exports = r(), a = !0), a || (s = window.Cookies, (o = window.Cookies = r()).noConflict = function() {
            return window.Cookies = s, o
        })
    }, {}],
    "lg-video.js": [function(c, n, r) {
        (function(e) {
            "use strict";

            function i(t) {
                return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                })(t)
            }! function(t) {
                "object" === (void 0 === r ? "undefined" : i(r)) && void 0 !== n ? n.exports = t() : "function" == typeof define && define.amd ? define([], t) : ("undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : this).LgVideo = t()
            }(function() {
                return function a(s, o, l) {
                    function h(e, t) {
                        if (!o[e]) {
                            if (!s[e]) {
                                var i = "function" == typeof c && c;
                                if (!t && i) return i(e, !0);
                                if (u) return u(e, !0);
                                var n = new Error("Cannot find module '" + e + "'");
                                throw n.code = "MODULE_NOT_FOUND", n
                            }
                            var r = o[e] = {
                                exports: {}
                            };
                            s[e][0].call(r.exports, function(t) {
                                return h(s[e][1][t] || t)
                            }, r, r.exports, a, s, o, l)
                        }
                        return o[e].exports
                    }
                    for (var u = "function" == typeof c && c, t = 0; t < l.length; t++) h(l[t]);
                    return h
                }({
                    1: [function(t, e, i) {
                        var n, r;
                        n = this, r = function() {
                            function t(t) {
                                return this.el = t, this.core = window.lgData[this.el.getAttribute("lg-uid")], this.core.s = e({}, i, this.core.s), this.videoLoaded = !1, this.init(), this
                            }
                            var e = Object.assign || function(t) {
                                    for (var e = 1; e < arguments.length; e++) {
                                        var i = arguments[e];
                                        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
                                    }
                                    return t
                                },
                                i = {
                                    videoMaxWidth: "855px",
                                    youtubePlayerParams: !1,
                                    vimeoPlayerParams: !1,
                                    dailymotionPlayerParams: !1,
                                    vkPlayerParams: !1,
                                    videojs: !1,
                                    videojsOptions: {}
                                };
                            t.prototype.init = function() {
                                var h = this;
                                utils.on(h.core.el, "hasVideo.lgtm", function(t) {
                                    if (h.core.___slide[t.detail.index].querySelector(".lg-video").insertAdjacentHTML("beforeend", h.loadVideo(t.detail.src, "lg-object", !0, t.detail.index, t.detail.html)), t.detail.html)
                                        if (h.core.s.videojs) try {
                                            videojs(h.core.___slide[t.detail.index].querySelector(".lg-html5"), h.core.s.videojsOptions, function() {
                                                h.videoLoaded || this.play()
                                            })
                                        } catch (t) {} else h.core.___slide[t.detail.index].querySelector(".lg-html5").play()
                                }), utils.on(h.core.el, "onAferAppendSlide.lgtm", function(t) {
                                    h.core.___slide[t.detail.index].querySelector(".lg-video-cont") && (h.core.___slide[t.detail.index].querySelector(".lg-video-cont").style.maxWidth = h.core.s.videoMaxWidth, h.videoLoaded = !0)
                                });

                                function e(i) {
                                    if (utils.hasClass(i.querySelector(".lg-object"), "lg-has-poster") && "none" !== i.querySelector(".lg-object").style.display)
                                        if (utils.hasClass(i, "lg-has-video")) {
                                            var t = i.querySelector(".lg-youtube"),
                                                e = i.querySelector(".lg-vimeo"),
                                                n = i.querySelector(".lg-dailymotion"),
                                                r = i.querySelector(".lg-html5");
                                            if (t) t.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', "*");
                                            else if (e) try {
                                                    $f(e).api("play")
                                                } catch (t) {} else if (n) n.contentWindow.postMessage("play", "*");
                                                else if (r)
                                                if (h.core.s.videojs) try {
                                                    videojs(r).play()
                                                } catch (t) {} else r.play();
                                            utils.addClass(i, "lg-video-playing")
                                        } else {
                                            utils.addClass(i, "lg-video-playing"), utils.addClass(i, "lg-has-video");
                                            var a = function(t, e) {
                                                if (i.querySelector(".lg-video").insertAdjacentHTML("beforeend", h.loadVideo(t, "", !1, h.core.index, e)), e)
                                                    if (h.core.s.videojs) try {
                                                        videojs(h.core.___slide[h.core.index].querySelector(".lg-html5"), h.core.s.videojsOptions, function() {
                                                            this.play()
                                                        })
                                                    } catch (t) {} else h.core.___slide[h.core.index].querySelector(".lg-html5").play()
                                            };
                                            h.core.s.dynamic ? a(h.core.s.dynamicEl[h.core.index].src, h.core.s.dynamicEl[h.core.index].html) : a(h.core.items[h.core.index].getAttribute("href") || h.core.items[h.core.index].getAttribute("data-src"), h.core.items[h.core.index].getAttribute("data-html"));
                                            var s = i.querySelector(".lg-object");
                                            i.querySelector(".lg-video").appendChild(s), utils.hasClass(i.querySelector(".lg-video-object"), "lg-html5") || (utils.removeClass(i, "lg-complete"), utils.on(i.querySelector(".lg-video-object"), "load.lg error.lg", function() {
                                                utils.addClass(i, "lg-complete")
                                            }))
                                        }
                                }
                                if (h.core.doCss() && 1 < h.core.items.length && (h.core.s.enableSwipe && h.core.isTouch || h.core.s.enableDrag && !h.core.isTouch)) utils.on(h.core.el, "onSlideClick.lgtm", function() {
                                    var t = h.core.___slide[h.core.index];
                                    e(t)
                                });
                                else
                                    for (var t = 0; t < h.core.___slide.length; t++) ! function(t) {
                                        utils.on(h.core.___slide[t], "click.lg", function() {
                                            e(h.core.___slide[t])
                                        })
                                    }(t);
                                utils.on(h.core.el, "onBeforeSlide.lgtm", function(t) {
                                    var e, i = h.core.___slide[t.detail.prevIndex],
                                        n = i.querySelector(".lg-youtube"),
                                        r = i.querySelector(".lg-vimeo"),
                                        a = i.querySelector(".lg-dailymotion"),
                                        s = i.querySelector(".lg-vk"),
                                        o = i.querySelector(".lg-html5");
                                    if (n) n.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', "*");
                                    else if (r) try {
                                            $f(r).api("pause")
                                        } catch (t) {} else if (a) a.contentWindow.postMessage("pause", "*");
                                        else if (o)
                                        if (h.core.s.videojs) try {
                                            videojs(o).pause()
                                        } catch (t) {} else o.pause();
                                    s && s.setAttribute("src", s.getAttribute("src").replace("&autoplay", "&noplay")), e = h.core.s.dynamic ? h.core.s.dynamicEl[t.detail.index].src : h.core.items[t.detail.index].getAttribute("href") || h.core.items[t.detail.index].getAttribute("data-src");
                                    var l = h.core.isVideo(e, t.detail.index) || {};
                                    (l.youtube || l.vimeo || l.dailymotion || l.vk) && utils.addClass(h.core.outer, "lg-hide-download")
                                }), utils.on(h.core.el, "onAfterSlide.lgtm", function(t) {
                                    utils.removeClass(h.core.___slide[t.detail.prevIndex], "lg-video-playing")
                                })
                            }, t.prototype.loadVideo = function(t, e, i, n, r) {
                                var a, s = "",
                                    o = 1,
                                    l = "",
                                    h = this.core.isVideo(t, n) || {};
                                i && (o = this.videoLoaded ? 0 : 1), a = this.core.s.dynamic ? this.core.s.dynamicEl[n].title : this.core.items[n].getAttribute("title");
                                var u, c = this.core.items[n].querySelector("img");
                                return c && (a = a || c.getAttribute("alt")), a = a ? 'title="' + a + '"' : "", h.youtube ? (l = "?wmode=opaque&autoplay=" + o + "&enablejsapi=1", this.core.s.youtubePlayerParams && (l = l + "&" + utils.param(this.core.s.youtubePlayerParams)), s = '<iframe class="lg-video-object lg-youtube ' + e + '" ' + a + ' width="560" height="315" src="//www.youtube.com/embed/' + h.youtube[1] + l + '" frameborder="0" allowfullscreen></iframe>') : h.vimeo ? (l = "?autoplay=" + o + "&api=1", this.core.s.vimeoPlayerParams && (l = l + "&" + utils.param(this.core.s.vimeoPlayerParams)), s = '<iframe class="lg-video-object lg-vimeo ' + e + '" ' + a + ' width="560" height="315"  src="//player.vimeo.com/video/' + h.vimeo[1] + l + '" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>') : h.dailymotion ? (l = "?wmode=opaque&autoplay=" + o + "&api=postMessage", this.core.s.dailymotionPlayerParams && (l = l + "&" + utils.param(this.core.s.dailymotionPlayerParams)), s = '<iframe class="lg-video-object lg-dailymotion ' + e + '" ' + a + ' width="560" height="315" src="//www.dailymotion.com/embed/video/' + h.dailymotion[1] + l + '" frameborder="0" allowfullscreen></iframe>') : h.html5 ? ("." !== (u = r.substring(0, 1)) && "#" !== u || (r = document.querySelector(r).innerHTML), s = r) : h.vk && (l = "&autoplay=" + o, this.core.s.vkPlayerParams && (l = l + "&" + utils.param(this.core.s.vkPlayerParams)), s = '<iframe class="lg-video-object lg-vk ' + e + '" ' + a + '  width="560" height="315" src="http://vk.com/video_ext.php?' + h.vk[1] + l + '" frameborder="0" allowfullscreen></iframe>'), s
                            }, t.prototype.destroy = function() {
                                this.videoLoaded = !1
                            }, window.lgModules.video = t
                        }, void 0 !== i ? r() : (r(), n.lgVideo = {})
                    }, {}]
                }, {}, [1])(1)
            })
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    "lightgallery.js": [function(t, e, i) {
        "use strict";
        var n;
        n = function(t) {
            var e, g = (e = t) && e.__esModule ? e : {
                default: e
            };
            var i = Object.assign || function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i = arguments[e];
                    for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
                }
                return t
            };

            function n(t, e) {
                e = e || {
                    bubbles: !1,
                    cancelable: !1,
                    detail: void 0
                };
                var i = document.createEvent("CustomEvent");
                return i.initCustomEvent(t, e.bubbles, e.cancelable, e.detail), i
            }
            "function" != typeof window.CustomEvent && (n.prototype = window.Event.prototype, window.CustomEvent = n), window.utils = g.default, window.lgData = {
                uid: 0
            };
            var r = {
                mode: "lg-slide",
                cssEasing: "ease",
                easing: "linear",
                speed: 600,
                height: "100%",
                width: "100%",
                addClass: "",
                startClass: "lg-start-zoom",
                backdropDuration: 150,
                hideBarsDelay: 6e3,
                useLeft: !(window.lgModules = {}),
                ariaLabelledby: "",
                ariaDescribedby: "",
                closable: !0,
                loop: !0,
                escKey: !0,
                keyPress: !0,
                controls: !0,
                slideEndAnimatoin: !0,
                hideControlOnEnd: !1,
                mousewheel: !1,
                getCaptionFromTitleOrAlt: !0,
                appendSubHtmlTo: ".lg-sub-html",
                subHtmlSelectorRelative: !1,
                preload: 1,
                showAfterLoad: !0,
                selector: "",
                selectWithin: "",
                nextHtml: "",
                prevHtml: "",
                index: !1,
                iframeMaxWidth: "100%",
                download: !0,
                counter: !0,
                appendCounterTo: ".lg-toolbar",
                swipeThreshold: 50,
                enableSwipe: !0,
                enableDrag: !0,
                dynamic: !1,
                dynamicEl: [],
                galleryId: 1
            };

            function a(t, e) {
                if (this.el = t, this.s = i({}, r, e), this.s.dynamic && "undefined" !== this.s.dynamicEl && this.s.dynamicEl.constructor === Array && !this.s.dynamicEl.length) throw "When using dynamic mode, you must also define dynamicEl as an Array.";
                return this.modules = {}, this.lGalleryOn = !1, this.lgBusy = !1, this.hideBartimeout = !1, this.isTouch = "ontouchstart" in document.documentElement, this.s.slideEndAnimatoin && (this.s.hideControlOnEnd = !1), this.items = [], this.s.dynamic ? this.items = this.s.dynamicEl : "this" === this.s.selector ? this.items.push(this.el) : "" !== this.s.selector ? this.s.selectWithin ? this.items = document.querySelector(this.s.selectWithin).querySelectorAll(this.s.selector) : this.items = this.el.querySelectorAll(this.s.selector) : this.items = this.el.children, this.___slide = "", this.outer = "", this.init(), this
            }
            a.prototype.init = function() {
                var i = this;
                i.s.preload > i.items.length && (i.s.preload = i.items.length);
                var t = window.location.hash;
                if (0 < t.indexOf("lg=" + this.s.galleryId) && (i.index = parseInt(t.split("&slide=")[1], 10), g.default.addClass(document.body, "lg-from-hash"), g.default.hasClass(document.body, "lg-on") || (g.default.addClass(document.body, "lg-on"), setTimeout(function() {
                        i.build(i.index)
                    }))), i.s.dynamic) g.default.trigger(this.el, "onBeforeOpen"), i.index = i.s.index || 0, g.default.hasClass(document.body, "lg-on") || (g.default.addClass(document.body, "lg-on"), setTimeout(function() {
                    i.build(i.index)
                }));
                else
                    for (var e = 0; e < i.items.length; e++) ! function(e) {
                        g.default.on(i.items[e], "click.lgcustom", function(t) {
                            t.preventDefault(), g.default.trigger(i.el, "onBeforeOpen"), i.index = i.s.index || e, g.default.hasClass(document.body, "lg-on") || (i.build(i.index), g.default.addClass(document.body, "lg-on"))
                        })
                    }(e)
            }, a.prototype.build = function(t) {
                var e = this;
                for (var i in e.structure(), window.lgModules) e.modules[i] = new window.lgModules[i](e.el);
                e.slide(t, !1, !1), e.s.keyPress && e.keyPress(), 1 < e.items.length && (e.arrow(), setTimeout(function() {
                    e.enableDrag(), e.enableSwipe()
                }, 50), e.s.mousewheel && e.mousewheel()), e.counter(), e.closeGallery(), g.default.trigger(e.el, "onAfterOpen"), g.default.on(e.outer, "mousemove.lg click.lg touchstart.lg", function() {
                    g.default.removeClass(e.outer, "lg-hide-items"), clearTimeout(e.hideBartimeout), e.hideBartimeout = setTimeout(function() {
                        g.default.addClass(e.outer, "lg-hide-items")
                    }, e.s.hideBarsDelay)
                })
            }, a.prototype.structure = function() {
                var t = "",
                    e = "",
                    i = 0,
                    n = "",
                    r = this;
                for (document.body.insertAdjacentHTML("beforeend", '<div class="lg-backdrop"></div>'), g.default.setVendor(document.querySelector(".lg-backdrop"), "TransitionDuration", this.s.backdropDuration + "ms"), i = 0; i < this.items.length; i++) t += '<div class="lg-item"></div>';
                this.s.controls && 1 < this.items.length && (e = '<div class="lg-actions"><button type="button" aria-label="Previous slide" class="lg-prev lg-icon">' + this.s.prevHtml + '</button><button type="button" aria-label="Next slide" class="lg-next lg-icon">' + this.s.nextHtml + "</button></div>"), ".lg-sub-html" === this.s.appendSubHtmlTo && (n = '<div role="status" aria-live="polite" class="lg-sub-html"></div>');
                var a, s = '<div tabindex="-1" aria-modal="true" ' + (this.s.ariaLabelledby ? 'aria-labelledby="' + this.s.ariaLabelledby + '"' : "") + " " + (this.s.ariaDescribedby ? 'aria-describedby="' + this.s.ariaDescribedby + '"' : "") + ' role="dialog" class="lg-outer ' + this.s.addClass + " " + this.s.startClass + '"><div class="lg" style="width:' + this.s.width + "; height:" + this.s.height + '"><div class="lg-inner">' + t + '</div><div class="lg-toolbar group"><button type="button" aria-label="Close gallery" class="lg-close lg-icon"></button></div>' + e + n + "</div></div>";
                document.body.insertAdjacentHTML("beforeend", s), this.outer = document.querySelector(".lg-outer"), this.outer.focus(), this.___slide = this.outer.querySelectorAll(".lg-item"), this.s.useLeft ? (g.default.addClass(this.outer, "lg-use-left"), this.s.mode = "lg-slide") : g.default.addClass(this.outer, "lg-use-css3"), r.setTop(), g.default.on(window, "resize.lg orientationchange.lg", function() {
                    setTimeout(function() {
                        r.setTop()
                    }, 100)
                }), g.default.addClass(this.___slide[this.index], "lg-current"), this.doCss() ? g.default.addClass(this.outer, "lg-css3") : (g.default.addClass(this.outer, "lg-css"), this.s.speed = 0), g.default.addClass(this.outer, this.s.mode), this.s.enableDrag && 1 < this.items.length && g.default.addClass(this.outer, "lg-grab"), this.s.showAfterLoad && g.default.addClass(this.outer, "lg-show-after-load"), this.doCss() && (a = this.outer.querySelector(".lg-inner"), g.default.setVendor(a, "TransitionTimingFunction", this.s.cssEasing), g.default.setVendor(a, "TransitionDuration", this.s.speed + "ms")), setTimeout(function() {
                    g.default.addClass(document.querySelector(".lg-backdrop"), "in")
                }), setTimeout(function() {
                    g.default.addClass(r.outer, "lg-visible")
                }, this.s.backdropDuration), this.s.download && this.outer.querySelector(".lg-toolbar").insertAdjacentHTML("beforeend", '<a id="lg-download" aria-label="Download" target="_blank" download class="lg-download lg-icon"></a>'), this.prevScrollTop = document.documentElement.scrollTop || document.body.scrollTop
            }, a.prototype.setTop = function() {
                var t, e, i;
                "100%" !== this.s.height && (e = ((t = window.innerHeight) - parseInt(this.s.height, 10)) / 2, i = this.outer.querySelector(".lg"), t >= parseInt(this.s.height, 10) ? i.style.top = e + "px" : i.style.top = "0px")
            }, a.prototype.doCss = function() {
                return !! function() {
                    for (var t = ["transition", "MozTransition", "WebkitTransition", "OTransition", "msTransition", "KhtmlTransition"], e = document.documentElement, i = 0, i = 0; i < t.length; i++)
                        if (t[i] in e.style) return !0
                }()
            }, a.prototype.isVideo = function(t, e) {
                var i = this.s.dynamic ? this.s.dynamicEl[e].html : this.items[e].getAttribute("data-html");
                if (!t && i) return {
                    html5: !0
                };
                var n = t.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com|be-nocookie\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)/i),
                    r = t.match(/\/\/(?:www\.)?vimeo.com\/([0-9a-z\-_]+)/i),
                    a = t.match(/\/\/(?:www\.)?dai.ly\/([0-9a-z\-_]+)/i),
                    s = t.match(/\/\/(?:www\.)?(?:vk\.com|vkontakte\.ru)\/(?:video_ext\.php\?)(.*)/i);
                return n ? {
                    youtube: n
                } : r ? {
                    vimeo: r
                } : a ? {
                    dailymotion: a
                } : s ? {
                    vk: s
                } : void 0
            }, a.prototype.counter = function() {
                this.s.counter && this.outer.querySelector(this.s.appendCounterTo).insertAdjacentHTML("beforeend", '<div id="lg-counter" role="status" aria-live="polite"><span id="lg-counter-current">' + (parseInt(this.index, 10) + 1) + '</span> / <span id="lg-counter-all">' + this.items.length + "</span></div>")
            }, a.prototype.addHtml = function(t) {
                var e, i, n = null;
                this.s.dynamic ? n = this.s.dynamicEl[t].subHtml : (n = (e = this.items[t]).getAttribute("data-sub-html"), this.s.getCaptionFromTitleOrAlt && !n && (n = e.getAttribute("title")) && e.querySelector("img") && (n = e.querySelector("img").getAttribute("alt"))), null != n ? "." !== (i = n.substring(0, 1)) && "#" !== i || (n = this.s.subHtmlSelectorRelative && !this.s.dynamic ? e.querySelector(n).innerHTML : document.querySelector(n).innerHTML) : n = "", ".lg-sub-html" === this.s.appendSubHtmlTo ? this.outer.querySelector(this.s.appendSubHtmlTo).innerHTML = n : this.___slide[t].insertAdjacentHTML("beforeend", n), null != n && ("" === n ? g.default.addClass(this.outer.querySelector(this.s.appendSubHtmlTo), "lg-empty-html") : g.default.removeClass(this.outer.querySelector(this.s.appendSubHtmlTo), "lg-empty-html")), g.default.trigger(this.el, "onAfterAppendSubHtml", {
                    index: t
                })
            }, a.prototype.preload = function(t) {
                for (var e = 1, i = 1, e = 1; e <= this.s.preload && !(e >= this.items.length - t); e++) this.loadContent(t + e, !1, 0);
                for (i = 1; i <= this.s.preload && !(t - i < 0); i++) this.loadContent(t - i, !1, 0)
            }, a.prototype.loadContent = function(e, t, i) {
                function n(t) {
                    for (var e = [], i = [], n = 0; n < t.length; n++) {
                        var r = t[n].split(" ");
                        "" === r[0] && r.splice(0, 1), i.push(r[0]), e.push(r[1])
                    }
                    for (var a = window.innerWidth, s = 0; s < e.length; s++)
                        if (parseInt(e[s], 10) > a) {
                            o = i[s];
                            break
                        }
                }
                var r, o, a, s, l, h, u = this,
                    c = !1,
                    p = u.s.dynamic ? (u.s.dynamicEl[e].poster && (c = !0, a = u.s.dynamicEl[e].poster), l = u.s.dynamicEl[e].html, o = u.s.dynamicEl[e].src, h = u.s.dynamicEl[e].alt, u.s.dynamicEl[e].responsive && n(u.s.dynamicEl[e].responsive.split(",")), s = u.s.dynamicEl[e].srcset, u.s.dynamicEl[e].sizes) : (u.items[e].getAttribute("data-poster") && (c = !0, a = u.items[e].getAttribute("data-poster")), l = u.items[e].getAttribute("data-html"), o = u.items[e].getAttribute("href") || u.items[e].getAttribute("data-src"), h = u.items[e].getAttribute("title"), u.items[e].querySelector("img") && (h = h || u.items[e].querySelector("img").getAttribute("alt")), u.items[e].getAttribute("data-responsive") && n(u.items[e].getAttribute("data-responsive").split(",")), s = u.items[e].getAttribute("data-srcset"), u.items[e].getAttribute("data-sizes")),
                    d = !1;
                u.s.dynamic ? u.s.dynamicEl[e].iframe && (d = !0) : "true" === u.items[e].getAttribute("data-iframe") && (d = !0);
                var f, m = u.isVideo(o, e);
                if (!g.default.hasClass(u.___slide[e], "lg-loaded")) {
                    if (d ? u.___slide[e].insertAdjacentHTML("afterbegin", '<div class="lg-video-cont" style="max-width:' + u.s.iframeMaxWidth + '"><div class="lg-video"><iframe class="lg-object" frameborder="0" src="' + o + '"  allowfullscreen="true"></iframe></div></div>') : c ? (f = "", f = m && m.youtube ? "lg-has-youtube" : m && m.vimeo ? "lg-has-vimeo" : "lg-has-html5", u.___slide[e].insertAdjacentHTML("beforeend", '<div class="lg-video-cont ' + f + ' "><div class="lg-video"><span class="lg-video-play"></span><img class="lg-object lg-has-poster" src="' + a + '" /></div></div>')) : m ? (u.___slide[e].insertAdjacentHTML("beforeend", '<div class="lg-video-cont "><div class="lg-video"></div></div>'), g.default.trigger(u.el, "hasVideo", {
                            index: e,
                            src: o,
                            html: l
                        })) : (h = h ? 'alt="' + h + '"' : "", u.___slide[e].insertAdjacentHTML("beforeend", '<div class="lg-img-wrap"><img class="lg-object lg-image" ' + h + ' src="' + o + '" /></div>')), g.default.trigger(u.el, "onAferAppendSlide", {
                            index: e
                        }), r = u.___slide[e].querySelector(".lg-object"), p && r.setAttribute("sizes", p), s) {
                        r.setAttribute("srcset", s);
                        try {
                            picturefill({
                                elements: [r[0]]
                            })
                        } catch (t) {}
                    }
                    ".lg-sub-html" !== this.s.appendSubHtmlTo && u.addHtml(e), g.default.addClass(u.___slide[e], "lg-loaded")
                }
                g.default.on(u.___slide[e].querySelector(".lg-object"), "load.lg error.lg", function() {
                    var t = 0;
                    i && !g.default.hasClass(document.body, "lg-from-hash") && (t = i), setTimeout(function() {
                        g.default.addClass(u.___slide[e], "lg-complete"), g.default.trigger(u.el, "onSlideItemLoad", {
                            index: e,
                            delay: i || 0
                        })
                    }, t)
                }), m && m.html5 && !c && g.default.addClass(u.___slide[e], "lg-complete"), !0 === t && (g.default.hasClass(u.___slide[e], "lg-complete") ? u.preload(e) : g.default.on(u.___slide[e].querySelector(".lg-object"), "load.lg error.lg", function() {
                    u.preload(e)
                }))
            }, a.prototype.slide = function(t, e, i) {
                for (var n = 0, r = 0; r < this.___slide.length; r++)
                    if (g.default.hasClass(this.___slide[r], "lg-current")) {
                        n = r;
                        break
                    }
                var a = this;
                if (!a.lGalleryOn || n !== t) {
                    var s, o = this.___slide.length,
                        l = a.lGalleryOn ? this.s.speed : 0,
                        h = !1,
                        u = !1;
                    if (!a.lgBusy) {
                        if (this.s.download && ((s = a.s.dynamic ? !1 !== a.s.dynamicEl[t].downloadUrl && (a.s.dynamicEl[t].downloadUrl || a.s.dynamicEl[t].src) : "false" !== a.items[t].getAttribute("data-download-url") && (a.items[t].getAttribute("data-download-url") || a.items[t].getAttribute("href") || a.items[t].getAttribute("data-src"))) ? (document.getElementById("lg-download").setAttribute("href", s), g.default.removeClass(a.outer, "lg-hide-download")) : g.default.addClass(a.outer, "lg-hide-download")), g.default.trigger(a.el, "onBeforeSlide", {
                                prevIndex: n,
                                index: t,
                                fromTouch: e,
                                fromThumb: i
                            }), a.lgBusy = !0, clearTimeout(a.hideBartimeout), ".lg-sub-html" === this.s.appendSubHtmlTo && setTimeout(function() {
                                a.addHtml(t)
                            }, l), this.arrowDisable(t), e) {
                            var c = t - 1,
                                p = t + 1;
                            (0 === t && n === o - 1 || t === o - 1 && 0 === n) && (p = 0, c = o - 1), g.default.removeClass(a.outer.querySelector(".lg-prev-slide"), "lg-prev-slide"), g.default.removeClass(a.outer.querySelector(".lg-current"), "lg-current"), g.default.removeClass(a.outer.querySelector(".lg-next-slide"), "lg-next-slide"), g.default.addClass(a.___slide[c], "lg-prev-slide"), g.default.addClass(a.___slide[p], "lg-next-slide"), g.default.addClass(a.___slide[t], "lg-current")
                        } else {
                            g.default.addClass(a.outer, "lg-no-trans");
                            for (var d = 0; d < this.___slide.length; d++) g.default.removeClass(this.___slide[d], "lg-prev-slide"), g.default.removeClass(this.___slide[d], "lg-next-slide");
                            t < n ? (u = !0, 0 !== t || n !== o - 1 || i || (h = !(u = !1))) : n < t && (h = !0, t !== o - 1 || 0 !== n || i || (h = !(u = !0))), u ? (g.default.addClass(this.___slide[t], "lg-prev-slide"), g.default.addClass(this.___slide[n], "lg-next-slide")) : h && (g.default.addClass(this.___slide[t], "lg-next-slide"), g.default.addClass(this.___slide[n], "lg-prev-slide")), setTimeout(function() {
                                g.default.removeClass(a.outer.querySelector(".lg-current"), "lg-current"), g.default.addClass(a.___slide[t], "lg-current"), g.default.removeClass(a.outer, "lg-no-trans")
                            }, 50)
                        }
                        a.lGalleryOn ? (setTimeout(function() {
                            a.loadContent(t, !0, 0)
                        }, this.s.speed + 50), setTimeout(function() {
                            a.lgBusy = !1, g.default.trigger(a.el, "onAfterSlide", {
                                prevIndex: n,
                                index: t,
                                fromTouch: e,
                                fromThumb: i
                            })
                        }, this.s.speed)) : (a.loadContent(t, !0, a.s.backdropDuration), a.lgBusy = !1, g.default.trigger(a.el, "onAfterSlide", {
                            prevIndex: n,
                            index: t,
                            fromTouch: e,
                            fromThumb: i
                        })), a.lGalleryOn = !0, this.s.counter && document.getElementById("lg-counter-current") && (document.getElementById("lg-counter-current").innerHTML = t + 1)
                    }
                }
            }, a.prototype.goToNextSlide = function(t) {
                var e = this;
                e.lgBusy || (e.index + 1 < e.___slide.length ? (e.index++, g.default.trigger(e.el, "onBeforeNextSlide", {
                    index: e.index
                }), e.slide(e.index, t, !1)) : e.s.loop ? (e.index = 0, g.default.trigger(e.el, "onBeforeNextSlide", {
                    index: e.index
                }), e.slide(e.index, t, !1)) : e.s.slideEndAnimatoin && (g.default.addClass(e.outer, "lg-right-end"), setTimeout(function() {
                    g.default.removeClass(e.outer, "lg-right-end")
                }, 400)))
            }, a.prototype.goToPrevSlide = function(t) {
                var e = this;
                e.lgBusy || (0 < e.index ? (e.index--, g.default.trigger(e.el, "onBeforePrevSlide", {
                    index: e.index,
                    fromTouch: t
                }), e.slide(e.index, t, !1)) : e.s.loop ? (e.index = e.items.length - 1, g.default.trigger(e.el, "onBeforePrevSlide", {
                    index: e.index,
                    fromTouch: t
                }), e.slide(e.index, t, !1)) : e.s.slideEndAnimatoin && (g.default.addClass(e.outer, "lg-left-end"), setTimeout(function() {
                    g.default.removeClass(e.outer, "lg-left-end")
                }, 400)))
            }, a.prototype.keyPress = function() {
                var e = this;
                1 < this.items.length && g.default.on(window, "keyup.lg", function(t) {
                    1 < e.items.length && (37 === t.keyCode && (t.preventDefault(), e.goToPrevSlide()), 39 === t.keyCode && (t.preventDefault(), e.goToNextSlide()))
                }), g.default.on(window, "keydown.lg", function(t) {
                    !0 === e.s.escKey && 27 === t.keyCode && (t.preventDefault(), g.default.hasClass(e.outer, "lg-thumb-open") ? g.default.removeClass(e.outer, "lg-thumb-open") : e.destroy())
                })
            }, a.prototype.arrow = function() {
                var t = this;
                g.default.on(this.outer.querySelector(".lg-prev"), "click.lg", function() {
                    t.goToPrevSlide()
                }), g.default.on(this.outer.querySelector(".lg-next"), "click.lg", function() {
                    t.goToNextSlide()
                })
            }, a.prototype.arrowDisable = function(t) {
                var e, i;
                !this.s.loop && this.s.hideControlOnEnd && (e = this.outer.querySelector(".lg-next"), i = this.outer.querySelector(".lg-prev"), t + 1 < this.___slide.length ? (e.removeAttribute("disabled"), g.default.removeClass(e, "disabled")) : (e.setAttribute("disabled", "disabled"), g.default.addClass(e, "disabled")), 0 < t ? (i.removeAttribute("disabled"), g.default.removeClass(i, "disabled")) : (i.setAttribute("disabled", "disabled"), g.default.addClass(i, "disabled")))
            }, a.prototype.setTranslate = function(t, e, i) {
                this.s.useLeft ? t.style.left = e : g.default.setVendor(t, "Transform", "translate3d(" + e + "px, " + i + "px, 0px)")
            }, a.prototype.touchMove = function(t, e) {
                var i = e - t;
                15 < Math.abs(i) && (g.default.addClass(this.outer, "lg-dragging"), this.setTranslate(this.___slide[this.index], i, 0), this.setTranslate(document.querySelector(".lg-prev-slide"), -this.___slide[this.index].clientWidth + i, 0), this.setTranslate(document.querySelector(".lg-next-slide"), this.___slide[this.index].clientWidth + i, 0))
            }, a.prototype.touchEnd = function(e) {
                var i = this;
                "lg-slide" !== i.s.mode && g.default.addClass(i.outer, "lg-slide");
                for (var t = 0; t < this.___slide.length; t++) g.default.hasClass(this.___slide[t], "lg-current") || g.default.hasClass(this.___slide[t], "lg-prev-slide") || g.default.hasClass(this.___slide[t], "lg-next-slide") || (this.___slide[t].style.opacity = "0");
                setTimeout(function() {
                    g.default.removeClass(i.outer, "lg-dragging"), e < 0 && Math.abs(e) > i.s.swipeThreshold ? i.goToNextSlide(!0) : 0 < e && Math.abs(e) > i.s.swipeThreshold ? i.goToPrevSlide(!0) : Math.abs(e) < 5 && g.default.trigger(i.el, "onSlideClick");
                    for (var t = 0; t < i.___slide.length; t++) i.___slide[t].removeAttribute("style")
                }), setTimeout(function() {
                    g.default.hasClass(i.outer, "lg-dragging") || "lg-slide" === i.s.mode || g.default.removeClass(i.outer, "lg-slide")
                }, i.s.speed + 100)
            }, a.prototype.enableSwipe = function() {
                var e = this,
                    i = 0,
                    n = 0,
                    r = !1;
                if (e.s.enableSwipe && e.isTouch && e.doCss()) {
                    for (var t = 0; t < e.___slide.length; t++) g.default.on(e.___slide[t], "touchstart.lg", function(t) {
                        g.default.hasClass(e.outer, "lg-zoomed") || e.lgBusy || (t.preventDefault(), e.manageSwipeClass(), i = t.targetTouches[0].pageX)
                    });
                    for (var a = 0; a < e.___slide.length; a++) g.default.on(e.___slide[a], "touchmove.lg", function(t) {
                        g.default.hasClass(e.outer, "lg-zoomed") || (t.preventDefault(), n = t.targetTouches[0].pageX, e.touchMove(i, n), r = !0)
                    });
                    for (var s = 0; s < e.___slide.length; s++) g.default.on(e.___slide[s], "touchend.lg", function() {
                        g.default.hasClass(e.outer, "lg-zoomed") || (r ? (r = !1, e.touchEnd(n - i)) : g.default.trigger(e.el, "onSlideClick"))
                    })
                }
            }, a.prototype.enableDrag = function() {
                var e = this,
                    i = 0,
                    n = 0,
                    r = !1,
                    a = !1;
                if (e.s.enableDrag && !e.isTouch && e.doCss()) {
                    for (var t = 0; t < e.___slide.length; t++) g.default.on(e.___slide[t], "mousedown.lg", function(t) {
                        g.default.hasClass(e.outer, "lg-zoomed") || (g.default.hasClass(t.target, "lg-object") || g.default.hasClass(t.target, "lg-video-play")) && (t.preventDefault(), e.lgBusy || (e.manageSwipeClass(), i = t.pageX, r = !0, e.outer.scrollLeft += 1, --e.outer.scrollLeft, g.default.removeClass(e.outer, "lg-grab"), g.default.addClass(e.outer, "lg-grabbing"), g.default.trigger(e.el, "onDragstart")))
                    });
                    g.default.on(window, "mousemove.lg", function(t) {
                        r && (a = !0, n = t.pageX, e.touchMove(i, n), g.default.trigger(e.el, "onDragmove"))
                    }), g.default.on(window, "mouseup.lg", function(t) {
                        a ? (a = !1, e.touchEnd(n - i), g.default.trigger(e.el, "onDragend")) : (g.default.hasClass(t.target, "lg-object") || g.default.hasClass(t.target, "lg-video-play")) && g.default.trigger(e.el, "onSlideClick"), r && (r = !1, g.default.removeClass(e.outer, "lg-grabbing"), g.default.addClass(e.outer, "lg-grab"))
                    })
                }
            }, a.prototype.manageSwipeClass = function() {
                var t = this.index + 1,
                    e = this.index - 1,
                    i = this.___slide.length;
                this.s.loop && (0 === this.index ? e = i - 1 : this.index === i - 1 && (t = 0));
                for (var n = 0; n < this.___slide.length; n++) g.default.removeClass(this.___slide[n], "lg-next-slide"), g.default.removeClass(this.___slide[n], "lg-prev-slide"); - 1 < e && g.default.addClass(this.___slide[e], "lg-prev-slide"), g.default.addClass(this.___slide[t], "lg-next-slide")
            }, a.prototype.mousewheel = function() {
                var e = this;
                g.default.on(e.outer, "mousewheel.lg", function(t) {
                    t.deltaY && (0 < t.deltaY ? e.goToPrevSlide() : e.goToNextSlide(), t.preventDefault())
                })
            }, a.prototype.closeGallery = function() {
                var e = this,
                    i = !1;
                g.default.on(this.outer.querySelector(".lg-close"), "click.lg", function() {
                    e.destroy()
                }), e.s.closable && (g.default.on(e.outer, "mousedown.lg", function(t) {
                    i = !!(g.default.hasClass(t.target, "lg-outer") || g.default.hasClass(t.target, "lg-item") || g.default.hasClass(t.target, "lg-img-wrap"))
                }), g.default.on(e.outer, "mouseup.lg", function(t) {
                    (g.default.hasClass(t.target, "lg-outer") || g.default.hasClass(t.target, "lg-item") || g.default.hasClass(t.target, "lg-img-wrap") && i) && (g.default.hasClass(e.outer, "lg-dragging") || e.destroy())
                }))
            }, a.prototype.destroy = function(t) {
                var e = this;
                if (t || g.default.trigger(e.el, "onBeforeClose"), document.body.scrollTop = e.prevScrollTop, document.documentElement.scrollTop = e.prevScrollTop, t) {
                    if (!e.s.dynamic)
                        for (var i = 0; i < this.items.length; i++) g.default.off(this.items[i], ".lg"), g.default.off(this.items[i], ".lgcustom");
                    var n = e.el.getAttribute("lg-uid");
                    delete window.lgData[n], e.el.removeAttribute("lg-uid")
                }
                for (var r in g.default.off(this.el, ".lgtm"), window.lgModules) e.modules[r] && e.modules[r].destroy(t);
                this.lGalleryOn = !1, clearTimeout(e.hideBartimeout), this.hideBartimeout = !1, g.default.off(window, ".lg"), g.default.removeClass(document.body, "lg-on"), g.default.removeClass(document.body, "lg-from-hash"), e.outer && g.default.removeClass(e.outer, "lg-visible"), g.default.removeClass(document.querySelector(".lg-backdrop"), "in"), setTimeout(function() {
                    try {
                        e.outer && e.outer.parentNode.removeChild(e.outer), document.querySelector(".lg-backdrop") && document.querySelector(".lg-backdrop").parentNode.removeChild(document.querySelector(".lg-backdrop")), t || g.default.trigger(e.el, "onCloseAfter"), e.el.focus()
                    } catch (t) {}
                }, e.s.backdropDuration + 50)
            }, window.lightGallery = function(t, e) {
                if (t) try {
                    if (t.getAttribute("lg-uid")) try {
                        window.lgData[t.getAttribute("lg-uid")].init()
                    } catch (t) {} else {
                        var i = "lg" + window.lgData.uid++;
                        window.lgData[i] = new a(t, e), t.setAttribute("lg-uid", i)
                    }
                } catch (t) {}
            }
        }, "function" == typeof define && define.amd ? define(["./lg-utils"], n) : void 0 !== i ? n(t("./lg-utils")) : (n((void 0).lgUtils), (void 0).lightgallery = {})
    }, {
        "./lg-utils": 3
    }],
    "lottie-web": [function(require, module, exports) {
        "use strict";

        function _typeof(t) {
            return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        var gde, hde;
        "undefined" != typeof navigator && (gde = window || {}, hde = function(window) {
            var svgNS = "http://www.w3.org/2000/svg",
                locationHref = "",
                initialDefaultFrame = -999999,
                subframeEnabled = !0,
                idPrefix = "",
                expressionsPlugin, isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                cachedColors = {},
                bmRnd, bmPow = Math.pow,
                bmSqrt = Math.sqrt,
                bmFloor = Math.floor,
                bmMax = Math.max,
                bmMin = Math.min,
                BMMath = {};

            function ProjectInterface() {
                return {}
            }! function() {
                for (var t = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], e = t.length, i = 0; i < e; i += 1) BMMath[t[i]] = Math[t[i]]
            }(), BMMath.random = Math.random, BMMath.abs = function(t) {
                if ("object" === _typeof(t) && t.length) {
                    for (var e = createSizedArray(t.length), i = t.length, n = 0; n < i; n += 1) e[n] = Math.abs(t[n]);
                    return e
                }
                return Math.abs(t)
            };
            var defaultCurveSegments = 150,
                degToRads = Math.PI / 180,
                roundCorner = .5519;

            function roundValues(t) {
                bmRnd = t ? Math.round : function(t) {
                    return t
                }
            }

            function styleDiv(t) {
                t.style.position = "absolute", t.style.top = 0, t.style.left = 0, t.style.display = "block", t.style.transformOrigin = "0 0", t.style.webkitTransformOrigin = "0 0", t.style.backfaceVisibility = "visible", t.style.webkitBackfaceVisibility = "visible", t.style.transformStyle = "preserve-3d", t.style.webkitTransformStyle = "preserve-3d", t.style.mozTransformStyle = "preserve-3d"
            }

            function BMEnterFrameEvent(t, e, i, n) {
                this.type = t, this.currentTime = e, this.totalTime = i, this.direction = n < 0 ? -1 : 1
            }

            function BMCompleteEvent(t, e) {
                this.type = t, this.direction = e < 0 ? -1 : 1
            }

            function BMCompleteLoopEvent(t, e, i, n) {
                this.type = t, this.currentLoop = i, this.totalLoops = e, this.direction = n < 0 ? -1 : 1
            }

            function BMSegmentStartEvent(t, e, i) {
                this.type = t, this.firstFrame = e, this.totalFrames = i
            }

            function BMDestroyEvent(t, e) {
                this.type = t, this.target = e
            }

            function BMRenderFrameErrorEvent(t, e) {
                this.type = "renderFrameError", this.nativeError = t, this.currentTime = e
            }

            function BMConfigErrorEvent(t) {
                this.type = "configError", this.nativeError = t
            }

            function BMAnimationConfigErrorEvent(t, e) {
                this.type = t, this.nativeError = e
            }
            roundValues(!1);
            var createElementID = (Ode = 0, function() {
                    return idPrefix + "__lottie_element_" + (Ode += 1)
                }),
                Ode;

            function HSVtoRGB(t, e, i) {
                var n, r, a, s = Math.floor(6 * t),
                    o = 6 * t - s,
                    l = i * (1 - e),
                    h = i * (1 - o * e),
                    u = i * (1 - (1 - o) * e);
                switch (s % 6) {
                    case 0:
                        n = i, r = u, a = l;
                        break;
                    case 1:
                        n = h, r = i, a = l;
                        break;
                    case 2:
                        n = l, r = i, a = u;
                        break;
                    case 3:
                        n = l, r = h, a = i;
                        break;
                    case 4:
                        n = u, r = l, a = i;
                        break;
                    case 5:
                        n = i, r = l, a = h
                }
                return [n, r, a]
            }

            function RGBtoHSV(t, e, i) {
                var n, r = Math.max(t, e, i),
                    a = Math.min(t, e, i),
                    s = r - a,
                    o = 0 === r ? 0 : s / r,
                    l = r / 255;
                switch (r) {
                    case a:
                        n = 0;
                        break;
                    case t:
                        n = e - i + s * (e < i ? 6 : 0), n /= 6 * s;
                        break;
                    case e:
                        n = i - t + 2 * s, n /= 6 * s;
                        break;
                    case i:
                        n = t - e + 4 * s, n /= 6 * s
                }
                return [n, o, l]
            }

            function addSaturationToRGB(t, e) {
                var i = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                return i[1] += e, 1 < i[1] ? i[1] = 1 : i[1] <= 0 && (i[1] = 0), HSVtoRGB(i[0], i[1], i[2])
            }

            function addBrightnessToRGB(t, e) {
                var i = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                return i[2] += e, 1 < i[2] ? i[2] = 1 : i[2] < 0 && (i[2] = 0), HSVtoRGB(i[0], i[1], i[2])
            }

            function addHueToRGB(t, e) {
                var i = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                return i[0] += e / 360, 1 < i[0] ? --i[0] : i[0] < 0 && (i[0] += 1), HSVtoRGB(i[0], i[1], i[2])
            }
            var rgbToHex = function() {
                for (var t, n = [], e = 0; e < 256; e += 1) t = e.toString(16), n[e] = 1 === t.length ? "0" + t : t;
                return function(t, e, i) {
                    return t < 0 && (t = 0), e < 0 && (e = 0), i < 0 && (i = 0), "#" + n[t] + n[e] + n[i]
                }
            }();

            function BaseEvent() {}
            BaseEvent.prototype = {
                triggerEvent: function(t, e) {
                    if (this._cbs[t])
                        for (var i = this._cbs[t], n = 0; n < i.length; n += 1) i[n](e)
                },
                addEventListener: function(t, e) {
                    return this._cbs[t] || (this._cbs[t] = []), this._cbs[t].push(e),
                        function() {
                            this.removeEventListener(t, e)
                        }.bind(this)
                },
                removeEventListener: function(t, e) {
                    if (e) {
                        if (this._cbs[t]) {
                            for (var i = 0, n = this._cbs[t].length; i < n;) this._cbs[t][i] === e && (this._cbs[t].splice(i, 1), --i, --n), i += 1;
                            this._cbs[t].length || (this._cbs[t] = null)
                        }
                    } else this._cbs[t] = null
                }
            };
            var createTypedArray = "function" == typeof Uint8ClampedArray && "function" == typeof Float32Array ? function(t, e) {
                return "float32" === t ? new Float32Array(e) : "int16" === t ? new Int16Array(e) : "uint8c" === t ? new Uint8ClampedArray(e) : Kee(t, e)
            } : Kee;

            function Kee(t, e) {
                var i, n = 0,
                    r = [];
                switch (t) {
                    case "int16":
                    case "uint8c":
                        i = 1;
                        break;
                    default:
                        i = 1.1
                }
                for (n = 0; n < e; n += 1) r.push(i);
                return r
            }

            function createSizedArray(t) {
                return Array.apply(null, {
                    length: t
                })
            }

            function createNS(t) {
                return document.createElementNS(svgNS, t)
            }

            function createTag(t) {
                return document.createElement(t)
            }

            function DynamicPropertyContainer() {}
            DynamicPropertyContainer.prototype = {
                addDynamicProperty: function(t) {
                    -1 === this.dynamicProperties.indexOf(t) && (this.dynamicProperties.push(t), this.container.addDynamicProperty(this), this._isAnimated = !0)
                },
                iterateDynamicProperties: function() {
                    this._mdf = !1;
                    for (var t = this.dynamicProperties.length, e = 0; e < t; e += 1) this.dynamicProperties[e].getValue(), this.dynamicProperties[e]._mdf && (this._mdf = !0)
                },
                initDynamicPropertyContainer: function(t) {
                    this.container = t, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1
                }
            };
            var getBlendMode = (bfe = {
                    0: "source-over",
                    1: "multiply",
                    2: "screen",
                    3: "overlay",
                    4: "darken",
                    5: "lighten",
                    6: "color-dodge",
                    7: "color-burn",
                    8: "hard-light",
                    9: "soft-light",
                    10: "difference",
                    11: "exclusion",
                    12: "hue",
                    13: "saturation",
                    14: "color",
                    15: "luminosity"
                }, function(t) {
                    return bfe[t] || ""
                }),
                bfe, lineCapEnum = {
                    1: "butt",
                    2: "round",
                    3: "square"
                },
                lineJoinEnum = {
                    1: "miter",
                    2: "round",
                    3: "bevel"
                },
                Matrix = (dfe = Math.cos, efe = Math.sin, ffe = Math.tan, gfe = Math.round, function() {
                    this.reset = hfe, this.rotate = ife, this.rotateX = jfe, this.rotateY = kfe, this.rotateZ = lfe, this.skew = nfe, this.skewFromAxis = ofe, this.shear = mfe, this.scale = pfe, this.setTransform = qfe, this.translate = rfe, this.transform = sfe, this.applyToPoint = xfe, this.applyToX = yfe, this.applyToY = zfe, this.applyToZ = Afe, this.applyToPointArray = Ffe, this.applyToTriplePoints = Efe, this.applyToPointStringified = Gfe, this.toCSS = Hfe, this.to2dCSS = Jfe, this.clone = vfe, this.cloneFromProps = wfe, this.equals = ufe, this.inversePoints = Dfe, this.inversePoint = Cfe, this.getInverseMatrix = Bfe, this._t = this.transform, this.isIdentity = tfe, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset()
                }),
                dfe, efe, ffe, gfe;

            function hfe() {
                return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this
            }

            function ife(t) {
                if (0 === t) return this;
                var e = dfe(t),
                    i = efe(t);
                return this._t(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }

            function jfe(t) {
                if (0 === t) return this;
                var e = dfe(t),
                    i = efe(t);
                return this._t(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1)
            }

            function kfe(t) {
                if (0 === t) return this;
                var e = dfe(t),
                    i = efe(t);
                return this._t(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1)
            }

            function lfe(t) {
                if (0 === t) return this;
                var e = dfe(t),
                    i = efe(t);
                return this._t(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }

            function mfe(t, e) {
                return this._t(1, e, t, 1, 0, 0)
            }

            function nfe(t, e) {
                return this.shear(ffe(t), ffe(e))
            }

            function ofe(t, e) {
                var i = dfe(e),
                    n = efe(e);
                return this._t(i, n, 0, 0, -n, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, ffe(t), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(i, -n, 0, 0, n, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }

            function pfe(t, e, i) {
                return i || 0 === i || (i = 1), 1 === t && 1 === e && 1 === i ? this : this._t(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1)
            }

            function qfe(t, e, i, n, r, a, s, o, l, h, u, c, p, d, f, m) {
                return this.props[0] = t, this.props[1] = e, this.props[2] = i, this.props[3] = n, this.props[4] = r, this.props[5] = a, this.props[6] = s, this.props[7] = o, this.props[8] = l, this.props[9] = h, this.props[10] = u, this.props[11] = c, this.props[12] = p, this.props[13] = d, this.props[14] = f, this.props[15] = m, this
            }

            function rfe(t, e, i) {
                return i = i || 0, 0 !== t || 0 !== e || 0 !== i ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, e, i, 1) : this
            }

            function sfe(t, e, i, n, r, a, s, o, l, h, u, c, p, d, f, m) {
                var g = this.props;
                if (1 === t && 0 === e && 0 === i && 0 === n && 0 === r && 1 === a && 0 === s && 0 === o && 0 === l && 0 === h && 1 === u && 0 === c) return g[12] = g[12] * t + g[15] * p, g[13] = g[13] * a + g[15] * d, g[14] = g[14] * u + g[15] * f, g[15] *= m, this._identityCalculated = !1, this;
                var v = g[0],
                    y = g[1],
                    b = g[2],
                    x = g[3],
                    _ = g[4],
                    w = g[5],
                    S = g[6],
                    M = g[7],
                    T = g[8],
                    C = g[9],
                    A = g[10],
                    E = g[11],
                    D = g[12],
                    P = g[13],
                    L = g[14],
                    k = g[15];
                return g[0] = v * t + y * r + b * l + x * p, g[1] = v * e + y * a + b * h + x * d, g[2] = v * i + y * s + b * u + x * f, g[3] = v * n + y * o + b * c + x * m, g[4] = _ * t + w * r + S * l + M * p, g[5] = _ * e + w * a + S * h + M * d, g[6] = _ * i + w * s + S * u + M * f, g[7] = _ * n + w * o + S * c + M * m, g[8] = T * t + C * r + A * l + E * p, g[9] = T * e + C * a + A * h + E * d, g[10] = T * i + C * s + A * u + E * f, g[11] = T * n + C * o + A * c + E * m, g[12] = D * t + P * r + L * l + k * p, g[13] = D * e + P * a + L * h + k * d, g[14] = D * i + P * s + L * u + k * f, g[15] = D * n + P * o + L * c + k * m, this._identityCalculated = !1, this
            }

            function tfe() {
                return this._identityCalculated || (this._identity = !(1 !== this.props[0] || 0 !== this.props[1] || 0 !== this.props[2] || 0 !== this.props[3] || 0 !== this.props[4] || 1 !== this.props[5] || 0 !== this.props[6] || 0 !== this.props[7] || 0 !== this.props[8] || 0 !== this.props[9] || 1 !== this.props[10] || 0 !== this.props[11] || 0 !== this.props[12] || 0 !== this.props[13] || 0 !== this.props[14] || 1 !== this.props[15]), this._identityCalculated = !0), this._identity
            }

            function ufe(t) {
                for (var e = 0; e < 16;) {
                    if (t.props[e] !== this.props[e]) return !1;
                    e += 1
                }
                return !0
            }

            function vfe(t) {
                for (var e = 0; e < 16; e += 1) t.props[e] = this.props[e];
                return t
            }

            function wfe(t) {
                for (var e = 0; e < 16; e += 1) this.props[e] = t[e]
            }

            function xfe(t, e, i) {
                return {
                    x: t * this.props[0] + e * this.props[4] + i * this.props[8] + this.props[12],
                    y: t * this.props[1] + e * this.props[5] + i * this.props[9] + this.props[13],
                    z: t * this.props[2] + e * this.props[6] + i * this.props[10] + this.props[14]
                }
            }

            function yfe(t, e, i) {
                return t * this.props[0] + e * this.props[4] + i * this.props[8] + this.props[12]
            }

            function zfe(t, e, i) {
                return t * this.props[1] + e * this.props[5] + i * this.props[9] + this.props[13]
            }

            function Afe(t, e, i) {
                return t * this.props[2] + e * this.props[6] + i * this.props[10] + this.props[14]
            }

            function Bfe() {
                var t = this.props[0] * this.props[5] - this.props[1] * this.props[4],
                    e = this.props[5] / t,
                    i = -this.props[1] / t,
                    n = -this.props[4] / t,
                    r = this.props[0] / t,
                    a = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / t,
                    s = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / t,
                    o = new Matrix;
                return o.props[0] = e, o.props[1] = i, o.props[4] = n, o.props[5] = r, o.props[12] = a, o.props[13] = s, o
            }

            function Cfe(t) {
                return this.getInverseMatrix().applyToPointArray(t[0], t[1], t[2] || 0)
            }

            function Dfe(t) {
                for (var e = t.length, i = [], n = 0; n < e; n += 1) i[n] = Cfe(t[n]);
                return i
            }

            function Efe(t, e, i) {
                var n, r, a, s, o, l, h = createTypedArray("float32", 6);
                return this.isIdentity() ? (h[0] = t[0], h[1] = t[1], h[2] = e[0], h[3] = e[1], h[4] = i[0], h[5] = i[1]) : (n = this.props[0], r = this.props[1], a = this.props[4], s = this.props[5], o = this.props[12], l = this.props[13], h[0] = t[0] * n + t[1] * a + o, h[1] = t[0] * r + t[1] * s + l, h[2] = e[0] * n + e[1] * a + o, h[3] = e[0] * r + e[1] * s + l, h[4] = i[0] * n + i[1] * a + o, h[5] = i[0] * r + i[1] * s + l), h
            }

            function Ffe(t, e, i) {
                var n = this.isIdentity() ? [t, e, i] : [t * this.props[0] + e * this.props[4] + i * this.props[8] + this.props[12], t * this.props[1] + e * this.props[5] + i * this.props[9] + this.props[13], t * this.props[2] + e * this.props[6] + i * this.props[10] + this.props[14]];
                return n
            }

            function Gfe(t, e) {
                if (this.isIdentity()) return t + "," + e;
                var i = this.props;
                return Math.round(100 * (t * i[0] + e * i[4] + i[12])) / 100 + "," + Math.round(100 * (t * i[1] + e * i[5] + i[13])) / 100
            }

            function Hfe() {
                for (var t = 0, e = this.props, i = "matrix3d("; t < 16;) i += gfe(1e4 * e[t]) / 1e4, i += 15 === t ? ")" : ",", t += 1;
                return i
            }

            function Ife(t) {
                return t < 1e-6 && 0 < t || -1e-6 < t && t < 0 ? gfe(1e4 * t) / 1e4 : t
            }

            function Jfe() {
                var t = this.props;
                return "matrix(" + Ife(t[0]) + "," + Ife(t[1]) + "," + Ife(t[4]) + "," + Ife(t[5]) + "," + Ife(t[12]) + "," + Ife(t[13]) + ")"
            }! function(o, l) {
                var h, u = this,
                    c = 256,
                    p = 6,
                    d = "random",
                    f = l.pow(c, p),
                    m = l.pow(2, 52),
                    g = 2 * m,
                    v = c - 1;

                function y(t) {
                    var e, i = t.length,
                        s = this,
                        n = 0,
                        r = s.i = s.j = 0,
                        a = s.S = [];
                    for (i || (t = [i++]); n < c;) a[n] = n++;
                    for (n = 0; n < c; n++) a[n] = a[r = v & r + t[n % i] + (e = a[n])], a[r] = e;
                    s.g = function(t) {
                        for (var e, i = 0, n = s.i, r = s.j, a = s.S; t--;) e = a[n = v & n + 1], i = i * c + a[v & (a[n] = a[r = v & r + e]) + (a[r] = e)];
                        return s.i = n, s.j = r, i
                    }
                }

                function b(t, e) {
                    return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
                }

                function x(t, e) {
                    for (var i, n = t + "", r = 0; r < n.length;) e[v & r] = v & (i ^= 19 * e[v & r]) + n.charCodeAt(r++);
                    return _(e)
                }

                function _(t) {
                    return String.fromCharCode.apply(0, t)
                }
                l["seed" + d] = function(t, e, i) {
                    function n() {
                        for (var t = s.g(p), e = f, i = 0; t < m;) t = (t + i) * c, e *= c, i = s.g(1);
                        for (; g <= t;) t /= 2, e /= 2, i >>>= 1;
                        return (t + i) / e
                    }
                    var r = [],
                        a = x(function t(e, i) {
                            var n, r = [],
                                a = _typeof(e);
                            if (i && "object" == a)
                                for (n in e) try {
                                    r.push(t(e[n], i - 1))
                                } catch (t) {}
                            return r.length ? r : "string" == a ? e : e + "\0"
                        }((e = !0 === e ? {
                            entropy: !0
                        } : e || {}).entropy ? [t, _(o)] : null === t ? function() {
                            try {
                                if (h) return _(h.randomBytes(c));
                                var t = new Uint8Array(c);
                                return (u.crypto || u.msCrypto).getRandomValues(t), _(t)
                            } catch (t) {
                                var e = u.navigator,
                                    i = e && e.plugins;
                                return [+new Date, u, i, u.screen, _(o)]
                            }
                        }() : t, 3), r),
                        s = new y(r);
                    return n.int32 = function() {
                        return 0 | s.g(4)
                    }, n.quick = function() {
                        return s.g(4) / 4294967296
                    }, n.double = n, x(_(s.S), o), (e.pass || i || function(t, e, i, n) {
                        return n && (n.S && b(n, s), t.state = function() {
                            return b(s, {})
                        }), i ? (l[d] = t, e) : t
                    })(n, a, "global" in e ? e.global : this == l, e.state)
                }, x(l.random(), o)
            }([], BMMath);
            var BezierFactory = (wje = {
                    getBezierEasing: function(t, e, i, n, r) {
                        var a = r || ("bez_" + t + "_" + e + "_" + i + "_" + n).replace(/\./g, "p");
                        if (xje[a]) return xje[a];
                        var s = new Nje([t, e, i, n]);
                        return xje[a] = s
                    }
                }, xje = {}, Dje = 11, Eje = 1 / (Dje - 1), Fje = "function" == typeof Float32Array, Nje.prototype = {
                    get: function(t) {
                        var e = this._p[0],
                            i = this._p[1],
                            n = this._p[2],
                            r = this._p[3];
                        return this._precomputed || this._precompute(), e === i && n === r ? t : 0 === t ? 0 : 1 === t ? 1 : Jje(this._getTForX(t), i, r)
                    },
                    _precompute: function() {
                        var t = this._p[0],
                            e = this._p[1],
                            i = this._p[2],
                            n = this._p[3];
                        this._precomputed = !0, t === e && i === n || this._calcSampleValues()
                    },
                    _calcSampleValues: function() {
                        for (var t = this._p[0], e = this._p[2], i = 0; i < Dje; ++i) this._mSampleValues[i] = Jje(i * Eje, t, e)
                    },
                    _getTForX: function(t) {
                        for (var e = this._p[0], i = this._p[2], n = this._mSampleValues, r = 0, a = 1, s = Dje - 1; a !== s && n[a] <= t; ++a) r += Eje;
                        var o = r + (t - n[--a]) / (n[a + 1] - n[a]) * Eje,
                            l = Kje(o, e, i);
                        return .001 <= l ? function(t, e, i, n) {
                            for (var r = 0; r < 4; ++r) {
                                var a = Kje(e, i, n);
                                if (0 === a) return e;
                                e -= (Jje(e, i, n) - t) / a
                            }
                            return e
                        }(t, o, e, i) : 0 === l ? o : function(t, e, i, n, r) {
                            for (var a, s, o = 0; 0 < (a = Jje(s = e + (i - e) / 2, n, r) - t) ? i = s : e = s, 1e-7 < Math.abs(a) && ++o < 10;);
                            return s
                        }(t, r, r + Eje, e, i)
                    }
                }, wje),
                wje, xje, Dje, Eje, Fje;

            function Gje(t, e) {
                return 1 - 3 * e + 3 * t
            }

            function Jje(t, e, i) {
                return ((Gje(e, i) * t + (3 * i - 6 * e)) * t + 3 * e) * t
            }

            function Kje(t, e, i) {
                return 3 * Gje(e, i) * t * t + 2 * (3 * i - 6 * e) * t + 3 * e
            }

            function Nje(t) {
                this._p = t, this._mSampleValues = new(Fje ? Float32Array : Array)(Dje), this._precomputed = !1, this.get = this.get.bind(this)
            }

            function extendPrototype(t, e) {
                for (var i, n = t.length, r = 0; r < n; r += 1)
                    for (var a in i = t[r].prototype) Object.prototype.hasOwnProperty.call(i, a) && (e.prototype[a] = i[a])
            }

            function getDescriptor(t, e) {
                return Object.getOwnPropertyDescriptor(t, e)
            }

            function createProxyFunction(t) {
                function e() {}
                return e.prototype = t, e
            }

            function bezFunction() {
                var D = Math;

                function g(t, e, i, n, r, a) {
                    var s = t * n + e * r + i * a - r * n - a * t - i * e;
                    return -.001 < s && s < .001
                }
                var u = function(t, e, i, n) {
                    for (var r, a, s, o, l = defaultCurveSegments, h = 0, u = [], c = [], p = bezierLengthPool.newElement(), d = i.length, f = 0; f < l; f += 1) {
                        for (s = f / (l - 1), r = o = 0; r < d; r += 1) a = bmPow(1 - s, 3) * t[r] + 3 * bmPow(1 - s, 2) * s * i[r] + 3 * (1 - s) * bmPow(s, 2) * n[r] + bmPow(s, 3) * e[r], u[r] = a, null !== c[r] && (o += bmPow(u[r] - c[r], 2)), c[r] = u[r];
                        o && (h += o = bmSqrt(o)), p.percents[f] = s, p.lengths[f] = h
                    }
                    return p.addedLength = h, p
                };

                function v(t) {
                    this.segmentLength = 0, this.points = new Array(t)
                }

                function y(t, e) {
                    this.partialLength = t, this.point = e
                }
                var b, t = (b = {}, function(t, e, i, n) {
                    var r = (t[0] + "_" + t[1] + "_" + e[0] + "_" + e[1] + "_" + i[0] + "_" + i[1] + "_" + n[0] + "_" + n[1]).replace(/\./g, "p");
                    if (!b[r]) {
                        var a, s, o, l, h, u = defaultCurveSegments,
                            c = 0,
                            p = null;
                        2 === t.length && (t[0] !== e[0] || t[1] !== e[1]) && g(t[0], t[1], e[0], e[1], t[0] + i[0], t[1] + i[1]) && g(t[0], t[1], e[0], e[1], e[0] + n[0], e[1] + n[1]) && (u = 2);
                        for (var d = new v(u), f = i.length, m = 0; m < u; m += 1) {
                            for (h = createSizedArray(f), o = m / (u - 1), a = l = 0; a < f; a += 1) s = bmPow(1 - o, 3) * t[a] + 3 * bmPow(1 - o, 2) * o * (t[a] + i[a]) + 3 * (1 - o) * bmPow(o, 2) * (e[a] + n[a]) + bmPow(o, 3) * e[a], h[a] = s, null !== p && (l += bmPow(h[a] - p[a], 2));
                            c += l = bmSqrt(l), d.points[m] = new y(l, h), p = h
                        }
                        d.segmentLength = c, b[r] = d
                    }
                    return b[r]
                });

                function P(t, e) {
                    var i = e.percents,
                        n = e.lengths,
                        r = i.length,
                        a = bmFloor((r - 1) * t),
                        s = t * e.addedLength,
                        o = 0;
                    if (a === r - 1 || 0 === a || s === n[a]) return i[a];
                    for (var l = n[a] > s ? -1 : 1, h = !0; h;)
                        if (n[a] <= s && n[a + 1] > s ? (o = (s - n[a]) / (n[a + 1] - n[a]), h = !1) : a += l, a < 0 || r - 1 <= a) {
                            if (a === r - 1) return i[a];
                            h = !1
                        }
                    return i[a] + (i[a + 1] - i[a]) * o
                }
                var L = createTypedArray("float32", 8);
                return {
                    getSegmentsLength: function(t) {
                        for (var e = segmentsLengthPool.newElement(), i = t.c, n = t.v, r = t.o, a = t.i, s = t._length, o = e.lengths, l = 0, h = 0; h < s - 1; h += 1) o[h] = u(n[h], n[h + 1], r[h], a[h + 1]), l += o[h].addedLength;
                        return i && s && (o[h] = u(n[h], n[0], r[h], a[0]), l += o[h].addedLength), e.totalLength = l, e
                    },
                    getNewSegment: function(t, e, i, n, r, a, s) {
                        r < 0 ? r = 0 : 1 < r && (r = 1);
                        for (var o = P(r, s), l = P(a = 1 < a ? 1 : a, s), h = t.length, u = 1 - o, c = 1 - l, p = u * u * u, d = o * u * u * 3, f = o * o * u * 3, m = o * o * o, g = u * u * c, v = o * u * c + u * o * c + u * u * l, y = o * o * c + u * o * l + o * u * l, b = o * o * l, x = u * c * c, _ = o * c * c + u * l * c + u * c * l, w = o * l * c + u * l * l + o * c * l, S = o * l * l, M = c * c * c, T = l * c * c + c * l * c + c * c * l, C = l * l * c + c * l * l + l * c * l, A = l * l * l, E = 0; E < h; E += 1) L[4 * E] = D.round(1e3 * (p * t[E] + d * i[E] + f * n[E] + m * e[E])) / 1e3, L[4 * E + 1] = D.round(1e3 * (g * t[E] + v * i[E] + y * n[E] + b * e[E])) / 1e3, L[4 * E + 2] = D.round(1e3 * (x * t[E] + _ * i[E] + w * n[E] + S * e[E])) / 1e3, L[4 * E + 3] = D.round(1e3 * (M * t[E] + T * i[E] + C * n[E] + A * e[E])) / 1e3;
                        return L
                    },
                    getPointInSegment: function(t, e, i, n, r, a) {
                        var s = P(r, a),
                            o = 1 - s;
                        return [D.round(1e3 * (o * o * o * t[0] + (s * o * o + o * s * o + o * o * s) * i[0] + (s * s * o + o * s * s + s * o * s) * n[0] + s * s * s * e[0])) / 1e3, D.round(1e3 * (o * o * o * t[1] + (s * o * o + o * s * o + o * o * s) * i[1] + (s * s * o + o * s * s + s * o * s) * n[1] + s * s * s * e[1])) / 1e3]
                    },
                    buildBezierData: t,
                    pointOnLine2D: g,
                    pointOnLine3D: function(t, e, i, n, r, a, s, o, l) {
                        if (0 === i && 0 === a && 0 === l) return g(t, e, n, r, s, o);
                        var h = D.sqrt(D.pow(n - t, 2) + D.pow(r - e, 2) + D.pow(a - i, 2)),
                            u = D.sqrt(D.pow(s - t, 2) + D.pow(o - e, 2) + D.pow(l - i, 2)),
                            c = D.sqrt(D.pow(s - n, 2) + D.pow(o - r, 2) + D.pow(l - a, 2)),
                            p = u < h ? c < h ? h - u - c : c - u - h : u < c ? c - u - h : u - h - c;
                        return -1e-4 < p && p < 1e-4
                    }
                }
            }! function() {
                for (var r = 0, t = ["ms", "moz", "webkit", "o"], e = 0; e < t.length && !window.requestAnimationFrame; ++e) window.requestAnimationFrame = window[t[e] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[t[e] + "CancelAnimationFrame"] || window[t[e] + "CancelRequestAnimationFrame"];
                window.requestAnimationFrame || (window.requestAnimationFrame = function(t) {
                    var e = (new Date).getTime(),
                        i = Math.max(0, 16 - (e - r)),
                        n = setTimeout(function() {
                            t(e + i)
                        }, i);
                    return r = e + i, n
                }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(t) {
                    clearTimeout(t)
                })
            }();
            var bez = bezFunction();

            function dataFunctionManager() {
                function p(t, e, i) {
                    for (var n, r, a, s, o = t.length, l = 0; l < o; l += 1)
                        if ("ks" in (n = t[l]) && !n.completed) {
                            if (n.completed = !0, n.tt && (t[l - 1].td = n.tt), n.hasMask)
                                for (var h = n.masksProperties, u = h.length, c = 0; c < u; c += 1)
                                    if (h[c].pt.k.i) d(h[c].pt.k);
                                    else
                                        for (a = h[c].pt.k.length, r = 0; r < a; r += 1) h[c].pt.k[r].s && d(h[c].pt.k[r].s[0]), h[c].pt.k[r].e && d(h[c].pt.k[r].e[0]);
                            0 === n.ty ? (n.layers = function(t, e) {
                                var i = 0,
                                    n = e.length;
                                for (; i < n;) {
                                    if (e[i].id === t) return e[i].layers.__used ? JSON.parse(JSON.stringify(e[i].layers)) : (e[i].layers.__used = !0, e[i].layers);
                                    i += 1
                                }
                                return null
                            }(n.refId, e), p(n.layers, e, i)) : 4 === n.ty ? function t(e) {
                                var i;
                                var n = e.length;
                                var r;
                                var a;
                                for (i = n - 1; 0 <= i; --i)
                                    if ("sh" === e[i].ty)
                                        if (e[i].ks.k.i) d(e[i].ks.k);
                                        else
                                            for (a = e[i].ks.k.length, r = 0; r < a; r += 1) e[i].ks.k[r].s && d(e[i].ks.k[r].s[0]), e[i].ks.k[r].e && d(e[i].ks.k[r].e[0]);
                                else "gr" === e[i].ty && t(e[i].it)
                            }(n.shapes) : 5 === n.ty && (0 !== (s = n).t.a.length || "m" in s.t.p || (s.singleShape = !0))
                        }
                }

                function d(t) {
                    for (var e = t.i.length, i = 0; i < e; i += 1) t.i[i][0] += t.v[i][0], t.i[i][1] += t.v[i][1], t.o[i][0] += t.v[i][0], t.o[i][1] += t.v[i][1]
                }

                function o(t, e) {
                    var i = e ? e.split(".") : [100, 100, 100];
                    if (t[0] > i[0]) return 1;
                    if (!(i[0] > t[0])) {
                        if (t[1] > i[1]) return 1;
                        if (!(i[1] > t[1])) return t[2] > i[2] || (i[2], void t[2])
                    }
                }
                var n, i = (n = [4, 4, 14], function(t) {
                    if (o(n, t.v) && (r(t.layers), t.assets))
                        for (var e = t.assets.length, i = 0; i < e; i += 1) t.assets[i].layers && r(t.assets[i].layers)
                });

                function r(t) {
                    for (var e, i, n = t.length, r = 0; r < n; r += 1) 5 === t[r].ty && (e = t[r], i = e.t.d, e.t.d = {
                        k: [{
                            s: i,
                            t: 0
                        }]
                    })
                }
                var l, a, s = (l = [4, 7, 99], function(t) {
                        if (t.chars && !o(l, t.v))
                            for (var e, i, n, r, a = t.chars.length, s = 0; s < a; s += 1)
                                if (t.chars[s].data && t.chars[s].data.shapes)
                                    for (i = (r = t.chars[s].data.shapes[0].it).length, e = 0; e < i; e += 1)(n = r[e].ks.k).__converted || (d(r[e].ks.k), n.__converted = !0)
                    }),
                    h = (a = [4, 1, 9], function(t) {
                        if (o(a, t.v) && (u(t.layers), t.assets))
                            for (var e = t.assets.length, i = 0; i < e; i += 1) t.assets[i].layers && u(t.assets[i].layers)
                    });

                function u(t) {
                    for (var e = t.length, i = 0; i < e; i += 1) 4 === t[i].ty && ! function t(e) {
                        for (var i, n, r = e.length, a = 0; a < r; a += 1)
                            if ("gr" === e[a].ty) t(e[a].it);
                            else if ("fl" === e[a].ty || "st" === e[a].ty)
                            if (e[a].c.k && e[a].c.k[0].i)
                                for (n = e[a].c.k.length, i = 0; i < n; i += 1) e[a].c.k[i].s && (e[a].c.k[i].s[0] /= 255, e[a].c.k[i].s[1] /= 255, e[a].c.k[i].s[2] /= 255, e[a].c.k[i].s[3] /= 255), e[a].c.k[i].e && (e[a].c.k[i].e[0] /= 255, e[a].c.k[i].e[1] /= 255, e[a].c.k[i].e[2] /= 255, e[a].c.k[i].e[3] /= 255);
                            else e[a].c.k[0] /= 255, e[a].c.k[1] /= 255, e[a].c.k[2] /= 255, e[a].c.k[3] /= 255
                    }(t[i].shapes)
                }
                var c, f = (c = [4, 4, 18], function(t) {
                    if (o(c, t.v) && (m(t.layers), t.assets))
                        for (var e = t.assets.length, i = 0; i < e; i += 1) t.assets[i].layers && m(t.assets[i].layers)
                });

                function m(t) {
                    for (var e, i, n, r = t.length, a = 0; a < r; a += 1) {
                        if ((e = t[a]).hasMask)
                            for (var s = e.masksProperties, o = s.length, l = 0; l < o; l += 1)
                                if (s[l].pt.k.i) s[l].pt.k.c = s[l].cl;
                                else
                                    for (n = s[l].pt.k.length, i = 0; i < n; i += 1) s[l].pt.k[i].s && (s[l].pt.k[i].s[0].c = s[l].cl), s[l].pt.k[i].e && (s[l].pt.k[i].e[0].c = s[l].cl);
                        4 === e.ty && ! function t(e) {
                            for (var i, n, r = e.length - 1; 0 <= r; --r)
                                if ("sh" === e[r].ty)
                                    if (e[r].ks.k.i) e[r].ks.k.c = e[r].closed;
                                    else
                                        for (n = e[r].ks.k.length, i = 0; i < n; i += 1) e[r].ks.k[i].s && (e[r].ks.k[i].s[0].c = e[r].closed), e[r].ks.k[i].e && (e[r].ks.k[i].e[0].c = e[r].closed);
                            else "gr" === e[r].ty && t(e[r].it)
                        }(e.shapes)
                    }
                }
                var t = {
                    completeData: function(t, e) {
                        t.__complete || (h(t), i(t), s(t), f(t), p(t.layers, t.assets, e), t.__complete = !0)
                    }
                };
                return t.checkColors = h, t.checkChars = s, t.checkShapes = f, t.completeLayers = p, t
            }
            var dataManager = dataFunctionManager();

            function getFontProperties(t) {
                for (var e = t.fStyle ? t.fStyle.split(" ") : [], i = "normal", n = "normal", r = e.length, a = 0; a < r; a += 1) switch (e[a].toLowerCase()) {
                    case "italic":
                        n = "italic";
                        break;
                    case "bold":
                        i = "700";
                        break;
                    case "black":
                        i = "900";
                        break;
                    case "medium":
                        i = "500";
                        break;
                    case "regular":
                    case "normal":
                        i = "400";
                        break;
                    case "light":
                    case "thin":
                        i = "200"
                }
                return {
                    style: n,
                    weight: t.fWeight || i
                }
            }
            var FontManager = (wpe = {
                    w: 0,
                    size: 0,
                    shapes: []
                }, xpe = (xpe = []).concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]), ype = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"], zpe = [65039, 8205], Npe.isModifier = function(t, e) {
                    var i = t.toString(16) + e.toString(16);
                    return -1 !== ype.indexOf(i)
                }, Npe.isZeroWidthJoiner = function(t, e) {
                    return e ? t === zpe[0] && e === zpe[1] : t === zpe[1]
                }, Npe.isCombinedCharacter = function(t) {
                    return -1 !== xpe.indexOf(t)
                }, Npe.prototype = {
                    addChars: function(t) {
                        if (t) {
                            this.chars || (this.chars = []);
                            for (var e, i, n = t.length, r = this.chars.length, a = 0; a < n; a += 1) {
                                for (e = 0, i = !1; e < r;) this.chars[e].style === t[a].style && this.chars[e].fFamily === t[a].fFamily && this.chars[e].ch === t[a].ch && (i = !0), e += 1;
                                i || (this.chars.push(t[a]), r += 1)
                            }
                        }
                    },
                    addFonts: function(t, e) {
                        if (t) {
                            if (this.chars) return this.isLoaded = !0, void(this.fonts = t.list);
                            for (var i = t.list, n = i.length, r = n, a = 0; a < n; a += 1) {
                                var s, o, l, h, u, c = !0;
                                if (i[a].loaded = !1, i[a].monoCase = Bpe(i[a].fFamily, "monospace"), i[a].sansCase = Bpe(i[a].fFamily, "sans-serif"), i[a].fPath) {
                                    if ("p" === i[a].fOrigin || 3 === i[a].origin) 0 < (l = document.querySelectorAll('style[f-forigin="p"][f-family="' + i[a].fFamily + '"], style[f-origin="3"][f-family="' + i[a].fFamily + '"]')).length && (c = !1), c && ((o = createTag("style")).setAttribute("f-forigin", i[a].fOrigin), o.setAttribute("f-origin", i[a].origin), o.setAttribute("f-family", i[a].fFamily), o.type = "text/css", o.innerText = "@font-face {font-family: " + i[a].fFamily + "; font-style: normal; src: url('" + i[a].fPath + "');}", e.appendChild(o));
                                    else if ("g" === i[a].fOrigin || 1 === i[a].origin) {
                                        for (l = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), s = 0; s < l.length; s += 1) - 1 !== l[s].href.indexOf(i[a].fPath) && (c = !1);
                                        c && ((h = createTag("link")).setAttribute("f-forigin", i[a].fOrigin), h.setAttribute("f-origin", i[a].origin), h.type = "text/css", h.rel = "stylesheet", h.href = i[a].fPath, document.body.appendChild(h))
                                    } else if ("t" === i[a].fOrigin || 2 === i[a].origin) {
                                        for (l = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), s = 0; s < l.length; s += 1) i[a].fPath === l[s].src && (c = !1);
                                        c && ((u = createTag("link")).setAttribute("f-forigin", i[a].fOrigin), u.setAttribute("f-origin", i[a].origin), u.setAttribute("rel", "stylesheet"), u.setAttribute("href", i[a].fPath), e.appendChild(u))
                                    }
                                } else i[a].loaded = !0, --r;
                                i[a].helper = function(t, e) {
                                    var i = createNS("text");
                                    i.style.fontSize = "100px";
                                    var n = getFontProperties(e);
                                    return i.setAttribute("font-family", e.fFamily), i.setAttribute("font-style", n.style), i.setAttribute("font-weight", n.weight), i.textContent = "1", e.fClass ? (i.style.fontFamily = "inherit", i.setAttribute("class", e.fClass)) : i.style.fontFamily = e.fFamily, t.appendChild(i), createTag("canvas").getContext("2d").font = e.fWeight + " " + e.fStyle + " 100px " + e.fFamily, i
                                }(e, i[a]), i[a].cache = {}, this.fonts.push(i[a])
                            }
                            0 === r ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
                        } else this.isLoaded = !0
                    },
                    getCharData: function(t, e, i) {
                        for (var n = 0, r = this.chars.length; n < r;) {
                            if (this.chars[n].ch === t && this.chars[n].style === e && this.chars[n].fFamily === i) return this.chars[n];
                            n += 1
                        }
                        return ("string" == typeof t && 13 !== t.charCodeAt(0) || !t) && console && console.warn && !this._warned && (this._warned = !0), wpe
                    },
                    getFontByName: function(t) {
                        for (var e = 0, i = this.fonts.length; e < i;) {
                            if (this.fonts[e].fName === t) return this.fonts[e];
                            e += 1
                        }
                        return this.fonts[0]
                    },
                    measureText: function(t, e, i) {
                        var n, r, a, s = this.getFontByName(e),
                            o = t.charCodeAt(0);
                        return s.cache[o + 1] || (n = s.helper, " " === t ? (n.textContent = "|" + t + "|", r = n.getComputedTextLength(), n.textContent = "||", a = n.getComputedTextLength(), s.cache[o + 1] = (r - a) / 100) : (n.textContent = t, s.cache[o + 1] = n.getComputedTextLength() / 100)), s.cache[o + 1] * i
                    },
                    checkLoadedFonts: function() {
                        for (var t, e, i = this.fonts.length, n = i, r = 0; r < i; r += 1) this.fonts[r].loaded ? --n : "n" === this.fonts[r].fOrigin || 0 === this.fonts[r].origin ? this.fonts[r].loaded = !0 : (t = this.fonts[r].monoCase.node, e = this.fonts[r].monoCase.w, t.offsetWidth !== e ? (--n, this.fonts[r].loaded = !0) : (t = this.fonts[r].sansCase.node, e = this.fonts[r].sansCase.w, t.offsetWidth !== e && (--n, this.fonts[r].loaded = !0)), this.fonts[r].loaded && (this.fonts[r].sansCase.parent.parentNode.removeChild(this.fonts[r].sansCase.parent), this.fonts[r].monoCase.parent.parentNode.removeChild(this.fonts[r].monoCase.parent)));
                        0 !== n && Date.now() - this.initTime < 5e3 ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
                    },
                    setIsLoaded: function() {
                        this.isLoaded = !0
                    }
                }, Npe),
                wpe, xpe, ype, zpe;

            function Bpe(t, e) {
                var i = createTag("span");
                i.setAttribute("aria-hidden", !0), i.style.fontFamily = e;
                var n = createTag("span");
                n.innerText = "giItT1WQy@!-/#", i.style.position = "absolute", i.style.left = "-10000px", i.style.top = "-10000px", i.style.fontSize = "300px", i.style.fontVariant = "normal", i.style.fontStyle = "normal", i.style.fontWeight = "normal", i.style.letterSpacing = "0", i.appendChild(n), document.body.appendChild(i);
                var r = n.offsetWidth;
                return n.style.fontFamily = function(t) {
                    for (var e = t.split(","), i = e.length, n = [], r = 0; r < i; r += 1) "sans-serif" !== e[r] && "monospace" !== e[r] && n.push(e[r]);
                    return n.join(",")
                }(t) + ", " + e, {
                    node: n,
                    w: r,
                    parent: i
                }
            }

            function Npe() {
                this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
            }
            var PropertyFactory = (Wqe = initialDefaultFrame, Xqe = Math.abs, {
                    getProp: function(t, e, i, n, r) {
                        var a;
                        if (e.k.length)
                            if ("number" == typeof e.k[0]) a = new fre(t, e, n, r);
                            else switch (i) {
                                case 0:
                                    a = new gre(t, e, n, r);
                                    break;
                                case 1:
                                    a = new hre(t, e, n, r)
                            } else a = new ere(t, e, n, r);
                        return a.effectsSequence.length && r.addDynamicProperty(a), a
                    }
                }),
                Wqe, Xqe;

            function Yqe(t, e) {
                var i, n = this.offsetTime;
                "multidimensional" === this.propType && (i = createTypedArray("float32", this.pv.length));
                for (var r, a, s, o, l = e.lastIndex, h = l, u = this.keyframes.length - 1, c = !0; c;) {
                    if (r = this.keyframes[h], a = this.keyframes[h + 1], h === u - 1 && t >= a.t - n) {
                        r.h && (r = a), l = 0;
                        break
                    }
                    if (a.t - n > t) {
                        l = h;
                        break
                    }
                    h < u - 1 ? h += 1 : (l = 0, c = !1)
                }
                var p, d, f, m, g, v, y, b, x, _ = a.t - n,
                    w = r.t - n;
                if (r.to) {
                    r.bezierData || (r.bezierData = bez.buildBezierData(r.s, a.s || r.e, r.to, r.ti));
                    var S = r.bezierData;
                    if (_ <= t || t < w)
                        for (var M = _ <= t ? S.points.length - 1 : 0, T = S.points[M].point.length, C = 0; C < T; C += 1) i[C] = S.points[M].point[C];
                    else {
                        r.__fnct ? o = r.__fnct : (o = BezierFactory.getBezierEasing(r.o.x, r.o.y, r.i.x, r.i.y, r.n).get, r.__fnct = o), s = o((t - w) / (_ - w));
                        for (var A, E = S.segmentLength * s, D = e.lastFrame < t && e._lastKeyframeIndex === h ? e._lastAddedLength : 0, P = e.lastFrame < t && e._lastKeyframeIndex === h ? e._lastPoint : 0, c = !0, L = S.points.length; c;) {
                            if (D += S.points[P].partialLength, 0 == E || 0 === s || P === S.points.length - 1) {
                                for (T = S.points[P].point.length, C = 0; C < T; C += 1) i[C] = S.points[P].point[C];
                                break
                            }
                            if (D <= E && E < D + S.points[P + 1].partialLength) {
                                for (A = (E - D) / S.points[P + 1].partialLength, T = S.points[P].point.length, C = 0; C < T; C += 1) i[C] = S.points[P].point[C] + (S.points[P + 1].point[C] - S.points[P].point[C]) * A;
                                break
                            }
                            P < L - 1 ? P += 1 : c = !1
                        }
                        e._lastPoint = P, e._lastAddedLength = D - S.points[P].partialLength, e._lastKeyframeIndex = h
                    }
                } else {
                    var k, O, F, I, N, B, R, u = r.s.length,
                        z = a.s || r.e;
                    if (this.sh && 1 !== r.h) _ <= t ? (i[0] = z[0], i[1] = z[1], i[2] = z[2]) : t <= w ? (i[0] = r.s[0], i[1] = r.s[1], i[2] = r.s[2]) : (B = _qe(r.s), R = _qe(z), p = i, d = function(t, e, i) {
                        var n, r, a, s, o, l = [],
                            h = t[0],
                            u = t[1],
                            c = t[2],
                            p = t[3],
                            d = e[0],
                            f = e[1],
                            m = e[2],
                            g = e[3];
                        (r = h * d + u * f + c * m + p * g) < 0 && (r = -r, d = -d, f = -f, m = -m, g = -g);
                        o = 1e-6 < 1 - r ? (n = Math.acos(r), a = Math.sin(n), s = Math.sin((1 - i) * n) / a, Math.sin(i * n) / a) : (s = 1 - i, i);
                        return l[0] = s * h + o * d, l[1] = s * u + o * f, l[2] = s * c + o * m, l[3] = s * p + o * g, l
                    }(B, R, (t - w) / (_ - w)), f = d[0], m = d[1], g = d[2], v = d[3], y = Math.atan2(2 * m * v - 2 * f * g, 1 - 2 * m * m - 2 * g * g), b = Math.asin(2 * f * m + 2 * g * v), x = Math.atan2(2 * f * v - 2 * m * g, 1 - 2 * f * f - 2 * g * g), p[0] = y / degToRads, p[1] = b / degToRads, p[2] = x / degToRads);
                    else
                        for (h = 0; h < u; h += 1) 1 !== r.h && (s = _ <= t ? 1 : t < w ? 0 : (r.o.x.constructor === Array ? (r.__fnct || (r.__fnct = []), r.__fnct[h] ? o = r.__fnct[h] : (k = void 0 === r.o.x[h] ? r.o.x[0] : r.o.x[h], O = void 0 === r.o.y[h] ? r.o.y[0] : r.o.y[h], F = void 0 === r.i.x[h] ? r.i.x[0] : r.i.x[h], I = void 0 === r.i.y[h] ? r.i.y[0] : r.i.y[h], o = BezierFactory.getBezierEasing(k, O, F, I).get, r.__fnct[h] = o)) : r.__fnct ? o = r.__fnct : (k = r.o.x, O = r.o.y, F = r.i.x, I = r.i.y, o = BezierFactory.getBezierEasing(k, O, F, I).get, r.__fnct = o), o((t - w) / (_ - w)))), z = a.s || r.e, N = 1 === r.h ? r.s[h] : r.s[h] + (z[h] - r.s[h]) * s, "multidimensional" === this.propType ? i[h] = N : i = N
                }
                return e.lastIndex = l, i
            }

            function _qe(t) {
                var e = t[0] * degToRads,
                    i = t[1] * degToRads,
                    n = t[2] * degToRads,
                    r = Math.cos(e / 2),
                    a = Math.cos(i / 2),
                    s = Math.cos(n / 2),
                    o = Math.sin(e / 2),
                    l = Math.sin(i / 2),
                    h = Math.sin(n / 2);
                return [o * l * s + r * a * h, o * a * s + r * l * h, r * l * s - o * a * h, r * a * s - o * l * h]
            }

            function are() {
                var t, e = this.comp.renderedFrame - this.offsetTime,
                    i = this.keyframes[0].t - this.offsetTime,
                    n = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
                return e === this._caching.lastFrame || this._caching.lastFrame !== Wqe && (this._caching.lastFrame >= n && n <= e || this._caching.lastFrame < i && e < i) || (this._caching.lastFrame >= e && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0), t = this.interpolateValue(e, this._caching), this.pv = t), this._caching.lastFrame = e, this.pv
            }

            function bre(t) {
                var e;
                if ("unidimensional" === this.propType) e = t * this.mult, 1e-5 < Xqe(this.v - e) && (this.v = e, this._mdf = !0);
                else
                    for (var i = 0, n = this.v.length; i < n;) e = t[i] * this.mult, 1e-5 < Xqe(this.v[i] - e) && (this.v[i] = e, this._mdf = !0), i += 1
            }

            function cre() {
                if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length)
                    if (this.lock) this.setVValue(this.pv);
                    else {
                        this.lock = !0, this._mdf = this._isFirstFrame;
                        for (var t = this.effectsSequence.length, e = this.kf ? this.pv : this.data.k, i = 0; i < t; i += 1) e = this.effectsSequence[i](e);
                        this.setVValue(e), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId
                    }
            }

            function dre(t) {
                this.effectsSequence.push(t), this.container.addDynamicProperty(this)
            }

            function ere(t, e, i, n) {
                this.propType = "unidimensional", this.mult = i || 1, this.data = e, this.v = i ? e.k * i : e.k, this.pv = e.k, this._mdf = !1, this.elem = t, this.container = n, this.comp = t.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = cre, this.setVValue = bre, this.addEffect = dre
            }

            function fre(t, e, i, n) {
                var r;
                this.propType = "multidimensional", this.mult = i || 1, this.data = e, this._mdf = !1, this.elem = t, this.container = n, this.comp = t.comp, this.k = !1, this.kf = !1, this.frameId = -1;
                var a = e.k.length;
                for (this.v = createTypedArray("float32", a), this.pv = createTypedArray("float32", a), this.vel = createTypedArray("float32", a), r = 0; r < a; r += 1) this.v[r] = e.k[r] * this.mult, this.pv[r] = e.k[r];
                this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = cre, this.setVValue = bre, this.addEffect = dre
            }

            function gre(t, e, i, n) {
                this.propType = "unidimensional", this.keyframes = e.k, this.offsetTime = t.data.st, this.frameId = -1, this._caching = {
                    lastFrame: Wqe,
                    lastIndex: 0,
                    value: 0,
                    _lastKeyframeIndex: -1
                }, this.k = !0, this.kf = !0, this.data = e, this.mult = i || 1, this.elem = t, this.container = n, this.comp = t.comp, this.v = Wqe, this.pv = Wqe, this._isFirstFrame = !0, this.getValue = cre, this.setVValue = bre, this.interpolateValue = Yqe, this.effectsSequence = [are.bind(this)], this.addEffect = dre
            }

            function hre(t, e, i, n) {
                this.propType = "multidimensional";
                for (var r, a, s, o, l = e.k.length, h = 0; h < l - 1; h += 1) e.k[h].to && e.k[h].s && e.k[h + 1] && e.k[h + 1].s && (r = e.k[h].s, a = e.k[h + 1].s, s = e.k[h].to, o = e.k[h].ti, (2 === r.length && (r[0] !== a[0] || r[1] !== a[1]) && bez.pointOnLine2D(r[0], r[1], a[0], a[1], r[0] + s[0], r[1] + s[1]) && bez.pointOnLine2D(r[0], r[1], a[0], a[1], a[0] + o[0], a[1] + o[1]) || 3 === r.length && (r[0] !== a[0] || r[1] !== a[1] || r[2] !== a[2]) && bez.pointOnLine3D(r[0], r[1], r[2], a[0], a[1], a[2], r[0] + s[0], r[1] + s[1], r[2] + s[2]) && bez.pointOnLine3D(r[0], r[1], r[2], a[0], a[1], a[2], a[0] + o[0], a[1] + o[1], a[2] + o[2])) && (e.k[h].to = null, e.k[h].ti = null), r[0] === a[0] && r[1] === a[1] && 0 === s[0] && 0 === s[1] && 0 === o[0] && 0 === o[1] && (2 === r.length || r[2] === a[2] && 0 === s[2] && 0 === o[2]) && (e.k[h].to = null, e.k[h].ti = null));
                this.effectsSequence = [are.bind(this)], this.data = e, this.keyframes = e.k, this.offsetTime = t.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = i || 1, this.elem = t, this.container = n, this.comp = t.comp, this.getValue = cre, this.setVValue = bre, this.interpolateValue = Yqe, this.frameId = -1;
                var u = e.k[0].s.length;
                for (this.v = createTypedArray("float32", u), this.pv = createTypedArray("float32", u), h = 0; h < u; h += 1) this.v[h] = Wqe, this.pv[h] = Wqe;
                this._caching = {
                    lastFrame: Wqe,
                    lastIndex: 0,
                    value: createTypedArray("float32", u)
                }, this.addEffect = dre
            }
            var TransformPropertyFactory = (rte = [0, 0], xte.prototype = {
                    applyToMatrix: function(t) {
                        var e = this._mdf;
                        this.iterateDynamicProperties(), this._mdf = this._mdf || e, this.a && t.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && t.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && t.skewFromAxis(-this.sk.v, this.sa.v), this.r ? t.rotate(-this.r.v) : t.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? t.translate(this.px.v, this.py.v, -this.pz.v) : t.translate(this.px.v, this.py.v, 0) : t.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                    },
                    getValue: function(t) {
                        var e, i, n, r, a;
                        this.elem.globalData.frameId !== this.frameId && (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), (this._mdf || t) && (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented && (a = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime ? i = this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (e = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / a, 0), this.p.getValueAtTime(this.p.keyframes[0].t / a, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (e = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / a, 0), this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / a, 0)) : (e = this.p.pv, this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / a, this.p.offsetTime)) : this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime ? (e = [], i = [], n = this.px, r = this.py, n._caching.lastFrame + n.offsetTime <= n.keyframes[0].t ? (e[0] = n.getValueAtTime((n.keyframes[0].t + .01) / a, 0), e[1] = r.getValueAtTime((r.keyframes[0].t + .01) / a, 0), i[0] = n.getValueAtTime(n.keyframes[0].t / a, 0), i[1] = r.getValueAtTime(r.keyframes[0].t / a, 0)) : n._caching.lastFrame + n.offsetTime >= n.keyframes[n.keyframes.length - 1].t ? (e[0] = n.getValueAtTime(n.keyframes[n.keyframes.length - 1].t / a, 0), e[1] = r.getValueAtTime(r.keyframes[r.keyframes.length - 1].t / a, 0), i[0] = n.getValueAtTime((n.keyframes[n.keyframes.length - 1].t - .01) / a, 0), i[1] = r.getValueAtTime((r.keyframes[r.keyframes.length - 1].t - .01) / a, 0)) : (e = [n.pv, r.pv], i[0] = n.getValueAtTime((n._caching.lastFrame + n.offsetTime - .01) / a, n.offsetTime), i[1] = r.getValueAtTime((r._caching.lastFrame + r.offsetTime - .01) / a, r.offsetTime))) : e = i = rte, this.v.rotate(-Math.atan2(e[1] - i[1], e[0] - i[0]))), this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])), this.frameId = this.elem.globalData.frameId)
                    },
                    precalculateMatrix: function() {
                        if (!this.a.k && (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1, !this.s.effectsSequence.length)) {
                            if (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2, this.sk) {
                                if (this.sk.effectsSequence.length || this.sa.effectsSequence.length) return;
                                this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3
                            }
                            this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : this.rz.effectsSequence.length || this.ry.effectsSequence.length || this.rx.effectsSequence.length || this.or.effectsSequence.length || (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4)
                        }
                    },
                    autoOrient: function() {}
                }, extendPrototype([DynamicPropertyContainer], xte), xte.prototype.addDynamicProperty = function(t) {
                    this._addDynamicProperty(t), this.elem.addDynamicProperty(t), this._isDirty = !0
                }, xte.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty, {
                    getTransformProperty: function(t, e, i) {
                        return new xte(t, e, i)
                    }
                }),
                rte;

            function xte(t, e, i) {
                if (this.elem = t, this.frameId = -1, this.propType = "transform", this.data = e, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(i || t), e.p && e.p.s ? (this.px = PropertyFactory.getProp(t, e.p.x, 0, 0, this), this.py = PropertyFactory.getProp(t, e.p.y, 0, 0, this), e.p.z && (this.pz = PropertyFactory.getProp(t, e.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(t, e.p || {
                        k: [0, 0, 0]
                    }, 1, 0, this), e.rx) {
                    if (this.rx = PropertyFactory.getProp(t, e.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(t, e.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(t, e.rz, 0, degToRads, this), e.or.k[0].ti)
                        for (var n = e.or.k.length, r = 0; r < n; r += 1) e.or.k[r].to = null, e.or.k[r].ti = null;
                    this.or = PropertyFactory.getProp(t, e.or, 1, degToRads, this), this.or.sh = !0
                } else this.r = PropertyFactory.getProp(t, e.r || {
                    k: 0
                }, 0, degToRads, this);
                e.sk && (this.sk = PropertyFactory.getProp(t, e.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(t, e.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(t, e.a || {
                    k: [0, 0, 0]
                }, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s || {
                    k: [100, 100, 100]
                }, 1, .01, this), e.o ? this.o = PropertyFactory.getProp(t, e.o, 0, .01, t) : this.o = {
                    _mdf: !1,
                    v: 1
                }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0)
            }

            function ShapePath() {
                this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength)
            }
            ShapePath.prototype.setPathData = function(t, e) {
                this.c = t, this.setLength(e);
                for (var i = 0; i < e;) this.v[i] = pointPool.newElement(), this.o[i] = pointPool.newElement(), this.i[i] = pointPool.newElement(), i += 1
            }, ShapePath.prototype.setLength = function(t) {
                for (; this._maxLength < t;) this.doubleArrayLength();
                this._length = t
            }, ShapePath.prototype.doubleArrayLength = function() {
                this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2
            }, ShapePath.prototype.setXYAt = function(t, e, i, n, r) {
                var a;
                switch (this._length = Math.max(this._length, n + 1), this._length >= this._maxLength && this.doubleArrayLength(), i) {
                    case "v":
                        a = this.v;
                        break;
                    case "i":
                        a = this.i;
                        break;
                    case "o":
                        a = this.o;
                        break;
                    default:
                        a = []
                }
                a[n] && (!a[n] || r) || (a[n] = pointPool.newElement()), a[n][0] = t, a[n][1] = e
            }, ShapePath.prototype.setTripleAt = function(t, e, i, n, r, a, s, o) {
                this.setXYAt(t, e, "v", s, o), this.setXYAt(i, n, "o", s, o), this.setXYAt(r, a, "i", s, o)
            }, ShapePath.prototype.reverse = function() {
                var t = new ShapePath;
                t.setPathData(this.c, this._length);
                var e = this.v,
                    i = this.o,
                    n = this.i,
                    r = 0;
                this.c && (t.setTripleAt(e[0][0], e[0][1], n[0][0], n[0][1], i[0][0], i[0][1], 0, !1), r = 1);
                for (var a = this._length - 1, s = this._length, o = r; o < s; o += 1) t.setTripleAt(e[a][0], e[a][1], n[a][0], n[a][1], i[a][0], i[a][1], o, !1), --a;
                return t
            };
            var ShapePropertyFactory = function() {
                    var r = -999999;

                    function t(t, e, i) {
                        var n, r, a, s, o, l, h, u = i.lastIndex,
                            c = this.keyframes;
                        if (t < c[0].t - this.offsetTime) n = c[0].s[0], r = !0, u = 0;
                        else if (t >= c[c.length - 1].t - this.offsetTime) n = c[c.length - 1].s ? c[c.length - 1].s[0] : c[c.length - 2].e[0], r = !0;
                        else {
                            for (var p, d, f, m, g, v = u, y = c.length - 1, b = !0; b && (p = c[v], !((d = c[v + 1]).t - this.offsetTime > t));) v < y - 1 ? v += 1 : b = !1;
                            u = v, (r = 1 === p.h) || (m = t >= d.t - this.offsetTime ? 1 : t < p.t - this.offsetTime ? 0 : (p.__fnct ? f = p.__fnct : (f = BezierFactory.getBezierEasing(p.o.x, p.o.y, p.i.x, p.i.y).get, p.__fnct = f), f((t - (p.t - this.offsetTime)) / (d.t - this.offsetTime - (p.t - this.offsetTime)))), g = d.s ? d.s[0] : p.e[0]), n = p.s[0]
                        }
                        for (o = e._length, l = n.i[0].length, i.lastIndex = u, a = 0; a < o; a += 1)
                            for (s = 0; s < l; s += 1) h = r ? n.i[a][s] : n.i[a][s] + (g.i[a][s] - n.i[a][s]) * m, e.i[a][s] = h, h = r ? n.o[a][s] : n.o[a][s] + (g.o[a][s] - n.o[a][s]) * m, e.o[a][s] = h, h = r ? n.v[a][s] : n.v[a][s] + (g.v[a][s] - n.v[a][s]) * m, e.v[a][s] = h
                    }

                    function a() {
                        this.paths = this.localShapeCollection
                    }

                    function e(t) {
                        ! function(t, e) {
                            if (t._length === e._length && t.c === e.c) {
                                for (var i = t._length, n = 0; n < i; n += 1)
                                    if (t.v[n][0] !== e.v[n][0] || t.v[n][1] !== e.v[n][1] || t.o[n][0] !== e.o[n][0] || t.o[n][1] !== e.o[n][1] || t.i[n][0] !== e.i[n][0] || t.i[n][1] !== e.i[n][1]) return;
                                return 1
                            }
                        }(this.v, t) && (this.v = shapePool.clone(t), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection)
                    }

                    function i() {
                        if (this.elem.globalData.frameId !== this.frameId)
                            if (this.effectsSequence.length)
                                if (this.lock) this.setVValue(this.pv);
                                else {
                                    var t;
                                    this.lock = !0, this._mdf = !1, t = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k;
                                    for (var e = this.effectsSequence.length, i = 0; i < e; i += 1) t = this.effectsSequence[i](t);
                                    this.setVValue(t), this.lock = !1, this.frameId = this.elem.globalData.frameId
                                }
                        else this._mdf = !1
                    }

                    function s(t, e, i) {
                        this.propType = "shape", this.comp = t.comp, this.container = t, this.elem = t, this.data = e, this.k = !1, this.kf = !1, this._mdf = !1;
                        var n = 3 === i ? e.pt.k : e.ks.k;
                        this.v = shapePool.clone(n), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = a, this.effectsSequence = []
                    }

                    function n(t) {
                        this.effectsSequence.push(t), this.container.addDynamicProperty(this)
                    }

                    function o(t, e, i) {
                        this.propType = "shape", this.comp = t.comp, this.elem = t, this.container = t, this.offsetTime = t.data.st, this.keyframes = 3 === i ? e.pt.k : e.ks.k, this.k = !0, this.kf = !0;
                        var n = this.keyframes[0].s[0].i.length;
                        this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, n), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = r, this.reset = a, this._caching = {
                            lastFrame: r,
                            lastIndex: 0
                        }, this.effectsSequence = [function() {
                            var t = this.comp.renderedFrame - this.offsetTime,
                                e = this.keyframes[0].t - this.offsetTime,
                                i = this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
                                n = this._caching.lastFrame;
                            return n !== r && (n < e && t < e || i < n && i < t) || (this._caching.lastIndex = n < t ? this._caching.lastIndex : 0, this.interpolateShape(t, this.pv, this._caching)), this._caching.lastFrame = t, this.pv
                        }.bind(this)]
                    }
                    s.prototype.interpolateShape = t, s.prototype.getValue = i, s.prototype.setVValue = e, s.prototype.addEffect = n, o.prototype.getValue = i, o.prototype.interpolateShape = t, o.prototype.setVValue = e, o.prototype.addEffect = n;
                    var l, h = (l = roundCorner, u.prototype = {
                        reset: a,
                        getValue: function() {
                            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath())
                        },
                        convertEllToPath: function() {
                            var t = this.p.v[0],
                                e = this.p.v[1],
                                i = this.s.v[0] / 2,
                                n = this.s.v[1] / 2,
                                r = 3 !== this.d,
                                a = this.v;
                            a.v[0][0] = t, a.v[0][1] = e - n, a.v[1][0] = r ? t + i : t - i, a.v[1][1] = e, a.v[2][0] = t, a.v[2][1] = e + n, a.v[3][0] = r ? t - i : t + i, a.v[3][1] = e, a.i[0][0] = r ? t - i * l : t + i * l, a.i[0][1] = e - n, a.i[1][0] = r ? t + i : t - i, a.i[1][1] = e - n * l, a.i[2][0] = r ? t + i * l : t - i * l, a.i[2][1] = e + n, a.i[3][0] = r ? t - i : t + i, a.i[3][1] = e + n * l, a.o[0][0] = r ? t + i * l : t - i * l, a.o[0][1] = e - n, a.o[1][0] = r ? t + i : t - i, a.o[1][1] = e + n * l, a.o[2][0] = r ? t - i * l : t + i * l, a.o[2][1] = e + n, a.o[3][0] = r ? t - i : t + i, a.o[3][1] = e - n * l
                        }
                    }, extendPrototype([DynamicPropertyContainer], u), u);

                    function u(t, e) {
                        this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = e.d, this.elem = t, this.comp = t.comp, this.frameId = -1, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath())
                    }
                    var c = (p.prototype = {
                        reset: a,
                        getValue: function() {
                            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath())
                        },
                        convertStarToPath: function() {
                            var t, e, i, n = 2 * Math.floor(this.pt.v),
                                r = 2 * Math.PI / n,
                                a = !0,
                                s = this.or.v,
                                o = this.ir.v,
                                l = this.os.v,
                                h = this.is.v,
                                u = 2 * Math.PI * s / (2 * n),
                                c = 2 * Math.PI * o / (2 * n),
                                p = -Math.PI / 2;
                            p += this.r.v;
                            for (var d = 3 === this.data.d ? -1 : 1, f = this.v._length = 0; f < n; f += 1) {
                                e = a ? l : h, i = a ? u : c;
                                var m = (t = a ? s : o) * Math.cos(p),
                                    g = t * Math.sin(p),
                                    v = 0 === m && 0 === g ? 0 : g / Math.sqrt(m * m + g * g),
                                    y = 0 === m && 0 === g ? 0 : -m / Math.sqrt(m * m + g * g);
                                m += +this.p.v[0], g += +this.p.v[1], this.v.setTripleAt(m, g, m - v * i * e * d, g - y * i * e * d, m + v * i * e * d, g + y * i * e * d, f, !0), a = !a, p += r * d
                            }
                        },
                        convertPolygonToPath: function() {
                            var t, e = Math.floor(this.pt.v),
                                i = 2 * Math.PI / e,
                                n = this.or.v,
                                r = this.os.v,
                                a = 2 * Math.PI * n / (4 * e),
                                s = .5 * -Math.PI,
                                o = 3 === this.data.d ? -1 : 1;
                            for (s += this.r.v, t = this.v._length = 0; t < e; t += 1) {
                                var l = n * Math.cos(s),
                                    h = n * Math.sin(s),
                                    u = 0 === l && 0 === h ? 0 : h / Math.sqrt(l * l + h * h),
                                    c = 0 === l && 0 === h ? 0 : -l / Math.sqrt(l * l + h * h);
                                l += +this.p.v[0], h += +this.p.v[1], this.v.setTripleAt(l, h, l - u * a * r * o, h - c * a * r * o, l + u * a * r * o, h + c * a * r * o, t, !0), s += i * o
                            }
                            this.paths.length = 0, this.paths[0] = this.v
                        }
                    }, extendPrototype([DynamicPropertyContainer], p), p);

                    function p(t, e) {
                        this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = t, this.comp = t.comp, this.data = e, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), 1 === e.sy ? (this.ir = PropertyFactory.getProp(t, e.ir, 0, 0, this), this.is = PropertyFactory.getProp(t, e.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(t, e.pt, 0, 0, this), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, degToRads, this), this.or = PropertyFactory.getProp(t, e.or, 0, 0, this), this.os = PropertyFactory.getProp(t, e.os, 0, .01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath())
                    }
                    var d = (f.prototype = {
                        convertRectToPath: function() {
                            var t = this.p.v[0],
                                e = this.p.v[1],
                                i = this.s.v[0] / 2,
                                n = this.s.v[1] / 2,
                                r = bmMin(i, n, this.r.v),
                                a = r * (1 - roundCorner);
                            this.v._length = 0, 2 === this.d || 1 === this.d ? (this.v.setTripleAt(t + i, e - n + r, t + i, e - n + r, t + i, e - n + a, 0, !0), this.v.setTripleAt(t + i, e + n - r, t + i, e + n - a, t + i, e + n - r, 1, !0), 0 !== r ? (this.v.setTripleAt(t + i - r, e + n, t + i - r, e + n, t + i - a, e + n, 2, !0), this.v.setTripleAt(t - i + r, e + n, t - i + a, e + n, t - i + r, e + n, 3, !0), this.v.setTripleAt(t - i, e + n - r, t - i, e + n - r, t - i, e + n - a, 4, !0), this.v.setTripleAt(t - i, e - n + r, t - i, e - n + a, t - i, e - n + r, 5, !0), this.v.setTripleAt(t - i + r, e - n, t - i + r, e - n, t - i + a, e - n, 6, !0), this.v.setTripleAt(t + i - r, e - n, t + i - a, e - n, t + i - r, e - n, 7, !0)) : (this.v.setTripleAt(t - i, e + n, t - i + a, e + n, t - i, e + n, 2), this.v.setTripleAt(t - i, e - n, t - i, e - n + a, t - i, e - n, 3))) : (this.v.setTripleAt(t + i, e - n + r, t + i, e - n + a, t + i, e - n + r, 0, !0), 0 !== r ? (this.v.setTripleAt(t + i - r, e - n, t + i - r, e - n, t + i - a, e - n, 1, !0), this.v.setTripleAt(t - i + r, e - n, t - i + a, e - n, t - i + r, e - n, 2, !0), this.v.setTripleAt(t - i, e - n + r, t - i, e - n + r, t - i, e - n + a, 3, !0), this.v.setTripleAt(t - i, e + n - r, t - i, e + n - a, t - i, e + n - r, 4, !0), this.v.setTripleAt(t - i + r, e + n, t - i + r, e + n, t - i + a, e + n, 5, !0), this.v.setTripleAt(t + i - r, e + n, t + i - a, e + n, t + i - r, e + n, 6, !0), this.v.setTripleAt(t + i, e + n - r, t + i, e + n - r, t + i, e + n - a, 7, !0)) : (this.v.setTripleAt(t - i, e - n, t - i + a, e - n, t - i, e - n, 1, !0), this.v.setTripleAt(t - i, e + n, t - i, e + n - a, t - i, e + n, 2, !0), this.v.setTripleAt(t + i, e + n, t + i - a, e + n, t + i, e + n, 3, !0)))
                        },
                        getValue: function() {
                            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath())
                        },
                        reset: a
                    }, extendPrototype([DynamicPropertyContainer], f), f);

                    function f(t, e) {
                        this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = t, this.comp = t.comp, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath())
                    }
                    var m = {
                        getShapeProp: function(t, e, i) {
                            var n;
                            return 3 === i || 4 === i ? n = new((3 === i ? e.pt : e.ks).k.length ? o : s)(t, e, i) : 5 === i ? n = new d(t, e) : 6 === i ? n = new h(t, e) : 7 === i && (n = new c(t, e)), n.k && t.addDynamicProperty(n), n
                        },
                        getConstructorFunction: function() {
                            return s
                        },
                        getKeyframedConstructorFunction: function() {
                            return o
                        }
                    };
                    return m
                }(),
                ShapeModifiers = (Ewe = {}, Fwe = {}, Ewe.registerModifier = function(t, e) {
                    Fwe[t] || (Fwe[t] = e)
                }, Ewe.getModifier = function(t, e, i) {
                    return new Fwe[t](e, i)
                }, Ewe),
                Ewe, Fwe;

            function ShapeModifier() {}

            function TrimModifier() {}

            function RoundCornersModifier() {}

            function PuckerAndBloatModifier() {}

            function RepeaterModifier() {}

            function ShapeCollection() {
                this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength)
            }

            function DashProperty(t, e, i, n) {
                this.elem = t, this.frameId = -1, this.dataProps = createSizedArray(e.length), this.renderer = i, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", e.length ? e.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(n);
                for (var r, a = e.length || 0, s = 0; s < a; s += 1) r = PropertyFactory.getProp(t, e[s].v, 0, 0, this), this.k = r.k || this.k, this.dataProps[s] = {
                    n: e[s].n,
                    p: r
                };
                this.k || this.getValue(!0), this._isAnimated = this.k
            }

            function GradientProperty(t, e, i) {
                this.data = e, this.c = createTypedArray("uint8c", 4 * e.p);
                var n = e.k.k[0].s ? e.k.k[0].s.length - 4 * e.p : e.k.k.length - 4 * e.p;
                this.o = createTypedArray("float32", n), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = n, this.initDynamicPropertyContainer(i), this.prop = PropertyFactory.getProp(t, e.k, 1, null, this), this.k = this.prop.k, this.getValue(!0)
            }
            ShapeModifier.prototype.initModifierProperties = function() {}, ShapeModifier.prototype.addShapeToModifier = function() {}, ShapeModifier.prototype.addShape = function(t) {
                var e;
                this.closed || (t.sh.container.addDynamicProperty(t.sh), e = {
                    shape: t.sh,
                    data: t,
                    localShapeCollection: shapeCollectionPool.newShapeCollection()
                }, this.shapes.push(e), this.addShapeToModifier(e), this._isAnimated && t.setAsAnimated())
            }, ShapeModifier.prototype.init = function(t, e) {
                this.shapes = [], this.elem = t, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
            }, ShapeModifier.prototype.processKeys = function() {
                this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties())
            }, extendPrototype([DynamicPropertyContainer], ShapeModifier), extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function(t, e) {
                this.s = PropertyFactory.getProp(t, e.s, 0, .01, this), this.e = PropertyFactory.getProp(t, e.e, 0, .01, this), this.o = PropertyFactory.getProp(t, e.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = e.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
            }, TrimModifier.prototype.addShapeToModifier = function(t) {
                t.pathsData = []
            }, TrimModifier.prototype.calculateShapeEdges = function(t, e, i, n, r) {
                var a = [];
                e <= 1 ? a.push({
                    s: t,
                    e: e
                }) : 1 <= t ? a.push({
                    s: t - 1,
                    e: e - 1
                }) : (a.push({
                    s: t,
                    e: 1
                }), a.push({
                    s: 0,
                    e: e - 1
                }));
                for (var s, o, l, h = [], u = a.length, c = 0; c < u; c += 1) {
                    (l = a[c]).e * r < n || l.s * r > n + i || (s = l.s * r <= n ? 0 : (l.s * r - n) / i, o = l.e * r >= n + i ? 1 : (l.e * r - n) / i, h.push([s, o]))
                }
                return h.length || h.push([0, 0]), h
            }, TrimModifier.prototype.releasePathsData = function(t) {
                for (var e = t.length, i = 0; i < e; i += 1) segmentsLengthPool.release(t[i]);
                return t.length = 0, t
            }, TrimModifier.prototype.processShapes = function(t) {
                var e, i, n, r, a;
                this._mdf || t ? ((e = this.o.v % 360 / 360) < 0 && (e += 1), n = 1 < this.s.v ? 1 + e : this.s.v < 0 ? 0 + e : this.s.v + e, (r = 1 < this.e.v ? 1 + e : this.e.v < 0 ? 0 + e : this.e.v + e) < n && (i = n, n = r, r = i), n = 1e-4 * Math.round(1e4 * n), r = 1e-4 * Math.round(1e4 * r), this.sValue = n, this.eValue = r) : (n = this.sValue, r = this.eValue);
                var s, o, l, h, u, c = this.shapes.length,
                    p = 0;
                if (r === n)
                    for (g = 0; g < c; g += 1) this.shapes[g].localShapeCollection.releaseShapes(), this.shapes[g].shape._mdf = !0, this.shapes[g].shape.paths = this.shapes[g].localShapeCollection, this._mdf && (this.shapes[g].pathsData.length = 0);
                else if (1 === r && 0 === n || 0 === r && 1 === n) {
                    if (this._mdf)
                        for (g = 0; g < c; g += 1) this.shapes[g].pathsData.length = 0, this.shapes[g].shape._mdf = !0
                } else {
                    for (var d, f, m = [], g = 0; g < c; g += 1)
                        if ((d = this.shapes[g]).shape._mdf || this._mdf || t || 2 === this.m) {
                            if (o = (a = d.shape.paths)._length, u = 0, !d.shape._mdf && d.pathsData.length) u = d.totalShapeLength;
                            else {
                                for (l = this.releasePathsData(d.pathsData), s = 0; s < o; s += 1) h = bez.getSegmentsLength(a.shapes[s]), l.push(h), u += h.totalLength;
                                d.totalShapeLength = u, d.pathsData = l
                            }
                            p += u, d.shape._mdf = !0
                        } else d.shape.paths = d.localShapeCollection;
                    var v, y = n,
                        b = r,
                        x = 0;
                    for (g = c - 1; 0 <= g; --g)
                        if ((d = this.shapes[g]).shape._mdf) {
                            for ((f = d.localShapeCollection).releaseShapes(), 2 === this.m && 1 < c ? (v = this.calculateShapeEdges(n, r, d.totalShapeLength, x, p), x += d.totalShapeLength) : v = [
                                    [y, b]
                                ], o = v.length, s = 0; s < o; s += 1) {
                                y = v[s][0], b = v[s][1], m.length = 0, b <= 1 ? m.push({
                                    s: d.totalShapeLength * y,
                                    e: d.totalShapeLength * b
                                }) : 1 <= y ? m.push({
                                    s: d.totalShapeLength * (y - 1),
                                    e: d.totalShapeLength * (b - 1)
                                }) : (m.push({
                                    s: d.totalShapeLength * y,
                                    e: d.totalShapeLength
                                }), m.push({
                                    s: 0,
                                    e: d.totalShapeLength * (b - 1)
                                }));
                                var _, w = this.addShapes(d, m[0]);
                                m[0].s !== m[0].e && (1 < m.length && (w = d.shape.paths.shapes[d.shape.paths._length - 1].c ? (_ = w.pop(), this.addPaths(w, f), this.addShapes(d, m[1], _)) : (this.addPaths(w, f), this.addShapes(d, m[1]))), this.addPaths(w, f))
                            }
                            d.shape.paths = f
                        }
                }
            }, TrimModifier.prototype.addPaths = function(t, e) {
                for (var i = t.length, n = 0; n < i; n += 1) e.addShape(t[n])
            }, TrimModifier.prototype.addSegment = function(t, e, i, n, r, a, s) {
                r.setXYAt(e[0], e[1], "o", a), r.setXYAt(i[0], i[1], "i", a + 1), s && r.setXYAt(t[0], t[1], "v", a), r.setXYAt(n[0], n[1], "v", a + 1)
            }, TrimModifier.prototype.addSegmentFromArray = function(t, e, i, n) {
                e.setXYAt(t[1], t[5], "o", i), e.setXYAt(t[2], t[6], "i", i + 1), n && e.setXYAt(t[0], t[4], "v", i), e.setXYAt(t[3], t[7], "v", i + 1)
            }, TrimModifier.prototype.addShapes = function(t, e, i) {
                var n, r, a, s, o, l, h, u, c = t.pathsData,
                    p = t.shape.paths.shapes,
                    d = t.shape.paths._length,
                    f = 0,
                    m = [],
                    g = !0,
                    v = i ? (s = i._length, i._length) : (i = shapePool.newElement(), s = 0);
                for (m.push(i), n = 0; n < d; n += 1) {
                    for (o = c[n].lengths, i.c = p[n].c, a = p[n].c ? o.length : o.length + 1, r = 1; r < a; r += 1)
                        if (f + (u = o[r - 1]).addedLength < e.s) f += u.addedLength, i.c = !1;
                        else {
                            if (f > e.e) {
                                i.c = !1;
                                break
                            }
                            e.s <= f && e.e >= f + u.addedLength ? (this.addSegment(p[n].v[r - 1], p[n].o[r - 1], p[n].i[r], p[n].v[r], i, s, g), g = !1) : (l = bez.getNewSegment(p[n].v[r - 1], p[n].v[r], p[n].o[r - 1], p[n].i[r], (e.s - f) / u.addedLength, (e.e - f) / u.addedLength, o[r - 1]), this.addSegmentFromArray(l, i, s, g), g = !1, i.c = !1), f += u.addedLength, s += 1
                        }
                    if (p[n].c && o.length && (u = o[r - 1], f <= e.e ? (h = o[r - 1].addedLength, e.s <= f && e.e >= f + h ? (this.addSegment(p[n].v[r - 1], p[n].o[r - 1], p[n].i[0], p[n].v[0], i, s, g), g = !1) : (l = bez.getNewSegment(p[n].v[r - 1], p[n].v[0], p[n].o[r - 1], p[n].i[0], (e.s - f) / h, (e.e - f) / h, o[r - 1]), this.addSegmentFromArray(l, i, s, g), g = !1, i.c = !1)) : i.c = !1, f += u.addedLength, s += 1), i._length && (i.setXYAt(i.v[v][0], i.v[v][1], "i", v), i.setXYAt(i.v[i._length - 1][0], i.v[i._length - 1][1], "o", i._length - 1)), f > e.e) break;
                    n < d - 1 && (i = shapePool.newElement(), g = !0, m.push(i), s = 0)
                }
                return m
            }, ShapeModifiers.registerModifier("tm", TrimModifier), extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function(t, e) {
                this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(t, e.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length
            }, RoundCornersModifier.prototype.processPath = function(t, e) {
                var i = shapePool.newElement();
                i.c = t.c;
                for (var n, r, a, s, o, l, h, u, c, p, d, f, m = t._length, g = 0, v = 0; v < m; v += 1) n = t.v[v], a = t.o[v], r = t.i[v], n[0] === a[0] && n[1] === a[1] && n[0] === r[0] && n[1] === r[1] ? 0 !== v && v !== m - 1 || t.c ? (s = 0 === v ? t.v[m - 1] : t.v[v - 1], l = (o = Math.sqrt(Math.pow(n[0] - s[0], 2) + Math.pow(n[1] - s[1], 2))) ? Math.min(o / 2, e) / o : 0, h = d = n[0] + (s[0] - n[0]) * l, u = f = n[1] - (n[1] - s[1]) * l, c = h - (h - n[0]) * roundCorner, p = u - (u - n[1]) * roundCorner, i.setTripleAt(h, u, c, p, d, f, g), g += 1, s = v === m - 1 ? t.v[0] : t.v[v + 1], l = (o = Math.sqrt(Math.pow(n[0] - s[0], 2) + Math.pow(n[1] - s[1], 2))) ? Math.min(o / 2, e) / o : 0, h = c = n[0] + (s[0] - n[0]) * l, u = p = n[1] + (s[1] - n[1]) * l, d = h - (h - n[0]) * roundCorner, f = u - (u - n[1]) * roundCorner, i.setTripleAt(h, u, c, p, d, f, g)) : i.setTripleAt(n[0], n[1], a[0], a[1], r[0], r[1], g) : i.setTripleAt(t.v[v][0], t.v[v][1], t.o[v][0], t.o[v][1], t.i[v][0], t.i[v][1], g), g += 1;
                return i
            }, RoundCornersModifier.prototype.processShapes = function(t) {
                var e, i, n, r = this.shapes.length,
                    a = this.rd.v;
                if (0 !== a)
                    for (var s, o, l = 0; l < r; l += 1) {
                        if (o = (s = this.shapes[l]).localShapeCollection, s.shape._mdf || this._mdf || t)
                            for (o.releaseShapes(), s.shape._mdf = !0, e = s.shape.paths.shapes, n = s.shape.paths._length, i = 0; i < n; i += 1) o.addShape(this.processPath(e[i], a));
                        s.shape.paths = s.localShapeCollection
                    }
                this.dynamicProperties.length || (this._mdf = !1)
            }, ShapeModifiers.registerModifier("rd", RoundCornersModifier), extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function(t, e) {
                this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(t, e.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length
            }, PuckerAndBloatModifier.prototype.processPath = function(t, e) {
                for (var i = e / 100, n = [0, 0], r = t._length, a = 0, a = 0; a < r; a += 1) n[0] += t.v[a][0], n[1] += t.v[a][1];
                n[0] /= r, n[1] /= r;
                var s, o, l, h, u, c, p = shapePool.newElement();
                for (p.c = t.c, a = 0; a < r; a += 1) s = t.v[a][0] + (n[0] - t.v[a][0]) * i, o = t.v[a][1] + (n[1] - t.v[a][1]) * i, l = t.o[a][0] + (n[0] - t.o[a][0]) * -i, h = t.o[a][1] + (n[1] - t.o[a][1]) * -i, u = t.i[a][0] + (n[0] - t.i[a][0]) * -i, c = t.i[a][1] + (n[1] - t.i[a][1]) * -i, p.setTripleAt(s, o, l, h, u, c, a);
                return p
            }, PuckerAndBloatModifier.prototype.processShapes = function(t) {
                var e, i, n, r = this.shapes.length,
                    a = this.amount.v;
                if (0 !== a)
                    for (var s, o, l = 0; l < r; l += 1) {
                        if (o = (s = this.shapes[l]).localShapeCollection, s.shape._mdf || this._mdf || t)
                            for (o.releaseShapes(), s.shape._mdf = !0, e = s.shape.paths.shapes, n = s.shape.paths._length, i = 0; i < n; i += 1) o.addShape(this.processPath(e[i], a));
                        s.shape.paths = s.localShapeCollection
                    }
                this.dynamicProperties.length || (this._mdf = !1)
            }, ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function(t, e) {
                this.getValue = this.processKeys, this.c = PropertyFactory.getProp(t, e.c, 0, null, this), this.o = PropertyFactory.getProp(t, e.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(t, e.tr, this), this.so = PropertyFactory.getProp(t, e.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(t, e.tr.eo, 0, .01, this), this.data = e, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix
            }, RepeaterModifier.prototype.applyTransforms = function(t, e, i, n, r, a) {
                var s = a ? -1 : 1,
                    o = n.s.v[0] + (1 - n.s.v[0]) * (1 - r),
                    l = n.s.v[1] + (1 - n.s.v[1]) * (1 - r);
                t.translate(n.p.v[0] * s * r, n.p.v[1] * s * r, n.p.v[2]), e.translate(-n.a.v[0], -n.a.v[1], n.a.v[2]), e.rotate(-n.r.v * s * r), e.translate(n.a.v[0], n.a.v[1], n.a.v[2]), i.translate(-n.a.v[0], -n.a.v[1], n.a.v[2]), i.scale(a ? 1 / o : o, a ? 1 / l : l), i.translate(n.a.v[0], n.a.v[1], n.a.v[2])
            }, RepeaterModifier.prototype.init = function(t, e, i, n) {
                for (this.elem = t, this.arr = e, this.pos = i, this.elemsData = n, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e[i]); 0 < i;) --i, this._elements.unshift(e[i]);
                this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
            }, RepeaterModifier.prototype.resetElements = function(t) {
                for (var e = t.length, i = 0; i < e; i += 1) t[i]._processed = !1, "gr" === t[i].ty && this.resetElements(t[i].it)
            }, RepeaterModifier.prototype.cloneElements = function(t) {
                var e = JSON.parse(JSON.stringify(t));
                return this.resetElements(e), e
            }, RepeaterModifier.prototype.changeGroupRender = function(t, e) {
                for (var i = t.length, n = 0; n < i; n += 1) t[n]._render = e, "gr" === t[n].ty && this.changeGroupRender(t[n].it, e)
            }, RepeaterModifier.prototype.processShapes = function(t) {
                var e, i, n, r, a, s = !1;
                if (this._mdf || t) {
                    var o = Math.ceil(this.c.v);
                    if (this._groups.length < o) {
                        for (; this._groups.length < o;) {
                            var l = {
                                it: this.cloneElements(this._elements),
                                ty: "gr"
                            };
                            l.it.push({
                                a: {
                                    a: 0,
                                    ix: 1,
                                    k: [0, 0]
                                },
                                nm: "Transform",
                                o: {
                                    a: 0,
                                    ix: 7,
                                    k: 100
                                },
                                p: {
                                    a: 0,
                                    ix: 2,
                                    k: [0, 0]
                                },
                                r: {
                                    a: 1,
                                    ix: 6,
                                    k: [{
                                        s: 0,
                                        e: 0,
                                        t: 0
                                    }, {
                                        s: 0,
                                        e: 0,
                                        t: 1
                                    }]
                                },
                                s: {
                                    a: 0,
                                    ix: 3,
                                    k: [100, 100]
                                },
                                sa: {
                                    a: 0,
                                    ix: 5,
                                    k: 0
                                },
                                sk: {
                                    a: 0,
                                    ix: 4,
                                    k: 0
                                },
                                ty: "tr"
                            }), this.arr.splice(0, 0, l), this._groups.splice(0, 0, l), this._currentCopies += 1
                        }
                        this.elem.reloadShapes(), s = !0
                    }
                    for (n = a = 0; n <= this._groups.length - 1; n += 1) {
                        var h, u, c = a < o;
                        this._groups[n]._render = c, this.changeGroupRender(this._groups[n].it, c), c || (0 !== (u = (h = this.elemsData[n].it)[h.length - 1]).transform.op.v ? (u.transform.op._mdf = !0, u.transform.op.v = 0) : u.transform.op._mdf = !1), a += 1
                    }
                    this._currentCopies = o;
                    var p = this.o.v,
                        d = p % 1,
                        f = 0 < p ? Math.floor(p) : Math.ceil(p),
                        m = this.pMatrix.props,
                        g = this.rMatrix.props,
                        v = this.sMatrix.props;
                    this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
                    var y, b, x = 0;
                    if (0 < p) {
                        for (; x < f;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), x += 1;
                        d && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, d, !1), x += d)
                    } else if (p < 0) {
                        for (; f < x;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), --x;
                        d && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -d, !0), x -= d)
                    }
                    for (n = 1 === this.data.m ? 0 : this._currentCopies - 1, r = 1 === this.data.m ? 1 : -1, a = this._currentCopies; a;) {
                        if (b = (i = (e = this.elemsData[n].it)[e.length - 1].transform.mProps.v.props).length, e[e.length - 1].transform.mProps._mdf = !0, e[e.length - 1].transform.op._mdf = !0, e[e.length - 1].transform.op.v = 1 === this._currentCopies ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (n / (this._currentCopies - 1)), 0 !== x) {
                            for ((0 !== n && 1 === r || n !== this._currentCopies - 1 && -1 === r) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14], g[15]), this.matrix.transform(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], v[12], v[13], v[14], v[15]), this.matrix.transform(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]), y = 0; y < b; y += 1) i[y] = this.matrix.props[y];
                            this.matrix.reset()
                        } else
                            for (this.matrix.reset(), y = 0; y < b; y += 1) i[y] = this.matrix.props[y];
                        x += 1, --a, n += r
                    }
                } else
                    for (a = this._currentCopies, n = 0, r = 1; a;) i = (e = this.elemsData[n].it)[e.length - 1].transform.mProps.v.props, e[e.length - 1].transform.mProps._mdf = !1, e[e.length - 1].transform.op._mdf = !1, --a, n += r;
                return s
            }, RepeaterModifier.prototype.addShape = function() {}, ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeCollection.prototype.addShape = function(t) {
                this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = t, this._length += 1
            }, ShapeCollection.prototype.releaseShapes = function() {
                for (var t = 0; t < this._length; t += 1) shapePool.release(this.shapes[t]);
                this._length = 0
            }, DashProperty.prototype.getValue = function(t) {
                if ((this.elem.globalData.frameId !== this.frameId || t) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || t, this._mdf)) {
                    var e = 0,
                        i = this.dataProps.length;
                    for ("svg" === this.renderer && (this.dashStr = ""), e = 0; e < i; e += 1) "o" !== this.dataProps[e].n ? "svg" === this.renderer ? this.dashStr += " " + this.dataProps[e].p.v : this.dashArray[e] = this.dataProps[e].p.v : this.dashoffset[0] = this.dataProps[e].p.v
                }
            }, extendPrototype([DynamicPropertyContainer], DashProperty), GradientProperty.prototype.comparePoints = function(t, e) {
                for (var i = 0, n = this.o.length / 2; i < n;) {
                    if (.01 < Math.abs(t[4 * i] - t[4 * e + 2 * i])) return !1;
                    i += 1
                }
                return !0
            }, GradientProperty.prototype.checkCollapsable = function() {
                if (this.o.length / 2 != this.c.length / 4) return !1;
                if (this.data.k.k[0].s)
                    for (var t = 0, e = this.data.k.k.length; t < e;) {
                        if (!this.comparePoints(this.data.k.k[t].s, this.data.p)) return !1;
                        t += 1
                    } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
                return !0
            }, GradientProperty.prototype.getValue = function(t) {
                if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || t) {
                    for (var e, i, n = 4 * this.data.p, r = 0; r < n; r += 1) e = r % 4 == 0 ? 100 : 255, i = Math.round(this.prop.v[r] * e), this.c[r] !== i && (this.c[r] = i, this._cmdf = !t);
                    if (this.o.length)
                        for (n = this.prop.v.length, r = 4 * this.data.p; r < n; r += 1) e = r % 2 == 0 ? 100 : 1, i = r % 2 == 0 ? Math.round(100 * this.prop.v[r]) : this.prop.v[r], this.o[r - 4 * this.data.p] !== i && (this.o[r - 4 * this.data.p] = i, this._omdf = !t);
                    this._mdf = !t
                }
            }, extendPrototype([DynamicPropertyContainer], GradientProperty);
            var buildShapeString = function(t, e, i, n) {
                    if (0 === e) return "";
                    for (var r = t.o, a = t.i, s = t.v, o = " M" + n.applyToPointStringified(s[0][0], s[0][1]), l = 1; l < e; l += 1) o += " C" + n.applyToPointStringified(r[l - 1][0], r[l - 1][1]) + " " + n.applyToPointStringified(a[l][0], a[l][1]) + " " + n.applyToPointStringified(s[l][0], s[l][1]);
                    return i && e && (o += " C" + n.applyToPointStringified(r[l - 1][0], r[l - 1][1]) + " " + n.applyToPointStringified(a[0][0], a[0][1]) + " " + n.applyToPointStringified(s[0][0], s[0][1]), o += "z"), o
                },
                audioControllerFactory = (MAe.prototype = {
                    addAudio: function(t) {
                        this.audios.push(t)
                    },
                    pause: function() {
                        for (var t = this.audios.length, e = 0; e < t; e += 1) this.audios[e].pause()
                    },
                    resume: function() {
                        for (var t = this.audios.length, e = 0; e < t; e += 1) this.audios[e].resume()
                    },
                    setRate: function(t) {
                        for (var e = this.audios.length, i = 0; i < e; i += 1) this.audios[i].setRate(t)
                    },
                    createAudio: function(t) {
                        return this.audioFactory ? this.audioFactory(t) : Howl ? new Howl({
                            src: [t]
                        }) : {
                            isPlaying: !1,
                            play: function() {
                                this.isPlaying = !0
                            },
                            seek: function() {
                                this.isPlaying = !1
                            },
                            playing: function() {},
                            rate: function() {},
                            setVolume: function() {}
                        }
                    },
                    setAudioFactory: function(t) {
                        this.audioFactory = t
                    },
                    setVolume: function(t) {
                        this._volume = t, this._updateVolume()
                    },
                    mute: function() {
                        this._isMuted = !0, this._updateVolume()
                    },
                    unmute: function() {
                        this._isMuted = !1, this._updateVolume()
                    },
                    getVolume: function() {
                        return this._volume
                    },
                    _updateVolume: function() {
                        for (var t = this.audios.length, e = 0; e < t; e += 1) this.audios[e].volume(this._volume * (this._isMuted ? 0 : 1))
                    }
                }, function() {
                    return new MAe
                });

            function MAe(t) {
                this.audios = [], this.audioFactory = t, this._volume = 1, this._isMuted = !1
            }
            var ImagePreloader = (pBe = function() {
                    var t = createTag("canvas");
                    t.width = 1, t.height = 1;
                    var e = t.getContext("2d");
                    return e.fillStyle = "rgba(0,0,0,0)", e.fillRect(0, 0, 1, 1), t
                }(), FBe.prototype = {
                    loadAssets: function(t, e) {
                        this.imagesLoadedCb = e;
                        for (var i = t.length, n = 0; n < i; n += 1) t[n].layers || (t[n].t && "seq" !== t[n].t ? 3 === t[n].t && (this.totalFootages += 1, this.images.push(this.createFootageData(t[n]))) : (this.totalImages += 1, this.images.push(this._createImageData(t[n]))))
                    },
                    setAssetsPath: function(t) {
                        this.assetsPath = t || ""
                    },
                    setPath: function(t) {
                        this.path = t || ""
                    },
                    loadedImages: function() {
                        return this.totalImages === this.loadedAssets
                    },
                    loadedFootages: function() {
                        return this.totalFootages === this.loadedFootagesCount
                    },
                    destroy: function() {
                        this.imagesLoadedCb = null, this.images.length = 0
                    },
                    getAsset: function(t) {
                        for (var e = 0, i = this.images.length; e < i;) {
                            if (this.images[e].assetData === t) return this.images[e].img;
                            e += 1
                        }
                        return null
                    },
                    createImgData: function(t) {
                        var e = sBe(t, this.assetsPath, this.path),
                            i = createTag("img");
                        i.crossOrigin = "anonymous", i.addEventListener("load", this._imageLoaded, !1), i.addEventListener("error", function() {
                            n.img = pBe, this._imageLoaded()
                        }.bind(this), !1), i.src = e;
                        var n = {
                            img: i,
                            assetData: t
                        };
                        return n
                    },
                    createImageData: function(t) {
                        var e = sBe(t, this.assetsPath, this.path),
                            i = createNS("image");
                        isSafari ? this.testImageLoaded(i) : i.addEventListener("load", this._imageLoaded, !1), i.addEventListener("error", function() {
                            n.img = pBe, this._imageLoaded()
                        }.bind(this), !1), i.setAttributeNS("http://www.w3.org/1999/xlink", "href", e), this._elementHelper.append ? this._elementHelper.append(i) : this._elementHelper.appendChild(i);
                        var n = {
                            img: i,
                            assetData: t
                        };
                        return n
                    },
                    imageLoaded: qBe,
                    footageLoaded: rBe,
                    setCacheType: function(t, e) {
                        "svg" === t ? (this._elementHelper = e, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
                    }
                }, FBe),
                pBe;

            function qBe() {
                this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }

            function rBe() {
                this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }

            function sBe(t, e, i) {
                var n, r = "";
                return t.e ? r = t.p : e ? (-1 !== (n = t.p).indexOf("images/") && (n = n.split("/")[1]), r = e + n) : (r = i, r += t.u ? t.u : "", r += t.p), r
            }

            function FBe() {
                this._imageLoaded = qBe.bind(this), this._footageLoaded = rBe.bind(this), this.testImageLoaded = function(t) {
                    var e = 0,
                        i = setInterval(function() {
                            (t.getBBox().width || 500 < e) && (this._imageLoaded(), clearInterval(i)), e += 1
                        }.bind(this), 50)
                }.bind(this), this.createFootageData = function(t) {
                    var e = {
                            assetData: t
                        },
                        i = sBe(t, this.assetsPath, this.path);
                    return assetLoader.load(i, function(t) {
                        e.img = t, this._footageLoaded()
                    }.bind(this), function() {
                        e.img = {}, this._footageLoaded()
                    }.bind(this)), e
                }.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = []
            }
            var featureSupport = (mCe = {
                    maskType: !0
                }, (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (mCe.maskType = !1), mCe),
                mCe, filtersFactory = (nCe = {}, nCe.createFilter = function(t, e) {
                    var i = createNS("filter");
                    return i.setAttribute("id", t), !0 !== e && (i.setAttribute("filterUnits", "objectBoundingBox"), i.setAttribute("x", "0%"), i.setAttribute("y", "0%"), i.setAttribute("width", "100%"), i.setAttribute("height", "100%")), i
                }, nCe.createAlphaToLuminanceFilter = function() {
                    var t = createNS("feColorMatrix");
                    return t.setAttribute("type", "matrix"), t.setAttribute("color-interpolation-filters", "sRGB"), t.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), t
                }, nCe),
                nCe, assetLoader = {
                    load: function(t, e, i) {
                        var n, r = new XMLHttpRequest;
                        try {
                            r.responseType = "json"
                        } catch (t) {}
                        r.onreadystatechange = function() {
                            if (4 === r.readyState)
                                if (200 === r.status) n = uCe(r), e(n);
                                else try {
                                    n = uCe(r), e(n)
                                } catch (t) {
                                    i && i(t)
                                }
                        }, r.open("GET", t, !0), r.send()
                    }
                };

            function uCe(t) {
                return t.response && "object" === _typeof(t.response) ? t.response : t.response && "string" == typeof t.response ? JSON.parse(t.response) : t.responseText ? JSON.parse(t.responseText) : null
            }

            function TextAnimatorProperty(t, e, i) {
                this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = t, this._renderType = e, this._elem = i, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {
                    alignment: {}
                }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(i)
            }

            function TextAnimatorDataProperty(t, e, i) {
                var n = {
                        propType: !1
                    },
                    r = PropertyFactory.getProp,
                    a = e.a;
                this.a = {
                    r: a.r ? r(t, a.r, 0, degToRads, i) : n,
                    rx: a.rx ? r(t, a.rx, 0, degToRads, i) : n,
                    ry: a.ry ? r(t, a.ry, 0, degToRads, i) : n,
                    sk: a.sk ? r(t, a.sk, 0, degToRads, i) : n,
                    sa: a.sa ? r(t, a.sa, 0, degToRads, i) : n,
                    s: a.s ? r(t, a.s, 1, .01, i) : n,
                    a: a.a ? r(t, a.a, 1, 0, i) : n,
                    o: a.o ? r(t, a.o, 0, .01, i) : n,
                    p: a.p ? r(t, a.p, 1, 0, i) : n,
                    sw: a.sw ? r(t, a.sw, 0, 0, i) : n,
                    sc: a.sc ? r(t, a.sc, 1, 0, i) : n,
                    fc: a.fc ? r(t, a.fc, 1, 0, i) : n,
                    fh: a.fh ? r(t, a.fh, 0, 0, i) : n,
                    fs: a.fs ? r(t, a.fs, 0, .01, i) : n,
                    fb: a.fb ? r(t, a.fb, 0, .01, i) : n,
                    t: a.t ? r(t, a.t, 0, 0, i) : n
                }, this.s = TextSelectorProp.getTextSelectorProp(t, e.s, i), this.s.t = e.s.t
            }

            function LetterProps(t, e, i, n, r, a) {
                this.o = t, this.sw = e, this.sc = i, this.fc = n, this.m = r, this.p = a, this._mdf = {
                    o: !0,
                    sw: !!e,
                    sc: !!i,
                    fc: !!n,
                    m: !0,
                    p: !0
                }
            }

            function TextProperty(t, e) {
                this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, this.data = e, this.elem = t, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
                    ascent: 0,
                    boxWidth: this.defaultBoxWidth,
                    f: "",
                    fStyle: "",
                    fWeight: "",
                    fc: "",
                    j: "",
                    justifyOffset: "",
                    l: [],
                    lh: 0,
                    lineWidths: [],
                    ls: "",
                    of: "",
                    s: "",
                    sc: "",
                    sw: 0,
                    t: 0,
                    tr: 0,
                    sz: 0,
                    ps: null,
                    fillColorAnim: !1,
                    strokeColorAnim: !1,
                    strokeWidthAnim: !1,
                    yOffset: 0,
                    finalSize: 0,
                    finalText: [],
                    finalLineHeight: 0,
                    __complete: !1
                }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData)
            }
            TextAnimatorProperty.prototype.searchProperties = function() {
                for (var t, e = this._textData.a.length, i = PropertyFactory.getProp, n = 0; n < e; n += 1) t = this._textData.a[n], this._animatorsData[n] = new TextAnimatorDataProperty(this._elem, t, this);
                this._textData.p && "m" in this._textData.p ? (this._pathData = {
                    f: i(this._elem, this._textData.p.f, 0, 0, this),
                    l: i(this._elem, this._textData.p.l, 0, 0, this),
                    r: this._textData.p.r,
                    m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
                }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = i(this._elem, this._textData.m.a, 1, 0, this)
            }, TextAnimatorProperty.prototype.getMeasures = function(t, e) {
                if (this.lettersChangedFlag = e, this._mdf || this._isFirstFrame || e || this._hasMaskedPath && this._pathData.m._mdf) {
                    this._isFirstFrame = !1;
                    var i, n, r, a, s, o, l, h, u, c, p, d, f, m, g, v, y, b, x = this._moreOptions.alignment.v,
                        _ = this._animatorsData,
                        w = this._textData,
                        S = this.mHelper,
                        M = this._renderType,
                        T = this.renderedLetters.length,
                        C = t.l;
                    if (this._hasMaskedPath) {
                        if (b = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
                            var A, E = b.v;
                            for (this._pathData.r && (E = E.reverse()), a = {
                                    tLength: 0,
                                    segments: []
                                }, r = E._length - 1, st = g = 0; st < r; st += 1) A = bez.buildBezierData(E.v[st], E.v[st + 1], [E.o[st][0] - E.v[st][0], E.o[st][1] - E.v[st][1]], [E.i[st + 1][0] - E.v[st + 1][0], E.i[st + 1][1] - E.v[st + 1][1]]), a.tLength += A.segmentLength, a.segments.push(A), g += A.segmentLength;
                            st = r, b.v.c && (A = bez.buildBezierData(E.v[st], E.v[0], [E.o[st][0] - E.v[st][0], E.o[st][1] - E.v[st][1]], [E.i[0][0] - E.v[0][0], E.i[0][1] - E.v[0][1]]), a.tLength += A.segmentLength, a.segments.push(A), g += A.segmentLength), this._pathData.pi = a
                        }
                        if (a = this._pathData.pi, s = this._pathData.f.v, u = 1, h = !(l = c = 0), f = a.segments, s < 0 && b.v.c)
                            for (a.tLength < Math.abs(s) && (s = -Math.abs(s) % a.tLength), u = (d = f[c = f.length - 1].points).length - 1; s < 0;) s += d[u].partialLength, --u < 0 && (u = (d = f[--c].points).length - 1);
                        p = (d = f[c].points)[u - 1], m = (o = d[u]).partialLength
                    }
                    r = C.length, n = i = 0;
                    var D, P, L, k, O, F, I, N, B, R, z, G, V, U, j, H, W = 1.2 * t.finalSize * .714,
                        q = !0,
                        X = _.length,
                        Y = -1,
                        J = s,
                        Z = c,
                        $ = u,
                        K = -1,
                        Q = "",
                        tt = this.defaultPropsArray;
                    if (2 === t.j || 1 === t.j) {
                        for (var et = 0, it = 0, nt = 2 === t.j ? -.5 : -1, rt = 0, at = !0, st = 0; st < r; st += 1)
                            if (C[st].n) {
                                for (et && (et += it); rt < st;) C[rt].animatorJustifyOffset = et, rt += 1;
                                at = !(et = 0)
                            } else {
                                for (lt = 0; lt < X; lt += 1)(D = _[lt].a).t.propType && (at && 2 === t.j && (it += D.t.v * nt), (L = _[lt].s.getMult(C[st].anIndexes[lt], w.a[lt].s.totalChars)).length ? et += D.t.v * L[0] * nt : et += D.t.v * L * nt);
                                at = !1
                            }
                        for (et && (et += it); rt < st;) C[rt].animatorJustifyOffset = et, rt += 1
                    }
                    for (st = 0; st < r; st += 1) {
                        if (S.reset(), I = 1, C[st].n) i = 0, n += t.yOffset, n += q ? 1 : 0, s = J, q = !1, this._hasMaskedPath && (u = $, p = (d = f[c = Z].points)[u - 1], m = (o = d[u]).partialLength, l = 0), j = G = U = Q = "", tt = this.defaultPropsArray;
                        else {
                            if (this._hasMaskedPath) {
                                if (K !== C[st].line) {
                                    switch (t.j) {
                                        case 1:
                                            s += g - t.lineWidths[C[st].line];
                                            break;
                                        case 2:
                                            s += (g - t.lineWidths[C[st].line]) / 2
                                    }
                                    K = C[st].line
                                }
                                Y !== C[st].ind && (C[Y] && (s += C[Y].extra), s += C[st].an / 2, Y = C[st].ind), s += x[0] * C[st].an * .005;
                                for (var ot = 0, lt = 0; lt < X; lt += 1)(D = _[lt].a).p.propType && ((L = _[lt].s.getMult(C[st].anIndexes[lt], w.a[lt].s.totalChars)).length ? ot += D.p.v[0] * L[0] : ot += D.p.v[0] * L), D.a.propType && ((L = _[lt].s.getMult(C[st].anIndexes[lt], w.a[lt].s.totalChars)).length ? ot += D.a.v[0] * L[0] : ot += D.a.v[0] * L);
                                for (h = !0; h;) s + ot <= l + m || !d ? (v = (s + ot - l) / o.partialLength, O = p.point[0] + (o.point[0] - p.point[0]) * v, F = p.point[1] + (o.point[1] - p.point[1]) * v, S.translate(-x[0] * C[st].an * .005, -x[1] * W * .01), h = !1) : d && (l += o.partialLength, (u += 1) >= d.length && (u = 0, d = f[c += 1] ? f[c].points : b.v.c ? f[c = u = 0].points : (l -= o.partialLength, null)), d && (p = o, m = (o = d[u]).partialLength));
                                k = C[st].an / 2 - C[st].add, S.translate(-k, 0, 0)
                            } else k = C[st].an / 2 - C[st].add, S.translate(-k, 0, 0), S.translate(-x[0] * C[st].an * .005, -x[1] * W * .01, 0);
                            for (lt = 0; lt < X; lt += 1)(D = _[lt].a).t.propType && (L = _[lt].s.getMult(C[st].anIndexes[lt], w.a[lt].s.totalChars), 0 === i && 0 === t.j || (this._hasMaskedPath ? L.length ? s += D.t.v * L[0] : s += D.t.v * L : L.length ? i += D.t.v * L[0] : i += D.t.v * L));
                            for (t.strokeWidthAnim && (B = t.sw || 0), t.strokeColorAnim && (N = t.sc ? [t.sc[0], t.sc[1], t.sc[2]] : [0, 0, 0]), t.fillColorAnim && t.fc && (R = [t.fc[0], t.fc[1], t.fc[2]]), lt = 0; lt < X; lt += 1)(D = _[lt].a).a.propType && ((L = _[lt].s.getMult(C[st].anIndexes[lt], w.a[lt].s.totalChars)).length ? S.translate(-D.a.v[0] * L[0], -D.a.v[1] * L[1], D.a.v[2] * L[2]) : S.translate(-D.a.v[0] * L, -D.a.v[1] * L, D.a.v[2] * L));
                            for (lt = 0; lt < X; lt += 1)(D = _[lt].a).s.propType && ((L = _[lt].s.getMult(C[st].anIndexes[lt], w.a[lt].s.totalChars)).length ? S.scale(1 + (D.s.v[0] - 1) * L[0], 1 + (D.s.v[1] - 1) * L[1], 1) : S.scale(1 + (D.s.v[0] - 1) * L, 1 + (D.s.v[1] - 1) * L, 1));
                            for (lt = 0; lt < X; lt += 1) {
                                if (D = _[lt].a, L = _[lt].s.getMult(C[st].anIndexes[lt], w.a[lt].s.totalChars), D.sk.propType && (L.length ? S.skewFromAxis(-D.sk.v * L[0], D.sa.v * L[1]) : S.skewFromAxis(-D.sk.v * L, D.sa.v * L)), D.r.propType && (L.length ? S.rotateZ(-D.r.v * L[2]) : S.rotateZ(-D.r.v * L)), D.ry.propType && (L.length ? S.rotateY(D.ry.v * L[1]) : S.rotateY(D.ry.v * L)), D.rx.propType && (L.length ? S.rotateX(D.rx.v * L[0]) : S.rotateX(D.rx.v * L)), D.o.propType && (L.length ? I += (D.o.v * L[0] - I) * L[0] : I += (D.o.v * L - I) * L), t.strokeWidthAnim && D.sw.propType && (L.length ? B += D.sw.v * L[0] : B += D.sw.v * L), t.strokeColorAnim && D.sc.propType)
                                    for (z = 0; z < 3; z += 1) L.length ? N[z] += (D.sc.v[z] - N[z]) * L[0] : N[z] += (D.sc.v[z] - N[z]) * L;
                                if (t.fillColorAnim && t.fc) {
                                    if (D.fc.propType)
                                        for (z = 0; z < 3; z += 1) L.length ? R[z] += (D.fc.v[z] - R[z]) * L[0] : R[z] += (D.fc.v[z] - R[z]) * L;
                                    D.fh.propType && (R = L.length ? addHueToRGB(R, D.fh.v * L[0]) : addHueToRGB(R, D.fh.v * L)), D.fs.propType && (R = L.length ? addSaturationToRGB(R, D.fs.v * L[0]) : addSaturationToRGB(R, D.fs.v * L)), D.fb.propType && (R = L.length ? addBrightnessToRGB(R, D.fb.v * L[0]) : addBrightnessToRGB(R, D.fb.v * L))
                                }
                            }
                            for (lt = 0; lt < X; lt += 1)(D = _[lt].a).p.propType && (L = _[lt].s.getMult(C[st].anIndexes[lt], w.a[lt].s.totalChars), this._hasMaskedPath ? L.length ? S.translate(0, D.p.v[1] * L[0], -D.p.v[2] * L[1]) : S.translate(0, D.p.v[1] * L, -D.p.v[2] * L) : L.length ? S.translate(D.p.v[0] * L[0], D.p.v[1] * L[1], -D.p.v[2] * L[2]) : S.translate(D.p.v[0] * L, D.p.v[1] * L, -D.p.v[2] * L));
                            if (t.strokeWidthAnim && (G = B < 0 ? 0 : B), t.strokeColorAnim && (V = "rgb(" + Math.round(255 * N[0]) + "," + Math.round(255 * N[1]) + "," + Math.round(255 * N[2]) + ")"), t.fillColorAnim && t.fc && (U = "rgb(" + Math.round(255 * R[0]) + "," + Math.round(255 * R[1]) + "," + Math.round(255 * R[2]) + ")"), this._hasMaskedPath) {
                                S.translate(0, -t.ls), S.translate(0, x[1] * W * .01 + n, 0), w.p.p && (y = (o.point[1] - p.point[1]) / (o.point[0] - p.point[0]), H = 180 * Math.atan(y) / Math.PI, o.point[0] < p.point[0] && (H += 180), S.rotate(-H * Math.PI / 180)), S.translate(O, F, 0), s -= x[0] * C[st].an * .005, C[st + 1] && Y !== C[st + 1].ind && (s += C[st].an / 2, s += .001 * t.tr * t.finalSize)
                            } else {
                                switch (S.translate(i, n, 0), t.ps && S.translate(t.ps[0], t.ps[1] + t.ascent, 0), t.j) {
                                    case 1:
                                        S.translate(C[st].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[C[st].line]), 0, 0);
                                        break;
                                    case 2:
                                        S.translate(C[st].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[C[st].line]) / 2, 0, 0)
                                }
                                S.translate(0, -t.ls), S.translate(k, 0, 0), S.translate(x[0] * C[st].an * .005, x[1] * W * .01, 0), i += C[st].l + .001 * t.tr * t.finalSize
                            }
                            "html" === M ? Q = S.toCSS() : "svg" === M ? Q = S.to2dCSS() : tt = [S.props[0], S.props[1], S.props[2], S.props[3], S.props[4], S.props[5], S.props[6], S.props[7], S.props[8], S.props[9], S.props[10], S.props[11], S.props[12], S.props[13], S.props[14], S.props[15]], j = I
                        }
                        T <= st ? (P = new LetterProps(j, G, V, U, Q, tt), this.renderedLetters.push(P), T += 1, this.lettersChangedFlag = !0) : (P = this.renderedLetters[st], this.lettersChangedFlag = P.update(j, G, V, U, Q, tt) || this.lettersChangedFlag)
                    }
                }
            }, TextAnimatorProperty.prototype.getValue = function() {
                this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties())
            }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty), LetterProps.prototype.update = function(t, e, i, n, r, a) {
                this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1;
                var s = this._mdf.p = !1;
                return this.o !== t && (this.o = t, s = this._mdf.o = !0), this.sw !== e && (this.sw = e, s = this._mdf.sw = !0), this.sc !== i && (this.sc = i, s = this._mdf.sc = !0), this.fc !== n && (this.fc = n, s = this._mdf.fc = !0), this.m !== r && (this.m = r, s = this._mdf.m = !0), !a.length || this.p[0] === a[0] && this.p[1] === a[1] && this.p[4] === a[4] && this.p[5] === a[5] && this.p[12] === a[12] && this.p[13] === a[13] || (this.p = a, s = this._mdf.p = !0), s
            }, TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function(t, e) {
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                return t
            }, TextProperty.prototype.setCurrentData = function(t) {
                t.__complete || this.completeTextData(t), this.currentData = t, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0
            }, TextProperty.prototype.searchProperty = function() {
                return this.searchKeyframes()
            }, TextProperty.prototype.searchKeyframes = function() {
                return this.kf = 1 < this.data.d.k.length, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf
            }, TextProperty.prototype.addEffect = function(t) {
                this.effectsSequence.push(t), this.elem.addDynamicProperty(this)
            }, TextProperty.prototype.getValue = function(t) {
                if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length || t) {
                    this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                    var e = this.currentData,
                        i = this.keysIndex;
                    if (this.lock) this.setCurrentData(this.currentData);
                    else {
                        this.lock = !0, this._mdf = !1;
                        for (var n = this.effectsSequence.length, r = t || this.data.d.k[this.keysIndex].s, a = 0; a < n; a += 1) r = i !== this.keysIndex ? this.effectsSequence[a](r, r.t) : this.effectsSequence[a](this.currentData, r.t);
                        e !== r && this.setCurrentData(r), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId
                    }
                }
            }, TextProperty.prototype.getKeyframeValue = function() {
                for (var t = this.data.d.k, e = this.elem.comp.renderedFrame, i = 0, n = t.length; i <= n - 1 && !(i === n - 1 || t[i + 1].t > e);) i += 1;
                return this.keysIndex !== i && (this.keysIndex = i), this.data.d.k[this.keysIndex].s
            }, TextProperty.prototype.buildFinalText = function(t) {
                for (var e, i, n = [], r = 0, a = t.length, s = !1; r < a;) e = t.charCodeAt(r), FontManager.isCombinedCharacter(e) ? n[n.length - 1] += t.charAt(r) : 55296 <= e && e <= 56319 ? 56320 <= (i = t.charCodeAt(r + 1)) && i <= 57343 ? (s || FontManager.isModifier(e, i) ? (n[n.length - 1] += t.substr(r, 2), s = !1) : n.push(t.substr(r, 2)), r += 1) : n.push(t.charAt(r)) : 56319 < e ? (i = t.charCodeAt(r + 1), FontManager.isZeroWidthJoiner(e, i) ? (s = !0, n[n.length - 1] += t.substr(r, 2), r += 1) : n.push(t.charAt(r))) : FontManager.isZeroWidthJoiner(e) ? (n[n.length - 1] += t.charAt(r), s = !0) : n.push(t.charAt(r)), r += 1;
                return n
            }, TextProperty.prototype.completeTextData = function(t) {
                t.__complete = !0;
                var e, i, n, r, a = this.elem.globalData.fontManager,
                    s = this.data,
                    o = [],
                    l = 0,
                    h = s.m.g,
                    u = 0,
                    c = 0,
                    p = 0,
                    d = [],
                    f = 0,
                    m = 0,
                    g = a.getFontByName(t.f),
                    v = 0,
                    y = getFontProperties(g);
                t.fWeight = y.weight, t.fStyle = y.style, t.finalSize = t.s, t.finalText = this.buildFinalText(t.t), e = t.finalText.length, t.finalLineHeight = t.lh;
                var b, x = t.tr / 1e3 * t.finalSize;
                if (t.sz)
                    for (var _, w, S = !0, M = t.sz[0], T = t.sz[1]; S;) {
                        f = _ = 0, e = (w = this.buildFinalText(t.t)).length, x = t.tr / 1e3 * t.finalSize;
                        for (var C = -1, A = 0; A < e; A += 1) b = w[A].charCodeAt(0), i = !1, " " === w[A] ? C = A : 13 !== b && 3 !== b || (i = !(f = 0), _ += t.finalLineHeight || 1.2 * t.finalSize), M < f + (v = a.chars ? (r = a.getCharData(w[A], g.fStyle, g.fFamily), i ? 0 : r.w * t.finalSize / 100) : a.measureText(w[A], t.f, t.finalSize)) && " " !== w[A] ? (-1 === C ? e += 1 : A = C, _ += t.finalLineHeight || 1.2 * t.finalSize, w.splice(A, C === A ? 1 : 0, "\r"), C = -1, f = 0) : (f += v, f += x);
                        _ += g.ascent * t.finalSize / 100, this.canResize && t.finalSize > this.minimumFontSize && T < _ ? (--t.finalSize, t.finalLineHeight = t.finalSize * t.lh / t.s) : (t.finalText = w, e = t.finalText.length, S = !1)
                    }
                f = -x;
                var E, D = v = 0;
                for (A = 0; A < e; A += 1)
                    if (i = !1, 13 === (b = (E = t.finalText[A]).charCodeAt(0)) || 3 === b ? (D = 0, d.push(f), m = m < f ? f : m, f = -2 * x, i = !(n = ""), p += 1) : n = E, v = a.chars ? (r = a.getCharData(E, g.fStyle, a.getFontByName(t.f).fFamily), i ? 0 : r.w * t.finalSize / 100) : a.measureText(n, t.f, t.finalSize), " " === E ? D += v + x : (f += v + x + D, D = 0), o.push({
                            l: v,
                            an: v,
                            add: u,
                            n: i,
                            anIndexes: [],
                            val: n,
                            line: p,
                            animatorJustifyOffset: 0
                        }), 2 == h) {
                        if (u += v, "" === n || " " === n || A === e - 1) {
                            for ("" !== n && " " !== n || (u -= v); c <= A;) o[c].an = u, o[c].ind = l, o[c].extra = v, c += 1;
                            l += 1, u = 0
                        }
                    } else if (3 == h) {
                    if (u += v, "" === n || A === e - 1) {
                        for ("" === n && (u -= v); c <= A;) o[c].an = u, o[c].ind = l, o[c].extra = v, c += 1;
                        u = 0, l += 1
                    }
                } else o[l].ind = l, o[l].extra = 0, l += 1;
                if (t.l = o, m = m < f ? f : m, d.push(f), t.sz) t.boxWidth = t.sz[0], t.justifyOffset = 0;
                else switch (t.boxWidth = m, t.j) {
                    case 1:
                        t.justifyOffset = -t.boxWidth;
                        break;
                    case 2:
                        t.justifyOffset = -t.boxWidth / 2;
                        break;
                    default:
                        t.justifyOffset = 0
                }
                t.lineWidths = d;
                for (var P, L, k, O, F = s.a, I = F.length, N = [], B = 0; B < I; B += 1) {
                    for ((P = F[B]).a.sc && (t.strokeColorAnim = !0), P.a.sw && (t.strokeWidthAnim = !0), (P.a.fc || P.a.fh || P.a.fs || P.a.fb) && (t.fillColorAnim = !0), O = 0, k = P.s.b, A = 0; A < e; A += 1)(L = o[A]).anIndexes[B] = O, (1 == k && "" !== L.val || 2 == k && "" !== L.val && " " !== L.val || 3 == k && (L.n || " " == L.val || A == e - 1) || 4 == k && (L.n || A == e - 1)) && (1 === P.s.rn && N.push(O), O += 1);
                    s.a[B].s.totalChars = O;
                    var R, z = -1;
                    if (1 === P.s.rn)
                        for (A = 0; A < e; A += 1) z != (L = o[A]).anIndexes[B] && (z = L.anIndexes[B], R = N.splice(Math.floor(Math.random() * N.length), 1)[0]), L.anIndexes[B] = R
                }
                t.yOffset = t.finalLineHeight || 1.2 * t.finalSize, t.ls = t.ls || 0, t.ascent = g.ascent * t.finalSize / 100
            }, TextProperty.prototype.updateDocumentData = function(t, e) {
                e = void 0 === e ? this.keysIndex : e;
                var i = this.copyData({}, this.data.d.k[e].s),
                    i = this.copyData(i, t);
                this.data.d.k[e].s = i, this.recalculate(e), this.elem.addDynamicProperty(this)
            }, TextProperty.prototype.recalculate = function(t) {
                var e = this.data.d.k[t].s;
                e.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(e)
            }, TextProperty.prototype.canResizeFont = function(t) {
                this.canResize = t, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
            }, TextProperty.prototype.setMinimumFontSize = function(t) {
                this.minimumFontSize = Math.floor(t) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
            };
            var TextSelectorProp = (DFe = Math.max, EFe = Math.min, FFe = Math.floor, GFe.prototype = {
                    getMult: function(t) {
                        this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                        var e = 0,
                            i = 0,
                            n = 1,
                            r = 1;
                        0 < this.ne.v ? e = this.ne.v / 100 : i = -this.ne.v / 100, 0 < this.xe.v ? n = 1 - this.xe.v / 100 : r = 1 + this.xe.v / 100;
                        var a, s, o, l = BezierFactory.getBezierEasing(e, i, n, r).get,
                            h = 0,
                            u = this.finalS,
                            c = this.finalE,
                            p = this.data.sh;
                        return (h = 2 === p ? l(h = c === u ? c <= t ? 1 : 0 : DFe(0, EFe(.5 / (c - u) + (t - u) / (c - u), 1))) : 3 === p ? l(h = c === u ? c <= t ? 0 : 1 : 1 - DFe(0, EFe(.5 / (c - u) + (t - u) / (c - u), 1))) : 4 === p ? (c === u ? h = 0 : (h = DFe(0, EFe(.5 / (c - u) + (t - u) / (c - u), 1))) < .5 ? h *= 2 : h = 1 - 2 * (h - .5), l(h)) : 5 === p ? l(h = c === u ? 0 : (s = -(a = c - u) / 2 + (t = EFe(DFe(0, t + .5 - u), c - u)), o = a / 2, Math.sqrt(1 - s * s / (o * o)))) : 6 === p ? l(h = c === u ? 0 : (t = EFe(DFe(0, t + .5 - u), c - u), (1 + Math.cos(Math.PI + 2 * Math.PI * t / (c - u))) / 2)) : (t >= FFe(u) && (h = DFe(0, EFe(t - u < 0 ? EFe(c, 1) - (u - t) : c - t, 1))), l(h))) * this.a.v
                    },
                    getValue: function(t) {
                        this.iterateDynamicProperties(), this._mdf = t || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, t && 2 === this.data.r && (this.e.v = this._currentTextLength);
                        var e, i = 2 === this.data.r ? 1 : 100 / this.data.totalChars,
                            n = this.o.v / i,
                            r = this.s.v / i + n,
                            a = this.e.v / i + n;
                        a < r && (e = r, r = a, a = e), this.finalS = r, this.finalE = a
                    }
                }, extendPrototype([DynamicPropertyContainer], GFe), {
                    getTextSelectorProp: function(t, e, i) {
                        return new GFe(t, e)
                    }
                }),
                DFe, EFe, FFe;

            function GFe(t, e) {
                this._currentTextLength = -1, this.k = !1, this.data = e, this.elem = t, this.comp = t.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(t), this.s = PropertyFactory.getProp(t, e.s || {
                    k: 0
                }, 0, 0, this), this.e = "e" in e ? PropertyFactory.getProp(t, e.e, 0, 0, this) : {
                    v: 100
                }, this.o = PropertyFactory.getProp(t, e.o || {
                    k: 0
                }, 0, 0, this), this.xe = PropertyFactory.getProp(t, e.xe || {
                    k: 0
                }, 0, 0, this), this.ne = PropertyFactory.getProp(t, e.ne || {
                    k: 0
                }, 0, 0, this), this.a = PropertyFactory.getProp(t, e.a, 0, .01, this), this.dynamicProperties.length || this.getValue()
            }
            var poolFactory = function(t, e, i) {
                    var n = 0,
                        r = t,
                        a = createSizedArray(r);
                    return {
                        newElement: function() {
                            return n ? a[--n] : e()
                        },
                        release: function(t) {
                            n === r && (a = pooling.double(a), r *= 2), i && i(t), a[n] = t, n += 1
                        }
                    }
                },
                pooling = {
                    double: function(t) {
                        return t.concat(createSizedArray(t.length))
                    }
                },
                pointPool = poolFactory(8, function() {
                    return createTypedArray("float32", 2)
                }),
                shapePool = (xGe = poolFactory(4, function() {
                    return new ShapePath
                }, function(t) {
                    for (var e = t._length, i = 0; i < e; i += 1) pointPool.release(t.v[i]), pointPool.release(t.i[i]), pointPool.release(t.o[i]), t.v[i] = null, t.i[i] = null, t.o[i] = null;
                    t._length = 0, t.c = !1
                }), xGe.clone = function(t) {
                    var e, i = xGe.newElement(),
                        n = void 0 === t._length ? t.v.length : t._length;
                    for (i.setLength(n), i.c = t.c, e = 0; e < n; e += 1) i.setTripleAt(t.v[e][0], t.v[e][1], t.o[e][0], t.o[e][1], t.i[e][0], t.i[e][1], e);
                    return i
                }, xGe),
                xGe, shapeCollectionPool = (FGe = {
                    newShapeCollection: function() {
                        var t;
                        t = GGe ? IGe[--GGe] : new ShapeCollection;
                        return t
                    },
                    release: function(t) {
                        var e, i = t._length;
                        for (e = 0; e < i; e += 1) shapePool.release(t.shapes[e]);
                        t._length = 0, GGe === HGe && (IGe = pooling.double(IGe), HGe *= 2);
                        IGe[GGe] = t, GGe += 1
                    }
                }, GGe = 0, HGe = 4, IGe = createSizedArray(HGe), FGe),
                FGe, GGe, HGe, IGe, segmentsLengthPool = poolFactory(8, function() {
                    return {
                        lengths: [],
                        totalLength: 0
                    }
                }, function(t) {
                    for (var e = t.lengths.length, i = 0; i < e; i += 1) bezierLengthPool.release(t.lengths[i]);
                    t.lengths.length = 0
                }),
                bezierLengthPool = poolFactory(8, function() {
                    return {
                        addedLength: 0,
                        percents: createTypedArray("float32", defaultCurveSegments),
                        lengths: createTypedArray("float32", defaultCurveSegments)
                    }
                }),
                markerParser = function(e) {
                    for (var t = [], i = 0; i < e.length; i += 1) {
                        var n = e[i],
                            r = {
                                time: n.tm,
                                duration: n.dr
                            };
                        try {
                            r.payload = JSON.parse(e[i].cm)
                        } catch (t) {
                            try {
                                r.payload = function(t) {
                                    for (var e, i = t.split("\r\n"), n = {}, r = 0, a = 0; a < i.length; a += 1) 2 === (e = i[a].split(":")).length && (n[e[0]] = e[1].trim(), r += 1);
                                    if (0 === r) throw new Error;
                                    return n
                                }(e[i].cm)
                            } catch (t) {
                                r.payload = {
                                    name: e[i]
                                }
                            }
                        }
                        t.push(r)
                    }
                    return t
                };

            function BaseRenderer() {}

            function SVGRenderer(t, e) {
                this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
                var i, n, r, a, s = "";
                e && e.title && (i = createNS("title"), n = createElementID(), i.setAttribute("id", n), i.textContent = e.title, this.svgElement.appendChild(i), s += n), e && e.description && (r = createNS("desc"), a = createElementID(), r.setAttribute("id", a), r.textContent = e.description, this.svgElement.appendChild(r), s += " " + a), s && this.svgElement.setAttribute("aria-labelledby", s);
                var o = createNS("defs");
                this.svgElement.appendChild(o);
                var l = createNS("g");
                this.svgElement.appendChild(l), this.layerElement = l, this.renderConfig = {
                    preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                    imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                    progressiveLoad: e && e.progressiveLoad || !1,
                    hideOnTransparent: !(e && !1 === e.hideOnTransparent),
                    viewBoxOnly: e && e.viewBoxOnly || !1,
                    viewBoxSize: e && e.viewBoxSize || !1,
                    className: e && e.className || "",
                    id: e && e.id || "",
                    focusable: e && e.focusable,
                    filterSize: {
                        width: e && e.filterSize && e.filterSize.width || "100%",
                        height: e && e.filterSize && e.filterSize.height || "100%",
                        x: e && e.filterSize && e.filterSize.x || "0%",
                        y: e && e.filterSize && e.filterSize.y || "0%"
                    }
                }, this.globalData = {
                    _mdf: !1,
                    frameNum: -1,
                    defs: o,
                    renderConfig: this.renderConfig
                }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg"
            }

            function CanvasRenderer(t, e) {
                this.animationItem = t, this.renderConfig = {
                    clearCanvas: !e || void 0 === e.clearCanvas || e.clearCanvas,
                    context: e && e.context || null,
                    progressiveLoad: e && e.progressiveLoad || !1,
                    preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                    imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                    className: e && e.className || "",
                    id: e && e.id || ""
                }, this.renderConfig.dpr = e && e.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = e && e.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
                    frameNum: -1,
                    _mdf: !1,
                    renderConfig: this.renderConfig,
                    currentGlobalAlpha: -1
                }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas"
            }

            function HybridRenderer(t, e) {
                this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
                    className: e && e.className || "",
                    imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                    hideOnTransparent: !(e && !1 === e.hideOnTransparent),
                    filterSize: {
                        width: e && e.filterSize && e.filterSize.width || "400%",
                        height: e && e.filterSize && e.filterSize.height || "400%",
                        x: e && e.filterSize && e.filterSize.x || "-100%",
                        y: e && e.filterSize && e.filterSize.y || "-100%"
                    }
                }, this.globalData = {
                    _mdf: !1,
                    frameNum: -1,
                    renderConfig: this.renderConfig
                }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
            }

            function MaskElement(t, e, i) {
                this.data = t, this.element = e, this.globalData = i, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
                var n, r = this.globalData.defs,
                    a = this.masksProperties ? this.masksProperties.length : 0;
                this.viewData = createSizedArray(a), this.solidPath = "";
                for (var s, o, l, h, u, c, p = this.masksProperties, d = 0, f = [], m = createElementID(), g = "clipPath", v = "clip-path", y = 0; y < a; y += 1)
                    if (("a" !== p[y].mode && "n" !== p[y].mode || p[y].inv || 100 !== p[y].o.k || p[y].o.x) && (v = g = "mask"), "s" !== p[y].mode && "i" !== p[y].mode || 0 !== d ? o = null : ((o = createNS("rect")).setAttribute("fill", "#ffffff"), o.setAttribute("width", this.element.comp.data.w || 0), o.setAttribute("height", this.element.comp.data.h || 0), f.push(o)), n = createNS("path"), "n" === p[y].mode) this.viewData[y] = {
                        op: PropertyFactory.getProp(this.element, p[y].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, p[y], 3),
                        elem: n,
                        lastPath: ""
                    }, r.appendChild(n);
                    else {
                        if (d += 1, n.setAttribute("fill", "s" === p[y].mode ? "#000000" : "#ffffff"), n.setAttribute("clip-rule", "nonzero"), 0 !== p[y].x.k ? (v = g = "mask", u = PropertyFactory.getProp(this.element, p[y].x, 0, null, this.element), c = createElementID(), (l = createNS("filter")).setAttribute("id", c), (h = createNS("feMorphology")).setAttribute("operator", "erode"), h.setAttribute("in", "SourceGraphic"), h.setAttribute("radius", "0"), l.appendChild(h), r.appendChild(l), n.setAttribute("stroke", "s" === p[y].mode ? "#000000" : "#ffffff")) : u = h = null, this.storedData[y] = {
                                elem: n,
                                x: u,
                                expan: h,
                                lastPath: "",
                                lastOperator: "",
                                filterId: c,
                                lastRadius: 0
                            }, "i" === p[y].mode) {
                            s = f.length;
                            for (var b = createNS("g"), x = 0; x < s; x += 1) b.appendChild(f[x]);
                            var _ = createNS("mask");
                            _.setAttribute("mask-type", "alpha"), _.setAttribute("id", m + "_" + d), _.appendChild(n), r.appendChild(_), b.setAttribute("mask", "url(" + locationHref + "#" + m + "_" + d + ")"), f.length = 0, f.push(b)
                        } else f.push(n);
                        p[y].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[y] = {
                            elem: n,
                            lastPath: "",
                            op: PropertyFactory.getProp(this.element, p[y].o, 0, .01, this.element),
                            prop: ShapePropertyFactory.getShapeProp(this.element, p[y], 3),
                            invRect: o
                        }, this.viewData[y].prop.k || this.drawPath(p[y], this.viewData[y].prop.v, this.viewData[y])
                    }
                for (this.maskElement = createNS(g), a = f.length, y = 0; y < a; y += 1) this.maskElement.appendChild(f[y]);
                0 < d && (this.maskElement.setAttribute("id", m), this.element.maskedElement.setAttribute(v, "url(" + locationHref + "#" + m + ")"), r.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this)
            }

            function HierarchyElement() {}

            function FrameElement() {}

            function TransformElement() {}

            function RenderableElement() {}

            function RenderableDOMElement() {}

            function ProcessedElement(t, e) {
                this.elem = t, this.pos = e
            }

            function SVGStyleData(t, e) {
                this.data = t, this.type = t.ty, this.d = "", this.lvl = e, this._mdf = !1, this.closed = !0 === t.hd, this.pElem = createNS("path"), this.msElem = null
            }

            function SVGShapeData(t, e, i) {
                this.caches = [], this.styles = [], this.transformers = t, this.lStr = "", this.sh = i, this.lvl = e, this._isAnimated = !!i.k;
                for (var n = 0, r = t.length; n < r;) {
                    if (t[n].mProps.dynamicProperties.length) {
                        this._isAnimated = !0;
                        break
                    }
                    n += 1
                }
            }

            function SVGTransformData(t, e, i) {
                this.transform = {
                    mProps: t,
                    op: e,
                    container: i
                }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
            }

            function SVGStrokeStyleData(t, e, i) {
                this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, "svg", this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = i, this._isAnimated = !!this._isAnimated
            }

            function SVGFillStyleData(t, e, i) {
                this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = i
            }

            function SVGGradientFillStyleData(t, e, i) {
                this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.initGradientData(t, e, i)
            }

            function SVGGradientStrokeStyleData(t, e, i) {
                this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, "svg", this), this.initGradientData(t, e, i), this._isAnimated = !!this._isAnimated
            }

            function ShapeGroupData() {
                this.it = [], this.prevViewData = [], this.gr = createNS("g")
            }
            BaseRenderer.prototype.checkLayers = function(t) {
                var e, i, n = this.layers.length;
                for (this.completeLayers = !0, e = n - 1; 0 <= e; --e) this.elements[e] || (i = this.layers[e]).ip - i.st <= t - this.layers[e].st && i.op - i.st > t - this.layers[e].st && this.buildItem(e), this.completeLayers = !!this.elements[e] && this.completeLayers;
                this.checkPendingElements()
            }, BaseRenderer.prototype.createItem = function(t) {
                switch (t.ty) {
                    case 2:
                        return this.createImage(t);
                    case 0:
                        return this.createComp(t);
                    case 1:
                        return this.createSolid(t);
                    case 3:
                        return this.createNull(t);
                    case 4:
                        return this.createShape(t);
                    case 5:
                        return this.createText(t);
                    case 6:
                        return this.createAudio(t);
                    case 13:
                        return this.createCamera(t);
                    case 15:
                        return this.createFootage(t);
                    default:
                        return this.createNull(t)
                }
            }, BaseRenderer.prototype.createCamera = function() {
                throw new Error("You're using a 3d camera. Try the html renderer.")
            }, BaseRenderer.prototype.createAudio = function(t) {
                return new AudioElement(t, this.globalData, this)
            }, BaseRenderer.prototype.createFootage = function(t) {
                return new FootageElement(t, this.globalData, this)
            }, BaseRenderer.prototype.buildAllItems = function() {
                for (var t = this.layers.length, e = 0; e < t; e += 1) this.buildItem(e);
                this.checkPendingElements()
            }, BaseRenderer.prototype.includeLayers = function(t) {
                this.completeLayers = !1;
                for (var e, i = t.length, n = this.layers.length, r = 0; r < i; r += 1)
                    for (e = 0; e < n;) {
                        if (this.layers[e].id === t[r].id) {
                            this.layers[e] = t[r];
                            break
                        }
                        e += 1
                    }
            }, BaseRenderer.prototype.setProjectInterface = function(t) {
                this.globalData.projectInterface = t
            }, BaseRenderer.prototype.initItems = function() {
                this.globalData.progressiveLoad || this.buildAllItems()
            }, BaseRenderer.prototype.buildElementParenting = function(t, e, i) {
                for (var n = this.elements, r = this.layers, a = 0, s = r.length; a < s;) r[a].ind == e && (n[a] && !0 !== n[a] ? (i.push(n[a]), n[a].setAsParent(), void 0 !== r[a].parent ? this.buildElementParenting(t, r[a].parent, i) : t.setHierarchy(i)) : (this.buildItem(a), this.addPendingElement(t))), a += 1
            }, BaseRenderer.prototype.addPendingElement = function(t) {
                this.pendingElements.push(t)
            }, BaseRenderer.prototype.searchExtraCompositions = function(t) {
                for (var e, i = t.length, n = 0; n < i; n += 1) {
                    t[n].xt && ((e = this.createComp(t[n])).initExpressions(), this.globalData.projectInterface.registerComposition(e))
                }
            }, BaseRenderer.prototype.setupGlobalData = function(t, e) {
                this.globalData.fontManager = new FontManager, this.globalData.fontManager.addChars(t.chars), this.globalData.fontManager.addFonts(t.fonts, e), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = t.fr, this.globalData.nm = t.nm, this.globalData.compSize = {
                    w: t.w,
                    h: t.h
                }
            }, extendPrototype([BaseRenderer], SVGRenderer), SVGRenderer.prototype.createNull = function(t) {
                return new NullElement(t, this.globalData, this)
            }, SVGRenderer.prototype.createShape = function(t) {
                return new SVGShapeElement(t, this.globalData, this)
            }, SVGRenderer.prototype.createText = function(t) {
                return new SVGTextLottieElement(t, this.globalData, this)
            }, SVGRenderer.prototype.createImage = function(t) {
                return new IImageElement(t, this.globalData, this)
            }, SVGRenderer.prototype.createComp = function(t) {
                return new SVGCompElement(t, this.globalData, this)
            }, SVGRenderer.prototype.createSolid = function(t) {
                return new ISolidElement(t, this.globalData, this)
            }, SVGRenderer.prototype.configAnimation = function(t) {
                this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + t.w + " " + t.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", t.w), this.svgElement.setAttribute("height", t.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)"), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), void 0 !== this.renderConfig.focusable && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
                var e = this.globalData.defs;
                this.setupGlobalData(t, e), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = t;
                var i = createNS("clipPath"),
                    n = createNS("rect");
                n.setAttribute("width", t.w), n.setAttribute("height", t.h), n.setAttribute("x", 0), n.setAttribute("y", 0);
                var r = createElementID();
                i.setAttribute("id", r), i.appendChild(n), this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + r + ")"), e.appendChild(i), this.layers = t.layers, this.elements = createSizedArray(t.layers.length)
            }, SVGRenderer.prototype.destroy = function() {
                this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null;
                for (var t = this.layers ? this.layers.length : 0, e = 0; e < t; e += 1) this.elements[e] && this.elements[e].destroy();
                this.elements.length = 0, this.destroyed = !0, this.animationItem = null
            }, SVGRenderer.prototype.updateContainerSize = function() {}, SVGRenderer.prototype.buildItem = function(t) {
                var e, i = this.elements;
                i[t] || 99 === this.layers[t].ty || (i[t] = !0, e = this.createItem(this.layers[t]), i[t] = e, expressionsPlugin && (0 === this.layers[t].ty && this.globalData.projectInterface.registerComposition(e), e.initExpressions()), this.appendElementInPos(e, t), this.layers[t].tt && (this.elements[t - 1] && !0 !== this.elements[t - 1] ? e.setMatte(i[t - 1].layerId) : (this.buildItem(t - 1), this.addPendingElement(e))))
            }, SVGRenderer.prototype.checkPendingElements = function() {
                for (; this.pendingElements.length;) {
                    var t = this.pendingElements.pop();
                    if (t.checkParenting(), t.data.tt)
                        for (var e = 0, i = this.elements.length; e < i;) {
                            if (this.elements[e] === t) {
                                t.setMatte(this.elements[e - 1].layerId);
                                break
                            }
                            e += 1
                        }
                }
            }, SVGRenderer.prototype.renderFrame = function(t) {
                if (this.renderedFrame !== t && !this.destroyed) {
                    var e;
                    null === t ? t = this.renderedFrame : this.renderedFrame = t, this.globalData.frameNum = t, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = t, this.globalData._mdf = !1;
                    var i = this.layers.length;
                    for (this.completeLayers || this.checkLayers(t), e = i - 1; 0 <= e; --e)(this.completeLayers || this.elements[e]) && this.elements[e].prepareFrame(t - this.layers[e].st);
                    if (this.globalData._mdf)
                        for (e = 0; e < i; e += 1)(this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
                }
            }, SVGRenderer.prototype.appendElementInPos = function(t, e) {
                var i = t.getBaseElement();
                if (i) {
                    for (var n, r = 0; r < e;) this.elements[r] && !0 !== this.elements[r] && this.elements[r].getBaseElement() && (n = this.elements[r].getBaseElement()), r += 1;
                    n ? this.layerElement.insertBefore(i, n) : this.layerElement.appendChild(i)
                }
            }, SVGRenderer.prototype.hide = function() {
                this.layerElement.style.display = "none"
            }, SVGRenderer.prototype.show = function() {
                this.layerElement.style.display = "block"
            }, extendPrototype([BaseRenderer], CanvasRenderer), CanvasRenderer.prototype.createShape = function(t) {
                return new CVShapeElement(t, this.globalData, this)
            }, CanvasRenderer.prototype.createText = function(t) {
                return new CVTextElement(t, this.globalData, this)
            }, CanvasRenderer.prototype.createImage = function(t) {
                return new CVImageElement(t, this.globalData, this)
            }, CanvasRenderer.prototype.createComp = function(t) {
                return new CVCompElement(t, this.globalData, this)
            }, CanvasRenderer.prototype.createSolid = function(t) {
                return new CVSolidElement(t, this.globalData, this)
            }, CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRenderer.prototype.ctxTransform = function(t) {
                var e, i;
                1 === t[0] && 0 === t[1] && 0 === t[4] && 1 === t[5] && 0 === t[12] && 0 === t[13] || (this.renderConfig.clearCanvas ? (this.transformMat.cloneFromProps(t), e = this.contextData.cTr.props, this.transformMat.transform(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]), this.contextData.cTr.cloneFromProps(this.transformMat.props), i = this.contextData.cTr.props, this.canvasContext.setTransform(i[0], i[1], i[4], i[5], i[12], i[13])) : this.canvasContext.transform(t[0], t[1], t[4], t[5], t[12], t[13]))
            }, CanvasRenderer.prototype.ctxOpacity = function(t) {
                if (!this.renderConfig.clearCanvas) return this.canvasContext.globalAlpha *= t < 0 ? 0 : t, void(this.globalData.currentGlobalAlpha = this.contextData.cO);
                this.contextData.cO *= t < 0 ? 0 : t, this.globalData.currentGlobalAlpha !== this.contextData.cO && (this.canvasContext.globalAlpha = this.contextData.cO, this.globalData.currentGlobalAlpha = this.contextData.cO)
            }, CanvasRenderer.prototype.reset = function() {
                this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore()
            }, CanvasRenderer.prototype.save = function(t) {
                if (this.renderConfig.clearCanvas) {
                    t && this.canvasContext.save();
                    var e = this.contextData.cTr.props;
                    this.contextData._length <= this.contextData.cArrPos && this.contextData.duplicate();
                    for (var i = this.contextData.saved[this.contextData.cArrPos], n = 0; n < 16; n += 1) i[n] = e[n];
                    this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO, this.contextData.cArrPos += 1
                } else this.canvasContext.save()
            }, CanvasRenderer.prototype.restore = function(t) {
                if (this.renderConfig.clearCanvas) {
                    t && (this.canvasContext.restore(), this.globalData.blendMode = "source-over"), --this.contextData.cArrPos;
                    for (var e = this.contextData.saved[this.contextData.cArrPos], i = this.contextData.cTr.props, n = 0; n < 16; n += 1) i[n] = e[n];
                    this.canvasContext.setTransform(e[0], e[1], e[4], e[5], e[12], e[13]), e = this.contextData.savedOp[this.contextData.cArrPos], this.contextData.cO = e, this.globalData.currentGlobalAlpha !== e && (this.canvasContext.globalAlpha = e, this.globalData.currentGlobalAlpha = e)
                } else this.canvasContext.restore()
            }, CanvasRenderer.prototype.configAnimation = function(t) {
                var e, i;
                this.animationItem.wrapper ? (this.animationItem.container = createTag("canvas"), (e = this.animationItem.container.style).width = "100%", e.height = "100%", i = "0px 0px 0px", e.transformOrigin = i, e.mozTransformOrigin = i, e.webkitTransformOrigin = i, e["-webkit-transform"] = i, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)) : this.canvasContext = this.renderConfig.context, this.data = t, this.layers = t.layers, this.transformCanvas = {
                    w: t.w,
                    h: t.h,
                    sx: 0,
                    sy: 0,
                    tx: 0,
                    ty: 0
                }, this.setupGlobalData(t, document.body), this.globalData.canvasContext = this.canvasContext, (this.globalData.renderer = this).globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(t.layers.length), this.updateContainerSize()
            }, CanvasRenderer.prototype.updateContainerSize = function() {
                var t, e, i, n, r, a, s, o, l;
                this.reset(), this.animationItem.wrapper && this.animationItem.container ? (t = this.animationItem.wrapper.offsetWidth, e = this.animationItem.wrapper.offsetHeight, this.animationItem.container.setAttribute("width", t * this.renderConfig.dpr), this.animationItem.container.setAttribute("height", e * this.renderConfig.dpr)) : (t = this.canvasContext.canvas.width * this.renderConfig.dpr, e = this.canvasContext.canvas.height * this.renderConfig.dpr), -1 !== this.renderConfig.preserveAspectRatio.indexOf("meet") || -1 !== this.renderConfig.preserveAspectRatio.indexOf("slice") ? (n = (i = this.renderConfig.preserveAspectRatio.split(" "))[1] || "meet", a = (r = i[0] || "xMidYMid").substr(0, 4), s = r.substr(4), (o = t / e) < (l = this.transformCanvas.w / this.transformCanvas.h) && "meet" === n || l < o && "slice" === n ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = t / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr)), this.transformCanvas.tx = "xMid" === a && (l < o && "meet" === n || o < l && "slice" === n) ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : "xMax" === a && (l < o && "meet" === n || o < l && "slice" === n) ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) * this.renderConfig.dpr : 0, this.transformCanvas.ty = "YMid" === s && (o < l && "meet" === n || l < o && "slice" === n) ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : "YMax" === s && (o < l && "meet" === n || l < o && "slice" === n) ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) * this.renderConfig.dpr : 0) : ("none" === this.renderConfig.preserveAspectRatio ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr)) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0), this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0)
            }, CanvasRenderer.prototype.destroy = function() {
                this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = "");
                for (var t = (this.layers ? this.layers.length : 0) - 1; 0 <= t; --t) this.elements[t] && this.elements[t].destroy();
                this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0
            }, CanvasRenderer.prototype.renderFrame = function(t, e) {
                if ((this.renderedFrame !== t || !0 !== this.renderConfig.clearCanvas || e) && !this.destroyed && -1 !== t) {
                    var i;
                    this.renderedFrame = t, this.globalData.frameNum = t - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || e, this.globalData.projectInterface.currentFrame = t;
                    var n = this.layers.length;
                    for (this.completeLayers || this.checkLayers(t), i = 0; i < n; i += 1)(this.completeLayers || this.elements[i]) && this.elements[i].prepareFrame(t - this.layers[i].st);
                    if (this.globalData._mdf) {
                        for (!0 === this.renderConfig.clearCanvas ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), i = n - 1; 0 <= i; --i)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame();
                        !0 !== this.renderConfig.clearCanvas && this.restore()
                    }
                }
            }, CanvasRenderer.prototype.buildItem = function(t) {
                var e, i = this.elements;
                i[t] || 99 === this.layers[t].ty || (e = this.createItem(this.layers[t], this, this.globalData), (i[t] = e).initExpressions())
            }, CanvasRenderer.prototype.checkPendingElements = function() {
                for (; this.pendingElements.length;) {
                    this.pendingElements.pop().checkParenting()
                }
            }, CanvasRenderer.prototype.hide = function() {
                this.animationItem.container.style.display = "none"
            }, CanvasRenderer.prototype.show = function() {
                this.animationItem.container.style.display = "block"
            }, extendPrototype([BaseRenderer], HybridRenderer), HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRenderer.prototype.checkPendingElements = function() {
                for (; this.pendingElements.length;) {
                    this.pendingElements.pop().checkParenting()
                }
            }, HybridRenderer.prototype.appendElementInPos = function(t, e) {
                var i = t.getBaseElement();
                if (i) {
                    var n = this.layers[e];
                    if (n.ddd && this.supports3d) this.addTo3dContainer(i, e);
                    else if (this.threeDElements) this.addTo3dContainer(i, e);
                    else {
                        for (var r, a, s = 0; s < e;) this.elements[s] && !0 !== this.elements[s] && this.elements[s].getBaseElement && (a = this.elements[s], r = (this.layers[s].ddd ? this.getThreeDContainerByPos(s) : a.getBaseElement()) || r), s += 1;
                        r ? n.ddd && this.supports3d || this.layerElement.insertBefore(i, r) : n.ddd && this.supports3d || this.layerElement.appendChild(i)
                    }
                }
            }, HybridRenderer.prototype.createShape = function(t) {
                return new(this.supports3d ? HShapeElement : SVGShapeElement)(t, this.globalData, this)
            }, HybridRenderer.prototype.createText = function(t) {
                return new(this.supports3d ? HTextElement : SVGTextLottieElement)(t, this.globalData, this)
            }, HybridRenderer.prototype.createCamera = function(t) {
                return this.camera = new HCameraElement(t, this.globalData, this), this.camera
            }, HybridRenderer.prototype.createImage = function(t) {
                return new(this.supports3d ? HImageElement : IImageElement)(t, this.globalData, this)
            }, HybridRenderer.prototype.createComp = function(t) {
                return new(this.supports3d ? HCompElement : SVGCompElement)(t, this.globalData, this)
            }, HybridRenderer.prototype.createSolid = function(t) {
                return new(this.supports3d ? HSolidElement : ISolidElement)(t, this.globalData, this)
            }, HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull, HybridRenderer.prototype.getThreeDContainerByPos = function(t) {
                for (var e = 0, i = this.threeDElements.length; e < i;) {
                    if (this.threeDElements[e].startPos <= t && this.threeDElements[e].endPos >= t) return this.threeDElements[e].perspectiveElem;
                    e += 1
                }
                return null
            }, HybridRenderer.prototype.createThreeDContainer = function(t, e) {
                var i, n, r = createTag("div");
                styleDiv(r);
                var a, s, o = createTag("div");
                styleDiv(o), "3d" === e && ((i = r.style).width = this.globalData.compSize.w + "px", i.height = this.globalData.compSize.h + "px", a = "50% 50%", i.webkitTransformOrigin = a, i.mozTransformOrigin = a, i.transformOrigin = a, s = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)", (n = o.style).transform = s, n.webkitTransform = s), r.appendChild(o);
                var l = {
                    container: o,
                    perspectiveElem: r,
                    startPos: t,
                    endPos: t,
                    type: e
                };
                return this.threeDElements.push(l), l
            }, HybridRenderer.prototype.build3dContainers = function() {
                for (var t, e = this.layers.length, i = "", n = 0; n < e; n += 1) this.layers[n].ddd && 3 !== this.layers[n].ty ? "3d" !== i && (i = "3d", t = this.createThreeDContainer(n, "3d")) : "2d" !== i && (i = "2d", t = this.createThreeDContainer(n, "2d")), t.endPos = Math.max(t.endPos, n);
                for (n = (e = this.threeDElements.length) - 1; 0 <= n; --n) this.resizerElem.appendChild(this.threeDElements[n].perspectiveElem)
            }, HybridRenderer.prototype.addTo3dContainer = function(t, e) {
                for (var i = 0, n = this.threeDElements.length; i < n;) {
                    if (e <= this.threeDElements[i].endPos) {
                        for (var r, a = this.threeDElements[i].startPos; a < e;) this.elements[a] && this.elements[a].getBaseElement && (r = this.elements[a].getBaseElement()), a += 1;
                        r ? this.threeDElements[i].container.insertBefore(t, r) : this.threeDElements[i].container.appendChild(t);
                        break
                    }
                    i += 1
                }
            }, HybridRenderer.prototype.configAnimation = function(t) {
                var e = createTag("div"),
                    i = this.animationItem.wrapper,
                    n = e.style;
                n.width = t.w + "px", n.height = t.h + "px", styleDiv(this.resizerElem = e), n.transformStyle = "flat", n.mozTransformStyle = "flat", n.webkitTransformStyle = "flat", this.renderConfig.className && e.setAttribute("class", this.renderConfig.className), i.appendChild(e), n.overflow = "hidden";
                var r = createNS("svg");
                r.setAttribute("width", "1"), r.setAttribute("height", "1"), styleDiv(r), this.resizerElem.appendChild(r);
                var a = createNS("defs");
                r.appendChild(a), this.data = t, this.setupGlobalData(t, r), this.globalData.defs = a, this.layers = t.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize()
            }, HybridRenderer.prototype.destroy = function() {
                this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null;
                for (var t = this.layers ? this.layers.length : 0, e = 0; e < t; e += 1) this.elements[e].destroy();
                this.elements.length = 0, this.destroyed = !0, this.animationItem = null
            }, HybridRenderer.prototype.updateContainerSize = function() {
                var t, e, i, n = this.animationItem.wrapper.offsetWidth,
                    r = this.animationItem.wrapper.offsetHeight,
                    a = n / r < this.globalData.compSize.w / this.globalData.compSize.h ? (t = n / this.globalData.compSize.w, e = n / this.globalData.compSize.w, i = 0, (r - this.globalData.compSize.h * (n / this.globalData.compSize.w)) / 2) : (t = r / this.globalData.compSize.h, e = r / this.globalData.compSize.h, i = (n - this.globalData.compSize.w * (r / this.globalData.compSize.h)) / 2, 0),
                    s = this.resizerElem.style;
                s.webkitTransform = "matrix3d(" + t + ",0,0,0,0," + e + ",0,0,0,0,1,0," + i + "," + a + ",0,1)", s.transform = s.webkitTransform
            }, HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRenderer.prototype.hide = function() {
                this.resizerElem.style.display = "none"
            }, HybridRenderer.prototype.show = function() {
                this.resizerElem.style.display = "block"
            }, HybridRenderer.prototype.initItems = function() {
                if (this.buildAllItems(), this.camera) this.camera.setup();
                else
                    for (var t = this.globalData.compSize.w, e = this.globalData.compSize.h, i = this.threeDElements.length, n = 0; n < i; n += 1) {
                        var r = this.threeDElements[n].perspectiveElem.style;
                        r.webkitPerspective = Math.sqrt(Math.pow(t, 2) + Math.pow(e, 2)) + "px", r.perspective = r.webkitPerspective
                    }
            }, HybridRenderer.prototype.searchExtraCompositions = function(t) {
                for (var e, i = t.length, n = createTag("div"), r = 0; r < i; r += 1) {
                    t[r].xt && ((e = this.createComp(t[r], n, this.globalData.comp, null)).initExpressions(), this.globalData.projectInterface.registerComposition(e))
                }
            }, MaskElement.prototype.getMaskProperty = function(t) {
                return this.viewData[t].prop
            }, MaskElement.prototype.renderFrame = function(t) {
                for (var e, i = this.element.finalTransform.mat, n = this.masksProperties.length, r = 0; r < n; r += 1) {
                    (this.viewData[r].prop._mdf || t) && this.drawPath(this.masksProperties[r], this.viewData[r].prop.v, this.viewData[r]), (this.viewData[r].op._mdf || t) && this.viewData[r].elem.setAttribute("fill-opacity", this.viewData[r].op.v), "n" !== this.masksProperties[r].mode && (this.viewData[r].invRect && (this.element.finalTransform.mProp._mdf || t) && this.viewData[r].invRect.setAttribute("transform", i.getInverseMatrix().to2dCSS()), this.storedData[r].x && (this.storedData[r].x._mdf || t) && (e = this.storedData[r].expan, this.storedData[r].x.v < 0 ? ("erode" !== this.storedData[r].lastOperator && (this.storedData[r].lastOperator = "erode", this.storedData[r].elem.setAttribute("filter", "url(" + locationHref + "#" + this.storedData[r].filterId + ")")), e.setAttribute("radius", -this.storedData[r].x.v)) : ("dilate" !== this.storedData[r].lastOperator && (this.storedData[r].lastOperator = "dilate", this.storedData[r].elem.setAttribute("filter", null)), this.storedData[r].elem.setAttribute("stroke-width", 2 * this.storedData[r].x.v))))
                }
            }, MaskElement.prototype.getMaskelement = function() {
                return this.maskElement
            }, MaskElement.prototype.createLayerSolidPath = function() {
                var t = "M0,0 ";
                return t += " h" + this.globalData.compSize.w, t += " v" + this.globalData.compSize.h, t += " h-" + this.globalData.compSize.w, t += " v-" + this.globalData.compSize.h + " "
            }, MaskElement.prototype.drawPath = function(t, e, i) {
                for (var n, r = " M" + e.v[0][0] + "," + e.v[0][1], a = e._length, s = 1; s < a; s += 1) r += " C" + e.o[s - 1][0] + "," + e.o[s - 1][1] + " " + e.i[s][0] + "," + e.i[s][1] + " " + e.v[s][0] + "," + e.v[s][1];
                e.c && 1 < a && (r += " C" + e.o[s - 1][0] + "," + e.o[s - 1][1] + " " + e.i[0][0] + "," + e.i[0][1] + " " + e.v[0][0] + "," + e.v[0][1]), i.lastPath !== r && (n = "", i.elem && (e.c && (n = t.inv ? this.solidPath + r : r), i.elem.setAttribute("d", n)), i.lastPath = r)
            }, MaskElement.prototype.destroy = function() {
                this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null
            }, HierarchyElement.prototype = {
                initHierarchy: function() {
                    this.hierarchy = [], this._isParent = !1, this.checkParenting()
                },
                setHierarchy: function(t) {
                    this.hierarchy = t
                },
                setAsParent: function() {
                    this._isParent = !0
                },
                checkParenting: function() {
                    void 0 !== this.data.parent && this.comp.buildElementParenting(this, this.data.parent, [])
                }
            }, FrameElement.prototype = {
                initFrame: function() {
                    this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1
                },
                prepareProperties: function(t, e) {
                    for (var i = this.dynamicProperties.length, n = 0; n < i; n += 1)(e || this._isParent && "transform" === this.dynamicProperties[n].propType) && (this.dynamicProperties[n].getValue(), this.dynamicProperties[n]._mdf && (this.globalData._mdf = !0, this._mdf = !0))
                },
                addDynamicProperty: function(t) {
                    -1 === this.dynamicProperties.indexOf(t) && this.dynamicProperties.push(t)
                }
            }, TransformElement.prototype = {
                initTransform: function() {
                    this.finalTransform = {
                        mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                            o: 0
                        },
                        _matMdf: !1,
                        _opMdf: !1,
                        mat: new Matrix
                    }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty
                },
                renderTransform: function() {
                    if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
                        var t, e = this.finalTransform.mat,
                            i = 0,
                            n = this.hierarchy.length;
                        if (!this.finalTransform._matMdf)
                            for (; i < n;) {
                                if (this.hierarchy[i].finalTransform.mProp._mdf) {
                                    this.finalTransform._matMdf = !0;
                                    break
                                }
                                i += 1
                            }
                        if (this.finalTransform._matMdf)
                            for (t = this.finalTransform.mProp.v.props, e.cloneFromProps(t), i = 0; i < n; i += 1) t = this.hierarchy[i].finalTransform.mProp.v.props, e.transform(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15])
                    }
                },
                globalToLocal: function(t) {
                    var e = [];
                    e.push(this.finalTransform);
                    for (var i = !0, n = this.comp; i;) n.finalTransform ? (n.data.hasMask && e.splice(0, 0, n.finalTransform), n = n.comp) : i = !1;
                    for (var r, a = e.length, s = 0; s < a; s += 1) r = e[s].mat.applyToPointArray(0, 0, 0), t = [t[0] - r[0], t[1] - r[1], 0];
                    return t
                },
                mHelper: new Matrix
            }, RenderableElement.prototype = {
                initRenderable: function() {
                    this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = []
                },
                addRenderableComponent: function(t) {
                    -1 === this.renderableComponents.indexOf(t) && this.renderableComponents.push(t)
                },
                removeRenderableComponent: function(t) {
                    -1 !== this.renderableComponents.indexOf(t) && this.renderableComponents.splice(this.renderableComponents.indexOf(t), 1)
                },
                prepareRenderableFrame: function(t) {
                    this.checkLayerLimits(t)
                },
                checkTransparency: function() {
                    this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show())
                },
                checkLayerLimits: function(t) {
                    this.data.ip - this.data.st <= t && this.data.op - this.data.st > t ? !0 !== this.isInRange && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : !1 !== this.isInRange && (this.globalData._mdf = !0, this.isInRange = !1, this.hide())
                },
                renderRenderable: function() {
                    for (var t = this.renderableComponents.length, e = 0; e < t; e += 1) this.renderableComponents[e].renderFrame(this._isFirstFrame)
                },
                sourceRectAtTime: function() {
                    return {
                        top: 0,
                        left: 0,
                        width: 100,
                        height: 100
                    }
                },
                getLayerSize: function() {
                    return 5 === this.data.ty ? {
                        w: this.data.textData.width,
                        h: this.data.textData.height
                    } : {
                        w: this.data.width,
                        h: this.data.height
                    }
                }
            }, extendPrototype([RenderableElement, createProxyFunction({
                initElement: function(t, e, i) {
                    this.initFrame(), this.initBaseData(t, e, i), this.initTransform(t, e, i), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide()
                },
                hide: function() {
                    this.hidden || this.isInRange && !this.isTransparent || ((this.baseElement || this.layerElement).style.display = "none", this.hidden = !0)
                },
                show: function() {
                    this.isInRange && !this.isTransparent && (this.data.hd || ((this.baseElement || this.layerElement).style.display = "block"), this.hidden = !1, this._isFirstFrame = !0)
                },
                renderFrame: function() {
                    this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                },
                renderInnerContent: function() {},
                prepareFrame: function(t) {
                    this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.checkTransparency()
                },
                destroy: function() {
                    this.innerElem = null, this.destroyBaseElement()
                }
            })], RenderableDOMElement), SVGStyleData.prototype.reset = function() {
                this.d = "", this._mdf = !1
            }, SVGShapeData.prototype.setAsAnimated = function() {
                this._isAnimated = !0
            }, extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData), extendPrototype([DynamicPropertyContainer], SVGFillStyleData), SVGGradientFillStyleData.prototype.initGradientData = function(t, e, i) {
                this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.s = PropertyFactory.getProp(t, e.s, 1, null, this), this.e = PropertyFactory.getProp(t, e.e, 1, null, this), this.h = PropertyFactory.getProp(t, e.h || {
                    k: 0
                }, 0, .01, this), this.a = PropertyFactory.getProp(t, e.a || {
                    k: 0
                }, 0, degToRads, this), this.g = new GradientProperty(t, e.g, this), this.style = i, this.stops = [], this.setGradientData(i.pElem, e), this.setGradientOpacity(e, i), this._isAnimated = !!this._isAnimated
            }, SVGGradientFillStyleData.prototype.setGradientData = function(t, e) {
                var i = createElementID(),
                    n = createNS(1 === e.t ? "linearGradient" : "radialGradient");
                n.setAttribute("id", i), n.setAttribute("spreadMethod", "pad"), n.setAttribute("gradientUnits", "userSpaceOnUse");
                for (var r, a = [], s = 4 * e.g.p, o = 0; o < s; o += 4) r = createNS("stop"), n.appendChild(r), a.push(r);
                t.setAttribute("gf" === e.ty ? "fill" : "stroke", "url(" + locationHref + "#" + i + ")"), this.gf = n, this.cst = a
            }, SVGGradientFillStyleData.prototype.setGradientOpacity = function(t, e) {
                if (this.g._hasOpacity && !this.g._collapsable) {
                    var i, n, r = createNS("mask"),
                        a = createNS("path");
                    r.appendChild(a);
                    var s = createElementID(),
                        o = createElementID();
                    r.setAttribute("id", o);
                    var l = createNS(1 === t.t ? "linearGradient" : "radialGradient");
                    l.setAttribute("id", s), l.setAttribute("spreadMethod", "pad"), l.setAttribute("gradientUnits", "userSpaceOnUse"), n = t.g.k.k[0].s ? t.g.k.k[0].s.length : t.g.k.k.length;
                    for (var h = this.stops, u = 4 * t.g.p; u < n; u += 2)(i = createNS("stop")).setAttribute("stop-color", "rgb(255,255,255)"), l.appendChild(i), h.push(i);
                    a.setAttribute("gf" === t.ty ? "fill" : "stroke", "url(" + locationHref + "#" + s + ")"), "gs" === t.ty && (a.setAttribute("stroke-linecap", lineCapEnum[t.lc || 2]), a.setAttribute("stroke-linejoin", lineJoinEnum[t.lj || 2]), 1 === t.lj && a.setAttribute("stroke-miterlimit", t.ml)), this.of = l, this.ms = r, this.ost = h, this.maskId = o, e.msElem = a
                }
            }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData), extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
            var SVGElementsRenderer = (VMe = new Matrix, WMe = new Matrix, {
                    createRenderFunction: function(t) {
                        switch (t.ty) {
                            case "fl":
                                return _Me;
                            case "gf":
                                return bNe;
                            case "gs":
                                return aNe;
                            case "st":
                                return cNe;
                            case "sh":
                            case "el":
                            case "rc":
                            case "sr":
                                return $Me;
                            case "tr":
                                return ZMe;
                            default:
                                return null
                        }
                    }
                }),
                VMe, WMe;

            function ZMe(t, e, i) {
                (i || e.transform.op._mdf) && e.transform.container.setAttribute("opacity", e.transform.op.v), (i || e.transform.mProps._mdf) && e.transform.container.setAttribute("transform", e.transform.mProps.v.to2dCSS())
            }

            function $Me(t, e, i) {
                for (var n, r, a, s, o, l, h, u, c, p, d = e.styles.length, f = e.lvl, m = 0; m < d; m += 1) {
                    if (s = e.sh._mdf || i, e.styles[m].lvl < f) {
                        for (h = WMe.reset(), c = f - e.styles[m].lvl, p = e.transformers.length - 1; !s && 0 < c;) s = e.transformers[p].mProps._mdf || s, --c, --p;
                        if (s)
                            for (c = f - e.styles[m].lvl, p = e.transformers.length - 1; 0 < c;) u = e.transformers[p].mProps.v.props, h.transform(u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], u[8], u[9], u[10], u[11], u[12], u[13], u[14], u[15]), --c, --p
                    } else h = VMe;
                    if (r = (l = e.sh.paths)._length, s) {
                        for (a = "", n = 0; n < r; n += 1)(o = l.shapes[n]) && o._length && (a += buildShapeString(o, o._length, o.c, h));
                        e.caches[m] = a
                    } else a = e.caches[m];
                    e.styles[m].d += !0 === t.hd ? "" : a, e.styles[m]._mdf = s || e.styles[m]._mdf
                }
            }

            function _Me(t, e, i) {
                var n = e.style;
                (e.c._mdf || i) && n.pElem.setAttribute("fill", "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || i) && n.pElem.setAttribute("fill-opacity", e.o.v)
            }

            function aNe(t, e, i) {
                bNe(t, e, i), cNe(0, e, i)
            }

            function bNe(t, e, i) {
                var n, r, a, s, o, l, h, u, c, p, d = e.gf,
                    f = e.g._hasOpacity,
                    m = e.s.v,
                    g = e.e.v;
                if ((e.o._mdf || i) && (n = "gf" === t.ty ? "fill-opacity" : "stroke-opacity", e.style.pElem.setAttribute(n, e.o.v)), (e.s._mdf || i) && (a = "x1" == (r = 1 === t.t ? "x1" : "cx") ? "y1" : "cy", d.setAttribute(r, m[0]), d.setAttribute(a, m[1]), f && !e.g._collapsable && (e.of.setAttribute(r, m[0]), e.of.setAttribute(a, m[1]))), e.g._cmdf || i) {
                    x = e.cst;
                    for (var v = e.g.c, y = x.length, b = 0; b < y; b += 1)(s = x[b]).setAttribute("offset", v[4 * b] + "%"), s.setAttribute("stop-color", "rgb(" + v[4 * b + 1] + "," + v[4 * b + 2] + "," + v[4 * b + 3] + ")")
                }
                if (f && (e.g._omdf || i)) {
                    var x, _ = e.g.o;
                    for (y = (x = e.g._collapsable ? e.cst : e.ost).length, b = 0; b < y; b += 1) s = x[b], e.g._collapsable || s.setAttribute("offset", _[2 * b] + "%"), s.setAttribute("stop-opacity", _[2 * b + 1])
                }
                1 === t.t ? (e.e._mdf || i) && (d.setAttribute("x2", g[0]), d.setAttribute("y2", g[1]), f && !e.g._collapsable && (e.of.setAttribute("x2", g[0]), e.of.setAttribute("y2", g[1]))) : ((e.s._mdf || e.e._mdf || i) && (o = Math.sqrt(Math.pow(m[0] - g[0], 2) + Math.pow(m[1] - g[1], 2)), d.setAttribute("r", o), f && !e.g._collapsable && e.of.setAttribute("r", o)), (e.e._mdf || e.h._mdf || e.a._mdf || i) && (o = o || Math.sqrt(Math.pow(m[0] - g[0], 2) + Math.pow(m[1] - g[1], 2)), l = Math.atan2(g[1] - m[1], g[0] - m[0]), 1 <= (h = e.h.v) ? h = .99 : h <= -1 && (h = -.99), u = o * h, c = Math.cos(l + e.a.v) * u + m[0], p = Math.sin(l + e.a.v) * u + m[1], d.setAttribute("fx", c), d.setAttribute("fy", p), f && !e.g._collapsable && (e.of.setAttribute("fx", c), e.of.setAttribute("fy", p))))
            }

            function cNe(t, e, i) {
                var n = e.style,
                    r = e.d;
                r && (r._mdf || i) && r.dashStr && (n.pElem.setAttribute("stroke-dasharray", r.dashStr), n.pElem.setAttribute("stroke-dashoffset", r.dashoffset[0])), e.c && (e.c._mdf || i) && n.pElem.setAttribute("stroke", "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || i) && n.pElem.setAttribute("stroke-opacity", e.o.v), (e.w._mdf || i) && (n.pElem.setAttribute("stroke-width", e.w.v), n.msElem && n.msElem.setAttribute("stroke-width", e.w.v))
            }

            function ShapeTransformManager() {
                this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0
            }

            function CVShapeData(t, e, i, n) {
                this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
                var r = 4;
                "rc" === e.ty ? r = 5 : "el" === e.ty ? r = 6 : "sr" === e.ty && (r = 7), this.sh = ShapePropertyFactory.getShapeProp(t, e, r, t);
                for (var a, s = i.length, o = 0; o < s; o += 1) i[o].closed || (a = {
                    transforms: n.addTransformSequence(i[o].transforms),
                    trNodes: []
                }, this.styledShapes.push(a), i[o].elements.push(a))
            }

            function BaseElement() {}

            function NullElement(t, e, i) {
                this.initFrame(), this.initBaseData(t, e, i), this.initFrame(), this.initTransform(t, e, i), this.initHierarchy()
            }

            function SVGBaseElement() {}

            function IShapeElement() {}

            function ITextElement() {}

            function ICompElement() {}

            function IImageElement(t, e, i) {
                this.assetData = e.getAssetData(t.refId), this.initElement(t, e, i), this.sourceRect = {
                    top: 0,
                    left: 0,
                    width: this.assetData.w,
                    height: this.assetData.h
                }
            }

            function ISolidElement(t, e, i) {
                this.initElement(t, e, i)
            }

            function AudioElement(t, e, i) {
                this.initFrame(), this.initRenderable(), this.assetData = e.getAssetData(t.refId), this.initBaseData(t, e, i), this._isPlaying = !1, this._canPlay = !1;
                var n = this.globalData.getAssetsPath(this.assetData);
                this.audio = this.globalData.audioController.createAudio(n), this._currentTime = 0, this.globalData.audioController.addAudio(this), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                    _placeholder: !0
                }
            }

            function FootageElement(t, e, i) {
                this.initFrame(), this.initRenderable(), this.assetData = e.getAssetData(t.refId), this.footageData = e.imageLoader.getAsset(this.assetData), this.initBaseData(t, e, i)
            }

            function SVGCompElement(t, e, i) {
                this.layers = t.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, i), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                    _placeholder: !0
                }
            }

            function SVGTextLottieElement(t, e, i) {
                this.textSpans = [], this.renderType = "svg", this.initElement(t, e, i)
            }

            function SVGShapeElement(t, e, i) {
                this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(t, e, i), this.prevViewData = []
            }

            function SVGTintFilter(t, e) {
                this.filterManager = e;
                var i, n, r = createNS("feColorMatrix");
                r.setAttribute("type", "matrix"), r.setAttribute("color-interpolation-filters", "linearRGB"), r.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), r.setAttribute("result", "f1"), t.appendChild(r), (r = createNS("feColorMatrix")).setAttribute("type", "matrix"), r.setAttribute("color-interpolation-filters", "sRGB"), r.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), r.setAttribute("result", "f2"), t.appendChild(r), this.matrixFilter = r, 100 === e.effectElements[2].p.v && !e.effectElements[2].p.k || (i = createNS("feMerge"), t.appendChild(i), (n = createNS("feMergeNode")).setAttribute("in", "SourceGraphic"), i.appendChild(n), (n = createNS("feMergeNode")).setAttribute("in", "f2"), i.appendChild(n))
            }

            function SVGFillFilter(t, e) {
                this.filterManager = e;
                var i = createNS("feColorMatrix");
                i.setAttribute("type", "matrix"), i.setAttribute("color-interpolation-filters", "sRGB"), i.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), t.appendChild(i), this.matrixFilter = i
            }

            function SVGGaussianBlurEffect(t, e) {
                t.setAttribute("x", "-100%"), t.setAttribute("y", "-100%"), t.setAttribute("width", "300%"), t.setAttribute("height", "300%"), this.filterManager = e;
                var i = createNS("feGaussianBlur");
                t.appendChild(i), this.feGaussianBlur = i
            }

            function SVGStrokeEffect(t, e) {
                this.initialized = !1, this.filterManager = e, this.elem = t, this.paths = []
            }

            function SVGTritoneFilter(t, e) {
                this.filterManager = e;
                var i = createNS("feColorMatrix");
                i.setAttribute("type", "matrix"), i.setAttribute("color-interpolation-filters", "linearRGB"), i.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), i.setAttribute("result", "f1"), t.appendChild(i);
                var n = createNS("feComponentTransfer");
                n.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(n), this.matrixFilter = n;
                var r = createNS("feFuncR");
                r.setAttribute("type", "table"), n.appendChild(r), this.feFuncR = r;
                var a = createNS("feFuncG");
                a.setAttribute("type", "table"), n.appendChild(a), this.feFuncG = a;
                var s = createNS("feFuncB");
                s.setAttribute("type", "table"), n.appendChild(s), this.feFuncB = s
            }

            function SVGProLevelsFilter(t, e) {
                this.filterManager = e;
                var i = this.filterManager.effectElements,
                    n = createNS("feComponentTransfer");
                (i[10].p.k || 0 !== i[10].p.v || i[11].p.k || 1 !== i[11].p.v || i[12].p.k || 1 !== i[12].p.v || i[13].p.k || 0 !== i[13].p.v || i[14].p.k || 1 !== i[14].p.v) && (this.feFuncR = this.createFeFunc("feFuncR", n)), (i[17].p.k || 0 !== i[17].p.v || i[18].p.k || 1 !== i[18].p.v || i[19].p.k || 1 !== i[19].p.v || i[20].p.k || 0 !== i[20].p.v || i[21].p.k || 1 !== i[21].p.v) && (this.feFuncG = this.createFeFunc("feFuncG", n)), (i[24].p.k || 0 !== i[24].p.v || i[25].p.k || 1 !== i[25].p.v || i[26].p.k || 1 !== i[26].p.v || i[27].p.k || 0 !== i[27].p.v || i[28].p.k || 1 !== i[28].p.v) && (this.feFuncB = this.createFeFunc("feFuncB", n)), (i[31].p.k || 0 !== i[31].p.v || i[32].p.k || 1 !== i[32].p.v || i[33].p.k || 1 !== i[33].p.v || i[34].p.k || 0 !== i[34].p.v || i[35].p.k || 1 !== i[35].p.v) && (this.feFuncA = this.createFeFunc("feFuncA", n)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (n.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(n), n = createNS("feComponentTransfer")), (i[3].p.k || 0 !== i[3].p.v || i[4].p.k || 1 !== i[4].p.v || i[5].p.k || 1 !== i[5].p.v || i[6].p.k || 0 !== i[6].p.v || i[7].p.k || 1 !== i[7].p.v) && (n.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(n), this.feFuncRComposed = this.createFeFunc("feFuncR", n), this.feFuncGComposed = this.createFeFunc("feFuncG", n), this.feFuncBComposed = this.createFeFunc("feFuncB", n))
            }

            function SVGDropShadowEffect(t, e) {
                var i = e.container.globalData.renderConfig.filterSize;
                t.setAttribute("x", i.x), t.setAttribute("y", i.y), t.setAttribute("width", i.width), t.setAttribute("height", i.height), this.filterManager = e;
                var n = createNS("feGaussianBlur");
                n.setAttribute("in", "SourceAlpha"), n.setAttribute("result", "drop_shadow_1"), n.setAttribute("stdDeviation", "0"), this.feGaussianBlur = n, t.appendChild(n);
                var r = createNS("feOffset");
                r.setAttribute("dx", "25"), r.setAttribute("dy", "0"), r.setAttribute("in", "drop_shadow_1"), r.setAttribute("result", "drop_shadow_2"), this.feOffset = r, t.appendChild(r);
                var a = createNS("feFlood");
                a.setAttribute("flood-color", "#00ff00"), a.setAttribute("flood-opacity", "1"), a.setAttribute("result", "drop_shadow_3"), this.feFlood = a, t.appendChild(a);
                var s = createNS("feComposite");
                s.setAttribute("in", "drop_shadow_3"), s.setAttribute("in2", "drop_shadow_2"), s.setAttribute("operator", "in"), s.setAttribute("result", "drop_shadow_4"), t.appendChild(s);
                var o, l = createNS("feMerge");
                t.appendChild(l), o = createNS("feMergeNode"), l.appendChild(o), (o = createNS("feMergeNode")).setAttribute("in", "SourceGraphic"), this.feMergeNode = o, this.feMerge = l, this.originalNodeAdded = !1, l.appendChild(o)
            }
            ShapeTransformManager.prototype = {
                addTransformSequence: function(t) {
                    for (var e = t.length, i = "_", n = 0; n < e; n += 1) i += t[n].transform.key + "_";
                    var r = this.sequences[i];
                    return r || (r = {
                        transforms: [].concat(t),
                        finalTransform: new Matrix,
                        _mdf: !1
                    }, this.sequences[i] = r, this.sequenceList.push(r)), r
                },
                processSequence: function(t, e) {
                    for (var i, n = 0, r = t.transforms.length, a = e; n < r && !e;) {
                        if (t.transforms[n].transform.mProps._mdf) {
                            a = !0;
                            break
                        }
                        n += 1
                    }
                    if (a)
                        for (t.finalTransform.reset(), n = r - 1; 0 <= n; --n) i = t.transforms[n].transform.mProps.v.props, t.finalTransform.transform(i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]);
                    t._mdf = a
                },
                processSequences: function(t) {
                    for (var e = this.sequenceList.length, i = 0; i < e; i += 1) this.processSequence(this.sequenceList[i], t)
                },
                getNewKey: function() {
                    return this.transform_key_count += 1, "_" + this.transform_key_count
                }
            }, CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated, BaseElement.prototype = {
                checkMasks: function() {
                    if (!this.data.hasMask) return !1;
                    for (var t = 0, e = this.data.masksProperties.length; t < e;) {
                        if ("n" !== this.data.masksProperties[t].mode && !1 !== this.data.masksProperties[t].cl) return !0;
                        t += 1
                    }
                    return !1
                },
                initExpressions: function() {
                    this.layerInterface = LayerExpressionInterface(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                    var t = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
                    this.layerInterface.registerEffectsInterface(t), 0 === this.data.ty || this.data.xt ? this.compInterface = CompExpressionInterface(this) : 4 === this.data.ty ? (this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : 5 === this.data.ty && (this.layerInterface.textInterface = TextExpressionInterface(this), this.layerInterface.text = this.layerInterface.textInterface)
                },
                setBlendMode: function() {
                    var t = getBlendMode(this.data.bm);
                    (this.baseElement || this.layerElement).style["mix-blend-mode"] = t
                },
                initBaseData: function(t, e, i) {
                    this.globalData = e, this.comp = i, this.data = t, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties)
                },
                getType: function() {
                    return this.type
                },
                sourceRectAtTime: function() {}
            }, NullElement.prototype.prepareFrame = function(t) {
                this.prepareProperties(t, !0)
            }, NullElement.prototype.renderFrame = function() {}, NullElement.prototype.getBaseElement = function() {
                return null
            }, NullElement.prototype.destroy = function() {}, NullElement.prototype.sourceRectAtTime = function() {}, NullElement.prototype.hide = function() {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement), SVGBaseElement.prototype = {
                initRendererElement: function() {
                    this.layerElement = createNS("g")
                },
                createContainerElements: function() {
                    this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
                    var t, e, i, n, r, a, s, o, l, h, u, c, p, d = null;
                    this.data.td ? 3 == this.data.td || 1 == this.data.td ? ((n = createNS("mask")).setAttribute("id", this.layerId), n.setAttribute("mask-type", 3 == this.data.td ? "luminance" : "alpha"), n.appendChild(this.layerElement), d = n, this.globalData.defs.appendChild(n), featureSupport.maskType || 1 != this.data.td || (n.setAttribute("mask-type", "luminance"), t = createElementID(), e = filtersFactory.createFilter(t), this.globalData.defs.appendChild(e), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), (i = createNS("g")).appendChild(this.layerElement), d = i, n.appendChild(i), i.setAttribute("filter", "url(" + locationHref + "#" + t + ")"))) : 2 == this.data.td && ((r = createNS("mask")).setAttribute("id", this.layerId), r.setAttribute("mask-type", "alpha"), a = createNS("g"), r.appendChild(a), t = createElementID(), e = filtersFactory.createFilter(t), (s = createNS("feComponentTransfer")).setAttribute("in", "SourceGraphic"), e.appendChild(s), (o = createNS("feFuncA")).setAttribute("type", "table"), o.setAttribute("tableValues", "1.0 0.0"), s.appendChild(o), this.globalData.defs.appendChild(e), (l = createNS("rect")).setAttribute("width", this.comp.data.w), l.setAttribute("height", this.comp.data.h), l.setAttribute("x", "0"), l.setAttribute("y", "0"), l.setAttribute("fill", "#ffffff"), l.setAttribute("opacity", "0"), a.setAttribute("filter", "url(" + locationHref + "#" + t + ")"), a.appendChild(l), a.appendChild(this.layerElement), d = a, featureSupport.maskType || (r.setAttribute("mask-type", "luminance"), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), i = createNS("g"), a.appendChild(l), i.appendChild(this.layerElement), d = i, a.appendChild(i)), this.globalData.defs.appendChild(r)) : this.data.tt ? (this.matteElement.appendChild(this.layerElement), d = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 !== this.data.ty || this.data.hd || (h = createNS("clipPath"), (u = createNS("path")).setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z"), c = createElementID(), h.setAttribute("id", c), h.appendChild(u), this.globalData.defs.appendChild(h), this.checkMasks() ? ((p = createNS("g")).setAttribute("clip-path", "url(" + locationHref + "#" + c + ")"), p.appendChild(this.layerElement), this.transformedElement = p, d ? d.appendChild(this.transformedElement) : this.baseElement = this.transformedElement) : this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + c + ")")), 0 !== this.data.bm && this.setBlendMode()
                },
                renderElement: function() {
                    this.finalTransform._matMdf && this.transformedElement.setAttribute("transform", this.finalTransform.mat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.mProp.o.v)
                },
                destroyBaseElement: function() {
                    this.layerElement = null, this.matteElement = null, this.maskManager.destroy()
                },
                getBaseElement: function() {
                    return this.data.hd ? null : this.baseElement
                },
                createRenderableComponents: function() {
                    this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this)
                },
                setMatte: function(t) {
                    this.matteElement && this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + t + ")")
                }
            }, IShapeElement.prototype = {
                addShapeToModifiers: function(t) {
                    for (var e = this.shapeModifiers.length, i = 0; i < e; i += 1) this.shapeModifiers[i].addShape(t)
                },
                isShapeInAnimatedModifiers: function(t) {
                    for (var e = this.shapeModifiers.length; 0 < e;)
                        if (this.shapeModifiers[0].isAnimatedWithShape(t)) return !0;
                    return !1
                },
                renderModifiers: function() {
                    if (this.shapeModifiers.length) {
                        for (var t = this.shapes.length, e = 0; e < t; e += 1) this.shapes[e].sh.reset();
                        for (e = (t = this.shapeModifiers.length) - 1; 0 <= e && !this.shapeModifiers[e].processShapes(this._isFirstFrame); --e);
                    }
                },
                searchProcessedElement: function(t) {
                    for (var e = this.processedElements, i = 0, n = e.length; i < n;) {
                        if (e[i].elem === t) return e[i].pos;
                        i += 1
                    }
                    return 0
                },
                addProcessedElement: function(t, e) {
                    for (var i = this.processedElements, n = i.length; n;)
                        if (i[--n].elem === t) return void(i[n].pos = e);
                    i.push(new ProcessedElement(t, e))
                },
                prepareFrame: function(t) {
                    this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange)
                }
            }, ITextElement.prototype.initElement = function(t, e, i) {
                this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(t, e, i), this.textProperty = new TextProperty(this, t.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(t.t, this.renderType, this), this.initTransform(t, e, i), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties)
            }, ITextElement.prototype.prepareFrame = function(t) {
                this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1)
            }, ITextElement.prototype.createPathShape = function(t, e) {
                for (var i, n = e.length, r = "", a = 0; a < n; a += 1) i = e[a].ks.k, r += buildShapeString(i, i.i.length, !0, t);
                return r
            }, ITextElement.prototype.updateDocumentData = function(t, e) {
                this.textProperty.updateDocumentData(t, e)
            }, ITextElement.prototype.canResizeFont = function(t) {
                this.textProperty.canResizeFont(t)
            }, ITextElement.prototype.setMinimumFontSize = function(t) {
                this.textProperty.setMinimumFontSize(t)
            }, ITextElement.prototype.applyTextPropertiesToMatrix = function(t, e, i, n, r) {
                switch (t.ps && e.translate(t.ps[0], t.ps[1] + t.ascent, 0), e.translate(0, -t.ls, 0), t.j) {
                    case 1:
                        e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[i]), 0, 0);
                        break;
                    case 2:
                        e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[i]) / 2, 0, 0)
                }
                e.translate(n, r, 0)
            }, ITextElement.prototype.buildColor = function(t) {
                return "rgb(" + Math.round(255 * t[0]) + "," + Math.round(255 * t[1]) + "," + Math.round(255 * t[2]) + ")"
            }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function() {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function(t, e, i) {
                this.initFrame(), this.initBaseData(t, e, i), this.initTransform(t, e, i), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), !this.data.xt && e.progressiveLoad || this.buildAllItems(), this.hide()
            }, ICompElement.prototype.prepareFrame = function(t) {
                if (this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.isInRange || this.data.xt) {
                    var e, i;
                    this.tm._placeholder ? this.renderedFrame = t / this.data.sr : ((e = this.tm.v) === this.data.op && (e = this.data.op - 1), this.renderedFrame = e);
                    var n = this.elements.length;
                    for (this.completeLayers || this.checkLayers(this.renderedFrame), i = n - 1; 0 <= i; --i)(this.completeLayers || this.elements[i]) && (this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st), this.elements[i]._mdf && (this._mdf = !0))
                }
            }, ICompElement.prototype.renderInnerContent = function() {
                for (var t = this.layers.length, e = 0; e < t; e += 1)(this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
            }, ICompElement.prototype.setElements = function(t) {
                this.elements = t
            }, ICompElement.prototype.getElements = function() {
                return this.elements
            }, ICompElement.prototype.destroyElements = function() {
                for (var t = this.layers.length, e = 0; e < t; e += 1) this.elements[e] && this.elements[e].destroy()
            }, ICompElement.prototype.destroy = function() {
                this.destroyElements(), this.destroyBaseElement()
            }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function() {
                var t = this.globalData.getAssetsPath(this.assetData);
                this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.innerElem)
            }, IImageElement.prototype.sourceRectAtTime = function() {
                return this.sourceRect
            }, extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function() {
                var t = createNS("rect");
                t.setAttribute("width", this.data.sw), t.setAttribute("height", this.data.sh), t.setAttribute("fill", this.data.sc), this.layerElement.appendChild(t)
            }, AudioElement.prototype.prepareFrame = function(t) {
                var e;
                this.prepareRenderableFrame(t, !0), this.prepareProperties(t, !0), this.tm._placeholder ? this._currentTime = t / this.data.sr : (e = this.tm.v, this._currentTime = e)
            }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function() {
                this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || .1 < Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek())) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0))
            }, AudioElement.prototype.show = function() {}, AudioElement.prototype.hide = function() {
                this.audio.pause(), this._isPlaying = !1
            }, AudioElement.prototype.pause = function() {
                this.audio.pause(), this._isPlaying = !1, this._canPlay = !1
            }, AudioElement.prototype.resume = function() {
                this._canPlay = !0
            }, AudioElement.prototype.setRate = function(t) {
                this.audio.rate(t)
            }, AudioElement.prototype.volume = function(t) {
                this.audio.volume(t)
            }, AudioElement.prototype.getBaseElement = function() {
                return null
            }, AudioElement.prototype.destroy = function() {}, AudioElement.prototype.sourceRectAtTime = function() {}, AudioElement.prototype.initExpressions = function() {}, FootageElement.prototype.prepareFrame = function() {}, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function() {
                return null
            }, FootageElement.prototype.renderFrame = function() {}, FootageElement.prototype.destroy = function() {}, FootageElement.prototype.initExpressions = function() {
                this.layerInterface = FootageInterface(this)
            }, FootageElement.prototype.getFootageData = function() {
                return this.footageData
            }, extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement), extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function() {
                this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
            }, SVGTextLottieElement.prototype.buildTextContents = function(t) {
                for (var e = 0, i = t.length, n = [], r = ""; e < i;) t[e] === String.fromCharCode(13) || t[e] === String.fromCharCode(3) ? (n.push(r), r = "") : r += t[e], e += 1;
                return n.push(r), n
            }, SVGTextLottieElement.prototype.buildNewText = function() {
                var t = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(t ? t.l.length : 0), t.fc ? this.layerElement.setAttribute("fill", this.buildColor(t.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), t.sc && (this.layerElement.setAttribute("stroke", this.buildColor(t.sc)), this.layerElement.setAttribute("stroke-width", t.sw)), this.layerElement.setAttribute("font-size", t.finalSize);
                var e, i, n = this.globalData.fontManager.getFontByName(t.f);
                n.fClass ? this.layerElement.setAttribute("class", n.fClass) : (this.layerElement.setAttribute("font-family", n.fFamily), e = t.fWeight, i = t.fStyle, this.layerElement.setAttribute("font-style", i), this.layerElement.setAttribute("font-weight", e)), this.layerElement.setAttribute("aria-label", t.t);
                var r, a = t.l || [],
                    s = !!this.globalData.fontManager.chars;
                _ = a.length;
                var o, l = this.mHelper,
                    h = "",
                    u = this.data.singleShape,
                    c = 0,
                    p = 0,
                    d = !0,
                    f = .001 * t.tr * t.finalSize;
                if (!u || s || t.sz) {
                    var m, g, v = this.textSpans.length;
                    for (w = 0; w < _; w += 1) s && u && 0 !== w || (r = w < v ? this.textSpans[w] : createNS(s ? "path" : "text"), v <= w && (r.setAttribute("stroke-linecap", "butt"), r.setAttribute("stroke-linejoin", "round"), r.setAttribute("stroke-miterlimit", "4"), this.textSpans[w] = r, this.layerElement.appendChild(r)), r.style.display = "inherit"), l.reset(), l.scale(t.finalSize / 100, t.finalSize / 100), u && (a[w].n && (c = -f, p += t.yOffset, p += d ? 1 : 0, d = !1), this.applyTextPropertiesToMatrix(t, l, a[w].line, c, p), c += a[w].l || 0, c += f), s ? (o = (m = (g = this.globalData.fontManager.getCharData(t.finalText[w], n.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily)) && g.data || {}).shapes ? m.shapes[0].it : [], u ? h += this.createPathShape(l, o) : r.setAttribute("d", this.createPathShape(l, o))) : (u && r.setAttribute("transform", "translate(" + l.props[12] + "," + l.props[13] + ")"), r.textContent = a[w].val, r.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"));
                    u && r && r.setAttribute("d", h)
                } else {
                    var y = this.textContainer,
                        b = "start";
                    switch (t.j) {
                        case 1:
                            b = "end";
                            break;
                        case 2:
                            b = "middle";
                            break;
                        default:
                            b = "start"
                    }
                    y.setAttribute("text-anchor", b), y.setAttribute("letter-spacing", f);
                    for (var x = this.buildTextContents(t.finalText), _ = x.length, p = t.ps ? t.ps[1] + t.ascent : 0, w = 0; w < _; w += 1)(r = this.textSpans[w] || createNS("tspan")).textContent = x[w], r.setAttribute("x", 0), r.setAttribute("y", p), r.style.display = "inherit", y.appendChild(r), this.textSpans[w] = r, p += t.finalLineHeight;
                    this.layerElement.appendChild(y)
                }
                for (; w < this.textSpans.length;) this.textSpans[w].style.display = "none", w += 1;
                this._sizeChanged = !0
            }, SVGTextLottieElement.prototype.sourceRectAtTime = function() {
                var t;
                return this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged && (this._sizeChanged = !1, t = this.layerElement.getBBox(), this.bbox = {
                    top: t.y,
                    left: t.x,
                    width: t.width,
                    height: t.height
                }), this.bbox
            }, SVGTextLottieElement.prototype.renderInnerContent = function() {
                if (!this.data.singleShape && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                    this._sizeChanged = !0;
                    for (var t, e, i = this.textAnimator.renderedLetters, n = this.textProperty.currentData.l, r = n.length, a = 0; a < r; a += 1) n[a].n || (t = i[a], e = this.textSpans[a], t._mdf.m && e.setAttribute("transform", t.m), t._mdf.o && e.setAttribute("opacity", t.o), t._mdf.sw && e.setAttribute("stroke-width", t.sw), t._mdf.sc && e.setAttribute("stroke", t.sc), t._mdf.fc && e.setAttribute("fill", t.fc))
                }
            }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function() {}, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function() {}, SVGShapeElement.prototype.createContent = function() {
                this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes()
            }, SVGShapeElement.prototype.filterUniqueShapes = function() {
                for (var t, e, i, n = this.shapes.length, r = this.stylesList.length, a = [], s = !1, o = 0; o < r; o += 1) {
                    for (i = this.stylesList[o], s = !1, t = a.length = 0; t < n; t += 1) - 1 !== (e = this.shapes[t]).styles.indexOf(i) && (a.push(e), s = e._isAnimated || s);
                    1 < a.length && s && this.setShapesAsAnimated(a)
                }
            }, SVGShapeElement.prototype.setShapesAsAnimated = function(t) {
                for (var e = t.length, i = 0; i < e; i += 1) t[i].setAsAnimated()
            }, SVGShapeElement.prototype.createStyleElement = function(t, e) {
                var i, n = new SVGStyleData(t, e),
                    r = n.pElem;
                return "st" === t.ty ? i = new SVGStrokeStyleData(this, t, n) : "fl" === t.ty ? i = new SVGFillStyleData(this, t, n) : "gf" !== t.ty && "gs" !== t.ty || (i = new("gf" === t.ty ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(this, t, n), this.globalData.defs.appendChild(i.gf), i.maskId && (this.globalData.defs.appendChild(i.ms), this.globalData.defs.appendChild(i.of), r.setAttribute("mask", "url(" + locationHref + "#" + i.maskId + ")"))), "st" !== t.ty && "gs" !== t.ty || (r.setAttribute("stroke-linecap", lineCapEnum[t.lc || 2]), r.setAttribute("stroke-linejoin", lineJoinEnum[t.lj || 2]), r.setAttribute("fill-opacity", "0"), 1 === t.lj && r.setAttribute("stroke-miterlimit", t.ml)), 2 === t.r && r.setAttribute("fill-rule", "evenodd"), t.ln && r.setAttribute("id", t.ln), t.cl && r.setAttribute("class", t.cl), t.bm && (r.style["mix-blend-mode"] = getBlendMode(t.bm)), this.stylesList.push(n), this.addToAnimatedContents(t, i), i
            }, SVGShapeElement.prototype.createGroupElement = function(t) {
                var e = new ShapeGroupData;
                return t.ln && e.gr.setAttribute("id", t.ln), t.cl && e.gr.setAttribute("class", t.cl), t.bm && (e.gr.style["mix-blend-mode"] = getBlendMode(t.bm)), e
            }, SVGShapeElement.prototype.createTransformElement = function(t, e) {
                var i = TransformPropertyFactory.getTransformProperty(this, t, this),
                    n = new SVGTransformData(i, i.o, e);
                return this.addToAnimatedContents(t, n), n
            }, SVGShapeElement.prototype.createShapeElement = function(t, e, i) {
                var n = 4;
                "rc" === t.ty ? n = 5 : "el" === t.ty ? n = 6 : "sr" === t.ty && (n = 7);
                var r = new SVGShapeData(e, i, ShapePropertyFactory.getShapeProp(this, t, n, this));
                return this.shapes.push(r), this.addShapeToModifiers(r), this.addToAnimatedContents(t, r), r
            }, SVGShapeElement.prototype.addToAnimatedContents = function(t, e) {
                for (var i = 0, n = this.animatedContents.length; i < n;) {
                    if (this.animatedContents[i].element === e) return;
                    i += 1
                }
                this.animatedContents.push({
                    fn: SVGElementsRenderer.createRenderFunction(t),
                    element: e,
                    data: t
                })
            }, SVGShapeElement.prototype.setElementStyles = function(t) {
                for (var e = t.styles, i = this.stylesList.length, n = 0; n < i; n += 1) this.stylesList[n].closed || e.push(this.stylesList[n])
            }, SVGShapeElement.prototype.reloadShapes = function() {
                this._isFirstFrame = !0;
                for (var t = this.itemsData.length, e = 0; e < t; e += 1) this.prevViewData[e] = this.itemsData[e];
                for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), t = this.dynamicProperties.length, e = 0; e < t; e += 1) this.dynamicProperties[e].getValue();
                this.renderModifiers()
            }, SVGShapeElement.prototype.searchShapes = function(t, e, i, n, r, a, s) {
                for (var o, l, h, u, c, p = [].concat(a), d = t.length - 1, f = [], m = [], g = d; 0 <= g; --g) {
                    if ((c = this.searchProcessedElement(t[g])) ? e[g] = i[c - 1] : t[g]._render = s, "fl" === t[g].ty || "st" === t[g].ty || "gf" === t[g].ty || "gs" === t[g].ty) c ? e[g].style.closed = !1 : e[g] = this.createStyleElement(t[g], r), t[g]._render && n.appendChild(e[g].style.pElem), f.push(e[g].style);
                    else if ("gr" === t[g].ty) {
                        if (c)
                            for (l = e[g].it.length, o = 0; o < l; o += 1) e[g].prevViewData[o] = e[g].it[o];
                        else e[g] = this.createGroupElement(t[g]);
                        this.searchShapes(t[g].it, e[g].it, e[g].prevViewData, e[g].gr, r + 1, p, s), t[g]._render && n.appendChild(e[g].gr)
                    } else "tr" === t[g].ty ? (c || (e[g] = this.createTransformElement(t[g], n)), h = e[g].transform, p.push(h)) : "sh" === t[g].ty || "rc" === t[g].ty || "el" === t[g].ty || "sr" === t[g].ty ? (c || (e[g] = this.createShapeElement(t[g], p, r)), this.setElementStyles(e[g])) : "tm" === t[g].ty || "rd" === t[g].ty || "ms" === t[g].ty || "pb" === t[g].ty ? (c ? (u = e[g]).closed = !1 : ((u = ShapeModifiers.getModifier(t[g].ty)).init(this, t[g]), e[g] = u, this.shapeModifiers.push(u)), m.push(u)) : "rp" === t[g].ty && (c ? (u = e[g]).closed = !0 : (u = ShapeModifiers.getModifier(t[g].ty), (e[g] = u).init(this, t, g, e), this.shapeModifiers.push(u), s = !1), m.push(u));
                    this.addProcessedElement(t[g], g + 1)
                }
                for (d = f.length, g = 0; g < d; g += 1) f[g].closed = !0;
                for (d = m.length, g = 0; g < d; g += 1) m[g].closed = !0
            }, SVGShapeElement.prototype.renderInnerContent = function() {
                this.renderModifiers();
                for (var t = this.stylesList.length, e = 0; e < t; e += 1) this.stylesList[e].reset();
                for (this.renderShape(), e = 0; e < t; e += 1)(this.stylesList[e]._mdf || this._isFirstFrame) && (this.stylesList[e].msElem && (this.stylesList[e].msElem.setAttribute("d", this.stylesList[e].d), this.stylesList[e].d = "M0 0" + this.stylesList[e].d), this.stylesList[e].pElem.setAttribute("d", this.stylesList[e].d || "M0 0"))
            }, SVGShapeElement.prototype.renderShape = function() {
                for (var t, e = this.animatedContents.length, i = 0; i < e; i += 1) t = this.animatedContents[i], (this._isFirstFrame || t.element._isAnimated) && !0 !== t.data && t.fn(t.data, t.element, this._isFirstFrame)
            }, SVGShapeElement.prototype.destroy = function() {
                this.destroyBaseElement(), this.shapesData = null, this.itemsData = null
            }, SVGTintFilter.prototype.renderFrame = function(t) {
                var e, i, n;
                (t || this.filterManager._mdf) && (e = this.filterManager.effectElements[0].p.v, i = this.filterManager.effectElements[1].p.v, n = this.filterManager.effectElements[2].p.v / 100, this.matrixFilter.setAttribute("values", i[0] - e[0] + " 0 0 0 " + e[0] + " " + (i[1] - e[1]) + " 0 0 0 " + e[1] + " " + (i[2] - e[2]) + " 0 0 0 " + e[2] + " 0 0 0 " + n + " 0"))
            }, SVGFillFilter.prototype.renderFrame = function(t) {
                var e, i;
                (t || this.filterManager._mdf) && (e = this.filterManager.effectElements[2].p.v, i = this.filterManager.effectElements[6].p.v, this.matrixFilter.setAttribute("values", "0 0 0 0 " + e[0] + " 0 0 0 0 " + e[1] + " 0 0 0 0 " + e[2] + " 0 0 0 " + i + " 0"))
            }, SVGGaussianBlurEffect.prototype.renderFrame = function(t) {
                var e, i, n, r, a;
                (t || this.filterManager._mdf) && (e = .3 * this.filterManager.effectElements[0].p.v, n = 3 == (i = this.filterManager.effectElements[1].p.v) ? 0 : e, r = 2 == i ? 0 : e, this.feGaussianBlur.setAttribute("stdDeviation", n + " " + r), a = 1 == this.filterManager.effectElements[2].p.v ? "wrap" : "duplicate", this.feGaussianBlur.setAttribute("edgeMode", a))
            }, SVGStrokeEffect.prototype.initialize = function() {
                var t, e, i, n, r = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                for (1 === this.filterManager.effectElements[1].p.v ? (n = this.elem.maskManager.masksProperties.length, i = 0) : n = (i = this.filterManager.effectElements[0].p.v - 1) + 1, (e = createNS("g")).setAttribute("fill", "none"), e.setAttribute("stroke-linecap", "round"), e.setAttribute("stroke-dashoffset", 1); i < n; i += 1) t = createNS("path"), e.appendChild(t), this.paths.push({
                    p: t,
                    m: i
                });
                if (3 === this.filterManager.effectElements[10].p.v) {
                    var a = createNS("mask"),
                        s = createElementID();
                    a.setAttribute("id", s), a.setAttribute("mask-type", "alpha"), a.appendChild(e), this.elem.globalData.defs.appendChild(a);
                    var o = createNS("g");
                    for (o.setAttribute("mask", "url(" + locationHref + "#" + s + ")"); r[0];) o.appendChild(r[0]);
                    this.elem.layerElement.appendChild(o), this.masker = a, e.setAttribute("stroke", "#fff")
                } else if (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) {
                    if (2 === this.filterManager.effectElements[10].p.v)
                        for (r = this.elem.layerElement.children || this.elem.layerElement.childNodes; r.length;) this.elem.layerElement.removeChild(r[0]);
                    this.elem.layerElement.appendChild(e), this.elem.layerElement.removeAttribute("mask"), e.setAttribute("stroke", "#fff")
                }
                this.initialized = !0, this.pathMasker = e
            }, SVGStrokeEffect.prototype.renderFrame = function(t) {
                this.initialized || this.initialize();
                for (var e, i, n, r = this.paths.length, a = 0; a < r; a += 1)
                    if (-1 !== this.paths[a].m && (e = this.elem.maskManager.viewData[this.paths[a].m], i = this.paths[a].p, (t || this.filterManager._mdf || e.prop._mdf) && i.setAttribute("d", e.lastPath), t || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || e.prop._mdf)) {
                        if (0 !== this.filterManager.effectElements[7].p.v || 100 !== this.filterManager.effectElements[8].p.v) {
                            for (var s = .01 * Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v), o = .01 * Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v), l = i.getTotalLength(), h = "0 0 0 " + l * s + " ", u = l * (o - s), c = 1 + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01, p = Math.floor(u / c), d = 0; d < p; d += 1) h += "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01 + " ";
                            h += "0 " + 10 * l + " 0 0"
                        } else h = "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01;
                        i.setAttribute("stroke-dasharray", h)
                    }(t || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", 2 * this.filterManager.effectElements[4].p.v), (t || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), 1 !== this.filterManager.effectElements[10].p.v && 2 !== this.filterManager.effectElements[10].p.v || (t || this.filterManager.effectElements[3].p._mdf) && (n = this.filterManager.effectElements[3].p.v, this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(255 * n[0]) + "," + bmFloor(255 * n[1]) + "," + bmFloor(255 * n[2]) + ")"))
            }, SVGTritoneFilter.prototype.renderFrame = function(t) {
                var e, i, n, r, a, s;
                (t || this.filterManager._mdf) && (e = this.filterManager.effectElements[0].p.v, i = this.filterManager.effectElements[1].p.v, r = (n = this.filterManager.effectElements[2].p.v)[0] + " " + i[0] + " " + e[0], a = n[1] + " " + i[1] + " " + e[1], s = n[2] + " " + i[2] + " " + e[2], this.feFuncR.setAttribute("tableValues", r), this.feFuncG.setAttribute("tableValues", a), this.feFuncB.setAttribute("tableValues", s))
            }, SVGProLevelsFilter.prototype.createFeFunc = function(t, e) {
                var i = createNS(t);
                return i.setAttribute("type", "table"), e.appendChild(i), i
            }, SVGProLevelsFilter.prototype.getTableValue = function(t, e, i, n, r) {
                for (var a, s, o = 0, l = Math.min(t, e), h = Math.max(t, e), u = Array.call(null, {
                        length: 256
                    }), c = 0, p = r - n, d = e - t; o <= 256;) s = (a = o / 256) <= l ? d < 0 ? r : n : h <= a ? d < 0 ? n : r : n + p * Math.pow((a - t) / d, 1 / i), u[c] = s, c += 1, o += 256 / 255;
                return u.join(" ")
            }, SVGProLevelsFilter.prototype.renderFrame = function(t) {
                var e, i;
                (t || this.filterManager._mdf) && (i = this.filterManager.effectElements, this.feFuncRComposed && (t || i[3].p._mdf || i[4].p._mdf || i[5].p._mdf || i[6].p._mdf || i[7].p._mdf) && (e = this.getTableValue(i[3].p.v, i[4].p.v, i[5].p.v, i[6].p.v, i[7].p.v), this.feFuncRComposed.setAttribute("tableValues", e), this.feFuncGComposed.setAttribute("tableValues", e), this.feFuncBComposed.setAttribute("tableValues", e)), this.feFuncR && (t || i[10].p._mdf || i[11].p._mdf || i[12].p._mdf || i[13].p._mdf || i[14].p._mdf) && (e = this.getTableValue(i[10].p.v, i[11].p.v, i[12].p.v, i[13].p.v, i[14].p.v), this.feFuncR.setAttribute("tableValues", e)), this.feFuncG && (t || i[17].p._mdf || i[18].p._mdf || i[19].p._mdf || i[20].p._mdf || i[21].p._mdf) && (e = this.getTableValue(i[17].p.v, i[18].p.v, i[19].p.v, i[20].p.v, i[21].p.v), this.feFuncG.setAttribute("tableValues", e)), this.feFuncB && (t || i[24].p._mdf || i[25].p._mdf || i[26].p._mdf || i[27].p._mdf || i[28].p._mdf) && (e = this.getTableValue(i[24].p.v, i[25].p.v, i[26].p.v, i[27].p.v, i[28].p.v), this.feFuncB.setAttribute("tableValues", e)), this.feFuncA && (t || i[31].p._mdf || i[32].p._mdf || i[33].p._mdf || i[34].p._mdf || i[35].p._mdf) && (e = this.getTableValue(i[31].p.v, i[32].p.v, i[33].p.v, i[34].p.v, i[35].p.v), this.feFuncA.setAttribute("tableValues", e)))
            }, SVGDropShadowEffect.prototype.renderFrame = function(t) {
                var e, i, n, r, a;
                (t || this.filterManager._mdf) && ((t || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), (t || this.filterManager.effectElements[0].p._mdf) && (e = this.filterManager.effectElements[0].p.v, this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(255 * e[0]), Math.round(255 * e[1]), Math.round(255 * e[2])))), (t || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), (t || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) && (i = this.filterManager.effectElements[3].p.v, n = (this.filterManager.effectElements[2].p.v - 90) * degToRads, r = i * Math.cos(n), a = i * Math.sin(n), this.feOffset.setAttribute("dx", r), this.feOffset.setAttribute("dy", a)))
            };
            var _svgMatteSymbols = [];

            function SVGMatte3Effect(t, e, i) {
                this.initialized = !1, this.filterManager = e, this.filterElem = t, (this.elem = i).matteElement = createNS("g"), i.matteElement.appendChild(i.layerElement), i.matteElement.appendChild(i.transformedElement), i.baseElement = i.matteElement
            }

            function SVGEffects(t) {
                var e, i, n = t.data.ef ? t.data.ef.length : 0,
                    r = createElementID(),
                    a = filtersFactory.createFilter(r, !0),
                    s = 0;
                for (this.filters = [], e = 0; e < n; e += 1) i = null, 20 === t.data.ef[e].ty ? (s += 1, i = new SVGTintFilter(a, t.effectsManager.effectElements[e])) : 21 === t.data.ef[e].ty ? (s += 1, i = new SVGFillFilter(a, t.effectsManager.effectElements[e])) : 22 === t.data.ef[e].ty ? i = new SVGStrokeEffect(t, t.effectsManager.effectElements[e]) : 23 === t.data.ef[e].ty ? (s += 1, i = new SVGTritoneFilter(a, t.effectsManager.effectElements[e])) : 24 === t.data.ef[e].ty ? (s += 1, i = new SVGProLevelsFilter(a, t.effectsManager.effectElements[e])) : 25 === t.data.ef[e].ty ? (s += 1, i = new SVGDropShadowEffect(a, t.effectsManager.effectElements[e])) : 28 === t.data.ef[e].ty ? i = new SVGMatte3Effect(a, t.effectsManager.effectElements[e], t) : 29 === t.data.ef[e].ty && (s += 1, i = new SVGGaussianBlurEffect(a, t.effectsManager.effectElements[e])), i && this.filters.push(i);
                s && (t.globalData.defs.appendChild(a), t.layerElement.setAttribute("filter", "url(" + locationHref + "#" + r + ")")), this.filters.length && t.addRenderableComponent(this)
            }

            function CVContextData() {
                var t;
                this.saved = [], this.cArrPos = 0, this.cTr = new Matrix, this.cO = 1;
                for (this.savedOp = createTypedArray("float32", 15), t = 0; t < 15; t += 1) this.saved[t] = createTypedArray("float32", 16);
                this._length = 15
            }

            function CVBaseElement() {}

            function CVImageElement(t, e, i) {
                this.assetData = e.getAssetData(t.refId), this.img = e.imageLoader.getAsset(this.assetData), this.initElement(t, e, i)
            }

            function CVCompElement(t, e, i) {
                this.completeLayers = !1, this.layers = t.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(t, e, i), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                    _placeholder: !0
                }
            }

            function CVMaskElement(t, e) {
                this.data = t, this.element = e, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
                for (var i = this.masksProperties.length, n = !1, r = 0; r < i; r += 1) "n" !== this.masksProperties[r].mode && (n = !0), this.viewData[r] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[r], 3);
                (this.hasMasks = n) && this.element.addRenderableComponent(this)
            }

            function CVShapeElement(t, e, i) {
                this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(t, e, i)
            }

            function CVSolidElement(t, e, i) {
                this.initElement(t, e, i)
            }

            function CVTextElement(t, e, i) {
                this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
                    fill: "rgba(0,0,0,0)",
                    stroke: "rgba(0,0,0,0)",
                    sWidth: 0,
                    fValue: ""
                }, this.initElement(t, e, i)
            }

            function CVEffects() {}

            function HBaseElement() {}

            function HSolidElement(t, e, i) {
                this.initElement(t, e, i)
            }

            function HCompElement(t, e, i) {
                this.layers = t.layers, this.supports3d = !t.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, i), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                    _placeholder: !0
                }
            }

            function HShapeElement(t, e, i) {
                this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(t, e, i), this.prevViewData = [], this.currentBBox = {
                    x: 999999,
                    y: -999999,
                    h: 0,
                    w: 0
                }
            }

            function HTextElement(t, e, i) {
                this.textSpans = [], this.textPaths = [], this.currentBBox = {
                    x: 999999,
                    y: -999999,
                    h: 0,
                    w: 0
                }, this.renderType = "svg", this.isMasked = !1, this.initElement(t, e, i)
            }

            function HImageElement(t, e, i) {
                this.assetData = e.getAssetData(t.refId), this.initElement(t, e, i)
            }

            function HCameraElement(t, e, i) {
                this.initFrame(), this.initBaseData(t, e, i), this.initHierarchy();
                var n = PropertyFactory.getProp;
                if (this.pe = n(this, t.pe, 0, 0, this), t.ks.p.s ? (this.px = n(this, t.ks.p.x, 1, 0, this), this.py = n(this, t.ks.p.y, 1, 0, this), this.pz = n(this, t.ks.p.z, 1, 0, this)) : this.p = n(this, t.ks.p, 1, 0, this), t.ks.a && (this.a = n(this, t.ks.a, 1, 0, this)), t.ks.or.k.length && t.ks.or.k[0].to)
                    for (var r = t.ks.or.k.length, a = 0; a < r; a += 1) t.ks.or.k[a].to = null, t.ks.or.k[a].ti = null;
                this.or = n(this, t.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = n(this, t.ks.rx, 0, degToRads, this), this.ry = n(this, t.ks.ry, 0, degToRads, this), this.rz = n(this, t.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = {
                    mProp: this
                }
            }

            function HEffects() {}
            SVGMatte3Effect.prototype.findSymbol = function(t) {
                for (var e = 0, i = _svgMatteSymbols.length; e < i;) {
                    if (_svgMatteSymbols[e] === t) return _svgMatteSymbols[e];
                    e += 1
                }
                return null
            }, SVGMatte3Effect.prototype.replaceInParent = function(t, e) {
                var i = t.layerElement.parentNode;
                if (i) {
                    for (var n, r = i.children, a = 0, s = r.length; a < s && r[a] !== t.layerElement;) a += 1;
                    a <= s - 2 && (n = r[a + 1]);
                    var o = createNS("use");
                    o.setAttribute("href", "#" + e), n ? i.insertBefore(o, n) : i.appendChild(o)
                }
            }, SVGMatte3Effect.prototype.setElementAsMask = function(t, e) {
                var i, n, r, a, s;
                this.findSymbol(e) || (i = createElementID(), (n = createNS("mask")).setAttribute("id", e.layerId), n.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(e), (r = t.globalData.defs).appendChild(n), (a = createNS("symbol")).setAttribute("id", i), this.replaceInParent(e, i), a.appendChild(e.layerElement), r.appendChild(a), (s = createNS("use")).setAttribute("href", "#" + i), n.appendChild(s), e.data.hd = !1, e.show()), t.setMatte(e.layerId)
            }, SVGMatte3Effect.prototype.initialize = function() {
                for (var t = this.filterManager.effectElements[0].p.v, e = this.elem.comp.elements, i = 0, n = e.length; i < n;) e[i] && e[i].data.ind === t && this.setElementAsMask(this.elem, e[i]), i += 1;
                this.initialized = !0
            }, SVGMatte3Effect.prototype.renderFrame = function() {
                this.initialized || this.initialize()
            }, SVGEffects.prototype.renderFrame = function(t) {
                for (var e = this.filters.length, i = 0; i < e; i += 1) this.filters[i].renderFrame(t)
            }, CVContextData.prototype.duplicate = function() {
                var t = 2 * this._length,
                    e = this.savedOp;
                this.savedOp = createTypedArray("float32", t), this.savedOp.set(e);
                for (var i = 0, i = this._length; i < t; i += 1) this.saved[i] = createTypedArray("float32", 16);
                this._length = t
            }, CVContextData.prototype.reset = function() {
                this.cArrPos = 0, this.cTr.reset(), this.cO = 1
            }, CVBaseElement.prototype = {
                createElements: function() {},
                initRendererElement: function() {},
                createContainerElements: function() {
                    this.canvasContext = this.globalData.canvasContext, this.renderableEffectsManager = new CVEffects(this)
                },
                createContent: function() {},
                setBlendMode: function() {
                    var t, e = this.globalData;
                    e.blendMode !== this.data.bm && (e.blendMode = this.data.bm, t = getBlendMode(this.data.bm), e.canvasContext.globalCompositeOperation = t)
                },
                createRenderableComponents: function() {
                    this.maskManager = new CVMaskElement(this.data, this)
                },
                hideElement: function() {
                    this.hidden || this.isInRange && !this.isTransparent || (this.hidden = !0)
                },
                showElement: function() {
                    this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0)
                },
                renderFrame: function() {
                    var t;
                    this.hidden || this.data.hd || (this.renderTransform(), this.renderRenderable(), this.setBlendMode(), t = 0 === this.data.ty, this.globalData.renderer.save(t), this.globalData.renderer.ctxTransform(this.finalTransform.mat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v), this.renderInnerContent(), this.globalData.renderer.restore(t), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1))
                },
                destroy: function() {
                    this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy()
                },
                mHelper: new Matrix
            }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function() {
                var t, e, i, n, r, a, s, o, l;
                !this.img.width || this.assetData.w === this.img.width && this.assetData.h === this.img.height || ((t = createTag("canvas")).width = this.assetData.w, t.height = this.assetData.h, e = t.getContext("2d"), r = (i = this.img.width) / (n = this.img.height), a = this.assetData.w / this.assetData.h, l = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio, a < r && "xMidYMid slice" === l || r < a && "xMidYMid slice" !== l ? s = (o = n) * a : o = (s = i) / a, e.drawImage(this.img, (i - s) / 2, (n - o) / 2, s, o, 0, 0, this.assetData.w, this.assetData.h), this.img = t)
            }, CVImageElement.prototype.renderInnerContent = function() {
                this.canvasContext.drawImage(this.img, 0, 0)
            }, CVImageElement.prototype.destroy = function() {
                this.img = null
            }, extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function() {
                var t = this.canvasContext;
                t.beginPath(), t.moveTo(0, 0), t.lineTo(this.data.w, 0), t.lineTo(this.data.w, this.data.h), t.lineTo(0, this.data.h), t.lineTo(0, 0), t.clip();
                for (var e = this.layers.length - 1; 0 <= e; --e)(this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
            }, CVCompElement.prototype.destroy = function() {
                for (var t = this.layers.length - 1; 0 <= t; --t) this.elements[t] && this.elements[t].destroy();
                this.layers = null, this.elements = null
            }, CVMaskElement.prototype.renderFrame = function() {
                if (this.hasMasks) {
                    var t, e, i, n, r = this.element.finalTransform.mat,
                        a = this.element.canvasContext,
                        s = this.masksProperties.length;
                    for (a.beginPath(), t = 0; t < s; t += 1)
                        if ("n" !== this.masksProperties[t].mode) {
                            this.masksProperties[t].inv && (a.moveTo(0, 0), a.lineTo(this.element.globalData.compSize.w, 0), a.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), a.lineTo(0, this.element.globalData.compSize.h), a.lineTo(0, 0)), n = this.viewData[t].v, e = r.applyToPointArray(n.v[0][0], n.v[0][1], 0), a.moveTo(e[0], e[1]);
                            for (var o = n._length, l = 1; l < o; l += 1) i = r.applyToTriplePoints(n.o[l - 1], n.i[l], n.v[l]), a.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5]);
                            i = r.applyToTriplePoints(n.o[l - 1], n.i[0], n.v[0]), a.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5])
                        }
                    this.element.globalData.renderer.save(!0), a.clip()
                }
            }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function() {
                this.element = null
            }, extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
                opacity: 1,
                _opMdf: !1
            }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function() {
                this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
            }, CVShapeElement.prototype.createStyleElement = function(t, e) {
                var i, n = {
                        data: t,
                        type: t.ty,
                        preTransforms: this.transformsManager.addTransformSequence(e),
                        transforms: [],
                        elements: [],
                        closed: !0 === t.hd
                    },
                    r = {};
                return "fl" === t.ty || "st" === t.ty ? (r.c = PropertyFactory.getProp(this, t.c, 1, 255, this), r.c.k || (n.co = "rgb(" + bmFloor(r.c.v[0]) + "," + bmFloor(r.c.v[1]) + "," + bmFloor(r.c.v[2]) + ")")) : "gf" !== t.ty && "gs" !== t.ty || (r.s = PropertyFactory.getProp(this, t.s, 1, null, this), r.e = PropertyFactory.getProp(this, t.e, 1, null, this), r.h = PropertyFactory.getProp(this, t.h || {
                    k: 0
                }, 0, .01, this), r.a = PropertyFactory.getProp(this, t.a || {
                    k: 0
                }, 0, degToRads, this), r.g = new GradientProperty(this, t.g, this)), r.o = PropertyFactory.getProp(this, t.o, 0, .01, this), "st" === t.ty || "gs" === t.ty ? (n.lc = lineCapEnum[t.lc || 2], n.lj = lineJoinEnum[t.lj || 2], 1 == t.lj && (n.ml = t.ml), r.w = PropertyFactory.getProp(this, t.w, 0, null, this), r.w.k || (n.wi = r.w.v), t.d && (i = new DashProperty(this, t.d, "canvas", this), r.d = i, r.d.k || (n.da = r.d.dashArray, n.do = r.d.dashoffset[0]))) : n.r = 2 === t.r ? "evenodd" : "nonzero", this.stylesList.push(n), r.style = n, r
            }, CVShapeElement.prototype.createGroupElement = function() {
                return {
                    it: [],
                    prevViewData: []
                }
            }, CVShapeElement.prototype.createTransformElement = function(t) {
                return {
                    transform: {
                        opacity: 1,
                        _opMdf: !1,
                        key: this.transformsManager.getNewKey(),
                        op: PropertyFactory.getProp(this, t.o, 0, .01, this),
                        mProps: TransformPropertyFactory.getTransformProperty(this, t, this)
                    }
                }
            }, CVShapeElement.prototype.createShapeElement = function(t) {
                var e = new CVShapeData(this, t, this.stylesList, this.transformsManager);
                return this.shapes.push(e), this.addShapeToModifiers(e), e
            }, CVShapeElement.prototype.reloadShapes = function() {
                this._isFirstFrame = !0;
                for (var t = this.itemsData.length, e = 0; e < t; e += 1) this.prevViewData[e] = this.itemsData[e];
                for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), t = this.dynamicProperties.length, e = 0; e < t; e += 1) this.dynamicProperties[e].getValue();
                this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame)
            }, CVShapeElement.prototype.addTransformToStyleList = function(t) {
                for (var e = this.stylesList.length, i = 0; i < e; i += 1) this.stylesList[i].closed || this.stylesList[i].transforms.push(t)
            }, CVShapeElement.prototype.removeTransformFromStyleList = function() {
                for (var t = this.stylesList.length, e = 0; e < t; e += 1) this.stylesList[e].closed || this.stylesList[e].transforms.pop()
            }, CVShapeElement.prototype.closeStyles = function(t) {
                for (var e = t.length, i = 0; i < e; i += 1) t[i].closed = !0
            }, CVShapeElement.prototype.searchShapes = function(t, e, i, n, r) {
                for (var a, s, o, l, h, u = t.length - 1, c = [], p = [], d = [].concat(r), f = u; 0 <= f; --f) {
                    if ((o = this.searchProcessedElement(t[f])) ? e[f] = i[o - 1] : t[f]._shouldRender = n, "fl" === t[f].ty || "st" === t[f].ty || "gf" === t[f].ty || "gs" === t[f].ty) o ? e[f].style.closed = !1 : e[f] = this.createStyleElement(t[f], d), c.push(e[f].style);
                    else if ("gr" === t[f].ty) {
                        if (o)
                            for (s = e[f].it.length, a = 0; a < s; a += 1) e[f].prevViewData[a] = e[f].it[a];
                        else e[f] = this.createGroupElement(t[f]);
                        this.searchShapes(t[f].it, e[f].it, e[f].prevViewData, n, d)
                    } else "tr" === t[f].ty ? (o || (h = this.createTransformElement(t[f]), e[f] = h), d.push(e[f]), this.addTransformToStyleList(e[f])) : "sh" === t[f].ty || "rc" === t[f].ty || "el" === t[f].ty || "sr" === t[f].ty ? o || (e[f] = this.createShapeElement(t[f])) : "tm" === t[f].ty || "rd" === t[f].ty || "pb" === t[f].ty ? (o ? (l = e[f]).closed = !1 : ((l = ShapeModifiers.getModifier(t[f].ty)).init(this, t[f]), e[f] = l, this.shapeModifiers.push(l)), p.push(l)) : "rp" === t[f].ty && (o ? (l = e[f]).closed = !0 : (l = ShapeModifiers.getModifier(t[f].ty), (e[f] = l).init(this, t, f, e), this.shapeModifiers.push(l), n = !1), p.push(l));
                    this.addProcessedElement(t[f], f + 1)
                }
                for (this.removeTransformFromStyleList(), this.closeStyles(c), u = p.length, f = 0; f < u; f += 1) p[f].closed = !0
            }, CVShapeElement.prototype.renderInnerContent = function() {
                this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
            }, CVShapeElement.prototype.renderShapeTransform = function(t, e) {
                (t._opMdf || e.op._mdf || this._isFirstFrame) && (e.opacity = t.opacity, e.opacity *= e.op.v, e._opMdf = !0)
            }, CVShapeElement.prototype.drawLayer = function() {
                for (var t, e, i, n, r, a, s, o, l = this.stylesList.length, h = this.globalData.renderer, u = this.globalData.canvasContext, c = 0; c < l; c += 1)
                    if (("st" !== (s = (o = this.stylesList[c]).type) && "gs" !== s || 0 !== o.wi) && o.data._shouldRender && 0 !== o.coOp && 0 !== this.globalData.currentGlobalAlpha) {
                        for (h.save(), r = o.elements, "st" === s || "gs" === s ? (u.strokeStyle = "st" === s ? o.co : o.grd, u.lineWidth = o.wi, u.lineCap = o.lc, u.lineJoin = o.lj, u.miterLimit = o.ml || 0) : u.fillStyle = "fl" === s ? o.co : o.grd, h.ctxOpacity(o.coOp), "st" !== s && "gs" !== s && u.beginPath(), h.ctxTransform(o.preTransforms.finalTransform.props), e = r.length, t = 0; t < e; t += 1) {
                            for ("st" !== s && "gs" !== s || (u.beginPath(), o.da && (u.setLineDash(o.da), u.lineDashOffset = o.do)), n = (a = r[t].trNodes).length, i = 0; i < n; i += 1) "m" === a[i].t ? u.moveTo(a[i].p[0], a[i].p[1]) : "c" === a[i].t ? u.bezierCurveTo(a[i].pts[0], a[i].pts[1], a[i].pts[2], a[i].pts[3], a[i].pts[4], a[i].pts[5]) : u.closePath();
                            "st" !== s && "gs" !== s || (u.stroke(), o.da && u.setLineDash(this.dashResetter))
                        }
                        "st" !== s && "gs" !== s && u.fill(o.r), h.restore()
                    }
            }, CVShapeElement.prototype.renderShape = function(t, e, i, n) {
                for (var r = t, a = e.length - 1; 0 <= a; --a) "tr" === e[a].ty ? (r = i[a].transform, this.renderShapeTransform(t, r)) : "sh" === e[a].ty || "el" === e[a].ty || "rc" === e[a].ty || "sr" === e[a].ty ? this.renderPath(e[a], i[a]) : "fl" === e[a].ty ? this.renderFill(e[a], i[a], r) : "st" === e[a].ty ? this.renderStroke(e[a], i[a], r) : "gf" === e[a].ty || "gs" === e[a].ty ? this.renderGradientFill(e[a], i[a], r) : "gr" === e[a].ty ? this.renderShape(r, e[a].it, i[a].it) : e[a].ty;
                n && this.drawLayer()
            }, CVShapeElement.prototype.renderStyledShape = function(t, e) {
                if (this._isFirstFrame || e._mdf || t.transforms._mdf) {
                    var i, n, r = t.trNodes,
                        a = e.paths,
                        s = a._length;
                    r.length = 0;
                    for (var o = t.transforms.finalTransform, l = 0; l < s; l += 1) {
                        var h = a.shapes[l];
                        if (h && h.v) {
                            for (n = h._length, i = 1; i < n; i += 1) 1 === i && r.push({
                                t: "m",
                                p: o.applyToPointArray(h.v[0][0], h.v[0][1], 0)
                            }), r.push({
                                t: "c",
                                pts: o.applyToTriplePoints(h.o[i - 1], h.i[i], h.v[i])
                            });
                            1 === n && r.push({
                                t: "m",
                                p: o.applyToPointArray(h.v[0][0], h.v[0][1], 0)
                            }), h.c && n && (r.push({
                                t: "c",
                                pts: o.applyToTriplePoints(h.o[i - 1], h.i[0], h.v[0])
                            }), r.push({
                                t: "z"
                            }))
                        }
                    }
                    t.trNodes = r
                }
            }, CVShapeElement.prototype.renderPath = function(t, e) {
                if (!0 !== t.hd && t._shouldRender)
                    for (var i = e.styledShapes.length, n = 0; n < i; n += 1) this.renderStyledShape(e.styledShapes[n], e.sh)
            }, CVShapeElement.prototype.renderFill = function(t, e, i) {
                var n = e.style;
                (e.c._mdf || this._isFirstFrame) && (n.co = "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || i._opMdf || this._isFirstFrame) && (n.coOp = e.o.v * i.opacity)
            }, CVShapeElement.prototype.renderGradientFill = function(t, e, i) {
                var n = e.style;
                if (!n.grd || e.g._mdf || e.s._mdf || e.e._mdf || 1 !== t.t && (e.h._mdf || e.a._mdf)) {
                    var r, a, s, o, l, h, u, c = this.globalData.canvasContext,
                        p = e.s.v,
                        d = e.e.v;
                    u = 1 === t.t ? c.createLinearGradient(p[0], p[1], d[0], d[1]) : (r = Math.sqrt(Math.pow(p[0] - d[0], 2) + Math.pow(p[1] - d[1], 2)), a = Math.atan2(d[1] - p[1], d[0] - p[0]), 1 <= (s = e.h.v) ? s = .99 : s <= -1 && (s = -.99), o = r * s, l = Math.cos(a + e.a.v) * o + p[0], h = Math.sin(a + e.a.v) * o + p[1], c.createRadialGradient(l, h, 0, p[0], p[1], r));
                    for (var f = t.g.p, m = e.g.c, g = 1, v = 0; v < f; v += 1) e.g._hasOpacity && e.g._collapsable && (g = e.g.o[2 * v + 1]), u.addColorStop(m[4 * v] / 100, "rgba(" + m[4 * v + 1] + "," + m[4 * v + 2] + "," + m[4 * v + 3] + "," + g + ")");
                    n.grd = u
                }
                n.coOp = e.o.v * i.opacity
            }, CVShapeElement.prototype.renderStroke = function(t, e, i) {
                var n = e.style,
                    r = e.d;
                r && (r._mdf || this._isFirstFrame) && (n.da = r.dashArray, n.do = r.dashoffset[0]), (e.c._mdf || this._isFirstFrame) && (n.co = "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || i._opMdf || this._isFirstFrame) && (n.coOp = e.o.v * i.opacity), (e.w._mdf || this._isFirstFrame) && (n.wi = e.w.v)
            }, CVShapeElement.prototype.destroy = function() {
                this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0
            }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function() {
                var t = this.canvasContext;
                t.fillStyle = this.data.sc, t.fillRect(0, 0, this.data.sw, this.data.sh)
            }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function() {
                var t = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(t.l ? t.l.length : 0);
                var e = !1;
                t.fc ? (e = !0, this.values.fill = this.buildColor(t.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = e;
                var i = !1;
                t.sc && (i = !0, this.values.stroke = this.buildColor(t.sc), this.values.sWidth = t.sw);
                var n, r, a, s, o, l, h, u, c, p, d, f = this.globalData.fontManager.getFontByName(t.f),
                    m = t.l,
                    g = this.mHelper;
                this.stroke = i, this.values.fValue = t.finalSize + "px " + this.globalData.fontManager.getFontByName(t.f).fFamily, n = t.finalText.length;
                for (var v = this.data.singleShape, y = .001 * t.tr * t.finalSize, b = 0, x = 0, _ = !0, w = 0, S = 0; S < n; S += 1) {
                    for (a = (r = this.globalData.fontManager.getCharData(t.finalText[S], f.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily)) && r.data || {}, g.reset(), v && m[S].n && (b = -y, x += t.yOffset, x += _ ? 1 : 0, _ = !1), u = (l = a.shapes ? a.shapes[0].it : []).length, g.scale(t.finalSize / 100, t.finalSize / 100), v && this.applyTextPropertiesToMatrix(t, g, m[S].line, b, x), p = createSizedArray(u), h = 0; h < u; h += 1) {
                        for (o = l[h].ks.k.i.length, c = l[h].ks.k, d = [], s = 1; s < o; s += 1) 1 === s && d.push(g.applyToX(c.v[0][0], c.v[0][1], 0), g.applyToY(c.v[0][0], c.v[0][1], 0)), d.push(g.applyToX(c.o[s - 1][0], c.o[s - 1][1], 0), g.applyToY(c.o[s - 1][0], c.o[s - 1][1], 0), g.applyToX(c.i[s][0], c.i[s][1], 0), g.applyToY(c.i[s][0], c.i[s][1], 0), g.applyToX(c.v[s][0], c.v[s][1], 0), g.applyToY(c.v[s][0], c.v[s][1], 0));
                        d.push(g.applyToX(c.o[s - 1][0], c.o[s - 1][1], 0), g.applyToY(c.o[s - 1][0], c.o[s - 1][1], 0), g.applyToX(c.i[0][0], c.i[0][1], 0), g.applyToY(c.i[0][0], c.i[0][1], 0), g.applyToX(c.v[0][0], c.v[0][1], 0), g.applyToY(c.v[0][0], c.v[0][1], 0)), p[h] = d
                    }
                    v && (b += m[S].l, b += y), this.textSpans[w] ? this.textSpans[w].elem = p : this.textSpans[w] = {
                        elem: p
                    }, w += 1
                }
            }, CVTextElement.prototype.renderInnerContent = function() {
                var t, e, i, n, r = this.canvasContext;
                r.font = this.values.fValue, r.lineCap = "butt", r.lineJoin = "miter", r.miterLimit = 4, this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
                for (var a, s, o, l = this.textAnimator.renderedLetters, h = this.textProperty.currentData.l, u = h.length, c = null, p = null, d = null, f = 0; f < u; f += 1)
                    if (!h[f].n) {
                        if ((a = l[f]) && (this.globalData.renderer.save(), this.globalData.renderer.ctxTransform(a.p), this.globalData.renderer.ctxOpacity(a.o)), this.fill) {
                            for (a && a.fc ? c !== a.fc && (c = a.fc, r.fillStyle = a.fc) : c !== this.values.fill && (c = this.values.fill, r.fillStyle = this.values.fill), e = (s = this.textSpans[f].elem).length, this.globalData.canvasContext.beginPath(), t = 0; t < e; t += 1)
                                for (n = (o = s[t]).length, this.globalData.canvasContext.moveTo(o[0], o[1]), i = 2; i < n; i += 6) this.globalData.canvasContext.bezierCurveTo(o[i], o[i + 1], o[i + 2], o[i + 3], o[i + 4], o[i + 5]);
                            this.globalData.canvasContext.closePath(), this.globalData.canvasContext.fill()
                        }
                        if (this.stroke) {
                            for (a && a.sw ? d !== a.sw && (d = a.sw, r.lineWidth = a.sw) : d !== this.values.sWidth && (d = this.values.sWidth, r.lineWidth = this.values.sWidth), a && a.sc ? p !== a.sc && (p = a.sc, r.strokeStyle = a.sc) : p !== this.values.stroke && (p = this.values.stroke, r.strokeStyle = this.values.stroke), e = (s = this.textSpans[f].elem).length, this.globalData.canvasContext.beginPath(), t = 0; t < e; t += 1)
                                for (n = (o = s[t]).length, this.globalData.canvasContext.moveTo(o[0], o[1]), i = 2; i < n; i += 6) this.globalData.canvasContext.bezierCurveTo(o[i], o[i + 1], o[i + 2], o[i + 3], o[i + 4], o[i + 5]);
                            this.globalData.canvasContext.closePath(), this.globalData.canvasContext.stroke()
                        }
                        a && this.globalData.renderer.restore()
                    }
            }, CVEffects.prototype.renderFrame = function() {}, HBaseElement.prototype = {
                checkBlendMode: function() {},
                initRendererElement: function() {
                    this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement)
                },
                createContainerElements: function() {
                    this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 !== this.data.bm && this.setBlendMode()
                },
                renderElement: function() {
                    var t, e = this.transformedElement ? this.transformedElement.style : {};
                    this.finalTransform._matMdf && (t = this.finalTransform.mat.toCSS(), e.transform = t, e.webkitTransform = t), this.finalTransform._opMdf && (e.opacity = this.finalTransform.mProp.o.v)
                },
                renderFrame: function() {
                    this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                },
                destroy: function() {
                    this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null)
                },
                createRenderableComponents: function() {
                    this.maskManager = new MaskElement(this.data, this, this.globalData)
                },
                addEffects: function() {},
                setMatte: function() {}
            }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function() {
                var t;
                this.data.hasMask ? ((t = createNS("rect")).setAttribute("width", this.data.sw), t.setAttribute("height", this.data.sh), t.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : ((t = createTag("div")).style.width = this.data.sw + "px", t.style.height = this.data.sh + "px", t.style.backgroundColor = this.data.sc), this.layerElement.appendChild(t)
            }, extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function() {
                this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
            }, HCompElement.prototype.addTo3dContainer = function(t, e) {
                for (var i, n = 0; n < e;) this.elements[n] && this.elements[n].getBaseElement && (i = this.elements[n].getBaseElement()), n += 1;
                i ? this.layerElement.insertBefore(t, i) : this.layerElement.appendChild(t)
            }, extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function() {
                var t, e;
                this.baseElement.style.fontSize = 0, this.data.hasMask ? (this.layerElement.appendChild(this.shapesContainer), t = this.svgElement) : (t = createNS("svg"), e = this.comp.data ? this.comp.data : this.globalData.compSize, t.setAttribute("width", e.w), t.setAttribute("height", e.h), t.appendChild(this.shapesContainer), this.layerElement.appendChild(t)), this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = t
            }, HShapeElement.prototype.getTransformedPoint = function(t, e) {
                for (var i = t.length, n = 0; n < i; n += 1) e = t[n].mProps.v.applyToPointArray(e[0], e[1], 0);
                return e
            }, HShapeElement.prototype.calculateShapeBoundingBox = function(t, e) {
                var i, n, r, a, s, o = t.sh.v,
                    l = t.transformers,
                    h = o._length;
                if (!(h <= 1)) {
                    for (i = 0; i < h - 1; i += 1) n = this.getTransformedPoint(l, o.v[i]), r = this.getTransformedPoint(l, o.o[i]), a = this.getTransformedPoint(l, o.i[i + 1]), s = this.getTransformedPoint(l, o.v[i + 1]), this.checkBounds(n, r, a, s, e);
                    o.c && (n = this.getTransformedPoint(l, o.v[i]), r = this.getTransformedPoint(l, o.o[i]), a = this.getTransformedPoint(l, o.i[0]), s = this.getTransformedPoint(l, o.v[0]), this.checkBounds(n, r, a, s, e))
                }
            }, HShapeElement.prototype.checkBounds = function(t, e, i, n, r) {
                this.getBoundsOfCurve(t, e, i, n);
                var a = this.shapeBoundingBox;
                r.x = bmMin(a.left, r.x), r.xMax = bmMax(a.right, r.xMax), r.y = bmMin(a.top, r.y), r.yMax = bmMax(a.bottom, r.yMax)
            }, HShapeElement.prototype.shapeBoundingBox = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, HShapeElement.prototype.tempBoundingBox = {
                x: 0,
                xMax: 0,
                y: 0,
                yMax: 0,
                width: 0,
                height: 0
            }, HShapeElement.prototype.getBoundsOfCurve = function(t, e, i, n) {
                for (var r, a, s, o, l, h, u, c = [
                        [t[0], n[0]],
                        [t[1], n[1]]
                    ], p = 0; p < 2; ++p) a = 6 * t[p] - 12 * e[p] + 6 * i[p], r = -3 * t[p] + 9 * e[p] - 9 * i[p] + 3 * n[p], s = 3 * e[p] - 3 * t[p], a |= 0, s |= 0, 0 == (r |= 0) && 0 == a || (0 == r ? 0 < (o = -s / a) && o < 1 && c[p].push(this.calculateF(o, t, e, i, n, p)) : 0 <= (l = a * a - 4 * s * r) && (0 < (h = (-a + bmSqrt(l)) / (2 * r)) && h < 1 && c[p].push(this.calculateF(h, t, e, i, n, p)), 0 < (u = (-a - bmSqrt(l)) / (2 * r)) && u < 1 && c[p].push(this.calculateF(u, t, e, i, n, p))));
                this.shapeBoundingBox.left = bmMin.apply(null, c[0]), this.shapeBoundingBox.top = bmMin.apply(null, c[1]), this.shapeBoundingBox.right = bmMax.apply(null, c[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, c[1])
            }, HShapeElement.prototype.calculateF = function(t, e, i, n, r, a) {
                return bmPow(1 - t, 3) * e[a] + 3 * bmPow(1 - t, 2) * t * i[a] + 3 * (1 - t) * bmPow(t, 2) * n[a] + bmPow(t, 3) * r[a]
            }, HShapeElement.prototype.calculateBoundingBox = function(t, e) {
                for (var i = t.length, n = 0; n < i; n += 1) t[n] && t[n].sh ? this.calculateShapeBoundingBox(t[n], e) : t[n] && t[n].it && this.calculateBoundingBox(t[n].it, e)
            }, HShapeElement.prototype.currentBoxContains = function(t) {
                return this.currentBBox.x <= t.x && this.currentBBox.y <= t.y && this.currentBBox.width + this.currentBBox.x >= t.x + t.width && this.currentBBox.height + this.currentBBox.y >= t.y + t.height
            }, HShapeElement.prototype.renderInnerContent = function() {
                if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
                    var t = this.tempBoundingBox,
                        e = 999999;
                    if (t.x = e, t.xMax = -e, t.y = e, t.yMax = -e, this.calculateBoundingBox(this.itemsData, t), t.width = t.xMax < t.x ? 0 : t.xMax - t.x, t.height = t.yMax < t.y ? 0 : t.yMax - t.y, this.currentBoxContains(t)) return;
                    var i, n, r = !1;
                    this.currentBBox.w !== t.width && (this.currentBBox.w = t.width, this.shapeCont.setAttribute("width", t.width), r = !0), this.currentBBox.h !== t.height && (this.currentBBox.h = t.height, this.shapeCont.setAttribute("height", t.height), r = !0), !r && this.currentBBox.x === t.x && this.currentBBox.y === t.y || (this.currentBBox.w = t.width, this.currentBBox.h = t.height, this.currentBBox.x = t.x, this.currentBBox.y = t.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), i = this.shapeCont.style, n = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)", i.transform = n, i.webkitTransform = n)
                }
            }, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function() {
                var t;
                this.isMasked = this.checkMasks(), this.isMasked ? (this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH), t = createNS("g"), this.maskedElement.appendChild(t), this.innerElem = t) : (this.renderType = "html", this.innerElem = this.layerElement), this.checkParenting()
            }, HTextElement.prototype.buildNewText = function() {
                var t = this.textProperty.currentData;
                this.renderedLetters = createSizedArray(t.l ? t.l.length : 0);
                var e = this.innerElem.style,
                    i = t.fc ? this.buildColor(t.fc) : "rgba(0,0,0,0)";
                e.fill = i, e.color = i, t.sc && (e.stroke = this.buildColor(t.sc), e.strokeWidth = t.sw + "px");
                var n, r, a = this.globalData.fontManager.getFontByName(t.f);
                this.globalData.fontManager.chars || (e.fontSize = t.finalSize + "px", e.lineHeight = t.finalSize + "px", a.fClass ? this.innerElem.className = a.fClass : (e.fontFamily = a.fFamily, n = t.fWeight, r = t.fStyle, e.fontStyle = r, e.fontWeight = n));
                for (var s, o, l, h, u, c, p, d, f, m, g, v = t.l, y = v.length, b = this.mHelper, x = "", _ = 0, w = 0; w < y; w += 1) {
                    this.globalData.fontManager.chars ? (this.textPaths[_] ? s = this.textPaths[_] : ((s = createNS("path")).setAttribute("stroke-linecap", lineCapEnum[1]), s.setAttribute("stroke-linejoin", lineJoinEnum[2]), s.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[_] ? l = (o = this.textSpans[_]).children[0] : ((o = createTag("div")).style.lineHeight = 0, (l = createNS("svg")).appendChild(s), styleDiv(o)))) : this.isMasked ? s = this.textPaths[_] ? this.textPaths[_] : createNS("text") : this.textSpans[_] ? (o = this.textSpans[_], s = this.textPaths[_]) : (styleDiv(o = createTag("span")), styleDiv(s = createTag("span")), o.appendChild(s)), this.globalData.fontManager.chars ? (f = (u = this.globalData.fontManager.getCharData(t.finalText[w], a.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily)) ? u.data : null, b.reset(), f && f.shapes && (h = f.shapes[0].it, b.scale(t.finalSize / 100, t.finalSize / 100), x = this.createPathShape(b, h), s.setAttribute("d", x)), this.isMasked ? this.innerElem.appendChild(s) : (this.innerElem.appendChild(o), f && f.shapes ? (document.body.appendChild(l), c = l.getBBox(), l.setAttribute("width", c.width + 2), l.setAttribute("height", c.height + 2), l.setAttribute("viewBox", c.x - 1 + " " + (c.y - 1) + " " + (c.width + 2) + " " + (c.height + 2)), p = l.style, d = "translate(" + (c.x - 1) + "px," + (c.y - 1) + "px)", p.transform = d, p.webkitTransform = d, v[w].yOffset = c.y - 1) : (l.setAttribute("width", 1), l.setAttribute("height", 1)), o.appendChild(l))) : (s.textContent = v[w].val, s.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked ? this.innerElem.appendChild(s) : (this.innerElem.appendChild(o), m = s.style, g = "translate3d(0," + -t.finalSize / 1.2 + "px,0)", m.transform = g, m.webkitTransform = g)), this.isMasked ? this.textSpans[_] = s : this.textSpans[_] = o, this.textSpans[_].style.display = "block", this.textPaths[_] = s, _ += 1
                }
                for (; _ < this.textSpans.length;) this.textSpans[_].style.display = "none", _ += 1
            }, HTextElement.prototype.renderInnerContent = function() {
                var t, e;
                if (this.data.singleShape) {
                    if (!this._isFirstFrame && !this.lettersChangedFlag) return;
                    this.isMasked && this.finalTransform._matMdf && (this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), t = this.svgElement.style, e = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)", t.transform = e, t.webkitTransform = e)
                }
                if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                    for (var i, n, r, a, s, o = 0, l = this.textAnimator.renderedLetters, h = this.textProperty.currentData.l, u = h.length, c = 0; c < u; c += 1) h[c].n ? o += 1 : (n = this.textSpans[c], r = this.textPaths[c], i = l[o], o += 1, i._mdf.m && (this.isMasked ? n.setAttribute("transform", i.m) : (n.style.webkitTransform = i.m, n.style.transform = i.m)), n.style.opacity = i.o, i.sw && i._mdf.sw && r.setAttribute("stroke-width", i.sw), i.sc && i._mdf.sc && r.setAttribute("stroke", i.sc), i.fc && i._mdf.fc && (r.setAttribute("fill", i.fc), r.style.color = i.fc));
                    this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf) && (a = this.innerElem.getBBox(), this.currentBBox.w !== a.width && (this.currentBBox.w = a.width, this.svgElement.setAttribute("width", a.width)), this.currentBBox.h !== a.height && (this.currentBBox.h = a.height, this.svgElement.setAttribute("height", a.height)), this.currentBBox.w === a.width + 2 && this.currentBBox.h === a.height + 2 && this.currentBBox.x === a.x - 1 && this.currentBBox.y === a.y - 1 || (this.currentBBox.w = a.width + 2, this.currentBBox.h = a.height + 2, this.currentBBox.x = a.x - 1, this.currentBBox.y = a.y - 1, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), t = this.svgElement.style, s = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)", t.transform = s, t.webkitTransform = s))
                }
            }, extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function() {
                var t = this.globalData.getAssetsPath(this.assetData),
                    e = new Image;
                this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(e), e.crossOrigin = "anonymous", e.src = t, this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
            }, extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function() {
                for (var t, e, i, n, r, a, s = this.comp.threeDElements.length, o = 0; o < s; o += 1) {
                    "3d" === (a = this.comp.threeDElements[o]).type && (t = a.perspectiveElem.style, e = a.container.style, i = this.pe.v + "px", n = "0px 0px 0px", r = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)", t.perspective = i, t.webkitPerspective = i, e.transformOrigin = n, e.mozTransformOrigin = n, e.webkitTransformOrigin = n, t.transform = r, t.webkitTransform = r)
                }
            }, HCameraElement.prototype.createElements = function() {}, HCameraElement.prototype.hide = function() {}, HCameraElement.prototype.renderFrame = function() {
                var t, e, i, n, r, a, s = this._isFirstFrame;
                if (this.hierarchy)
                    for (d = this.hierarchy.length, f = 0; f < d; f += 1) s = this.hierarchy[f].finalTransform.mProp._mdf || s;
                if (s || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                    if (this.mat.reset(), this.hierarchy)
                        for (f = d = this.hierarchy.length - 1; 0 <= f; --f) {
                            var o = this.hierarchy[f].finalTransform.mProp;
                            this.mat.translate(-o.p.v[0], -o.p.v[1], o.p.v[2]), this.mat.rotateX(-o.or.v[0]).rotateY(-o.or.v[1]).rotateZ(o.or.v[2]), this.mat.rotateX(-o.rx.v).rotateY(-o.ry.v).rotateZ(o.rz.v), this.mat.scale(1 / o.s.v[0], 1 / o.s.v[1], 1 / o.s.v[2]), this.mat.translate(o.a.v[0], o.a.v[1], o.a.v[2])
                        }
                    this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a && (t = this.p ? [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]], e = Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2)), i = [t[0] / e, t[1] / e, t[2] / e], n = Math.sqrt(i[2] * i[2] + i[0] * i[0]), r = Math.atan2(i[1], n), a = Math.atan2(i[0], -i[2]), this.mat.rotateY(a).rotateX(-r)), this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
                    var l = !this._prevMat.equals(this.mat);
                    if ((l || this.pe._mdf) && this.comp.threeDElements) {
                        for (var h, u, c, p, d = this.comp.threeDElements.length, f = 0; f < d; f += 1) {
                            "3d" === (p = this.comp.threeDElements[f]).type && (l && (u = this.mat.toCSS(), (c = p.container.style).transform = u, c.webkitTransform = u), this.pe._mdf && ((h = p.perspectiveElem.style).perspective = this.pe.v + "px", h.webkitPerspective = this.pe.v + "px"))
                        }
                        this.mat.clone(this._prevMat)
                    }
                }
                this._isFirstFrame = !1
            }, HCameraElement.prototype.prepareFrame = function(t) {
                this.prepareProperties(t, !0)
            }, HCameraElement.prototype.destroy = function() {}, HCameraElement.prototype.getBaseElement = function() {
                return null
            }, HEffects.prototype.renderFrame = function() {};
            var animationManager = (I_e = {}, J_e = [], K_e = 0, L_e = 0, M_e = 0, N_e = !0, O_e = !1, I_e.registerAnimation = Q_e, I_e.loadAnimation = function(t) {
                    var e = new AnimationItem;
                    return U_e(e, null), e.setParams(t), e
                }, I_e.setSpeed = function(t, e) {
                    for (var i = 0; i < L_e; i += 1) J_e[i].animation.setSpeed(t, e)
                }, I_e.setDirection = function(t, e) {
                    for (var i = 0; i < L_e; i += 1) J_e[i].animation.setDirection(t, e)
                }, I_e.play = function(t) {
                    for (var e = 0; e < L_e; e += 1) J_e[e].animation.play(t)
                }, I_e.pause = function(t) {
                    for (var e = 0; e < L_e; e += 1) J_e[e].animation.pause(t)
                }, I_e.stop = function(t) {
                    for (var e = 0; e < L_e; e += 1) J_e[e].animation.stop(t)
                }, I_e.togglePause = function(t) {
                    for (var e = 0; e < L_e; e += 1) J_e[e].animation.togglePause(t)
                }, I_e.searchAnimations = function(t, e, i) {
                    for (var n, r, a = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), s = a.length, o = 0; o < s; o += 1) i && a[o].setAttribute("data-bm-type", i), Q_e(a[o], t);
                    e && 0 === s && (i = i || "svg", (n = document.getElementsByTagName("body")[0]).innerText = "", (r = createTag("div")).style.width = "100%", r.style.height = "100%", r.setAttribute("data-bm-type", i), n.appendChild(r), Q_e(r, t))
                }, I_e.resize = function() {
                    for (var t = 0; t < L_e; t += 1) J_e[t].animation.resize()
                }, I_e.goToAndStop = function(t, e, i) {
                    for (var n = 0; n < L_e; n += 1) J_e[n].animation.goToAndStop(t, e, i)
                }, I_e.destroy = function(t) {
                    for (var e = L_e - 1; 0 <= e; --e) J_e[e].animation.destroy(t)
                }, I_e.freeze = function() {
                    O_e = !0
                }, I_e.unfreeze = function() {
                    O_e = !1, g0e()
                }, I_e.setVolume = function(t, e) {
                    for (var i = 0; i < L_e; i += 1) J_e[i].animation.setVolume(t, e)
                }, I_e.mute = function(t) {
                    for (var e = 0; e < L_e; e += 1) J_e[e].animation.mute(t)
                }, I_e.unmute = function(t) {
                    for (var e = 0; e < L_e; e += 1) J_e[e].animation.unmute(t)
                }, I_e.getRegisteredAnimations = function() {
                    for (var t = J_e.length, e = [], i = 0; i < t; i += 1) e.push(J_e[i].animation);
                    return e
                }, I_e),
                I_e, J_e, K_e, L_e, M_e, N_e, O_e;

            function P_e(t) {
                for (var e = 0, i = t.target; e < L_e;) J_e[e].animation === i && (J_e.splice(e, 1), --e, --L_e, i.isPaused || T_e()), e += 1
            }

            function Q_e(t, e) {
                if (!t) return null;
                for (var i = 0; i < L_e;) {
                    if (J_e[i].elem === t && null !== J_e[i].elem) return J_e[i].animation;
                    i += 1
                }
                var n = new AnimationItem;
                return U_e(n, t), n.setData(t, e), n
            }

            function S_e() {
                M_e += 1, g0e()
            }

            function T_e() {
                --M_e
            }

            function U_e(t, e) {
                t.addEventListener("destroy", P_e), t.addEventListener("_active", S_e), t.addEventListener("_idle", T_e), J_e.push({
                    elem: e,
                    animation: t
                }), L_e += 1
            }

            function Z_e(t) {
                for (var e = t - K_e, i = 0; i < L_e; i += 1) J_e[i].animation.advanceTime(e);
                K_e = t, M_e && !O_e ? window.requestAnimationFrame(Z_e) : N_e = !0
            }

            function $_e(t) {
                K_e = t, window.requestAnimationFrame(Z_e)
            }

            function g0e() {
                !O_e && M_e && N_e && (window.requestAnimationFrame($_e), N_e = !1)
            }
            var AnimationItem = function() {
                this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = subframeEnabled, this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory(), this.markers = []
            };
            extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function(t) {
                (t.wrapper || t.container) && (this.wrapper = t.wrapper || t.container);
                var e = "svg";
                switch (t.animType ? e = t.animType : t.renderer && (e = t.renderer), e) {
                    case "canvas":
                        this.renderer = new CanvasRenderer(this, t.rendererSettings);
                        break;
                    case "svg":
                        this.renderer = new SVGRenderer(this, t.rendererSettings);
                        break;
                    default:
                        this.renderer = new HybridRenderer(this, t.rendererSettings)
                }
                this.imagePreloader.setCacheType(e, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = e, "" === t.loop || null === t.loop || void 0 === t.loop || !0 === t.loop ? this.loop = !0 : !1 === t.loop ? this.loop = !1 : this.loop = parseInt(t.loop, 10), this.autoplay = !("autoplay" in t) || t.autoplay, this.name = t.name ? t.name : "", this.autoloadSegments = !Object.prototype.hasOwnProperty.call(t, "autoloadSegments") || t.autoloadSegments, this.assetsPath = t.assetsPath, this.initialSegment = t.initialSegment, t.audioFactory && this.audioController.setAudioFactory(t.audioFactory), t.animationData ? this.configAnimation(t.animationData) : t.path && (-1 !== t.path.lastIndexOf("\\") ? this.path = t.path.substr(0, t.path.lastIndexOf("\\") + 1) : this.path = t.path.substr(0, t.path.lastIndexOf("/") + 1), this.fileName = t.path.substr(t.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), assetLoader.load(t.path, this.configAnimation.bind(this), function() {
                    this.trigger("data_failed")
                }.bind(this)))
            }, AnimationItem.prototype.setData = function(t, e) {
                e && "object" !== _typeof(e) && (e = JSON.parse(e));
                var i = {
                        wrapper: t,
                        animationData: e
                    },
                    n = t.attributes;
                i.path = n.getNamedItem("data-animation-path") ? n.getNamedItem("data-animation-path").value : n.getNamedItem("data-bm-path") ? n.getNamedItem("data-bm-path").value : n.getNamedItem("bm-path") ? n.getNamedItem("bm-path").value : "", i.animType = n.getNamedItem("data-anim-type") ? n.getNamedItem("data-anim-type").value : n.getNamedItem("data-bm-type") ? n.getNamedItem("data-bm-type").value : n.getNamedItem("bm-type") ? n.getNamedItem("bm-type").value : n.getNamedItem("data-bm-renderer") ? n.getNamedItem("data-bm-renderer").value : n.getNamedItem("bm-renderer") ? n.getNamedItem("bm-renderer").value : "canvas";
                var r = n.getNamedItem("data-anim-loop") ? n.getNamedItem("data-anim-loop").value : n.getNamedItem("data-bm-loop") ? n.getNamedItem("data-bm-loop").value : n.getNamedItem("bm-loop") ? n.getNamedItem("bm-loop").value : "";
                "false" === r ? i.loop = !1 : "true" === r ? i.loop = !0 : "" !== r && (i.loop = parseInt(r, 10));
                var a = n.getNamedItem("data-anim-autoplay") ? n.getNamedItem("data-anim-autoplay").value : n.getNamedItem("data-bm-autoplay") ? n.getNamedItem("data-bm-autoplay").value : !n.getNamedItem("bm-autoplay") || n.getNamedItem("bm-autoplay").value;
                i.autoplay = "false" !== a, i.name = n.getNamedItem("data-name") ? n.getNamedItem("data-name").value : n.getNamedItem("data-bm-name") ? n.getNamedItem("data-bm-name").value : n.getNamedItem("bm-name") ? n.getNamedItem("bm-name").value : "", "false" === (n.getNamedItem("data-anim-prerender") ? n.getNamedItem("data-anim-prerender").value : n.getNamedItem("data-bm-prerender") ? n.getNamedItem("data-bm-prerender").value : n.getNamedItem("bm-prerender") ? n.getNamedItem("bm-prerender").value : "") && (i.prerender = !1), this.setParams(i)
            }, AnimationItem.prototype.includeLayers = function(t) {
                t.op > this.animationData.op && (this.animationData.op = t.op, this.totalFrames = Math.floor(t.op - this.animationData.ip));
                for (var e, i = this.animationData.layers, n = i.length, r = t.layers, a = r.length, s = 0; s < a; s += 1)
                    for (e = 0; e < n;) {
                        if (i[e].id === r[s].id) {
                            i[e] = r[s];
                            break
                        }
                        e += 1
                    }
                if ((t.chars || t.fonts) && (this.renderer.globalData.fontManager.addChars(t.chars), this.renderer.globalData.fontManager.addFonts(t.fonts, this.renderer.globalData.defs)), t.assets)
                    for (n = t.assets.length, e = 0; e < n; e += 1) this.animationData.assets.push(t.assets[e]);
                this.animationData.__complete = !1, dataManager.completeData(this.animationData, this.renderer.globalData.fontManager), this.renderer.includeLayers(t.layers), expressionsPlugin && expressionsPlugin.initExpressions(this), this.loadNextSegment()
            }, AnimationItem.prototype.loadNextSegment = function() {
                var t = this.animationData.segments;
                if (!t || 0 === t.length || !this.autoloadSegments) return this.trigger("data_ready"), void(this.timeCompleted = this.totalFrames);
                var e = t.shift();
                this.timeCompleted = e.time * this.frameRate;
                var i = this.path + this.fileName + "_" + this.segmentPos + ".json";
                this.segmentPos += 1, assetLoader.load(i, this.includeLayers.bind(this), function() {
                    this.trigger("data_failed")
                }.bind(this))
            }, AnimationItem.prototype.loadSegments = function() {
                this.animationData.segments || (this.timeCompleted = this.totalFrames), this.loadNextSegment()
            }, AnimationItem.prototype.imagesLoaded = function() {
                this.trigger("loaded_images"), this.checkLoaded()
            }, AnimationItem.prototype.preloadImages = function() {
                this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
            }, AnimationItem.prototype.configAnimation = function(t) {
                if (this.renderer) try {
                    this.animationData = t, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(t), t.assets || (t.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(t.assets), this.markers = markerParser(t.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause()
                } catch (t) {
                    this.triggerConfigError(t)
                }
            }, AnimationItem.prototype.waitForFontsLoaded = function() {
                this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
            }, AnimationItem.prototype.checkLoaded = function() {
                !this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || "canvas" !== this.renderer.rendererType) && this.imagePreloader.loadedFootages() && (this.isLoaded = !0, dataManager.completeData(this.animationData, this.renderer.globalData.fontManager), expressionsPlugin && expressionsPlugin.initExpressions(this), this.renderer.initItems(), setTimeout(function() {
                    this.trigger("DOMLoaded")
                }.bind(this), 0), this.gotoFrame(), this.autoplay && this.play())
            }, AnimationItem.prototype.resize = function() {
                this.renderer.updateContainerSize()
            }, AnimationItem.prototype.setSubframe = function(t) {
                this.isSubframeEnabled = !!t
            }, AnimationItem.prototype.gotoFrame = function() {
                this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame()
            }, AnimationItem.prototype.renderFrame = function() {
                if (!1 !== this.isLoaded && this.renderer) try {
                    this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                } catch (t) {
                    this.triggerRenderFrameError(t)
                }
            }, AnimationItem.prototype.play = function(t) {
                t && this.name !== t || !0 === this.isPaused && (this.isPaused = !1, this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active")))
            }, AnimationItem.prototype.pause = function(t) {
                t && this.name !== t || !1 === this.isPaused && (this.isPaused = !0, this._idle = !0, this.trigger("_idle"), this.audioController.pause())
            }, AnimationItem.prototype.togglePause = function(t) {
                t && this.name !== t || (!0 === this.isPaused ? this.play() : this.pause())
            }, AnimationItem.prototype.stop = function(t) {
                t && this.name !== t || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0))
            }, AnimationItem.prototype.getMarkerData = function(t) {
                for (var e, i = 0; i < this.markers.length; i += 1)
                    if ((e = this.markers[i]).payload && e.payload.name === t) return e;
                return null
            }, AnimationItem.prototype.goToAndStop = function(t, e, i) {
                var n, r;
                i && this.name !== i || (n = Number(t), isNaN(n) ? (r = this.getMarkerData(t)) && this.goToAndStop(r.time, !0) : e ? this.setCurrentRawFrameValue(t) : this.setCurrentRawFrameValue(t * this.frameModifier), this.pause())
            }, AnimationItem.prototype.goToAndPlay = function(t, e, i) {
                var n, r;
                i && this.name !== i || (n = Number(t), isNaN(n) ? (r = this.getMarkerData(t)) && (r.duration ? this.playSegments([r.time, r.time + r.duration], !0) : this.goToAndStop(r.time, !0)) : this.goToAndStop(n, e, i), this.play())
            }, AnimationItem.prototype.advanceTime = function(t) {
                var e, i;
                !0 !== this.isPaused && !1 !== this.isLoaded && (i = !1, (e = this.currentRawFrame + t * this.frameModifier) >= this.totalFrames - 1 && 0 < this.frameModifier ? this.loop && this.playCount !== this.loop ? e >= this.totalFrames ? (this.playCount += 1, this.checkSegments(e % this.totalFrames) || (this.setCurrentRawFrameValue(e % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(e) : this.checkSegments(e > this.totalFrames ? e % this.totalFrames : 0) || (i = !0, e = this.totalFrames - 1) : e < 0 ? this.checkSegments(e % this.totalFrames) || (!this.loop || this.playCount-- <= 0 && !0 !== this.loop ? (i = !0, e = 0) : (this.setCurrentRawFrameValue(this.totalFrames + e % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0)) : this.setCurrentRawFrameValue(e), i && (this.setCurrentRawFrameValue(e), this.pause(), this.trigger("complete")))
            }, AnimationItem.prototype.adjustSegment = function(t, e) {
                this.playCount = 0, t[1] < t[0] ? (0 < this.frameModifier && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = t[0] - t[1], this.timeCompleted = this.totalFrames, this.firstFrame = t[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - e)) : t[1] > t[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = t[1] - t[0], this.timeCompleted = this.totalFrames, this.firstFrame = t[0], this.setCurrentRawFrameValue(.001 + e)), this.trigger("segmentStart")
            }, AnimationItem.prototype.setSegment = function(t, e) {
                var i = -1;
                this.isPaused && (this.currentRawFrame + this.firstFrame < t ? i = t : this.currentRawFrame + this.firstFrame > e && (i = e - t)), this.firstFrame = t, this.totalFrames = e - t, this.timeCompleted = this.totalFrames, -1 !== i && this.goToAndStop(i, !0)
            }, AnimationItem.prototype.playSegments = function(t, e) {
                if (e && (this.segments.length = 0), "object" === _typeof(t[0]))
                    for (var i = t.length, n = 0; n < i; n += 1) this.segments.push(t[n]);
                else this.segments.push(t);
                this.segments.length && e && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play()
            }, AnimationItem.prototype.resetSegments = function(t) {
                this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), t && this.checkSegments(0)
            }, AnimationItem.prototype.checkSegments = function(t) {
                return !!this.segments.length && (this.adjustSegment(this.segments.shift(), t), !0)
            }, AnimationItem.prototype.destroy = function(t) {
                t && this.name !== t || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.renderer = null, this.imagePreloader = null, this.projectInterface = null)
            }, AnimationItem.prototype.setCurrentRawFrameValue = function(t) {
                this.currentRawFrame = t, this.gotoFrame()
            }, AnimationItem.prototype.setSpeed = function(t) {
                this.playSpeed = t, this.updaFrameModifier()
            }, AnimationItem.prototype.setDirection = function(t) {
                this.playDirection = t < 0 ? -1 : 1, this.updaFrameModifier()
            }, AnimationItem.prototype.setVolume = function(t, e) {
                e && this.name !== e || this.audioController.setVolume(t)
            }, AnimationItem.prototype.getVolume = function() {
                return this.audioController.getVolume()
            }, AnimationItem.prototype.mute = function(t) {
                t && this.name !== t || this.audioController.mute()
            }, AnimationItem.prototype.unmute = function(t) {
                t && this.name !== t || this.audioController.unmute()
            }, AnimationItem.prototype.updaFrameModifier = function() {
                this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection)
            }, AnimationItem.prototype.getPath = function() {
                return this.path
            }, AnimationItem.prototype.getAssetsPath = function(t) {
                var e, i = "";
                return t.e ? i = t.p : this.assetsPath ? (-1 !== (e = t.p).indexOf("images/") && (e = e.split("/")[1]), i = this.assetsPath + e) : (i = this.path, i += t.u ? t.u : "", i += t.p), i
            }, AnimationItem.prototype.getAssetData = function(t) {
                for (var e = 0, i = this.assets.length; e < i;) {
                    if (t === this.assets[e].id) return this.assets[e];
                    e += 1
                }
                return null
            }, AnimationItem.prototype.hide = function() {
                this.renderer.hide()
            }, AnimationItem.prototype.show = function() {
                this.renderer.show()
            }, AnimationItem.prototype.getDuration = function(t) {
                return t ? this.totalFrames : this.totalFrames / this.frameRate
            }, AnimationItem.prototype.trigger = function(t) {
                if (this._cbs && this._cbs[t]) switch (t) {
                    case "enterFrame":
                        this.triggerEvent(t, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameModifier));
                        break;
                    case "loopComplete":
                        this.triggerEvent(t, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult));
                        break;
                    case "complete":
                        this.triggerEvent(t, new BMCompleteEvent(t, this.frameMult));
                        break;
                    case "segmentStart":
                        this.triggerEvent(t, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames));
                        break;
                    case "destroy":
                        this.triggerEvent(t, new BMDestroyEvent(t, this));
                        break;
                    default:
                        this.triggerEvent(t)
                }
                "enterFrame" === t && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameMult)), "loopComplete" === t && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult)), "complete" === t && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(t, this.frameMult)), "segmentStart" === t && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames)), "destroy" === t && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(t, this))
            }, AnimationItem.prototype.triggerRenderFrameError = function(t) {
                var e = new BMRenderFrameErrorEvent(t, this.currentFrame);
                this.triggerEvent("error", e), this.onError && this.onError.call(this, e)
            }, AnimationItem.prototype.triggerConfigError = function(t) {
                var e = new BMConfigErrorEvent(t, this.currentFrame);
                this.triggerEvent("error", e), this.onError && this.onError.call(this, e)
            };
            var Expressions = (I2e = {}, I2e.initExpressions = function(t) {
                    var e = 0,
                        i = [];
                    t.renderer.compInterface = CompExpressionInterface(t.renderer), t.renderer.globalData.projectInterface.registerComposition(t.renderer), t.renderer.globalData.pushExpression = function() {
                        e += 1
                    }, t.renderer.globalData.popExpression = function() {
                        0 == --e && function() {
                            var t, e = i.length;
                            for (t = 0; t < e; t += 1) i[t].release();
                            i.length = 0
                        }()
                    }, t.renderer.globalData.registerExpressionProperty = function(t) {
                        -1 === i.indexOf(t) && i.push(t)
                    }
                }, I2e),
                I2e, expressionsPlugin = Expressions,
                ExpressionManager = function() {
                    var ob = {},
                        Math = BMMath,
                        window = null,
                        document = null,
                        XMLHttpRequest = null,
                        fetch = null;

                    function $bm_isInstanceOfArray(t) {
                        return t.constructor === Array || t.constructor === Float32Array
                    }

                    function isNumerable(t, e) {
                        return "number" === t || "boolean" === t || "string" === t || e instanceof Number
                    }

                    function $bm_neg(t) {
                        var e = _typeof(t);
                        if ("number" === e || "boolean" === e || t instanceof Number) return -t;
                        if ($bm_isInstanceOfArray(t)) {
                            for (var i = t.length, n = [], r = 0; r < i; r += 1) n[r] = -t[r];
                            return n
                        }
                        return t.propType ? t.v : -t
                    }
                    var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get,
                        easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get,
                        easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;

                    function sum(t, e) {
                        var i = _typeof(t),
                            n = _typeof(e);
                        if ("string" === i || "string" === n) return t + e;
                        if (isNumerable(i, t) && isNumerable(n, e)) return t + e;
                        if ($bm_isInstanceOfArray(t) && isNumerable(n, e)) return (t = t.slice(0))[0] += e, t;
                        if (isNumerable(i, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t + e[0], e;
                        if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) {
                            for (var r = 0, a = t.length, s = e.length, o = []; r < a || r < s;)("number" == typeof t[r] || t[r] instanceof Number) && ("number" == typeof e[r] || e[r] instanceof Number) ? o[r] = t[r] + e[r] : o[r] = void 0 === e[r] ? t[r] : t[r] || e[r], r += 1;
                            return o
                        }
                        return 0
                    }
                    var add = sum;

                    function sub(t, e) {
                        var i = _typeof(t),
                            n = _typeof(e);
                        if (isNumerable(i, t) && isNumerable(n, e)) return "string" === i && (t = parseInt(t, 10)), "string" === n && (e = parseInt(e, 10)), t - e;
                        if ($bm_isInstanceOfArray(t) && isNumerable(n, e)) return (t = t.slice(0))[0] -= e, t;
                        if (isNumerable(i, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t - e[0], e;
                        if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) {
                            for (var r = 0, a = t.length, s = e.length, o = []; r < a || r < s;)("number" == typeof t[r] || t[r] instanceof Number) && ("number" == typeof e[r] || e[r] instanceof Number) ? o[r] = t[r] - e[r] : o[r] = void 0 === e[r] ? t[r] : t[r] || e[r], r += 1;
                            return o
                        }
                        return 0
                    }

                    function mul(t, e) {
                        var i, n, r, a = _typeof(t),
                            s = _typeof(e);
                        if (isNumerable(a, t) && isNumerable(s, e)) return t * e;
                        if ($bm_isInstanceOfArray(t) && isNumerable(s, e)) {
                            for (r = t.length, i = createTypedArray("float32", r), n = 0; n < r; n += 1) i[n] = t[n] * e;
                            return i
                        }
                        if (isNumerable(a, t) && $bm_isInstanceOfArray(e)) {
                            for (r = e.length, i = createTypedArray("float32", r), n = 0; n < r; n += 1) i[n] = t * e[n];
                            return i
                        }
                        return 0
                    }

                    function div(t, e) {
                        var i, n, r, a = _typeof(t),
                            s = _typeof(e);
                        if (isNumerable(a, t) && isNumerable(s, e)) return t / e;
                        if ($bm_isInstanceOfArray(t) && isNumerable(s, e)) {
                            for (r = t.length, i = createTypedArray("float32", r), n = 0; n < r; n += 1) i[n] = t[n] / e;
                            return i
                        }
                        if (isNumerable(a, t) && $bm_isInstanceOfArray(e)) {
                            for (r = e.length, i = createTypedArray("float32", r), n = 0; n < r; n += 1) i[n] = t / e[n];
                            return i
                        }
                        return 0
                    }

                    function mod(t, e) {
                        return "string" == typeof t && (t = parseInt(t, 10)), "string" == typeof e && (e = parseInt(e, 10)), t % e
                    }
                    var $bm_sum = sum,
                        $bm_sub = sub,
                        $bm_mul = mul,
                        $bm_div = div,
                        $bm_mod = mod;

                    function clamp(t, e, i) {
                        var n;
                        return i < e && (n = i, i = e, e = n), Math.min(Math.max(t, e), i)
                    }

                    function radiansToDegrees(t) {
                        return t / degToRads
                    }
                    var radians_to_degrees = radiansToDegrees;

                    function degreesToRadians(t) {
                        return t * degToRads
                    }
                    var degrees_to_radians = radiansToDegrees,
                        helperLengthArray = [0, 0, 0, 0, 0, 0];

                    function length(t, e) {
                        if ("number" == typeof t || t instanceof Number) return e = e || 0, Math.abs(t - e);
                        e = e || helperLengthArray;
                        for (var i = Math.min(t.length, e.length), n = 0, r = 0; r < i; r += 1) n += Math.pow(e[r] - t[r], 2);
                        return Math.sqrt(n)
                    }

                    function normalize(t) {
                        return div(t, length(t))
                    }

                    function rgbToHsl(t) {
                        var e = t[0],
                            i = t[1],
                            n = t[2],
                            r = Math.max(e, i, n),
                            a = Math.min(e, i, n);
                        if (r === a) 0;
                        else {
                            switch (r) {
                                case e:
                                    0;
                                    break;
                                case i:
                                    0;
                                    break;
                                case n:
                                    0
                            }
                            0
                        }
                        return t[3], 1
                    }

                    function hue2rgb(t, e, i) {
                        return i < 0 && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
                    }

                    function hslToRgb(t) {
                        var e, i, n = t[0],
                            r = t[1],
                            a = t[2];
                        return 0 === r ? 0 : (hue2rgb(i = 2 * a - (e = a < .5 ? a * (1 + r) : a + r - a * r), e, n + 1 / 3), hue2rgb(i, e, n), hue2rgb(i, e, n - 1 / 3)), t[3], 1
                    }

                    function linear(t, e, i, n, r) {
                        var a;
                        if (void 0 !== n && void 0 !== r || (n = e, r = i, e = 0, i = 1), i < e && (a = i, i = e, e = a), t <= e) return n;
                        if (i <= t) return r;
                        var s = i === e ? 0 : (t - e) / (i - e);
                        if (!n.length) return n + (r - n) * s;
                        for (var o = n.length, l = createTypedArray("float32", o), h = 0; h < o; h += 1) l[h] = n[h] + (r[h] - n[h]) * s;
                        return l
                    }

                    function random(t, e) {
                        if (void 0 === e && (void 0 === t ? (t = 0, e = 1) : (e = t, t = void 0)), e.length) {
                            var i = e.length;
                            t = t || createTypedArray("float32", i);
                            for (var n = createTypedArray("float32", i), r = BMMath.random(), a = 0; a < i; a += 1) n[a] = t[a] + r * (e[a] - t[a]);
                            return n
                        }
                        return void 0 === t && (t = 0), t + BMMath.random() * (e - t)
                    }

                    function createPath(t, e, i, n) {
                        var r = t.length,
                            a = shapePool.newElement();
                        a.setPathData(!!n, r);
                        for (var s, o, l = [0, 0], h = 0; h < r; h += 1) s = e && e[h] ? e[h] : l, o = i && i[h] ? i[h] : l, a.setTripleAt(t[h][0], t[h][1], o[0] + t[h][0], o[1] + t[h][1], s[0] + t[h][0], s[1] + t[h][1], h, !0);
                        return a
                    }

                    function initiateExpression(elem, data, property) {
                        var val = data.x,
                            needsVelocity = /velocity(?![\w\d])/.test(val),
                            _needsRandom = -1 !== val.indexOf("random"),
                            elemType = elem.data.ty,
                            transform, $bm_transform, content, effect, thisProperty = property;
                        thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
                            get: function() {
                                return thisProperty.v
                            }
                        }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
                        var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
                            outPoint = elem.data.op / elem.comp.globalData.frameRate,
                            width = elem.data.sw ? elem.data.sw : 0,
                            height = elem.data.sh ? elem.data.sh : 0,
                            name = elem.data.nm,
                            loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0],
                            numKeys = property.kf ? data.k.length : 0,
                            active = !this.data || !0 !== this.data.hd,
                            wiggle = function(t, e) {
                                var i = this.pv.length ? this.pv.length : 1,
                                    n = createTypedArray("float32", i);
                                for (var r = Math.floor(5 * time), a = 0, s = 0; a < r;) {
                                    for (s = 0; s < i; s += 1) n[s] += -e + 2 * e * BMMath.random();
                                    a += 1
                                }
                                var o = 5 * time,
                                    l = o - Math.floor(o),
                                    h = createTypedArray("float32", i);
                                if (1 < i) {
                                    for (s = 0; s < i; s += 1) h[s] = this.pv[s] + n[s] + (-e + 2 * e * BMMath.random()) * l;
                                    return h
                                }
                                return this.pv + n[0] + (-e + 2 * e * BMMath.random()) * l
                            }.bind(this);

                        function loopInDuration(t, e) {
                            return loopIn(t, e, !0)
                        }

                        function loopOutDuration(t, e) {
                            return loopOut(t, e, !0)
                        }
                        thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)), this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface),
                            time, velocity, value, text, textIndex, textTotal, selectorValue;

                        function lookAt(t, e) {
                            var i = [e[0] - t[0], e[1] - t[1], e[2] - t[2]];
                            Math.atan2(i[0], Math.sqrt(i[1] * i[1] + i[2] * i[2])), Math.atan2(i[1], i[2]);
                            return 1
                        }

                        function easeOut(t, e, i, n, r) {
                            return applyEase(easeOutBez, t, e, i, n, r)
                        }

                        function easeIn(t, e, i, n, r) {
                            return applyEase(easeInBez, t, e, i, n, r)
                        }

                        function ease(t, e, i, n, r) {
                            return applyEase(easeInOutBez, t, e, i, n, r)
                        }

                        function applyEase(t, e, i, n, r, a) {
                            void 0 === r ? (r = i, a = n) : e = (e - i) / (n - i), 1 < e ? e = 1 : e < 0 && (e = 0);
                            var s = t(e);
                            if ($bm_isInstanceOfArray(r)) {
                                for (var o = r.length, l = createTypedArray("float32", o), h = 0; h < o; h += 1) l[h] = (a[h] - r[h]) * s + r[h];
                                return l
                            }
                            return (a - r) * s + r
                        }

                        function nearestKey(t) {
                            var e, i, n, r = data.k.length;
                            if (data.k.length && "number" != typeof data.k[0])
                                if (i = -1, (t *= elem.comp.globalData.frameRate) < data.k[0].t) i = 1, n = data.k[0].t;
                                else {
                                    for (e = 0; e < r - 1; e += 1) {
                                        if (t === data.k[e].t) {
                                            i = e + 1, n = data.k[e].t;
                                            break
                                        }
                                        if (t > data.k[e].t && t < data.k[e + 1].t) {
                                            n = t - data.k[e].t > data.k[e + 1].t - t ? (i = e + 2, data.k[e + 1].t) : (i = e + 1, data.k[e].t);
                                            break
                                        }
                                    } - 1 === i && (i = e + 1, n = data.k[e].t)
                                }
                            else n = i = 0;
                            var a = {};
                            return a.index = i, a.time = n / elem.comp.globalData.frameRate, a
                        }

                        function key(t) {
                            var e;
                            if (!data.k.length || "number" == typeof data.k[0]) throw new Error("The property has no keyframe at index " + t);
                            --t, e = {
                                time: data.k[t].t / elem.comp.globalData.frameRate,
                                value: []
                            };
                            for (var i = Object.prototype.hasOwnProperty.call(data.k[t], "s") ? data.k[t].s : data.k[t - 1].e, n = i.length, r = 0; r < n; r += 1) e[r] = i[r], e.value[r] = i[r];
                            return e
                        }

                        function framesToTime(t, e) {
                            return t / (e = e || elem.comp.globalData.frameRate)
                        }

                        function timeToFrames(t, e) {
                            return t || 0 === t || (t = time), t * (e = e || elem.comp.globalData.frameRate)
                        }

                        function seedRandom(t) {
                            BMMath.seedrandom(randSeed + t)
                        }

                        function sourceRectAtTime() {
                            return elem.sourceRectAtTime()
                        }

                        function substring(t, e) {
                            return "string" == typeof value && (void 0 === e ? value.substring(t) : value.substring(t, e))
                        }

                        function substr(t, e) {
                            return "string" == typeof value && (void 0 === e ? value.substr(t) : value.substr(t, e))
                        }

                        function posterizeTime(t) {
                            time = 0 === t ? 0 : Math.floor(time * t) / t, value = valueAtTime(time)
                        }
                        var index = elem.data.ind,
                            hasParent = !(!elem.hierarchy || !elem.hierarchy.length),
                            parent, randSeed = Math.floor(1e6 * Math.random()),
                            globalData = elem.globalData;

                        function executeExpression(t) {
                            return value = t, _needsRandom && seedRandom(randSeed), this.frameExpressionId === elem.globalData.frameId && "textSelector" !== this.propType ? value : ("textSelector" === this.propType && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), ($bm_transform = transform) && (anchorPoint = transform.anchorPoint)), 4 !== elemType || content || (content = thisLayer("ADBE Root Vectors Group")), effect = effect || thisLayer(4), (hasParent = !(!elem.hierarchy || !elem.hierarchy.length)) && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, "shape" === scoped_bm_rt.propType && (scoped_bm_rt = scoped_bm_rt.v), scoped_bm_rt)
                        }
                        return executeExpression
                    }
                    return ob.initiateExpression = initiateExpression, ob
                }(),
                expressionHelpers = {
                    searchExpressions: function(t, e, i) {
                        e.x && (i.k = !0, i.x = !0, i.initiateExpression = ExpressionManager.initiateExpression, i.effectsSequence.push(i.initiateExpression(t, e, i).bind(i)))
                    },
                    getSpeedAtTime: function(t) {
                        var e = this.getValueAtTime(t),
                            i = this.getValueAtTime(t + -.01),
                            n = 0;
                        if (e.length) {
                            for (var r = 0; r < e.length; r += 1) n += Math.pow(i[r] - e[r], 2);
                            n = 100 * Math.sqrt(n)
                        } else n = 0;
                        return n
                    },
                    getVelocityAtTime: function(t) {
                        if (void 0 !== this.vel) return this.vel;
                        var e = this.getValueAtTime(t),
                            i = this.getValueAtTime(t + -.001);
                        if (e.length)
                            for (var n = createTypedArray("float32", e.length), r = 0; r < e.length; r += 1) n[r] = (i[r] - e[r]) / -.001;
                        else n = (i - e) / -.001;
                        return n
                    },
                    getValueAtTime: function(t) {
                        return t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < t ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(t, this._cachingAtTime), this._cachingAtTime.lastFrame = t), this._cachingAtTime.value
                    },
                    getStaticValueAtTime: function() {
                        return this.pv
                    },
                    setGroupProperty: function(t) {
                        this.propertyGroup = t
                    }
                };
            ! function() {
                function o(t, e, i) {
                    if (!this.k || !this.keyframes) return this.pv;
                    t = t ? t.toLowerCase() : "";
                    var n, r, a, s, o, l = this.comp.renderedFrame,
                        h = this.keyframes,
                        u = h[h.length - 1].t;
                    if (l <= u) return this.pv;
                    if (i ? r = u - (n = e ? Math.abs(u - this.elem.comp.globalData.frameRate * e) : Math.max(0, u - this.elem.data.ip)) : ((!e || e > h.length - 1) && (e = h.length - 1), n = u - (r = h[h.length - 1 - e].t)), "pingpong" === t) {
                        if (Math.floor((l - r) / n) % 2 != 0) return this.getValueAtTime((n - (l - r) % n + r) / this.comp.globalData.frameRate, 0)
                    } else {
                        if ("offset" === t) {
                            var c = this.getValueAtTime(r / this.comp.globalData.frameRate, 0),
                                p = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                                d = this.getValueAtTime(((l - r) % n + r) / this.comp.globalData.frameRate, 0),
                                f = Math.floor((l - r) / n);
                            if (this.pv.length) {
                                for (s = (o = new Array(c.length)).length, a = 0; a < s; a += 1) o[a] = (p[a] - c[a]) * f + d[a];
                                return o
                            }
                            return (p - c) * f + d
                        }
                        if ("continue" === t) {
                            var m = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                                g = this.getValueAtTime((u - .001) / this.comp.globalData.frameRate, 0);
                            if (this.pv.length) {
                                for (s = (o = new Array(m.length)).length, a = 0; a < s; a += 1) o[a] = m[a] + (m[a] - g[a]) * ((l - u) / this.comp.globalData.frameRate) / 5e-4;
                                return o
                            }
                            return m + (l - u) / .001 * (m - g)
                        }
                    }
                    return this.getValueAtTime(((l - r) % n + r) / this.comp.globalData.frameRate, 0)
                }

                function l(t, e, i) {
                    if (!this.k) return this.pv;
                    t = t ? t.toLowerCase() : "";
                    var n, r, a, s, o, l = this.comp.renderedFrame,
                        h = this.keyframes,
                        u = h[0].t;
                    if (u <= l) return this.pv;
                    if (i ? r = u + (n = e ? Math.abs(this.elem.comp.globalData.frameRate * e) : Math.max(0, this.elem.data.op - u)) : ((!e || e > h.length - 1) && (e = h.length - 1), n = (r = h[e].t) - u), "pingpong" === t) {
                        if (Math.floor((u - l) / n) % 2 == 0) return this.getValueAtTime(((u - l) % n + u) / this.comp.globalData.frameRate, 0)
                    } else {
                        if ("offset" === t) {
                            var c = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                                p = this.getValueAtTime(r / this.comp.globalData.frameRate, 0),
                                d = this.getValueAtTime((n - (u - l) % n + u) / this.comp.globalData.frameRate, 0),
                                f = Math.floor((u - l) / n) + 1;
                            if (this.pv.length) {
                                for (s = (o = new Array(c.length)).length, a = 0; a < s; a += 1) o[a] = d[a] - (p[a] - c[a]) * f;
                                return o
                            }
                            return d - (p - c) * f
                        }
                        if ("continue" === t) {
                            var m = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                                g = this.getValueAtTime((u + .001) / this.comp.globalData.frameRate, 0);
                            if (this.pv.length) {
                                for (s = (o = new Array(m.length)).length, a = 0; a < s; a += 1) o[a] = m[a] + (m[a] - g[a]) * (u - l) / .001;
                                return o
                            }
                            return m + (m - g) * (u - l) / .001
                        }
                    }
                    return this.getValueAtTime((n - ((u - l) % n + u)) / this.comp.globalData.frameRate, 0)
                }

                function h(t, e) {
                    if (!this.k) return this.pv;
                    if (t = .5 * (t || .4), (e = Math.floor(e || 5)) <= 1) return this.pv;
                    for (var i, n = this.comp.renderedFrame / this.comp.globalData.frameRate, r = n - t, a = 1 < e ? (n + t - r) / (e - 1) : 1, s = 0, o = 0, l = this.pv.length ? createTypedArray("float32", this.pv.length) : 0; s < e;) {
                        if (i = this.getValueAtTime(r + s * a), this.pv.length)
                            for (o = 0; o < this.pv.length; o += 1) l[o] += i[o];
                        else l += i;
                        s += 1
                    }
                    if (this.pv.length)
                        for (o = 0; o < this.pv.length; o += 1) l[o] /= e;
                    else l /= e;
                    return l
                }
                var r = TransformPropertyFactory.getTransformProperty;
                TransformPropertyFactory.getTransformProperty = function(t, e, i) {
                    var n = r(t, e, i);
                    return n.dynamicProperties.length ? n.getValueAtTime = function(t) {
                        this._transformCachingAtTime || (this._transformCachingAtTime = {
                            v: new Matrix
                        });
                        var e, i, n, r, a, s, o, l, h, u, c, p, d, f = this._transformCachingAtTime.v;
                        return f.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && (e = this.a.getValueAtTime(t), f.translate(-e[0] * this.a.mult, -e[1] * this.a.mult, e[2] * this.a.mult)), this.appliedTransformations < 2 && (i = this.s.getValueAtTime(t), f.scale(i[0] * this.s.mult, i[1] * this.s.mult, i[2] * this.s.mult)), this.sk && this.appliedTransformations < 3 && (n = this.sk.getValueAtTime(t), r = this.sa.getValueAtTime(t), f.skewFromAxis(-n * this.sk.mult, r * this.sa.mult)), this.r && this.appliedTransformations < 4 ? (a = this.r.getValueAtTime(t), f.rotate(-a * this.r.mult)) : !this.r && this.appliedTransformations < 4 && (s = this.rz.getValueAtTime(t), o = this.ry.getValueAtTime(t), l = this.rx.getValueAtTime(t), h = this.or.getValueAtTime(t), f.rotateZ(-s * this.rz.mult).rotateY(o * this.ry.mult).rotateX(l * this.rx.mult).rotateZ(-h[2] * this.or.mult).rotateY(h[1] * this.or.mult).rotateX(h[0] * this.or.mult)), this.data.p && this.data.p.s ? (u = this.px.getValueAtTime(t), c = this.py.getValueAtTime(t), this.data.p.z ? (p = this.pz.getValueAtTime(t), f.translate(u * this.px.mult, c * this.py.mult, -p * this.pz.mult)) : f.translate(u * this.px.mult, c * this.py.mult, 0)) : (d = this.p.getValueAtTime(t), f.translate(d[0] * this.p.mult, d[1] * this.p.mult, -d[2] * this.p.mult)), f
                    }.bind(n) : n.getValueAtTime = function() {
                        return this.v.clone(new Matrix)
                    }.bind(n), n.setGroupProperty = expressionHelpers.setGroupProperty, n
                };
                var u = PropertyFactory.getProp;
                PropertyFactory.getProp = function(t, e, i, n, r) {
                    var a = u(t, e, i, n, r);
                    a.kf ? a.getValueAtTime = expressionHelpers.getValueAtTime.bind(a) : a.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(a), a.setGroupProperty = expressionHelpers.setGroupProperty, a.loopOut = o, a.loopIn = l, a.smooth = h, a.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(a), a.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(a), a.numKeys = 1 === e.a ? e.k.length : 0, a.propertyIndex = e.ix;
                    var s = 0;
                    return 0 !== i && (s = createTypedArray("float32", 1 === e.a ? e.k[0].s.length : e.k.length)), a._cachingAtTime = {
                        lastFrame: initialDefaultFrame,
                        lastIndex: 0,
                        value: s
                    }, expressionHelpers.searchExpressions(t, e, a), a.k && r.addDynamicProperty(a), a
                };
                var t = ShapePropertyFactory.getConstructorFunction(),
                    e = ShapePropertyFactory.getKeyframedConstructorFunction();

                function i() {}
                i.prototype = {
                    vertices: function(t, e) {
                        this.k && this.getValue();
                        var i = this.v;
                        void 0 !== e && (i = this.getValueAtTime(e, 0));
                        for (var n = i._length, r = i[t], a = i.v, s = createSizedArray(n), o = 0; o < n; o += 1) s[o] = "i" === t || "o" === t ? [r[o][0] - a[o][0], r[o][1] - a[o][1]] : [r[o][0], r[o][1]];
                        return s
                    },
                    points: function(t) {
                        return this.vertices("v", t)
                    },
                    inTangents: function(t) {
                        return this.vertices("i", t)
                    },
                    outTangents: function(t) {
                        return this.vertices("o", t)
                    },
                    isClosed: function() {
                        return this.v.c
                    },
                    pointOnPath: function(t, e) {
                        var i = this.v;
                        void 0 !== e && (i = this.getValueAtTime(e, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(i));
                        for (var n = this._segmentsLength, r = n.lengths, a = n.totalLength * t, s = 0, o = r.length, l = 0; s < o;) {
                            if (l + r[s].addedLength > a) {
                                var h = i.c && s === o - 1 ? 0 : s + 1,
                                    u = (a - l) / r[s].addedLength,
                                    c = bez.getPointInSegment(i.v[s], i.v[h], i.o[s], i.i[h], u, r[s]);
                                break
                            }
                            l += r[s].addedLength, s += 1
                        }
                        return c = c || (i.c ? [i.v[0][0], i.v[0][1]] : [i.v[i._length - 1][0], i.v[i._length - 1][1]])
                    },
                    vectorOnPath: function(t, e, i) {
                        1 == t ? t = this.v.c : 0 == t && (t = .999);
                        var n = this.pointOnPath(t, e),
                            r = this.pointOnPath(t + .001, e),
                            a = r[0] - n[0],
                            s = r[1] - n[1],
                            o = Math.sqrt(Math.pow(a, 2) + Math.pow(s, 2));
                        return 0 === o ? [0, 0] : "tangent" === i ? [a / o, s / o] : [-s / o, a / o]
                    },
                    tangentOnPath: function(t, e) {
                        return this.vectorOnPath(t, e, "tangent")
                    },
                    normalOnPath: function(t, e) {
                        return this.vectorOnPath(t, e, "normal")
                    },
                    setGroupProperty: expressionHelpers.setGroupProperty,
                    getValueAtTime: expressionHelpers.getStaticValueAtTime
                }, extendPrototype([i], t), extendPrototype([i], e), e.prototype.getValueAtTime = function(t) {
                    return this._cachingAtTime || (this._cachingAtTime = {
                        shapeValue: shapePool.clone(this.pv),
                        lastIndex: 0,
                        lastTime: initialDefaultFrame
                    }), t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < t ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = t, this.interpolateShape(t, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue
                }, e.prototype.initiateExpression = ExpressionManager.initiateExpression;
                var s = ShapePropertyFactory.getShapeProp;
                ShapePropertyFactory.getShapeProp = function(t, e, i, n, r) {
                    var a = s(t, e, i, n, r);
                    return a.propertyIndex = e.ix, a.lock = !1, 3 === i ? expressionHelpers.searchExpressions(t, e.pt, a) : 4 === i && expressionHelpers.searchExpressions(t, e.ks, a), a.k && t.addDynamicProperty(a), a
                }
            }(), TextProperty.prototype.getExpressionValue = function(t, e) {
                var i = this.calculateExpression(e);
                if (t.t === i) return t;
                var n = {};
                return this.copyData(n, t), n.t = i.toString(), n.__complete = !1, n
            }, TextProperty.prototype.searchProperty = function() {
                var t = this.searchKeyframes(),
                    e = this.searchExpressions();
                return this.kf = t || e, this.kf
            }, TextProperty.prototype.searchExpressions = function() {
                return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null
            };
            var ShapePathInterface = function(t, e, i) {
                    var n = e.sh;

                    function r(t) {
                        return "Shape" === t || "shape" === t || "Path" === t || "path" === t || "ADBE Vector Shape" === t || 2 === t ? r.path : null
                    }
                    var a = propertyGroupFactory(r, i);
                    return n.setGroupProperty(PropertyInterface("Path", a)), Object.defineProperties(r, {
                        path: {
                            get: function() {
                                return n.k && n.getValue(), n
                            }
                        },
                        shape: {
                            get: function() {
                                return n.k && n.getValue(), n
                            }
                        },
                        _name: {
                            value: t.nm
                        },
                        ix: {
                            value: t.ix
                        },
                        propertyIndex: {
                            value: t.ix
                        },
                        mn: {
                            value: t.mn
                        },
                        propertyGroup: {
                            value: i
                        }
                    }), r
                },
                propertyGroupFactory = function(e, i) {
                    return function(t) {
                        return (t = void 0 === t ? 1 : t) <= 0 ? e : i(t - 1)
                    }
                },
                PropertyInterface = function(t, e) {
                    var i = {
                        _name: t
                    };
                    return function(t) {
                        return (t = void 0 === t ? 1 : t) <= 0 ? i : e(t - 1)
                    }
                },
                ShapeExpressionInterface = function(t, e, n) {
                    var r;

                    function i(t) {
                        if ("number" == typeof t) return 0 === (t = void 0 === t ? 1 : t) ? n : r[t - 1];
                        for (var e = 0, i = r.length; e < i;) {
                            if (r[e]._name === t) return r[e];
                            e += 1
                        }
                        return null
                    }
                    return i.propertyGroup = propertyGroupFactory(i, function() {
                        return n
                    }), r = x9e(t, e, i.propertyGroup), i.numProperties = r.length, i._name = "Contents", i
                };

            function x9e(t, e, i) {
                for (var n, r, a, s, o, l, h = [], u = t ? t.length : 0, c = 0; c < u; c += 1) "gr" === t[c].ty ? h.push(function(t, e, i) {
                    var n = function(t) {
                        switch (t) {
                            case "ADBE Vectors Group":
                            case "Contents":
                            case 2:
                                return n.content;
                            default:
                                return n.transform
                        }
                    };
                    n.propertyGroup = propertyGroupFactory(n, i);
                    var r = function(t, e, i) {
                            function n(t) {
                                for (var e = 0, i = r.length; e < i;) {
                                    if (r[e]._name === t || r[e].mn === t || r[e].propertyIndex === t || r[e].ix === t || r[e].ind === t) return r[e];
                                    e += 1
                                }
                                return "number" == typeof t ? r[t - 1] : null
                            }
                            var r;
                            n.propertyGroup = propertyGroupFactory(n, i), r = x9e(t.it, e.it, n.propertyGroup), n.numProperties = r.length;
                            var a = F9e(t.it[t.it.length - 1], e.it[e.it.length - 1], n.propertyGroup);
                            return n.transform = a, n.propertyIndex = t.cix, n._name = t.nm, n
                        }(t, e, n.propertyGroup),
                        a = F9e(t.it[t.it.length - 1], e.it[e.it.length - 1], n.propertyGroup);
                    return n.content = r, n.transform = a, Object.defineProperty(n, "_name", {
                        get: function() {
                            return t.nm
                        }
                    }), n.numProperties = t.np, n.propertyIndex = t.ix, n.nm = t.nm, n.mn = t.mn, n
                }(t[c], e[c], i)) : "fl" === t[c].ty ? h.push((s = t[c], o = e[c], l = i, Object.defineProperties(d, {
                    color: {
                        get: ExpressionPropertyInterface(o.c)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(o.o)
                    },
                    _name: {
                        value: s.nm
                    },
                    mn: {
                        value: s.mn
                    }
                }), o.c.setGroupProperty(PropertyInterface("Color", l)), o.o.setGroupProperty(PropertyInterface("Opacity", l)), d)) : "st" === t[c].ty ? h.push(function(e, i, t) {
                    var n, r = propertyGroupFactory(l, t),
                        a = propertyGroupFactory(o, r);
                    var s = e.d ? e.d.length : 0,
                        o = {};
                    for (n = 0; n < s; n += 1) ! function(t) {
                        Object.defineProperty(o, e.d[t].nm, {
                            get: ExpressionPropertyInterface(i.d.dataProps[t].p)
                        })
                    }(n), i.d.dataProps[n].p.setGroupProperty(a);

                    function l(t) {
                        return "Color" === t || "color" === t ? l.color : "Opacity" === t || "opacity" === t ? l.opacity : "Stroke Width" === t || "stroke width" === t ? l.strokeWidth : null
                    }
                    return Object.defineProperties(l, {
                        color: {
                            get: ExpressionPropertyInterface(i.c)
                        },
                        opacity: {
                            get: ExpressionPropertyInterface(i.o)
                        },
                        strokeWidth: {
                            get: ExpressionPropertyInterface(i.w)
                        },
                        dash: {
                            get: function() {
                                return o
                            }
                        },
                        _name: {
                            value: e.nm
                        },
                        mn: {
                            value: e.mn
                        }
                    }), i.c.setGroupProperty(PropertyInterface("Color", r)), i.o.setGroupProperty(PropertyInterface("Opacity", r)), i.w.setGroupProperty(PropertyInterface("Stroke Width", r)), l
                }(t[c], e[c], i)) : "tm" === t[c].ty ? h.push(function(e, t, i) {
                    function n(t) {
                        return t === e.e.ix || "End" === t || "end" === t ? n.end : t === e.s.ix ? n.start : t === e.o.ix ? n.offset : null
                    }
                    var r = propertyGroupFactory(n, i);
                    return n.propertyIndex = e.ix, t.s.setGroupProperty(PropertyInterface("Start", r)), t.e.setGroupProperty(PropertyInterface("End", r)), t.o.setGroupProperty(PropertyInterface("Offset", r)), n.propertyIndex = e.ix, n.propertyGroup = i, Object.defineProperties(n, {
                        start: {
                            get: ExpressionPropertyInterface(t.s)
                        },
                        end: {
                            get: ExpressionPropertyInterface(t.e)
                        },
                        offset: {
                            get: ExpressionPropertyInterface(t.o)
                        },
                        _name: {
                            value: e.nm
                        }
                    }), n.mn = e.mn, n
                }(t[c], e[c], i)) : "tr" === t[c].ty || ("el" === t[c].ty ? h.push(function(e, t, i) {
                    function n(t) {
                        return e.p.ix === t ? n.position : e.s.ix === t ? n.size : null
                    }
                    var r = propertyGroupFactory(n, i);
                    n.propertyIndex = e.ix;
                    var a = "tm" === t.sh.ty ? t.sh.prop : t.sh;
                    return a.s.setGroupProperty(PropertyInterface("Size", r)), a.p.setGroupProperty(PropertyInterface("Position", r)), Object.defineProperties(n, {
                        size: {
                            get: ExpressionPropertyInterface(a.s)
                        },
                        position: {
                            get: ExpressionPropertyInterface(a.p)
                        },
                        _name: {
                            value: e.nm
                        }
                    }), n.mn = e.mn, n
                }(t[c], e[c], i)) : "sr" === t[c].ty ? h.push(function(e, t, i) {
                    function n(t) {
                        return e.p.ix === t ? n.position : e.r.ix === t ? n.rotation : e.pt.ix === t ? n.points : e.or.ix === t || "ADBE Vector Star Outer Radius" === t ? n.outerRadius : e.os.ix === t ? n.outerRoundness : !e.ir || e.ir.ix !== t && "ADBE Vector Star Inner Radius" !== t ? e.is && e.is.ix === t ? n.innerRoundness : null : n.innerRadius
                    }
                    var r = propertyGroupFactory(n, i),
                        a = "tm" === t.sh.ty ? t.sh.prop : t.sh;
                    n.propertyIndex = e.ix, a.or.setGroupProperty(PropertyInterface("Outer Radius", r)), a.os.setGroupProperty(PropertyInterface("Outer Roundness", r)), a.pt.setGroupProperty(PropertyInterface("Points", r)), a.p.setGroupProperty(PropertyInterface("Position", r)), a.r.setGroupProperty(PropertyInterface("Rotation", r)), e.ir && (a.ir.setGroupProperty(PropertyInterface("Inner Radius", r)), a.is.setGroupProperty(PropertyInterface("Inner Roundness", r)));
                    return Object.defineProperties(n, {
                        position: {
                            get: ExpressionPropertyInterface(a.p)
                        },
                        rotation: {
                            get: ExpressionPropertyInterface(a.r)
                        },
                        points: {
                            get: ExpressionPropertyInterface(a.pt)
                        },
                        outerRadius: {
                            get: ExpressionPropertyInterface(a.or)
                        },
                        outerRoundness: {
                            get: ExpressionPropertyInterface(a.os)
                        },
                        innerRadius: {
                            get: ExpressionPropertyInterface(a.ir)
                        },
                        innerRoundness: {
                            get: ExpressionPropertyInterface(a.is)
                        },
                        _name: {
                            value: e.nm
                        }
                    }), n.mn = e.mn, n
                }(t[c], e[c], i)) : "sh" === t[c].ty ? h.push(ShapePathInterface(t[c], e[c], i)) : "rc" === t[c].ty ? h.push(function(e, t, i) {
                    function n(t) {
                        return e.p.ix === t ? n.position : e.r.ix === t ? n.roundness : e.s.ix === t || "Size" === t || "ADBE Vector Rect Size" === t ? n.size : null
                    }
                    var r = propertyGroupFactory(n, i),
                        a = "tm" === t.sh.ty ? t.sh.prop : t.sh;
                    return n.propertyIndex = e.ix, a.p.setGroupProperty(PropertyInterface("Position", r)), a.s.setGroupProperty(PropertyInterface("Size", r)), a.r.setGroupProperty(PropertyInterface("Rotation", r)), Object.defineProperties(n, {
                        position: {
                            get: ExpressionPropertyInterface(a.p)
                        },
                        roundness: {
                            get: ExpressionPropertyInterface(a.r)
                        },
                        size: {
                            get: ExpressionPropertyInterface(a.s)
                        },
                        _name: {
                            value: e.nm
                        }
                    }), n.mn = e.mn, n
                }(t[c], e[c], i)) : "rd" === t[c].ty ? h.push(function(e, t, i) {
                    function n(t) {
                        return e.r.ix === t || "Round Corners 1" === t ? n.radius : null
                    }
                    var r = propertyGroupFactory(n, i),
                        a = t;
                    return n.propertyIndex = e.ix, a.rd.setGroupProperty(PropertyInterface("Radius", r)), Object.defineProperties(n, {
                        radius: {
                            get: ExpressionPropertyInterface(a.rd)
                        },
                        _name: {
                            value: e.nm
                        }
                    }), n.mn = e.mn, n
                }(t[c], e[c], i)) : "rp" === t[c].ty ? h.push(function(e, t, i) {
                    function n(t) {
                        return e.c.ix === t || "Copies" === t ? n.copies : e.o.ix === t || "Offset" === t ? n.offset : null
                    }
                    var r = propertyGroupFactory(n, i),
                        a = t;
                    return n.propertyIndex = e.ix, a.c.setGroupProperty(PropertyInterface("Copies", r)), a.o.setGroupProperty(PropertyInterface("Offset", r)), Object.defineProperties(n, {
                        copies: {
                            get: ExpressionPropertyInterface(a.c)
                        },
                        offset: {
                            get: ExpressionPropertyInterface(a.o)
                        },
                        _name: {
                            value: e.nm
                        }
                    }), n.mn = e.mn, n
                }(t[c], e[c], i)) : "gf" === t[c].ty ? h.push((n = t[c], r = e[c], a = i, Object.defineProperties(p, {
                    startPoint: {
                        get: ExpressionPropertyInterface(r.s)
                    },
                    endPoint: {
                        get: ExpressionPropertyInterface(r.e)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(r.o)
                    },
                    type: {
                        get: function() {
                            return "a"
                        }
                    },
                    _name: {
                        value: n.nm
                    },
                    mn: {
                        value: n.mn
                    }
                }), r.s.setGroupProperty(PropertyInterface("Start Point", a)), r.e.setGroupProperty(PropertyInterface("End Point", a)), r.o.setGroupProperty(PropertyInterface("Opacity", a)), p)) : h.push((t[c], e[c], function() {
                    return null
                })));

                function p(t) {
                    return "Start Point" === t || "start point" === t ? p.startPoint : "End Point" === t || "end point" === t ? p.endPoint : "Opacity" === t || "opacity" === t ? p.opacity : null
                }

                function d(t) {
                    return "Color" === t || "color" === t ? d.color : "Opacity" === t || "opacity" === t ? d.opacity : null
                }
                return h
            }

            function F9e(e, t, i) {
                function n(t) {
                    return e.a.ix === t || "Anchor Point" === t ? n.anchorPoint : e.o.ix === t || "Opacity" === t ? n.opacity : e.p.ix === t || "Position" === t ? n.position : e.r.ix === t || "Rotation" === t || "ADBE Vector Rotation" === t ? n.rotation : e.s.ix === t || "Scale" === t ? n.scale : e.sk && e.sk.ix === t || "Skew" === t ? n.skew : e.sa && e.sa.ix === t || "Skew Axis" === t ? n.skewAxis : null
                }
                var r = propertyGroupFactory(n, i);
                return t.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", r)), t.transform.mProps.p.setGroupProperty(PropertyInterface("Position", r)), t.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", r)), t.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", r)), t.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", r)), t.transform.mProps.sk && (t.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", r)), t.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", r))), t.transform.op.setGroupProperty(PropertyInterface("Opacity", r)), Object.defineProperties(n, {
                    opacity: {
                        get: ExpressionPropertyInterface(t.transform.mProps.o)
                    },
                    position: {
                        get: ExpressionPropertyInterface(t.transform.mProps.p)
                    },
                    anchorPoint: {
                        get: ExpressionPropertyInterface(t.transform.mProps.a)
                    },
                    scale: {
                        get: ExpressionPropertyInterface(t.transform.mProps.s)
                    },
                    rotation: {
                        get: ExpressionPropertyInterface(t.transform.mProps.r)
                    },
                    skew: {
                        get: ExpressionPropertyInterface(t.transform.mProps.sk)
                    },
                    skewAxis: {
                        get: ExpressionPropertyInterface(t.transform.mProps.sa)
                    },
                    _name: {
                        value: e.nm
                    }
                }), n.ty = "tr", n.mn = e.mn, n.propertyGroup = i, n
            }
            var TextExpressionInterface = function(e) {
                    var i;

                    function n(t) {
                        switch (t) {
                            case "ADBE Text Document":
                                return n.sourceText;
                            default:
                                return null
                        }
                    }
                    return Object.defineProperty(n, "sourceText", {
                        get: function() {
                            e.textProperty.getValue();
                            var t = e.textProperty.currentData.t;
                            return void 0 !== t && (e.textProperty.currentData.t = void 0, (i = new String(t)).value = t || new String(t)), i
                        }
                    }), n
                },
                LayerExpressionInterface = function(e) {
                    var i;

                    function n(t) {
                        switch (t) {
                            case "ADBE Root Vectors Group":
                            case "Contents":
                            case 2:
                                return n.shapeInterface;
                            case 1:
                            case 6:
                            case "Transform":
                            case "transform":
                            case "ADBE Transform Group":
                                return i;
                            case 4:
                            case "ADBE Effect Parade":
                            case "effects":
                            case "Effects":
                                return n.effect;
                            case "ADBE Text Properties":
                                return n.textInterface;
                            default:
                                return null
                        }
                    }
                    n.getMatrix = Qbf, n.invertPoint = Wbf, n.applyPoint = Vbf, n.toWorld = Sbf, n.toWorldVec = Rbf, n.fromWorld = Ubf, n.fromWorldVec = Tbf, n.toComp = Sbf, n.fromComp = Xbf, n.sampleImage = Ybf, n.sourceRectAtTime = e.sourceRectAtTime.bind(e);
                    var t = getDescriptor(i = TransformExpressionInterface((n._elem = e).finalTransform.mProp), "anchorPoint");
                    return Object.defineProperties(n, {
                        hasParent: {
                            get: function() {
                                return e.hierarchy.length
                            }
                        },
                        parent: {
                            get: function() {
                                return e.hierarchy[0].layerInterface
                            }
                        },
                        rotation: getDescriptor(i, "rotation"),
                        scale: getDescriptor(i, "scale"),
                        position: getDescriptor(i, "position"),
                        opacity: getDescriptor(i, "opacity"),
                        anchorPoint: t,
                        anchor_point: t,
                        transform: {
                            get: function() {
                                return i
                            }
                        },
                        active: {
                            get: function() {
                                return e.isInRange
                            }
                        }
                    }), n.startTime = e.data.st, n.index = e.data.ind, n.source = e.data.refId, n.height = 0 === e.data.ty ? e.data.h : 100, n.width = 0 === e.data.ty ? e.data.w : 100, n.inPoint = e.data.ip / e.comp.globalData.frameRate, n.outPoint = e.data.op / e.comp.globalData.frameRate, n._name = e.data.nm, n.registerMaskInterface = function(t) {
                        n.mask = new MaskManagerInterface(t, e)
                    }, n.registerEffectsInterface = function(t) {
                        n.effect = t
                    }, n
                };

            function Qbf(t) {
                var e = new Matrix;
                return void 0 !== t ? this._elem.finalTransform.mProp.getValueAtTime(t).clone(e) : this._elem.finalTransform.mProp.applyToMatrix(e), e
            }

            function Rbf(t, e) {
                var i = this.getMatrix(e);
                return i.props[12] = 0, i.props[13] = 0, i.props[14] = 0, this.applyPoint(i, t)
            }

            function Sbf(t, e) {
                var i = this.getMatrix(e);
                return this.applyPoint(i, t)
            }

            function Tbf(t, e) {
                var i = this.getMatrix(e);
                return i.props[12] = 0, i.props[13] = 0, i.props[14] = 0, this.invertPoint(i, t)
            }

            function Ubf(t, e) {
                var i = this.getMatrix(e);
                return this.invertPoint(i, t)
            }

            function Vbf(t, e) {
                if (this._elem.hierarchy && this._elem.hierarchy.length)
                    for (var i = this._elem.hierarchy.length, n = 0; n < i; n += 1) this._elem.hierarchy[n].finalTransform.mProp.applyToMatrix(t);
                return t.applyToPointArray(e[0], e[1], e[2] || 0)
            }

            function Wbf(t, e) {
                if (this._elem.hierarchy && this._elem.hierarchy.length)
                    for (var i = this._elem.hierarchy.length, n = 0; n < i; n += 1) this._elem.hierarchy[n].finalTransform.mProp.applyToMatrix(t);
                return t.inversePoint(e)
            }

            function Xbf(t) {
                var e = new Matrix;
                if (e.reset(), this._elem.finalTransform.mProp.applyToMatrix(e), this._elem.hierarchy && this._elem.hierarchy.length) {
                    for (var i = this._elem.hierarchy.length, n = 0; n < i; n += 1) this._elem.hierarchy[n].finalTransform.mProp.applyToMatrix(e);
                    return e.inversePoint(t)
                }
                return e.inversePoint(t)
            }

            function Ybf() {
                return [1, 1, 1, 1]
            }
            var FootageInterface = function(t) {
                function e(t) {
                    return "Data" === t ? e.dataInterface : null
                }
                return e._name = "Data", e.dataInterface = Ncf(t), e
            };

            function Ncf(t) {
                function e(t) {
                    return "Outline" === t ? e.outlineInterface() : null
                }

                function n(t) {
                    if (a[t]) return "object" === _typeof(a = a[r = t]) ? n : a;
                    var e = t.indexOf(r);
                    if (-1 === e) return "";
                    var i = parseInt(t.substr(e + r.length), 10);
                    return "object" === _typeof(a = a[i]) ? n : a
                }
                var i, r, a;
                return e._name = "Outline", e.outlineInterface = (r = "", a = (i = t).getFootageData(), function() {
                    return r = "", a = i.getFootageData(), n
                }), e
            }
            var CompExpressionInterface = function(n) {
                    function t(t) {
                        for (var e = 0, i = n.layers.length; e < i;) {
                            if (n.layers[e].nm === t || n.layers[e].ind === t) return n.elements[e].layerInterface;
                            e += 1
                        }
                        return null
                    }
                    return Object.defineProperty(t, "_name", {
                        value: n.data.nm
                    }), (t.layer = t).pixelAspect = 1, t.height = n.data.h || n.globalData.compSize.h, t.width = n.data.w || n.globalData.compSize.w, t.pixelAspect = 1, t.frameDuration = 1 / n.globalData.frameRate, t.displayStartTime = 0, t.numLayers = n.layers.length, t
                },
                TransformExpressionInterface = function(t) {
                    function e(t) {
                        switch (t) {
                            case "scale":
                            case "Scale":
                            case "ADBE Scale":
                            case 6:
                                return e.scale;
                            case "rotation":
                            case "Rotation":
                            case "ADBE Rotation":
                            case "ADBE Rotate Z":
                            case 10:
                                return e.rotation;
                            case "ADBE Rotate X":
                                return e.xRotation;
                            case "ADBE Rotate Y":
                                return e.yRotation;
                            case "position":
                            case "Position":
                            case "ADBE Position":
                            case 2:
                                return e.position;
                            case "ADBE Position_0":
                                return e.xPosition;
                            case "ADBE Position_1":
                                return e.yPosition;
                            case "ADBE Position_2":
                                return e.zPosition;
                            case "anchorPoint":
                            case "AnchorPoint":
                            case "Anchor Point":
                            case "ADBE AnchorPoint":
                            case 1:
                                return e.anchorPoint;
                            case "opacity":
                            case "Opacity":
                            case 11:
                                return e.opacity;
                            default:
                                return null
                        }
                    }
                    var i, n, r, a;
                    return Object.defineProperty(e, "rotation", {
                        get: ExpressionPropertyInterface(t.r || t.rz)
                    }), Object.defineProperty(e, "zRotation", {
                        get: ExpressionPropertyInterface(t.rz || t.r)
                    }), Object.defineProperty(e, "xRotation", {
                        get: ExpressionPropertyInterface(t.rx)
                    }), Object.defineProperty(e, "yRotation", {
                        get: ExpressionPropertyInterface(t.ry)
                    }), Object.defineProperty(e, "scale", {
                        get: ExpressionPropertyInterface(t.s)
                    }), t.p ? a = ExpressionPropertyInterface(t.p) : (i = ExpressionPropertyInterface(t.px), n = ExpressionPropertyInterface(t.py), t.pz && (r = ExpressionPropertyInterface(t.pz))), Object.defineProperty(e, "position", {
                        get: function() {
                            return t.p ? a() : [i(), n(), r ? r() : 0]
                        }
                    }), Object.defineProperty(e, "xPosition", {
                        get: ExpressionPropertyInterface(t.px)
                    }), Object.defineProperty(e, "yPosition", {
                        get: ExpressionPropertyInterface(t.py)
                    }), Object.defineProperty(e, "zPosition", {
                        get: ExpressionPropertyInterface(t.pz)
                    }), Object.defineProperty(e, "anchorPoint", {
                        get: ExpressionPropertyInterface(t.a)
                    }), Object.defineProperty(e, "opacity", {
                        get: ExpressionPropertyInterface(t.o)
                    }), Object.defineProperty(e, "skew", {
                        get: ExpressionPropertyInterface(t.sk)
                    }), Object.defineProperty(e, "skewAxis", {
                        get: ExpressionPropertyInterface(t.sa)
                    }), Object.defineProperty(e, "orientation", {
                        get: ExpressionPropertyInterface(t.or)
                    }), e
                },
                ProjectInterface = function() {
                    function t(t) {
                        for (var e = 0, i = this.compositions.length; e < i;) {
                            if (this.compositions[e].data && this.compositions[e].data.nm === t) return this.compositions[e].prepareFrame && this.compositions[e].data.xt && this.compositions[e].prepareFrame(this.currentFrame), this.compositions[e].compInterface;
                            e += 1
                        }
                        return null
                    }
                    return t.compositions = [], t.currentFrame = 0, t.registerComposition = pdf, t
                };

            function pdf(t) {
                this.compositions.push(t)
            }
            var EffectsExpressionInterface = {
                createEffectsInterface: function(t, e) {
                    if (t.effectsManager) {
                        var i, n = [],
                            r = t.data.ef,
                            a = t.effectsManager.effectElements.length;
                        for (i = 0; i < a; i += 1) n.push(function t(r, e, i, n) {
                            function a(t) {
                                for (var e = r.ef, i = 0, n = e.length; i < n;) {
                                    if (t === e[i].nm || t === e[i].mn || t === e[i].ix) return 5 === e[i].ty ? l[i] : l[i]();
                                    i += 1
                                }
                                throw new Error
                            }
                            var s, o = propertyGroupFactory(a, i),
                                l = [],
                                h = r.ef.length;
                            for (s = 0; s < h; s += 1) 5 === r.ef[s].ty ? l.push(t(r.ef[s], e.effectElements[s], e.effectElements[s].propertyGroup, n)) : l.push(ydf(e.effectElements[s], r.ef[s].ty, n, o));
                            return "ADBE Color Control" === r.mn && Object.defineProperty(a, "color", {
                                get: function() {
                                    return l[0]()
                                }
                            }), Object.defineProperties(a, {
                                numProperties: {
                                    get: function() {
                                        return r.np
                                    }
                                },
                                _name: {
                                    value: r.nm
                                },
                                propertyGroup: {
                                    value: o
                                }
                            }), a.enabled = 0 !== r.en, a.active = a.enabled, a
                        }(r[i], t.effectsManager.effectElements[i], e, t));
                        var s = t.data.ef || [],
                            o = function(t) {
                                for (i = 0, a = s.length; i < a;) {
                                    if (t === s[i].nm || t === s[i].mn || t === s[i].ix) return n[i];
                                    i += 1
                                }
                                return null
                            };
                        return Object.defineProperty(o, "numProperties", {
                            get: function() {
                                return s.length
                            }
                        }), o
                    }
                    return null
                }
            };

            function ydf(t, e, i, n) {
                var r = ExpressionPropertyInterface(t.p);
                return t.p.setGroupProperty && t.p.setGroupProperty(PropertyInterface("", n)),
                    function() {
                        return 10 === e ? i.comp.compInterface(t.p.v) : r()
                    }
            }
            var MaskManagerInterface = function() {
                    function t(t, e) {
                        this._mask = t, this._data = e
                    }
                    Object.defineProperty(t.prototype, "maskPath", {
                        get: function() {
                            return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
                        }
                    }), Object.defineProperty(t.prototype, "maskOpacity", {
                        get: function() {
                            return this._mask.op.k && this._mask.op.getValue(), 100 * this._mask.op.v
                        }
                    });
                    return function(e) {
                        for (var i = createSizedArray(e.viewData.length), n = e.viewData.length, r = 0; r < n; r += 1) i[r] = new t(e.viewData[r], e.masksProperties[r]);
                        return function(t) {
                            for (r = 0; r < n;) {
                                if (e.masksProperties[r].nm === t) return i[r];
                                r += 1
                            }
                            return null
                        }
                    }
                }(),
                ExpressionPropertyInterface = (ref = {
                    pv: 0,
                    v: 0,
                    mult: 1
                }, sef = {
                    pv: [0, 0, 0],
                    v: [0, 0, 0],
                    mult: 1
                }, function(t) {
                    return t ? ("unidimensional" === t.propType ? function(t) {
                        t && "pv" in t || (t = ref);
                        var e = 1 / t.mult,
                            i = t.pv * e,
                            n = new Number(i);
                        return n.value = i, tef(n, t, "unidimensional"),
                            function() {
                                return t.k && t.getValue(), i = t.v * e, n.value !== i && ((n = new Number(i)).value = i, tef(n, t, "unidimensional")), n
                            }
                    } : function(e) {
                        e && "pv" in e || (e = sef);
                        var i = 1 / e.mult,
                            n = e.data && e.data.l || e.pv.length,
                            r = createTypedArray("float32", n),
                            a = createTypedArray("float32", n);
                        return r.value = a, tef(r, e, "multidimensional"),
                            function() {
                                e.k && e.getValue();
                                for (var t = 0; t < n; t += 1) a[t] = e.v[t] * i, r[t] = a[t];
                                return r
                            }
                    })(t) : wef
                }),
                ref, sef;

            function tef(n, r, a) {
                Object.defineProperty(n, "velocity", {
                    get: function() {
                        return r.getVelocityAtTime(r.comp.currentFrame)
                    }
                }), n.numKeys = r.keyframes ? r.keyframes.length : 0, n.key = function(t) {
                    if (!n.numKeys) return 0;
                    var e = "",
                        e = "s" in r.keyframes[t - 1] ? r.keyframes[t - 1].s : "e" in r.keyframes[t - 2] ? r.keyframes[t - 2].e : r.keyframes[t - 2].s,
                        i = "unidimensional" === a ? new Number(e) : Object.assign({}, e);
                    return i.time = r.keyframes[t - 1].t / r.elem.comp.globalData.frameRate, i.value = "unidimensional" === a ? e[0] : e, i
                }, n.valueAtTime = r.getValueAtTime, n.speedAtTime = r.getSpeedAtTime, n.velocityAtTime = r.getVelocityAtTime, n.propertyGroup = r.propertyGroup
            }

            function wef() {
                return ref
            }
            var TextExpressionSelectorPropFactory = function(t, e) {
                this.pv = 1, this.comp = t.comp, this.elem = t, this.mult = .01, this.propType = "textSelector", this.textTotal = e.totalChars, this.selectorValue = 100, this.lastValue = [1, 1, 1], this.k = !0, this.x = !0, this.getValue = ExpressionManager.initiateExpression.bind(this)(t, e, this), this.getMult = Pef, this.getVelocityAtTime = expressionHelpers.getVelocityAtTime, this.kf ? this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this) : this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this), this.setGroupProperty = expressionHelpers.setGroupProperty
            };

            function Pef(t, e) {
                return this.textIndex = t + 1, this.textTotal = e, this.v = this.getValue() * this.mult, this.v
            }
            var propertyGetTextProp = TextSelectorProp.getTextSelectorProp;

            function SliderEffect(t, e, i) {
                this.p = PropertyFactory.getProp(e, t.v, 0, 0, i)
            }

            function AngleEffect(t, e, i) {
                this.p = PropertyFactory.getProp(e, t.v, 0, 0, i)
            }

            function ColorEffect(t, e, i) {
                this.p = PropertyFactory.getProp(e, t.v, 1, 0, i)
            }

            function PointEffect(t, e, i) {
                this.p = PropertyFactory.getProp(e, t.v, 1, 0, i)
            }

            function LayerIndexEffect(t, e, i) {
                this.p = PropertyFactory.getProp(e, t.v, 0, 0, i)
            }

            function MaskIndexEffect(t, e, i) {
                this.p = PropertyFactory.getProp(e, t.v, 0, 0, i)
            }

            function CheckboxEffect(t, e, i) {
                this.p = PropertyFactory.getProp(e, t.v, 0, 0, i)
            }

            function NoValueEffect() {
                this.p = {}
            }

            function EffectsManager(t, e) {
                var i = t.ef || [];
                this.effectElements = [];
                for (var n, r = i.length, a = 0; a < r; a += 1) n = new GroupEffect(i[a], e), this.effectElements.push(n)
            }

            function GroupEffect(t, e) {
                this.init(t, e)
            }
            TextSelectorProp.getTextSelectorProp = function(t, e, i) {
                return 1 === e.t ? new TextExpressionSelectorPropFactory(t, e, i) : propertyGetTextProp(t, e, i)
            }, extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function(t, e) {
                this.data = t, this.effectElements = [], this.initDynamicPropertyContainer(e);
                for (var i, n = this.data.ef.length, r = this.data.ef, a = 0; a < n; a += 1) {
                    switch (i = null, r[a].ty) {
                        case 0:
                            i = new SliderEffect(r[a], e, this);
                            break;
                        case 1:
                            i = new AngleEffect(r[a], e, this);
                            break;
                        case 2:
                            i = new ColorEffect(r[a], e, this);
                            break;
                        case 3:
                            i = new PointEffect(r[a], e, this);
                            break;
                        case 4:
                        case 7:
                            i = new CheckboxEffect(r[a], e, this);
                            break;
                        case 10:
                            i = new LayerIndexEffect(r[a], e, this);
                            break;
                        case 11:
                            i = new MaskIndexEffect(r[a], e, this);
                            break;
                        case 5:
                            i = new EffectsManager(r[a], e, this);
                            break;
                        default:
                            i = new NoValueEffect(r[a], e, this)
                    }
                    i && this.effectElements.push(i)
                }
            };
            var lottie = {};

            function setLocationHref(t) {
                locationHref = t
            }

            function searchAnimations() {
                !0 === standalone ? animationManager.searchAnimations(animationData, standalone, renderer) : animationManager.searchAnimations()
            }

            function setSubframeRendering(t) {
                subframeEnabled = t
            }

            function setIDPrefix(t) {
                idPrefix = t
            }

            function loadAnimation(t) {
                return !0 === standalone && (t.animationData = JSON.parse(animationData)), animationManager.loadAnimation(t)
            }

            function setQuality(t) {
                if ("string" == typeof t) switch (t) {
                    case "high":
                        defaultCurveSegments = 200;
                        break;
                    default:
                    case "medium":
                        defaultCurveSegments = 50;
                        break;
                    case "low":
                        defaultCurveSegments = 10
                } else !isNaN(t) && 1 < t && (defaultCurveSegments = t);
                roundValues(!(50 <= defaultCurveSegments))
            }

            function inBrowser() {
                return "undefined" != typeof navigator
            }

            function installPlugin(t, e) {
                "expressions" === t && (expressionsPlugin = e)
            }

            function getFactory(t) {
                switch (t) {
                    case "propertyFactory":
                        return PropertyFactory;
                    case "shapePropertyFactory":
                        return ShapePropertyFactory;
                    case "matrix":
                        return Matrix;
                    default:
                        return null
                }
            }

            function checkReady() {
                "complete" === document.readyState && (clearInterval(readyStateCheckInterval), searchAnimations())
            }

            function getQueryVariable(t) {
                for (var e = queryString.split("&"), i = 0; i < e.length; i += 1) {
                    var n = e[i].split("=");
                    if (decodeURIComponent(n[0]) == t) return decodeURIComponent(n[1])
                }
                return null
            }
            lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocationHref, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.setIDPrefix = setIDPrefix, lottie.__getFactory = getFactory, lottie.version = "5.7.13";
            var standalone = "__[STANDALONE]__",
                animationData = "__[ANIMATIONDATA]__",
                renderer = "",
                queryString, scripts, index, myScript, queryString, renderer;
            standalone && (scripts = document.getElementsByTagName("script"), index = scripts.length - 1, myScript = scripts[index] || {
                src: ""
            }, queryString = myScript.src.replace(/^[^\?]+\??/, ""), renderer = getQueryVariable("renderer"));
            var readyStateCheckInterval = setInterval(checkReady, 100);
            return lottie
        }, "function" == typeof define && define.amd ? define(function() {
            return hde(gde)
        }) : "object" === (void 0 === module ? "undefined" : _typeof(module)) && module.exports ? module.exports = hde(gde) : (gde.lottie = hde(gde), gde.bodymovin = gde.lottie))
    }, {}],
    plyr: [function(t, r, a) {
        (function(t) {
            "use strict";

            function e(t) {
                return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                })(t)
            }
            var i, n;
            "object" == ("undefined" == typeof navigator ? "undefined" : e(navigator)) && (n = function() {
                function h(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function n(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                function t(t, e, i) {
                    return e && n(t.prototype, e), i && n(t, i), t
                }

                function a(t, e, i) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = i, t
                }

                function r(e, t) {
                    var i, n = Object.keys(e);
                    return Object.getOwnPropertySymbols && (i = Object.getOwnPropertySymbols(e), t && (i = i.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), n.push.apply(n, i)), n
                }

                function x(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var i = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? r(Object(i), !0).forEach(function(t) {
                            a(e, t, i[t])
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : r(Object(i)).forEach(function(t) {
                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                        })
                    }
                    return e
                }

                function _(t, e) {
                    return function(t) {
                        if (Array.isArray(t)) return t
                    }(t) || function(t, e) {
                        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) {
                            var i = [],
                                n = !0,
                                r = !1,
                                a = void 0;
                            try {
                                for (var s, o = t[Symbol.iterator](); !(n = (s = o.next()).done) && (i.push(s.value), !e || i.length !== e); n = !0);
                            } catch (t) {
                                r = !0, a = t
                            } finally {
                                try {
                                    n || null == o.return || o.return()
                                } finally {
                                    if (r) throw a
                                }
                            }
                            return i
                        }
                    }(t, e) || i(t, e) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function u(t) {
                    return function(t) {
                        if (Array.isArray(t)) return s(t)
                    }(t) || function(t) {
                        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
                    }(t) || i(t) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function i(t, e) {
                    if (t) {
                        if ("string" == typeof t) return s(t, e);
                        var i = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? s(t, e) : void 0
                    }
                }

                function s(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
                    return n
                }

                function e(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                function o(e, t) {
                    var i, n = Object.keys(e);
                    return Object.getOwnPropertySymbols && (i = Object.getOwnPropertySymbols(e), t && (i = i.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), n.push.apply(n, i)), n
                }

                function l(r) {
                    for (var t = 1; t < arguments.length; t++) {
                        var a = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? o(Object(a), !0).forEach(function(t) {
                            var e, i, n;
                            e = r, n = a[i = t], i in e ? Object.defineProperty(e, i, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : e[i] = n
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(a)) : o(Object(a)).forEach(function(t) {
                            Object.defineProperty(r, t, Object.getOwnPropertyDescriptor(a, t))
                        })
                    }
                    return r
                }
                var c = {
                    addCSS: !0,
                    thumbWidth: 15,
                    watch: !0
                };

                function p(t) {
                    return null != t ? t.constructor : null
                }

                function d(t, e) {
                    return !!(t && e && t instanceof e)
                }

                function f(t) {
                    return p(t) === String
                }

                function m(t) {
                    return Array.isArray(t)
                }

                function g(t) {
                    return d(t, NodeList)
                }

                function v(t) {
                    return d(t, Event)
                }
                var y = f,
                    b = m,
                    w = g,
                    S = function(t) {
                        return d(t, Element)
                    },
                    M = function(t) {
                        return null == t || (f(t) || m(t) || g(t)) && !t.length || p(t) === Object && !Object.keys(t).length
                    };

                function T(t) {
                    return null != t ? t.constructor : null
                }

                function C(t, e) {
                    return Boolean(t && e && t instanceof e)
                }

                function A(t) {
                    return null == t
                }

                function E(t) {
                    return T(t) === Object
                }

                function D(t) {
                    return T(t) === String
                }

                function P(t) {
                    return T(t) === Function
                }

                function L(t) {
                    return Array.isArray(t)
                }

                function k(t) {
                    return C(t, NodeList)
                }

                function O(t) {
                    return A(t) || (D(t) || L(t) || k(t)) && !t.length || E(t) && !Object.keys(t).length
                }

                function F(t) {
                    return T(t) === Boolean
                }

                function I(t) {
                    return C(t, Event)
                }

                function N(t) {
                    return C(t, KeyboardEvent)
                }

                function B(t) {
                    return C(t, TextTrack) || !A(t) && D(t.kind)
                }

                function R(t) {
                    if (C(t, window.URL)) return !0;
                    if (!D(t)) return !1;
                    var e = t;
                    t.startsWith("http://") && t.startsWith("https://") || (e = "http://".concat(t));
                    try {
                        return !O(new URL(e).hostname)
                    } catch (t) {
                        return !1
                    }
                }
                var z, G, V, U, j, H = (j = [{
                        key: "setup",
                        value: function(i, t) {
                            var e = 1 < arguments.length && void 0 !== t ? t : {},
                                n = null;
                            if (M(i) || y(i) ? n = Array.from(document.querySelectorAll(y(i) ? i : 'input[type="range"]')) : S(i) ? n = [i] : w(i) ? n = Array.from(i) : b(i) && (n = i.filter(S)), M(n)) return null;
                            var r = l({}, c, {}, e);
                            return y(i) && r.watch && new MutationObserver(function(t) {
                                Array.from(t).forEach(function(t) {
                                    Array.from(t.addedNodes).forEach(function(t) {
                                        var e;
                                        S(t) && function() {
                                            return Array.from(document.querySelectorAll(e)).includes(this)
                                        }.call(t, e = i) && new it(t, r)
                                    })
                                })
                            }).observe(document.body, {
                                childList: !0,
                                subtree: !0
                            }), n.map(function(t) {
                                return new it(t, e)
                            })
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return "ontouchstart" in document.documentElement
                        }
                    }], e((U = it).prototype, [{
                        key: "init",
                        value: function() {
                            it.enabled && (this.config.addCSS && (this.element.style.userSelect = "none", this.element.style.webKitUserSelect = "none", this.element.style.touchAction = "manipulation"), this.listeners(!0), this.element.rangeTouch = this)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            it.enabled && (this.config.addCSS && (this.element.style.userSelect = "", this.element.style.webKitUserSelect = "", this.element.style.touchAction = ""), this.listeners(!1), this.element.rangeTouch = null)
                        }
                    }, {
                        key: "listeners",
                        value: function(t) {
                            var e = this,
                                i = t ? "addEventListener" : "removeEventListener";
                            ["touchstart", "touchmove", "touchend"].forEach(function(t) {
                                e.element[i](t, function(t) {
                                    return e.set(t)
                                }, !1)
                            })
                        }
                    }, {
                        key: "get",
                        value: function(t) {
                            if (!it.enabled || !v(t)) return null;
                            var e, i = t.target,
                                n = t.changedTouches[0],
                                r = parseFloat(i.getAttribute("min")) || 0,
                                a = parseFloat(i.getAttribute("max")) || 100,
                                s = parseFloat(i.getAttribute("step")) || 1,
                                o = i.getBoundingClientRect(),
                                l = 100 / o.width * (this.config.thumbWidth / 2) / 100;
                            return (e = 100 / o.width * (n.clientX - o.left)) < 0 ? e = 0 : 100 < e && (e = 100), e < 50 ? e -= (100 - 2 * e) * l : 50 < e && (e += 2 * (e - 50) * l), r + function(t, e) {
                                if (e < 1) {
                                    var i = (n = "".concat(e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/)) ? Math.max(0, (n[1] ? n[1].length : 0) - (n[2] ? +n[2] : 0)) : 0;
                                    return parseFloat(t.toFixed(i))
                                }
                                var n;
                                return Math.round(t / e) * e
                            }(e / 100 * (a - r), s)
                        }
                    }, {
                        key: "set",
                        value: function(t) {
                            it.enabled && v(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), function(t, e) {
                                var i;
                                t && e && (i = new Event(e, {
                                    bubbles: !0
                                }), t.dispatchEvent(i))
                            }(t.target, "touchend" === t.type ? "change" : "input"))
                        }
                    }]), e(U, j), it),
                    W = A,
                    q = E,
                    X = function(t) {
                        return T(t) === Number && !Number.isNaN(t)
                    },
                    Y = D,
                    J = P,
                    Z = L,
                    $ = k,
                    K = function(t) {
                        return C(t, Element)
                    },
                    Q = function(t) {
                        return C(t, Promise) && P(t.then)
                    },
                    tt = O,
                    et = (z = document.createElement("span"), G = {
                        WebkitTransition: "webkitTransitionEnd",
                        MozTransition: "transitionend",
                        OTransition: "oTransitionEnd otransitionend",
                        transition: "transitionend"
                    }, V = Object.keys(G).find(function(t) {
                        return void 0 !== z.style[t]
                    }), !!Y(V) && G[V]);

                function it(t, e) {
                    (function(t) {
                        if (!(t instanceof it)) throw new TypeError("Cannot call a class as a function")
                    })(this), S(t) ? this.element = t : y(t) && (this.element = document.querySelector(t)), S(this.element) && M(this.element.rangeTouch) && (this.config = l({}, c, {}, e), this.init())
                }

                function nt(t, e) {
                    setTimeout(function() {
                        try {
                            t.hidden = !0, t.offsetHeight, t.hidden = !1
                        } catch (t) {}
                    }, e)
                }
                var rt = {
                    isIE: !!document.documentMode,
                    isEdge: window.navigator.userAgent.includes("Edge"),
                    isWebkit: "WebkitAppearance" in document.documentElement.style && !/Edge/.test(navigator.userAgent),
                    isIPhone: /(iPhone|iPod)/gi.test(navigator.platform),
                    isIos: /(iPad|iPhone|iPod)/gi.test(navigator.platform)
                };

                function at(t, e) {
                    return e.split(".").reduce(function(t, e) {
                        return t && t[e]
                    }, t)
                }

                function st() {
                    for (var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length, i = new Array(1 < t ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];
                    if (!i.length) return e;
                    var r = i.shift();
                    return q(r) ? (Object.keys(r).forEach(function(t) {
                        q(r[t]) ? (Object.keys(e).includes(t) || Object.assign(e, a({}, t, {})), st(e[t], r[t])) : Object.assign(e, a({}, t, r[t]))
                    }), st.apply(void 0, [e].concat(i))) : e
                }

                function ot(t, a) {
                    var e = t.length ? t : [t];
                    Array.from(e).reverse().forEach(function(t, e) {
                        var i = 0 < e ? a.cloneNode(!0) : a,
                            n = t.parentNode,
                            r = t.nextSibling;
                        i.appendChild(t), r ? n.insertBefore(i, r) : n.appendChild(i)
                    })
                }

                function lt(r, t) {
                    K(r) && !tt(t) && Object.entries(t).filter(function(t) {
                        var e = _(t, 2)[1];
                        return !W(e)
                    }).forEach(function(t) {
                        var e = _(t, 2),
                            i = e[0],
                            n = e[1];
                        return r.setAttribute(i, n)
                    })
                }

                function ht(t, e, i) {
                    var n = document.createElement(t);
                    return q(e) && lt(n, e), Y(i) && (n.innerText = i), n
                }

                function ut(t, e, i, n) {
                    K(e) && e.appendChild(ht(t, i, n))
                }

                function ct(t) {
                    $(t) || Z(t) ? Array.from(t).forEach(ct) : K(t) && K(t.parentNode) && t.parentNode.removeChild(t)
                }

                function pt(t) {
                    if (K(t))
                        for (var e = t.childNodes.length; 0 < e;) t.removeChild(t.lastChild), --e
                }

                function dt(t, e) {
                    return K(e) && K(e.parentNode) && K(t) ? (e.parentNode.replaceChild(t, e), t) : null
                }

                function ft(t, e) {
                    if (!Y(t) || tt(t)) return {};
                    var s = {},
                        o = st({}, e);
                    return t.split(",").forEach(function(t) {
                        var e = t.trim(),
                            i = e.replace(".", ""),
                            n = e.replace(/[[\]]/g, "").split("="),
                            r = _(n, 1)[0],
                            a = 1 < n.length ? n[1].replace(/["']/g, "") : "";
                        switch (e.charAt(0)) {
                            case ".":
                                Y(o.class) ? s.class = "".concat(o.class, " ").concat(i) : s.class = i;
                                break;
                            case "#":
                                s.id = e.replace("#", "");
                                break;
                            case "[":
                                s[r] = a
                        }
                    }), st(o, s)
                }

                function mt(t, e) {
                    var i;
                    K(t) && (F(i = e) || (i = !t.hidden), t.hidden = i)
                }

                function gt(t, e, i) {
                    if ($(t)) return Array.from(t).map(function(t) {
                        return gt(t, e, i)
                    });
                    if (K(t)) {
                        var n = void 0 !== i ? i ? "add" : "remove" : "toggle";
                        return t.classList[n](e), t.classList.contains(e)
                    }
                    return !1
                }

                function vt(t, e) {
                    return K(t) && t.classList.contains(e)
                }

                function yt(t, e) {
                    var i = Element.prototype;
                    return (i.matches || i.webkitMatchesSelector || i.mozMatchesSelector || i.msMatchesSelector || function() {
                        return Array.from(document.querySelectorAll(e)).includes(this)
                    }).call(t, e)
                }

                function bt(t) {
                    return this.elements.container.querySelectorAll(t)
                }

                function xt(t) {
                    return this.elements.container.querySelector(t)
                }

                function _t() {
                    var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null,
                        e = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
                    K(t) && (t.focus({
                        preventScroll: !0
                    }), e && gt(t, this.config.classNames.tabFocus))
                }
                var wt, St = {
                        "audio/ogg": "vorbis",
                        "audio/wav": "1",
                        "video/webm": "vp8, vorbis",
                        "video/mp4": "avc1.42E01E, mp4a.40.2",
                        "video/ogg": "theora"
                    },
                    Mt = {
                        audio: "canPlayType" in document.createElement("audio"),
                        video: "canPlayType" in document.createElement("video"),
                        check: function(t, e, i) {
                            var n = rt.isIPhone && i && Mt.playsinline,
                                r = Mt[t] || "html5" !== e;
                            return {
                                api: r,
                                ui: r && Mt.rangeInput && ("video" !== t || !rt.isIPhone || n)
                            }
                        },
                        pip: !(rt.isIPhone || !J(ht("video").webkitSetPresentationMode) && (!document.pictureInPictureEnabled || ht("video").disablePictureInPicture)),
                        airplay: J(window.WebKitPlaybackTargetAvailabilityEvent),
                        playsinline: "playsInline" in document.createElement("video"),
                        mime: function(t) {
                            if (tt(t)) return !1;
                            var e = _(t.split("/"), 1)[0],
                                i = t;
                            if (!this.isHTML5 || e !== this.type) return !1;
                            Object.keys(St).includes(i) && (i += '; codecs="'.concat(St[t], '"'));
                            try {
                                return Boolean(i && this.media.canPlayType(i).replace(/no/, ""))
                            } catch (t) {
                                return !1
                            }
                        },
                        textTracks: "textTracks" in document.createElement("video"),
                        rangeInput: ((wt = document.createElement("input")).type = "range") === wt.type,
                        touch: "ontouchstart" in document.documentElement,
                        transitions: !1 !== et,
                        reducedMotion: "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches
                    },
                    Tt = function() {
                        var t = !1;
                        try {
                            var e = Object.defineProperty({}, "passive", {
                                get: function() {
                                    return t = !0, null
                                }
                            });
                            window.addEventListener("test", null, e), window.removeEventListener("test", null, e)
                        } catch (t) {}
                        return t
                    }();

                function Ct(e, t, i) {
                    var n, r, a = this,
                        s = 3 < arguments.length && void 0 !== arguments[3] && arguments[3],
                        o = !(4 < arguments.length && void 0 !== arguments[4]) || arguments[4],
                        l = 5 < arguments.length && void 0 !== arguments[5] && arguments[5];
                    e && "addEventListener" in e && !tt(t) && J(i) && (n = t.split(" "), r = Tt ? {
                        passive: o,
                        capture: l
                    } : l, n.forEach(function(t) {
                        a && a.eventListeners && s && a.eventListeners.push({
                            element: e,
                            type: t,
                            callback: i,
                            options: r
                        }), e[s ? "addEventListener" : "removeEventListener"](t, i, r)
                    }))
                }

                function At(t) {
                    Ct.call(this, t, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "", 2 < arguments.length ? arguments[2] : void 0, !0, !(3 < arguments.length && void 0 !== arguments[3]) || arguments[3], 4 < arguments.length && void 0 !== arguments[4] && arguments[4])
                }

                function Et(t) {
                    Ct.call(this, t, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "", 2 < arguments.length ? arguments[2] : void 0, !1, !(3 < arguments.length && void 0 !== arguments[3]) || arguments[3], 4 < arguments.length && void 0 !== arguments[4] && arguments[4])
                }

                function Dt(r) {
                    var a = this,
                        s = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "",
                        o = 2 < arguments.length ? arguments[2] : void 0,
                        l = !(3 < arguments.length && void 0 !== arguments[3]) || arguments[3],
                        h = 4 < arguments.length && void 0 !== arguments[4] && arguments[4];
                    Ct.call(this, r, s, function t() {
                        Et(r, s, t, l, h);
                        for (var e = arguments.length, i = new Array(e), n = 0; n < e; n++) i[n] = arguments[n];
                        o.apply(a, i)
                    }, !0, l, h)
                }

                function Pt(t) {
                    var e, i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "",
                        n = 2 < arguments.length && void 0 !== arguments[2] && arguments[2],
                        r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};
                    K(t) && !tt(i) && (e = new CustomEvent(i, {
                        bubbles: n,
                        detail: x(x({}, r), {}, {
                            plyr: this
                        })
                    }), t.dispatchEvent(e))
                }

                function Lt(t) {
                    Q(t) && t.then(null, function() {})
                }

                function kt(t) {
                    return (Z(t) || Y(t) && t.includes(":")) && (Z(t) ? t : t.split(":")).map(Number).every(X)
                }

                function Ot(t) {
                    if (!Z(t) || !t.every(X)) return null;
                    var e = _(t, 2),
                        i = e[0],
                        n = e[1],
                        r = function t(e, i) {
                            return 0 === i ? e : t(i, e % i)
                        }(i, n);
                    return [i / r, n / r]
                }

                function Ft(t) {
                    function e(t) {
                        return kt(t) ? t.split(":").map(Number) : null
                    }
                    var i, n = e(t);
                    return null === n && (n = e(this.config.ratio)), null === n && !tt(this.embed) && Z(this.embed.ratio) && (n = this.embed.ratio), null === n && this.isHTML5 && (n = Ot([(i = this.media).videoWidth, i.videoHeight])), n
                }

                function It(t) {
                    if (!this.isVideo) return {};
                    var e, i, n = this.elements.wrapper,
                        r = Ft.call(this, t),
                        a = _(Z(r) ? r : [0, 0], 2),
                        s = 100 / a[0] * a[1];
                    return n.style.paddingBottom = "".concat(s, "%"), this.isVimeo && !this.config.vimeo.premium && this.supported.ui ? (i = ((e = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10)) - s) / (e / 50), this.media.style.transform = "translateY(-".concat(i, "%)")) : this.isHTML5 && n.classList.toggle(this.config.classNames.videoFixedRatio, null !== r), {
                        padding: s,
                        ratio: r
                    }
                }
                var Nt = {
                    getSources: function() {
                        var i = this;
                        return this.isHTML5 ? Array.from(this.media.querySelectorAll("source")).filter(function(t) {
                            var e = t.getAttribute("type");
                            return !!tt(e) || Mt.mime.call(i, e)
                        }) : []
                    },
                    getQualityOptions: function() {
                        return this.config.quality.forced ? this.config.quality.options : Nt.getSources.call(this).map(function(t) {
                            return Number(t.getAttribute("size"))
                        }).filter(Boolean)
                    },
                    setup: function() {
                        var l;
                        this.isHTML5 && ((l = this).options.speed = l.config.speed.options, tt(this.config.ratio) || It.call(l), Object.defineProperty(l.media, "quality", {
                            get: function() {
                                var t = Nt.getSources.call(l).find(function(t) {
                                    return t.getAttribute("src") === l.source
                                });
                                return t && Number(t.getAttribute("size"))
                            },
                            set: function(e) {
                                if (l.quality !== e) {
                                    if (l.config.quality.forced && J(l.config.quality.onChange)) l.config.quality.onChange(e);
                                    else {
                                        var t = Nt.getSources.call(l).find(function(t) {
                                            return Number(t.getAttribute("size")) === e
                                        });
                                        if (!t) return;
                                        var i = l.media,
                                            n = i.currentTime,
                                            r = i.paused,
                                            a = i.preload,
                                            s = i.readyState,
                                            o = i.playbackRate;
                                        l.media.src = t.getAttribute("src"), "none" === a && !s || (l.once("loadedmetadata", function() {
                                            l.speed = o, l.currentTime = n, r || Lt(l.play())
                                        }), l.media.load())
                                    }
                                    Pt.call(l, l.media, "qualitychange", !1, {
                                        quality: e
                                    })
                                }
                            }
                        }))
                    },
                    cancelRequests: function() {
                        this.isHTML5 && (ct(Nt.getSources.call(this)), this.media.setAttribute("src", this.config.blankVideo), this.media.load(), this.debug.log("Cancelled network requests"))
                    }
                };

                function Bt(i) {
                    return Z(i) ? i.filter(function(t, e) {
                        return i.indexOf(t) === e
                    }) : i
                }

                function Rt(t) {
                    for (var e = arguments.length, i = new Array(1 < e ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];
                    return tt(t) ? t : t.toString().replace(/{(\d+)}/g, function(t, e) {
                        return i[e].toString()
                    })
                }

                function zt(t, e, i) {
                    var n = 1 < arguments.length && void 0 !== e ? e : "",
                        r = 2 < arguments.length && void 0 !== i ? i : "";
                    return (0 < arguments.length && void 0 !== t ? t : "").replace(new RegExp(n.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "g"), r.toString())
                }

                function Gt(t) {
                    return (0 < arguments.length && void 0 !== t ? t : "").toString().replace(/\w\S*/g, function(t) {
                        return t.charAt(0).toUpperCase() + t.substr(1).toLowerCase()
                    })
                }

                function Vt(t) {
                    var e = document.createElement("div");
                    return e.appendChild(t), e.innerHTML
                }

                function Ut(t, e) {
                    var i = 0 < arguments.length && void 0 !== t ? t : "",
                        n = 1 < arguments.length && void 0 !== e ? e : {};
                    if (tt(i) || tt(n)) return "";
                    var r = at(n.i18n, i);
                    if (tt(r)) return Object.keys(jt).includes(i) ? jt[i] : "";
                    var a = {
                        "{seektime}": n.seekTime,
                        "{title}": n.title
                    };
                    return Object.entries(a).forEach(function(t) {
                        var e = _(t, 2),
                            i = e[0],
                            n = e[1];
                        r = zt(r, i, n)
                    }), r
                }
                var jt = {
                        pip: "PIP",
                        airplay: "AirPlay",
                        html5: "HTML5",
                        vimeo: "Vimeo",
                        youtube: "YouTube"
                    },
                    Ht = (t(Wt, [{
                        key: "get",
                        value: function(t) {
                            if (!Wt.supported || !this.enabled) return null;
                            var e = window.localStorage.getItem(this.key);
                            if (tt(e)) return null;
                            var i = JSON.parse(e);
                            return Y(t) && t.length ? i[t] : i
                        }
                    }, {
                        key: "set",
                        value: function(t) {
                            var e;
                            Wt.supported && this.enabled && q(t) && (e = this.get(), tt(e) && (e = {}), st(e, t), window.localStorage.setItem(this.key, JSON.stringify(e)))
                        }
                    }], [{
                        key: "supported",
                        get: function() {
                            try {
                                return "localStorage" in window && (window.localStorage.setItem("___test", "___test"), window.localStorage.removeItem("___test"), !0)
                            } catch (t) {
                                return !1
                            }
                        }
                    }]), Wt);

                function Wt(t) {
                    h(this, Wt), this.enabled = t.config.storage.enabled, this.key = t.config.storage.key
                }

                function qt(t, e) {
                    var r = 1 < arguments.length && void 0 !== e ? e : "text";
                    return new Promise(function(e, i) {
                        try {
                            var n = new XMLHttpRequest;
                            if (!("withCredentials" in n)) return;
                            n.addEventListener("load", function() {
                                if ("text" === r) try {
                                    e(JSON.parse(n.responseText))
                                } catch (t) {
                                    e(n.responseText)
                                } else e(n.response)
                            }), n.addEventListener("error", function() {
                                throw new Error(n.status)
                            }), n.open("GET", t, !0), n.responseType = r, n.send()
                        } catch (t) {
                            i(t)
                        }
                    })
                }

                function Xt(t, e) {
                    var i, n, r, a, s, o, l;
                    Y(t) && (i = Y(e), n = function() {
                        return null !== document.getElementById(e)
                    }, r = function(t, e) {
                        t.innerHTML = e, i && n() || document.body.insertAdjacentElement("afterbegin", t)
                    }, i && n() || (a = Ht.supported, (s = document.createElement("div")).setAttribute("hidden", ""), i && s.setAttribute("id", e), a && null !== (o = window.localStorage.getItem("".concat("cache", "-").concat(e))) && (l = JSON.parse(o), r(s, l.content)), qt(t).then(function(t) {
                        tt(t) || (a && window.localStorage.setItem("".concat("cache", "-").concat(e), JSON.stringify({
                            content: t
                        })), r(s, t))
                    }).catch(function() {})))
                }
                var Yt = function(t) {
                        return Math.trunc(t / 60 / 60 % 60, 10)
                    },
                    Jt = function(t) {
                        return Math.trunc(t / 60 % 60, 10)
                    },
                    Zt = function(t) {
                        return Math.trunc(t % 60, 10)
                    };

                function $t(t, e, i) {
                    var n = 0 < arguments.length && void 0 !== t ? t : 0,
                        r = 1 < arguments.length && void 0 !== e && e,
                        a = 2 < arguments.length && void 0 !== i && i;
                    if (!X(n)) return $t(void 0, r, a);

                    function s(t) {
                        return "0".concat(t).slice(-2)
                    }
                    var o = Yt(n),
                        l = Jt(n),
                        h = Zt(n),
                        o = r || 0 < o ? "".concat(o, ":") : "";
                    return "".concat(a && 0 < n ? "-" : "").concat(o).concat(s(l), ":").concat(s(h))
                }
                var Kt = {
                    getIconUrl: function() {
                        var t = new URL(this.config.iconUrl, window.location).host !== window.location.host || rt.isIE && !window.svg4everybody;
                        return {
                            url: this.config.iconUrl,
                            cors: t
                        }
                    },
                    findElements: function() {
                        try {
                            return this.elements.controls = xt.call(this, this.config.selectors.controls.wrapper), this.elements.buttons = {
                                play: bt.call(this, this.config.selectors.buttons.play),
                                pause: xt.call(this, this.config.selectors.buttons.pause),
                                restart: xt.call(this, this.config.selectors.buttons.restart),
                                rewind: xt.call(this, this.config.selectors.buttons.rewind),
                                fastForward: xt.call(this, this.config.selectors.buttons.fastForward),
                                mute: xt.call(this, this.config.selectors.buttons.mute),
                                pip: xt.call(this, this.config.selectors.buttons.pip),
                                airplay: xt.call(this, this.config.selectors.buttons.airplay),
                                settings: xt.call(this, this.config.selectors.buttons.settings),
                                captions: xt.call(this, this.config.selectors.buttons.captions),
                                fullscreen: xt.call(this, this.config.selectors.buttons.fullscreen)
                            }, this.elements.progress = xt.call(this, this.config.selectors.progress), this.elements.inputs = {
                                seek: xt.call(this, this.config.selectors.inputs.seek),
                                volume: xt.call(this, this.config.selectors.inputs.volume)
                            }, this.elements.display = {
                                buffer: xt.call(this, this.config.selectors.display.buffer),
                                currentTime: xt.call(this, this.config.selectors.display.currentTime),
                                duration: xt.call(this, this.config.selectors.display.duration)
                            }, K(this.elements.progress) && (this.elements.display.seekTooltip = this.elements.progress.querySelector(".".concat(this.config.classNames.tooltip))), !0
                        } catch (t) {
                            return this.debug.warn("It looks like there is a problem with your custom controls HTML", t), this.toggleNativeControls(!0), !1
                        }
                    },
                    createIcon: function(t, e) {
                        var i = Kt.getIconUrl.call(this),
                            n = "".concat(i.cors ? "" : i.url, "#").concat(this.config.iconPrefix),
                            r = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                        lt(r, st(e, {
                            "aria-hidden": "true",
                            focusable: "false"
                        }));
                        var a = document.createElementNS("http://www.w3.org/2000/svg", "use"),
                            s = "".concat(n, "-").concat(t);
                        return "href" in a && a.setAttributeNS("http://www.w3.org/1999/xlink", "href", s), a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", s), r.appendChild(a), r
                    },
                    createLabel: function(t, e) {
                        var i = 1 < arguments.length && void 0 !== e ? e : {},
                            n = Ut(t, this.config);
                        return ht("span", x(x({}, i), {}, {
                            class: [i.class, this.config.classNames.hidden].filter(Boolean).join(" ")
                        }), n)
                    },
                    createBadge: function(t) {
                        if (tt(t)) return null;
                        var e = ht("span", {
                            class: this.config.classNames.menu.value
                        });
                        return e.appendChild(ht("span", {
                            class: this.config.classNames.menu.badge
                        }, t)), e
                    },
                    createButton: function(t, e) {
                        var i = this,
                            n = st({}, e),
                            r = function(t) {
                                var e = (0 < arguments.length && void 0 !== t ? t : "").toString();
                                return (e = function(t) {
                                    var e = (0 < arguments.length && void 0 !== t ? t : "").toString(),
                                        e = zt(e, "-", " ");
                                    return e = zt(e, "_", " "), e = Gt(e), zt(e, " ", "")
                                }(e)).charAt(0).toLowerCase() + e.slice(1)
                            }(t),
                            a = {
                                element: "button",
                                toggle: !1,
                                label: null,
                                icon: null,
                                labelPressed: null,
                                iconPressed: null
                            };
                        switch (["element", "icon", "label"].forEach(function(t) {
                            Object.keys(n).includes(t) && (a[t] = n[t], delete n[t])
                        }), "button" !== a.element || Object.keys(n).includes("type") || (n.type = "button"), Object.keys(n).includes("class") ? n.class.split(" ").some(function(t) {
                            return t === i.config.classNames.control
                        }) || st(n, {
                            class: "".concat(n.class, " ").concat(this.config.classNames.control)
                        }) : n.class = this.config.classNames.control, t) {
                            case "play":
                                a.toggle = !0, a.label = "play", a.labelPressed = "pause", a.icon = "play", a.iconPressed = "pause";
                                break;
                            case "mute":
                                a.toggle = !0, a.label = "mute", a.labelPressed = "unmute", a.icon = "volume", a.iconPressed = "muted";
                                break;
                            case "captions":
                                a.toggle = !0, a.label = "enableCaptions", a.labelPressed = "disableCaptions", a.icon = "captions-off", a.iconPressed = "captions-on";
                                break;
                            case "fullscreen":
                                a.toggle = !0, a.label = "enterFullscreen", a.labelPressed = "exitFullscreen", a.icon = "enter-fullscreen", a.iconPressed = "exit-fullscreen";
                                break;
                            case "play-large":
                                n.class += " ".concat(this.config.classNames.control, "--overlaid"), r = "play", a.label = "play", a.icon = "play";
                                break;
                            default:
                                tt(a.label) && (a.label = r), tt(a.icon) && (a.icon = t)
                        }
                        var s = ht(a.element);
                        return a.toggle ? (s.appendChild(Kt.createIcon.call(this, a.iconPressed, {
                            class: "icon--pressed"
                        })), s.appendChild(Kt.createIcon.call(this, a.icon, {
                            class: "icon--not-pressed"
                        })), s.appendChild(Kt.createLabel.call(this, a.labelPressed, {
                            class: "label--pressed"
                        })), s.appendChild(Kt.createLabel.call(this, a.label, {
                            class: "label--not-pressed"
                        }))) : (s.appendChild(Kt.createIcon.call(this, a.icon)), s.appendChild(Kt.createLabel.call(this, a.label))), st(n, ft(this.config.selectors.buttons[r], n)), lt(s, n), "play" === r ? (Z(this.elements.buttons[r]) || (this.elements.buttons[r] = []), this.elements.buttons[r].push(s)) : this.elements.buttons[r] = s, s
                    },
                    createRange: function(t, e) {
                        var i = ht("input", st(ft(this.config.selectors.inputs[t]), {
                            type: "range",
                            min: 0,
                            max: 100,
                            step: .01,
                            value: 0,
                            autocomplete: "off",
                            role: "slider",
                            "aria-label": Ut(t, this.config),
                            "aria-valuemin": 0,
                            "aria-valuemax": 100,
                            "aria-valuenow": 0
                        }, e));
                        return this.elements.inputs[t] = i, Kt.updateRangeFill.call(this, i), H.setup(i), i
                    },
                    createProgress: function(t, e) {
                        var i, n, r = ht("progress", st(ft(this.config.selectors.display[t]), {
                            min: 0,
                            max: 100,
                            value: 0,
                            role: "progressbar",
                            "aria-hidden": !0
                        }, e));
                        return "volume" !== t && (r.appendChild(ht("span", null, "0")), n = (i = {
                            played: "played",
                            buffer: "buffered"
                        }[t]) ? Ut(i, this.config) : "", r.innerText = "% ".concat(n.toLowerCase())), this.elements.display[t] = r
                    },
                    createTime: function(t, e) {
                        var i = ft(this.config.selectors.display[t], e),
                            n = ht("div", st(i, {
                                class: "".concat(i.class ? i.class : "", " ").concat(this.config.classNames.display.time, " ").trim(),
                                "aria-label": Ut(t, this.config)
                            }), "00:00");
                        return this.elements.display[t] = n
                    },
                    bindMenuItemShortcuts: function(n, r) {
                        var a = this;
                        At.call(this, n, "keydown keyup", function(t) {
                            var e, i;
                            [32, 38, 39, 40].includes(t.which) && (t.preventDefault(), t.stopPropagation(), "keydown" !== t.type) && (!(i = yt(n, '[role="menuitemradio"]')) && [32, 39].includes(t.which) ? Kt.showMenuPanel.call(a, r, !0) : 32 !== t.which && (40 === t.which || i && 39 === t.which ? (e = n.nextElementSibling, K(e) || (e = n.parentNode.firstElementChild)) : (e = n.previousElementSibling, K(e) || (e = n.parentNode.lastElementChild)), _t.call(a, e, !0)))
                        }, !1), At.call(this, n, "keyup", function(t) {
                            13 === t.which && Kt.focusFirstMenuItem.call(a, null, !0)
                        })
                    },
                    createMenuItem: function(t) {
                        var e = this,
                            i = t.value,
                            n = t.list,
                            r = t.type,
                            a = t.title,
                            s = t.badge,
                            o = void 0 === s ? null : s,
                            l = t.checked,
                            h = void 0 !== l && l,
                            u = ft(this.config.selectors.inputs[r]),
                            c = ht("button", st(u, {
                                type: "button",
                                role: "menuitemradio",
                                class: "".concat(this.config.classNames.control, " ").concat(u.class ? u.class : "").trim(),
                                "aria-checked": h,
                                value: i
                            })),
                            p = ht("span");
                        p.innerHTML = a, K(o) && p.appendChild(o), c.appendChild(p), Object.defineProperty(c, "checked", {
                            enumerable: !0,
                            get: function() {
                                return "true" === c.getAttribute("aria-checked")
                            },
                            set: function(t) {
                                t && Array.from(c.parentNode.children).filter(function(t) {
                                    return yt(t, '[role="menuitemradio"]')
                                }).forEach(function(t) {
                                    return t.setAttribute("aria-checked", "false")
                                }), c.setAttribute("aria-checked", t ? "true" : "false")
                            }
                        }), this.listeners.bind(c, "click keyup", function(t) {
                            if (!N(t) || 32 === t.which) {
                                switch (t.preventDefault(), t.stopPropagation(), c.checked = !0, r) {
                                    case "language":
                                        e.currentTrack = Number(i);
                                        break;
                                    case "quality":
                                        e.quality = i;
                                        break;
                                    case "speed":
                                        e.speed = parseFloat(i)
                                }
                                Kt.showMenuPanel.call(e, "home", N(t))
                            }
                        }, r, !1), Kt.bindMenuItemShortcuts.call(this, c, r), n.appendChild(c)
                    },
                    formatTime: function(t, e) {
                        var i = 0 < arguments.length && void 0 !== t ? t : 0,
                            n = 1 < arguments.length && void 0 !== e && e;
                        return X(i) ? $t(i, 0 < Yt(this.duration), n) : i
                    },
                    updateTimeDisplay: function(t, e, i) {
                        var n = 0 < arguments.length && void 0 !== t ? t : null,
                            r = 1 < arguments.length && void 0 !== e ? e : 0,
                            a = 2 < arguments.length && void 0 !== i && i;
                        K(n) && X(r) && (n.innerText = Kt.formatTime(r, a))
                    },
                    updateVolume: function() {
                        this.supported.ui && (K(this.elements.inputs.volume) && Kt.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume), K(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || 0 === this.volume))
                    },
                    setRange: function(t, e) {
                        var i = 1 < arguments.length && void 0 !== e ? e : 0;
                        K(t) && (t.value = i, Kt.updateRangeFill.call(this, t))
                    },
                    updateProgress: function(t) {
                        var e, i, n, r, a, s = this;
                        if (this.supported.ui && I(t)) {
                            var o, l, h = 0;
                            if (t) switch (t.type) {
                                case "timeupdate":
                                case "seeking":
                                case "seeked":
                                    o = this.currentTime, l = this.duration, h = 0 === o || 0 === l || Number.isNaN(o) || Number.isNaN(l) ? 0 : (o / l * 100).toFixed(2), "timeupdate" === t.type && Kt.setRange.call(this, this.elements.inputs.seek, h);
                                    break;
                                case "playing":
                                case "progress":
                                    e = this.elements.display.buffer, i = 100 * this.buffered, r = X(i) ? i : 0, a = K(e) ? e : s.elements.display.buffer, K(a) && (a.value = r, n = a.getElementsByTagName("span")[0], K(n) && (n.childNodes[0].nodeValue = r))
                            }
                        }
                    },
                    updateRangeFill: function(t) {
                        var e, i, n, r, a = I(t) ? t.target : t;
                        K(a) && "range" === a.getAttribute("type") && (yt(a, this.config.selectors.inputs.seek) ? (a.setAttribute("aria-valuenow", this.currentTime), e = Kt.formatTime(this.currentTime), i = Kt.formatTime(this.duration), n = Ut("seekLabel", this.config), a.setAttribute("aria-valuetext", n.replace("{currentTime}", e).replace("{duration}", i))) : yt(a, this.config.selectors.inputs.volume) ? (r = 100 * a.value, a.setAttribute("aria-valuenow", r), a.setAttribute("aria-valuetext", "".concat(r.toFixed(1), "%"))) : a.setAttribute("aria-valuenow", a.value), rt.isWebkit && a.style.setProperty("--value", "".concat(a.value / a.max * 100, "%")))
                    },
                    updateSeekTooltip: function(t) {
                        var e = this;
                        if (this.config.tooltips.seek && K(this.elements.inputs.seek) && K(this.elements.display.seekTooltip) && 0 !== this.duration) {
                            var i = "".concat(this.config.classNames.tooltip, "--visible"),
                                n = function(t) {
                                    return gt(e.elements.display.seekTooltip, i, t)
                                };
                            if (this.touch) n(!1);
                            else {
                                var r = 0,
                                    a = this.elements.progress.getBoundingClientRect();
                                if (I(t)) r = 100 / a.width * (t.pageX - a.left);
                                else {
                                    if (!vt(this.elements.display.seekTooltip, i)) return;
                                    r = parseFloat(this.elements.display.seekTooltip.style.left, 10)
                                }
                                r < 0 ? r = 0 : 100 < r && (r = 100), Kt.updateTimeDisplay.call(this, this.elements.display.seekTooltip, this.duration / 100 * r), this.elements.display.seekTooltip.style.left = "".concat(r, "%"), I(t) && ["mouseenter", "mouseleave"].includes(t.type) && n("mouseenter" === t.type)
                            }
                        }
                    },
                    timeUpdate: function(t) {
                        var e = !K(this.elements.display.duration) && this.config.invertTime;
                        Kt.updateTimeDisplay.call(this, this.elements.display.currentTime, e ? this.duration - this.currentTime : this.currentTime, e), t && "timeupdate" === t.type && this.media.seeking || Kt.updateProgress.call(this, t)
                    },
                    durationUpdate: function() {
                        if (this.supported.ui && (this.config.invertTime || !this.currentTime)) {
                            if (this.duration >= Math.pow(2, 32)) return mt(this.elements.display.currentTime, !0), void mt(this.elements.progress, !0);
                            K(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute("aria-valuemax", this.duration);
                            var t = K(this.elements.display.duration);
                            !t && this.config.displayDuration && this.paused && Kt.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration), t && Kt.updateTimeDisplay.call(this, this.elements.display.duration, this.duration), Kt.updateSeekTooltip.call(this)
                        }
                    },
                    toggleMenuButton: function(t, e) {
                        mt(this.elements.settings.buttons[t], !e)
                    },
                    updateSetting: function(t, e, i) {
                        var n, r = this.elements.settings.panels[t],
                            a = null,
                            s = e;
                        if ("captions" === t) a = this.currentTrack;
                        else {
                            if (a = tt(i) ? this[t] : i, tt(a) && (a = this.config[t].default), !tt(this.options[t]) && !this.options[t].includes(a)) return void this.debug.warn("Unsupported value of '".concat(a, "' for ").concat(t));
                            if (!this.config[t].options.includes(a)) return void this.debug.warn("Disabled value of '".concat(a, "' for ").concat(t))
                        }
                        K(s) || (s = r && r.querySelector('[role="menu"]')), K(s) && (this.elements.settings.buttons[t].querySelector(".".concat(this.config.classNames.menu.value)).innerHTML = Kt.getLabel.call(this, t, a), n = s && s.querySelector('[value="'.concat(a, '"]')), K(n) && (n.checked = !0))
                    },
                    getLabel: function(t, e) {
                        switch (t) {
                            case "speed":
                                return 1 === e ? Ut("normal", this.config) : "".concat(e, "&times;");
                            case "quality":
                                if (X(e)) {
                                    var i = Ut("qualityLabel.".concat(e), this.config);
                                    return i.length ? i : "".concat(e, "p")
                                }
                                return Gt(e);
                            case "captions":
                                return ie.getLabel.call(this);
                            default:
                                return null
                        }
                    },
                    setQualityMenu: function(t) {
                        var i, e, n = this;
                        K(this.elements.settings.panels.quality) && (i = this.elements.settings.panels.quality.querySelector('[role="menu"]'), Z(t) && (this.options.quality = Bt(t).filter(function(t) {
                            return n.config.quality.options.includes(t)
                        })), e = !tt(this.options.quality) && 1 < this.options.quality.length, Kt.toggleMenuButton.call(this, "quality", e), pt(i), Kt.checkMenu.call(this), e && (this.options.quality.sort(function(t, e) {
                            var i = n.config.quality.options;
                            return i.indexOf(t) > i.indexOf(e) ? 1 : -1
                        }).forEach(function(t) {
                            var e;
                            Kt.createMenuItem.call(n, {
                                value: t,
                                list: i,
                                type: "quality",
                                title: Kt.getLabel.call(n, "quality", t),
                                badge: (e = Ut("qualityBadge.".concat(t), n.config)).length ? Kt.createBadge.call(n, e) : null
                            })
                        }), Kt.updateSetting.call(this, "quality", i)))
                    },
                    setCaptionsMenu: function() {
                        var i, t, e, n, r = this;
                        K(this.elements.settings.panels.captions) && (i = this.elements.settings.panels.captions.querySelector('[role="menu"]'), t = ie.getTracks.call(this), e = Boolean(t.length), Kt.toggleMenuButton.call(this, "captions", e), pt(i), Kt.checkMenu.call(this), e && ((n = t.map(function(t, e) {
                            return {
                                value: e,
                                checked: r.captions.toggled && r.currentTrack === e,
                                title: ie.getLabel.call(r, t),
                                badge: t.language && Kt.createBadge.call(r, t.language.toUpperCase()),
                                list: i,
                                type: "language"
                            }
                        })).unshift({
                            value: -1,
                            checked: !this.captions.toggled,
                            title: Ut("disabled", this.config),
                            list: i,
                            type: "language"
                        }), n.forEach(Kt.createMenuItem.bind(this)), Kt.updateSetting.call(this, "captions", i)))
                    },
                    setSpeedMenu: function() {
                        var e, t, i = this;
                        K(this.elements.settings.panels.speed) && (e = this.elements.settings.panels.speed.querySelector('[role="menu"]'), this.options.speed = this.options.speed.filter(function(t) {
                            return t >= i.minimumSpeed && t <= i.maximumSpeed
                        }), t = !tt(this.options.speed) && 1 < this.options.speed.length, Kt.toggleMenuButton.call(this, "speed", t), pt(e), Kt.checkMenu.call(this), t && (this.options.speed.forEach(function(t) {
                            Kt.createMenuItem.call(i, {
                                value: t,
                                list: e,
                                type: "speed",
                                title: Kt.getLabel.call(i, "speed", t)
                            })
                        }), Kt.updateSetting.call(this, "speed", e)))
                    },
                    checkMenu: function() {
                        var t = this.elements.settings.buttons,
                            e = !tt(t) && Object.values(t).some(function(t) {
                                return !t.hidden
                            });
                        mt(this.elements.settings.menu, !e)
                    },
                    focusFirstMenuItem: function(t, e) {
                        var i, n, r = 1 < arguments.length && void 0 !== e && e;
                        this.elements.settings.popup.hidden || (K(i = t) || (i = Object.values(this.elements.settings.panels).find(function(t) {
                            return !t.hidden
                        })), n = i.querySelector('[role^="menuitem"]'), _t.call(this, n, r))
                    },
                    toggleMenu: function(t) {
                        var e = this.elements.settings.popup,
                            i = this.elements.buttons.settings;
                        if (K(e) && K(i)) {
                            var n = e.hidden,
                                r = n;
                            if (F(t)) r = t;
                            else if (N(t) && 27 === t.which) r = !1;
                            else if (I(t)) {
                                var a = J(t.composedPath) ? t.composedPath()[0] : t.target,
                                    s = e.contains(a);
                                if (s || !s && t.target !== i && r) return
                            }
                            i.setAttribute("aria-expanded", r), mt(e, !r), gt(this.elements.container, this.config.classNames.menu.open, r), r && N(t) ? Kt.focusFirstMenuItem.call(this, null, !0) : r || n || _t.call(this, i, N(t))
                        }
                    },
                    getMenuSize: function(t) {
                        var e = t.cloneNode(!0);
                        e.style.position = "absolute", e.style.opacity = 0, e.removeAttribute("hidden"), t.parentNode.appendChild(e);
                        var i = e.scrollWidth,
                            n = e.scrollHeight;
                        return ct(e), {
                            width: i,
                            height: n
                        }
                    },
                    showMenuPanel: function(t, e) {
                        var i, n, r, a = this,
                            s = 0 < arguments.length && void 0 !== t ? t : "",
                            o = 1 < arguments.length && void 0 !== e && e,
                            l = this.elements.container.querySelector("#plyr-settings-".concat(this.id, "-").concat(s));
                        K(l) && (i = l.parentNode, n = Array.from(i.children).find(function(t) {
                            return !t.hidden
                        }), Mt.transitions && !Mt.reducedMotion && (i.style.width = "".concat(n.scrollWidth, "px"), i.style.height = "".concat(n.scrollHeight, "px"), r = Kt.getMenuSize.call(this, l), At.call(this, i, et, function t(e) {
                            e.target === i && ["width", "height"].includes(e.propertyName) && (i.style.width = "", i.style.height = "", Et.call(a, i, et, t))
                        }), i.style.width = "".concat(r.width, "px"), i.style.height = "".concat(r.height, "px")), mt(n, !0), mt(l, !1), Kt.focusFirstMenuItem.call(this, l, o))
                    },
                    setDownloadUrl: function() {
                        var t = this.elements.buttons.download;
                        K(t) && t.setAttribute("href", this.download)
                    },
                    create: function(d) {
                        var f = this,
                            m = Kt.bindMenuItemShortcuts,
                            g = Kt.createButton,
                            v = Kt.createProgress,
                            y = Kt.createRange,
                            b = Kt.createTime,
                            t = Kt.setQualityMenu,
                            e = Kt.setSpeedMenu,
                            x = Kt.showMenuPanel;
                        this.elements.controls = null, Z(this.config.controls) && this.config.controls.includes("play-large") && this.elements.container.appendChild(g.call(this, "play-large"));
                        var _ = ht("div", ft(this.config.selectors.controls.wrapper));
                        this.elements.controls = _;
                        var w = {
                            class: "plyr__controls__item"
                        };
                        return Bt(Z(this.config.controls) ? this.config.controls : []).forEach(function(t) {
                            var e, i, n, r, a, s, o, l, h, u, c, p;
                            "restart" === t && _.appendChild(g.call(f, "restart", w)), "rewind" === t && _.appendChild(g.call(f, "rewind", w)), "play" === t && _.appendChild(g.call(f, "play", w)), "fast-forward" === t && _.appendChild(g.call(f, "fast-forward", w)), "progress" === t && (e = ht("div", {
                                class: "".concat(w.class, " plyr__progress__container")
                            }), (i = ht("div", ft(f.config.selectors.progress))).appendChild(y.call(f, "seek", {
                                id: "plyr-seek-".concat(d.id)
                            })), i.appendChild(v.call(f, "buffer")), f.config.tooltips.seek && (n = ht("span", {
                                class: f.config.classNames.tooltip
                            }, "00:00"), i.appendChild(n), f.elements.display.seekTooltip = n), f.elements.progress = i, e.appendChild(f.elements.progress), _.appendChild(e)), "current-time" === t && _.appendChild(b.call(f, "currentTime", w)), "duration" === t && _.appendChild(b.call(f, "duration", w)), "mute" !== t && "volume" !== t || (r = f.elements.volume, K(r) && _.contains(r) || (r = ht("div", st({}, w, {
                                class: "".concat(w.class, " plyr__volume").trim()
                            })), f.elements.volume = r, _.appendChild(r)), "mute" === t && r.appendChild(g.call(f, "mute")), "volume" !== t || rt.isIos || (a = {
                                max: 1,
                                step: .05,
                                value: f.config.volume
                            }, r.appendChild(y.call(f, "volume", st(a, {
                                id: "plyr-volume-".concat(d.id)
                            }))))), "captions" === t && _.appendChild(g.call(f, "captions", w)), "settings" !== t || tt(f.config.settings) || ((s = ht("div", st({}, w, {
                                class: "".concat(w.class, " plyr__menu").trim(),
                                hidden: ""
                            }))).appendChild(g.call(f, "settings", {
                                "aria-haspopup": !0,
                                "aria-controls": "plyr-settings-".concat(d.id),
                                "aria-expanded": !1
                            })), o = ht("div", {
                                class: "plyr__menu__container",
                                id: "plyr-settings-".concat(d.id),
                                hidden: ""
                            }), l = ht("div"), h = ht("div", {
                                id: "plyr-settings-".concat(d.id, "-home")
                            }), u = ht("div", {
                                role: "menu"
                            }), h.appendChild(u), l.appendChild(h), f.elements.settings.panels.home = h, f.config.settings.forEach(function(t) {
                                var e = ht("button", st(ft(f.config.selectors.buttons.settings), {
                                    type: "button",
                                    class: "".concat(f.config.classNames.control, " ").concat(f.config.classNames.control, "--forward"),
                                    role: "menuitem",
                                    "aria-haspopup": !0,
                                    hidden: ""
                                }));
                                m.call(f, e, t), At.call(f, e, "click", function() {
                                    x.call(f, t, !1)
                                });
                                var i = ht("span", null, Ut(t, f.config)),
                                    n = ht("span", {
                                        class: f.config.classNames.menu.value
                                    });
                                n.innerHTML = d[t], i.appendChild(n), e.appendChild(i), u.appendChild(e);
                                var r = ht("div", {
                                        id: "plyr-settings-".concat(d.id, "-").concat(t),
                                        hidden: ""
                                    }),
                                    a = ht("button", {
                                        type: "button",
                                        class: "".concat(f.config.classNames.control, " ").concat(f.config.classNames.control, "--back")
                                    });
                                a.appendChild(ht("span", {
                                    "aria-hidden": !0
                                }, Ut(t, f.config))), a.appendChild(ht("span", {
                                    class: f.config.classNames.hidden
                                }, Ut("menuBack", f.config))), At.call(f, r, "keydown", function(t) {
                                    37 === t.which && (t.preventDefault(), t.stopPropagation(), x.call(f, "home", !0))
                                }, !1), At.call(f, a, "click", function() {
                                    x.call(f, "home", !1)
                                }), r.appendChild(a), r.appendChild(ht("div", {
                                    role: "menu"
                                })), l.appendChild(r), f.elements.settings.buttons[t] = e, f.elements.settings.panels[t] = r
                            }), o.appendChild(l), s.appendChild(o), _.appendChild(s), f.elements.settings.popup = o, f.elements.settings.menu = s), "pip" === t && Mt.pip && _.appendChild(g.call(f, "pip", w)), "airplay" === t && Mt.airplay && _.appendChild(g.call(f, "airplay", w)), "download" === t && (c = st({}, w, {
                                element: "a",
                                href: f.download,
                                target: "_blank"
                            }), f.isHTML5 && (c.download = ""), p = f.config.urls.download, !R(p) && f.isEmbed && st(c, {
                                icon: "logo-".concat(f.provider),
                                label: f.provider
                            }), _.appendChild(g.call(f, "download", c))), "fullscreen" === t && _.appendChild(g.call(f, "fullscreen", w))
                        }), this.isHTML5 && t.call(this, Nt.getQualityOptions.call(this)), e.call(this), _
                    },
                    inject: function() {
                        var t, n = this;
                        !this.config.loadSprite || (t = Kt.getIconUrl.call(this)).cors && Xt(t.url, "sprite-plyr"), this.id = Math.floor(1e4 * Math.random());
                        var e = null;
                        this.elements.controls = null;
                        var r, i, a, s, o, l, h, u, c = {
                                id: this.id,
                                seektime: this.config.seekTime,
                                title: this.config.title
                            },
                            p = !0;
                        J(this.config.controls) && (this.config.controls = this.config.controls.call(this, c)), this.config.controls || (this.config.controls = []), K(this.config.controls) || Y(this.config.controls) ? e = this.config.controls : (e = Kt.create.call(this, {
                            id: this.id,
                            seektime: this.config.seekTime,
                            speed: this.speed,
                            quality: this.quality,
                            captions: ie.getLabel.call(this)
                        }), p = !1), p && Y(this.config.controls) && (r = e, Object.entries(c).forEach(function(t) {
                            var e = _(t, 2),
                                i = e[0],
                                n = e[1];
                            r = zt(r, "{".concat(i, "}"), n)
                        }), e = r), Y(this.config.selectors.controls.container) && (i = document.querySelector(this.config.selectors.controls.container)), K(i) || (i = this.elements.container), i[K(e) ? "insertAdjacentElement" : "insertAdjacentHTML"]("afterbegin", e), K(this.elements.controls) || Kt.findElements.call(this), tt(this.elements.buttons) || (a = function(e) {
                            var i = n.config.classNames.controlPressed;
                            Object.defineProperty(e, "pressed", {
                                enumerable: !0,
                                get: function() {
                                    return vt(e, i)
                                },
                                set: function(t) {
                                    gt(e, i, 0 < arguments.length && void 0 !== t && t)
                                }
                            })
                        }, Object.values(this.elements.buttons).filter(Boolean).forEach(function(t) {
                            Z(t) || $(t) ? Array.from(t).filter(Boolean).forEach(a) : a(t)
                        })), rt.isEdge && nt(i), this.config.tooltips.controls && (o = (s = this.config).classNames, l = s.selectors, h = "".concat(l.controls.wrapper, " ").concat(l.labels, " .").concat(o.hidden), u = bt.call(this, h), Array.from(u).forEach(function(t) {
                            gt(t, n.config.classNames.hidden, !1), gt(t, n.config.classNames.tooltip, !0)
                        }))
                    }
                };

                function Qt(t, e) {
                    var i, n = t;
                    1 < arguments.length && void 0 !== e && !e || ((i = document.createElement("a")).href = n, n = i.href);
                    try {
                        return new URL(n)
                    } catch (t) {
                        return null
                    }
                }

                function te(t) {
                    var r = new URLSearchParams;
                    return q(t) && Object.entries(t).forEach(function(t) {
                        var e = _(t, 2),
                            i = e[0],
                            n = e[1];
                        r.set(i, n)
                    }), r
                }

                function ee() {}
                var ie = {
                        setup: function() {
                            var t, e, i, n, r, a, s;
                            this.supported.ui && (!this.isVideo || this.isYouTube || this.isHTML5 && !Mt.textTracks ? Z(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && Kt.setCaptionsMenu.call(this) : (K(this.elements.captions) || (this.elements.captions = ht("div", ft(this.config.selectors.captions)), a = this.elements.captions, s = this.elements.wrapper, K(a) && K(s) && s.parentNode.insertBefore(a, s.nextSibling)), rt.isIE && window.URL && (t = this.media.querySelectorAll("track"), Array.from(t).forEach(function(e) {
                                var t = e.getAttribute("src"),
                                    i = Qt(t);
                                null !== i && i.hostname !== window.location.href.hostname && ["http:", "https:"].includes(i.protocol) && qt(t, "blob").then(function(t) {
                                    e.setAttribute("src", window.URL.createObjectURL(t))
                                }).catch(function() {
                                    ct(e)
                                })
                            })), e = Bt((navigator.languages || [navigator.language || navigator.userLanguage || "en"]).map(function(t) {
                                return t.split("-")[0]
                            })), "auto" === (i = (this.storage.get("language") || this.config.captions.language || "auto").toLowerCase()) && (i = _(e, 1)[0]), n = this.storage.get("captions"), F(n) || (n = this.config.captions.active), Object.assign(this.captions, {
                                toggled: !1,
                                active: n,
                                language: i,
                                languages: e
                            }), this.isHTML5 && (r = this.config.captions.update ? "addtrack removetrack" : "removetrack", At.call(this, this.media.textTracks, r, ie.update.bind(this))), setTimeout(ie.update.bind(this), 0)))
                        },
                        update: function() {
                            var e = this,
                                t = ie.getTracks.call(this, !0),
                                i = this.captions,
                                n = i.active,
                                r = i.language,
                                a = i.meta,
                                s = i.currentTrackNode,
                                o = Boolean(t.find(function(t) {
                                    return t.language === r
                                }));
                            this.isHTML5 && this.isVideo && t.filter(function(t) {
                                return !a.get(t)
                            }).forEach(function(t) {
                                e.debug.log("Track added", t), a.set(t, {
                                    default: "showing" === t.mode
                                }), "showing" === t.mode && (t.mode = "hidden"), At.call(e, t, "cuechange", function() {
                                    return ie.updateCues.call(e)
                                })
                            }), (o && this.language !== r || !t.includes(s)) && (ie.setLanguage.call(this, r), ie.toggle.call(this, n && o)), gt(this.elements.container, this.config.classNames.captions.enabled, !tt(t)), Z(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && Kt.setCaptionsMenu.call(this)
                        },
                        toggle: function(t, e) {
                            var i = this,
                                n = !(1 < arguments.length && void 0 !== e) || e;
                            if (this.supported.ui) {
                                var r = this.captions.toggled,
                                    a = this.config.classNames.captions.active,
                                    s = W(t) ? !r : t;
                                if (s !== r) {
                                    if (n || (this.captions.active = s, this.storage.set({
                                            captions: s
                                        })), !this.language && s && !n) {
                                        var o = ie.getTracks.call(this),
                                            l = ie.findTrack.call(this, [this.captions.language].concat(u(this.captions.languages)), !0);
                                        return this.captions.language = l.language, void ie.set.call(this, o.indexOf(l))
                                    }
                                    this.elements.buttons.captions && (this.elements.buttons.captions.pressed = s), gt(this.elements.container, a, s), this.captions.toggled = s, Kt.updateSetting.call(this, "captions"), Pt.call(this, this.media, s ? "captionsenabled" : "captionsdisabled")
                                }
                                setTimeout(function() {
                                    s && i.captions.toggled && (i.captions.currentTrackNode.mode = "hidden")
                                })
                            }
                        },
                        set: function(t, e) {
                            var i, n, r = !(1 < arguments.length && void 0 !== e) || e,
                                a = ie.getTracks.call(this); - 1 !== t ? X(t) ? t in a ? (this.captions.currentTrack !== t && (n = ((i = a[this.captions.currentTrack = t]) || {}).language, this.captions.currentTrackNode = i, Kt.updateSetting.call(this, "captions"), r || (this.captions.language = n, this.storage.set({
                                language: n
                            })), this.isVimeo && this.embed.enableTextTrack(n), Pt.call(this, this.media, "languagechange")), ie.toggle.call(this, !0, r), this.isHTML5 && this.isVideo && ie.updateCues.call(this)) : this.debug.warn("Track not found", t) : this.debug.warn("Invalid caption argument", t) : ie.toggle.call(this, !1, r)
                        },
                        setLanguage: function(t, e) {
                            var i, n, r, a = !(1 < arguments.length && void 0 !== e) || e;
                            Y(t) ? (i = t.toLowerCase(), this.captions.language = i, n = ie.getTracks.call(this), r = ie.findTrack.call(this, [i]), ie.set.call(this, n.indexOf(r), a)) : this.debug.warn("Invalid language argument", t)
                        },
                        getTracks: function(t) {
                            var e = this,
                                i = 0 < arguments.length && void 0 !== t && t;
                            return Array.from((this.media || {}).textTracks || []).filter(function(t) {
                                return !e.isHTML5 || i || e.captions.meta.has(t)
                            }).filter(function(t) {
                                return ["captions", "subtitles"].includes(t.kind)
                            })
                        },
                        findTrack: function(t, e) {
                            function i(t) {
                                return Number((r.captions.meta.get(t) || {}).default)
                            }
                            var n, r = this,
                                a = 1 < arguments.length && void 0 !== e && e,
                                s = ie.getTracks.call(this),
                                o = Array.from(s).sort(function(t, e) {
                                    return i(e) - i(t)
                                });
                            return t.every(function(e) {
                                return !(n = o.find(function(t) {
                                    return t.language === e
                                }))
                            }), n || (a ? o[0] : void 0)
                        },
                        getCurrentTrack: function() {
                            return ie.getTracks.call(this)[this.currentTrack]
                        },
                        getLabel: function(t) {
                            var e = t;
                            return !B(e) && Mt.textTracks && this.captions.toggled && (e = ie.getCurrentTrack.call(this)), B(e) ? tt(e.label) ? tt(e.language) ? Ut("enabled", this.config) : t.language.toUpperCase() : e.label : Ut("disabled", this.config)
                        },
                        updateCues: function(t) {
                            var e, i, n, r;
                            this.supported.ui && (K(this.elements.captions) ? W(t) || Array.isArray(t) ? ((i = t) || (e = ie.getCurrentTrack.call(this), i = Array.from((e || {}).activeCues || []).map(function(t) {
                                return t.getCueAsHTML()
                            }).map(Vt)), (n = i.map(function(t) {
                                return t.trim()
                            }).join("\n")) !== this.elements.captions.innerHTML && (pt(this.elements.captions), (r = ht("span", ft(this.config.selectors.caption))).innerHTML = n, this.elements.captions.appendChild(r), Pt.call(this, this.media, "cuechange"))) : this.debug.warn("updateCues: Invalid input", t) : this.debug.warn("No captions element to render to"))
                        }
                    },
                    ne = {
                        enabled: !0,
                        title: "",
                        debug: !1,
                        autoplay: !1,
                        autopause: !0,
                        playsinline: !0,
                        seekTime: 10,
                        volume: 1,
                        muted: !1,
                        duration: null,
                        displayDuration: !0,
                        invertTime: !0,
                        toggleInvert: !0,
                        ratio: null,
                        clickToPlay: !0,
                        hideControls: !0,
                        resetOnEnd: !1,
                        disableContextMenu: !0,
                        loadSprite: !0,
                        iconPrefix: "plyr",
                        iconUrl: "https://cdn.plyr.io/3.6.2/plyr.svg",
                        blankVideo: "https://cdn.plyr.io/static/blank.mp4",
                        quality: {
                            default: 576,
                            options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],
                            forced: !1,
                            onChange: null
                        },
                        loop: {
                            active: !1
                        },
                        speed: {
                            selected: 1,
                            options: [.5, .75, 1, 1.25, 1.5, 1.75, 2, 4]
                        },
                        keyboard: {
                            focused: !0,
                            global: !1
                        },
                        tooltips: {
                            controls: !1,
                            seek: !0
                        },
                        captions: {
                            active: !1,
                            language: "auto",
                            update: !1
                        },
                        fullscreen: {
                            enabled: !0,
                            fallback: !0,
                            iosNative: !1
                        },
                        storage: {
                            enabled: !0,
                            key: "plyr"
                        },
                        controls: ["play-large", "play", "progress", "current-time", "mute", "volume", "captions", "settings", "pip", "airplay", "fullscreen"],
                        settings: ["captions", "quality", "speed"],
                        i18n: {
                            restart: "Restart",
                            rewind: "Rewind {seektime}s",
                            play: "Play",
                            pause: "Pause",
                            fastForward: "Forward {seektime}s",
                            seek: "Seek",
                            seekLabel: "{currentTime} of {duration}",
                            played: "Played",
                            buffered: "Buffered",
                            currentTime: "Current time",
                            duration: "Duration",
                            volume: "Volume",
                            mute: "Mute",
                            unmute: "Unmute",
                            enableCaptions: "Enable captions",
                            disableCaptions: "Disable captions",
                            download: "Download",
                            enterFullscreen: "Enter fullscreen",
                            exitFullscreen: "Exit fullscreen",
                            frameTitle: "Player for {title}",
                            captions: "Captions",
                            settings: "Settings",
                            pip: "PIP",
                            menuBack: "Go back to previous menu",
                            speed: "Speed",
                            normal: "Normal",
                            quality: "Quality",
                            loop: "Loop",
                            start: "Start",
                            end: "End",
                            all: "All",
                            reset: "Reset",
                            disabled: "Disabled",
                            enabled: "Enabled",
                            advertisement: "Ad",
                            qualityBadge: {
                                2160: "4K",
                                1440: "HD",
                                1080: "HD",
                                720: "HD",
                                576: "SD",
                                480: "SD"
                            }
                        },
                        urls: {
                            download: null,
                            vimeo: {
                                sdk: "https://player.vimeo.com/api/player.js",
                                iframe: "https://player.vimeo.com/video/{0}?{1}",
                                api: "https://vimeo.com/api/v2/video/{0}.json"
                            },
                            youtube: {
                                sdk: "https://www.youtube.com/iframe_api",
                                api: "https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}"
                            },
                            googleIMA: {
                                sdk: "https://imasdk.googleapis.com/js/sdkloader/ima3.js"
                            }
                        },
                        listeners: {
                            seek: null,
                            play: null,
                            pause: null,
                            restart: null,
                            rewind: null,
                            fastForward: null,
                            mute: null,
                            volume: null,
                            captions: null,
                            download: null,
                            fullscreen: null,
                            pip: null,
                            airplay: null,
                            speed: null,
                            quality: null,
                            loop: null,
                            language: null
                        },
                        events: ["ended", "progress", "stalled", "playing", "waiting", "canplay", "canplaythrough", "loadstart", "loadeddata", "loadedmetadata", "timeupdate", "volumechange", "play", "pause", "error", "seeking", "seeked", "emptied", "ratechange", "cuechange", "download", "enterfullscreen", "exitfullscreen", "captionsenabled", "captionsdisabled", "languagechange", "controlshidden", "controlsshown", "ready", "statechange", "qualitychange", "adsloaded", "adscontentpause", "adscontentresume", "adstarted", "adsmidpoint", "adscomplete", "adsallcomplete", "adsimpression", "adsclick"],
                        selectors: {
                            editable: "input, textarea, select, [contenteditable]",
                            container: ".plyr",
                            controls: {
                                container: null,
                                wrapper: ".plyr__controls"
                            },
                            labels: "[data-plyr]",
                            buttons: {
                                play: '[data-plyr="play"]',
                                pause: '[data-plyr="pause"]',
                                restart: '[data-plyr="restart"]',
                                rewind: '[data-plyr="rewind"]',
                                fastForward: '[data-plyr="fast-forward"]',
                                mute: '[data-plyr="mute"]',
                                captions: '[data-plyr="captions"]',
                                download: '[data-plyr="download"]',
                                fullscreen: '[data-plyr="fullscreen"]',
                                pip: '[data-plyr="pip"]',
                                airplay: '[data-plyr="airplay"]',
                                settings: '[data-plyr="settings"]',
                                loop: '[data-plyr="loop"]'
                            },
                            inputs: {
                                seek: '[data-plyr="seek"]',
                                volume: '[data-plyr="volume"]',
                                speed: '[data-plyr="speed"]',
                                language: '[data-plyr="language"]',
                                quality: '[data-plyr="quality"]'
                            },
                            display: {
                                currentTime: ".plyr__time--current",
                                duration: ".plyr__time--duration",
                                buffer: ".plyr__progress__buffer",
                                loop: ".plyr__progress__loop",
                                volume: ".plyr__volume--display"
                            },
                            progress: ".plyr__progress",
                            captions: ".plyr__captions",
                            caption: ".plyr__caption"
                        },
                        classNames: {
                            type: "plyr--{0}",
                            provider: "plyr--{0}",
                            video: "plyr__video-wrapper",
                            embed: "plyr__video-embed",
                            videoFixedRatio: "plyr__video-wrapper--fixed-ratio",
                            embedContainer: "plyr__video-embed__container",
                            poster: "plyr__poster",
                            posterEnabled: "plyr__poster-enabled",
                            ads: "plyr__ads",
                            control: "plyr__control",
                            controlPressed: "plyr__control--pressed",
                            playing: "plyr--playing",
                            paused: "plyr--paused",
                            stopped: "plyr--stopped",
                            loading: "plyr--loading",
                            hover: "plyr--hover",
                            tooltip: "plyr__tooltip",
                            cues: "plyr__cues",
                            hidden: "plyr__sr-only",
                            hideControls: "plyr--hide-controls",
                            isIos: "plyr--is-ios",
                            isTouch: "plyr--is-touch",
                            uiSupported: "plyr--full-ui",
                            noTransition: "plyr--no-transition",
                            display: {
                                time: "plyr__time"
                            },
                            menu: {
                                value: "plyr__menu__value",
                                badge: "plyr__badge",
                                open: "plyr--menu-open"
                            },
                            captions: {
                                enabled: "plyr--captions-enabled",
                                active: "plyr--captions-active"
                            },
                            fullscreen: {
                                enabled: "plyr--fullscreen-enabled",
                                fallback: "plyr--fullscreen-fallback"
                            },
                            pip: {
                                supported: "plyr--pip-supported",
                                active: "plyr--pip-active"
                            },
                            airplay: {
                                supported: "plyr--airplay-supported",
                                active: "plyr--airplay-active"
                            },
                            tabFocus: "plyr__tab-focus",
                            previewThumbnails: {
                                thumbContainer: "plyr__preview-thumb",
                                thumbContainerShown: "plyr__preview-thumb--is-shown",
                                imageContainer: "plyr__preview-thumb__image-container",
                                timeContainer: "plyr__preview-thumb__time-container",
                                scrubbingContainer: "plyr__preview-scrubbing",
                                scrubbingContainerShown: "plyr__preview-scrubbing--is-shown"
                            }
                        },
                        attributes: {
                            embed: {
                                provider: "data-plyr-provider",
                                id: "data-plyr-embed-id"
                            }
                        },
                        ads: {
                            enabled: !1,
                            publisherId: "",
                            tagUrl: ""
                        },
                        previewThumbnails: {
                            enabled: !1,
                            src: ""
                        },
                        vimeo: {
                            byline: !1,
                            portrait: !1,
                            title: !1,
                            speed: !0,
                            transparent: !1,
                            premium: !1,
                            referrerPolicy: null
                        },
                        youtube: {
                            noCookie: !0,
                            rel: 0,
                            showinfo: 0,
                            iv_load_policy: 3,
                            modestbranding: 1
                        }
                    },
                    re = "picture-in-picture",
                    ae = {
                        html5: "html5",
                        youtube: "youtube",
                        vimeo: "vimeo"
                    },
                    se = "video",
                    oe = (t(ue, [{
                        key: "log",
                        get: function() {
                            return this.enabled ? Function.prototype.bind.call(console.log, console) : ee
                        }
                    }, {
                        key: "warn",
                        get: function() {
                            return this.enabled ? Function.prototype.bind.call(console.warn, console) : ee
                        }
                    }, {
                        key: "error",
                        get: function() {
                            return this.enabled ? Function.prototype.bind.call(console.error, console) : ee
                        }
                    }]), ue),
                    le = (t(he, [{
                        key: "onChange",
                        value: function() {
                            var t;
                            this.enabled && (t = this.player.elements.buttons.fullscreen, K(t) && (t.pressed = this.active), Pt.call(this.player, this.target, this.active ? "enterfullscreen" : "exitfullscreen", !0))
                        }
                    }, {
                        key: "toggleFallback",
                        value: function(t) {
                            var e, i, n, r = 0 < arguments.length && void 0 !== t && t;
                            r ? this.scrollPosition = {
                                x: window.scrollX || 0,
                                y: window.scrollY || 0
                            } : window.scrollTo(this.scrollPosition.x, this.scrollPosition.y), document.body.style.overflow = r ? "hidden" : "", gt(this.target, this.player.config.classNames.fullscreen.fallback, r), rt.isIos && (e = document.head.querySelector('meta[name="viewport"]'), i = "viewport-fit=cover", e || (e = document.createElement("meta")).setAttribute("name", "viewport"), n = Y(e.content) && e.content.includes(i), r ? (this.cleanupViewport = !n, n || (e.content += ",".concat(i))) : this.cleanupViewport && (e.content = e.content.split(",").filter(function(t) {
                                return t.trim() !== i
                            }).join(","))), this.onChange()
                        }
                    }, {
                        key: "trapFocus",
                        value: function(t) {
                            var e, i, n, r;
                            !rt.isIos && this.active && "Tab" === t.key && 9 === t.keyCode && (e = document.activeElement, n = _(i = bt.call(this.player, "a[href], button:not(:disabled), input:not(:disabled), [tabindex]"), 1)[0], e !== (r = i[i.length - 1]) || t.shiftKey ? e === n && t.shiftKey && (r.focus(), t.preventDefault()) : (n.focus(), t.preventDefault()))
                        }
                    }, {
                        key: "update",
                        value: function() {
                            var t;
                            this.enabled ? (t = this.forceFallback ? "Fallback (forced)" : he.native ? "Native" : "Fallback", this.player.debug.log("".concat(t, " fullscreen enabled"))) : this.player.debug.log("Fullscreen not supported and fallback disabled"), gt(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled)
                        }
                    }, {
                        key: "enter",
                        value: function() {
                            this.enabled && (rt.isIos && this.player.config.fullscreen.iosNative ? this.target.webkitEnterFullscreen() : !he.native || this.forceFallback ? this.toggleFallback(!0) : this.prefix ? tt(this.prefix) || this.target["".concat(this.prefix, "Request").concat(this.property)]() : this.target.requestFullscreen({
                                navigationUI: "hide"
                            }))
                        }
                    }, {
                        key: "exit",
                        value: function() {
                            var t;
                            this.enabled && (rt.isIos && this.player.config.fullscreen.iosNative ? (this.target.webkitExitFullscreen(), Lt(this.player.play())) : !he.native || this.forceFallback ? this.toggleFallback(!1) : this.prefix ? tt(this.prefix) || (t = "moz" === this.prefix ? "Cancel" : "Exit", document["".concat(this.prefix).concat(t).concat(this.property)]()) : (document.cancelFullScreen || document.exitFullscreen).call(document))
                        }
                    }, {
                        key: "toggle",
                        value: function() {
                            this.active ? this.exit() : this.enter()
                        }
                    }, {
                        key: "usingNative",
                        get: function() {
                            return he.native && !this.forceFallback
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return (he.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo
                        }
                    }, {
                        key: "active",
                        get: function() {
                            if (!this.enabled) return !1;
                            if (!he.native || this.forceFallback) return vt(this.target, this.player.config.classNames.fullscreen.fallback);
                            var t = this.prefix ? document["".concat(this.prefix).concat(this.property, "Element")] : document.fullscreenElement;
                            return t && t.shadowRoot ? t === this.target.getRootNode().host : t === this.target
                        }
                    }, {
                        key: "target",
                        get: function() {
                            return rt.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen || this.player.elements.container
                        }
                    }], [{
                        key: "native",
                        get: function() {
                            return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled)
                        }
                    }, {
                        key: "prefix",
                        get: function() {
                            if (J(document.exitFullscreen)) return "";
                            var e = "";
                            return ["webkit", "moz", "ms"].some(function(t) {
                                return !(!J(document["".concat(t, "ExitFullscreen")]) && !J(document["".concat(t, "CancelFullScreen")]) || (e = t, 0))
                            }), e
                        }
                    }, {
                        key: "property",
                        get: function() {
                            return "moz" === this.prefix ? "FullScreen" : "Fullscreen"
                        }
                    }]), he);

                function he(t) {
                    var e, i, n = this;
                    h(this, he), this.player = t, this.prefix = he.prefix, this.property = he.property, this.scrollPosition = {
                        x: 0,
                        y: 0
                    }, this.forceFallback = "force" === t.config.fullscreen.fallback, this.player.elements.fullscreen = t.config.fullscreen.container && (e = this.player.elements.container, i = t.config.fullscreen.container, (Element.prototype.closest || function() {
                        var t = this;
                        do {
                            if (yt.matches(t, i)) return t;
                            t = t.parentElement || t.parentNode
                        } while (null !== t && 1 === t.nodeType);
                        return null
                    }).call(e, i)), At.call(this.player, document, "ms" === this.prefix ? "MSFullscreenChange" : "".concat(this.prefix, "fullscreenchange"), function() {
                        n.onChange()
                    }), At.call(this.player, this.player.elements.container, "dblclick", function(t) {
                        K(n.player.elements.controls) && n.player.elements.controls.contains(t.target) || n.toggle()
                    }), At.call(this, this.player.elements.container, "keydown", function(t) {
                        return n.trapFocus(t)
                    }), this.update()
                }

                function ue() {
                    var t = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
                    h(this, ue), this.enabled = window.console && t, this.enabled && this.log("Debugging enabled")
                }

                function ce(r, t) {
                    var a = 1 < arguments.length && void 0 !== t ? t : 1;
                    return new Promise(function(t, e) {
                        function i() {
                            delete n.onload, delete n.onerror, (n.naturalWidth >= a ? t : e)(n)
                        }
                        var n = new Image;
                        Object.assign(n, {
                            onload: i,
                            onerror: i,
                            src: r
                        })
                    })
                }
                var pe = {
                        addStyleHook: function() {
                            gt(this.elements.container, this.config.selectors.container.replace(".", ""), !0), gt(this.elements.container, this.config.classNames.uiSupported, this.supported.ui)
                        },
                        toggleNativeControls: function(t) {
                            0 < arguments.length && void 0 !== t && t && this.isHTML5 ? this.media.setAttribute("controls", "") : this.media.removeAttribute("controls")
                        },
                        build: function() {
                            var t = this;
                            if (this.listeners.media(), !this.supported.ui) return this.debug.warn("Basic support only for ".concat(this.provider, " ").concat(this.type)), void pe.toggleNativeControls.call(this, !0);
                            K(this.elements.controls) || (Kt.inject.call(this), this.listeners.controls()), pe.toggleNativeControls.call(this), this.isHTML5 && ie.setup.call(this), this.volume = null, this.muted = null, this.loop = null, this.quality = null, this.speed = null, Kt.updateVolume.call(this), Kt.timeUpdate.call(this), pe.checkPlaying.call(this), gt(this.elements.container, this.config.classNames.pip.supported, Mt.pip && this.isHTML5 && this.isVideo), gt(this.elements.container, this.config.classNames.airplay.supported, Mt.airplay && this.isHTML5), gt(this.elements.container, this.config.classNames.isIos, rt.isIos), gt(this.elements.container, this.config.classNames.isTouch, this.touch), this.ready = !0, setTimeout(function() {
                                Pt.call(t, t.media, "ready")
                            }, 0), pe.setTitle.call(this), this.poster && pe.setPoster.call(this, this.poster, !1).catch(function() {}), this.config.duration && Kt.durationUpdate.call(this)
                        },
                        setTitle: function() {
                            var e = Ut("play", this.config);
                            if (Y(this.config.title) && !tt(this.config.title) && (e += ", ".concat(this.config.title)), Array.from(this.elements.buttons.play || []).forEach(function(t) {
                                    t.setAttribute("aria-label", e)
                                }), this.isEmbed) {
                                var t = xt.call(this, "iframe");
                                if (!K(t)) return;
                                var i = tt(this.config.title) ? "video" : this.config.title,
                                    n = Ut("frameTitle", this.config);
                                t.setAttribute("title", n.replace("{title}", i))
                            }
                        },
                        togglePoster: function(t) {
                            gt(this.elements.container, this.config.classNames.posterEnabled, t)
                        },
                        setPoster: function(e, t) {
                            var i = this;
                            return (!(1 < arguments.length && void 0 !== t) || t) && this.poster ? Promise.reject(new Error("Poster already set")) : (this.media.setAttribute("data-poster", e), function() {
                                var e = this;
                                return new Promise(function(t) {
                                    return e.ready ? setTimeout(t, 0) : At.call(e, e.elements.container, "ready", t)
                                }).then(function() {})
                            }.call(this).then(function() {
                                return ce(e)
                            }).catch(function(t) {
                                throw e === i.poster && pe.togglePoster.call(i, !1), t
                            }).then(function() {
                                if (e !== i.poster) throw new Error("setPoster cancelled by later call to setPoster")
                            }).then(function() {
                                return Object.assign(i.elements.poster.style, {
                                    backgroundImage: "url('".concat(e, "')"),
                                    backgroundSize: ""
                                }), pe.togglePoster.call(i, !0), e
                            }))
                        },
                        checkPlaying: function(t) {
                            var e = this;
                            gt(this.elements.container, this.config.classNames.playing, this.playing), gt(this.elements.container, this.config.classNames.paused, this.paused), gt(this.elements.container, this.config.classNames.stopped, this.stopped), Array.from(this.elements.buttons.play || []).forEach(function(t) {
                                Object.assign(t, {
                                    pressed: e.playing
                                }), t.setAttribute("aria-label", Ut(e.playing ? "pause" : "play", e.config))
                            }), I(t) && "timeupdate" === t.type || pe.toggleControls.call(this)
                        },
                        checkLoading: function(t) {
                            var e = this;
                            this.loading = ["stalled", "waiting"].includes(t.type), clearTimeout(this.timers.loading), this.timers.loading = setTimeout(function() {
                                gt(e.elements.container, e.config.classNames.loading, e.loading), pe.toggleControls.call(e)
                            }, this.loading ? 250 : 0)
                        },
                        toggleControls: function(t) {
                            var e, i = this.elements.controls;
                            i && this.config.hideControls && (e = this.touch && this.lastSeekTime + 2e3 > Date.now(), this.toggleControls(Boolean(t || this.loading || this.paused || i.pressed || i.hover || e)))
                        },
                        migrateStyles: function() {
                            var e = this;
                            Object.values(x({}, this.media.style)).filter(function(t) {
                                return !tt(t) && t.startsWith("--plyr")
                            }).forEach(function(t) {
                                e.elements.container.style.setProperty(t, e.media.style.getPropertyValue(t)), e.media.style.removeProperty(t)
                            }), tt(this.media.style) && this.media.removeAttribute("style")
                        }
                    },
                    de = (t(fe, [{
                        key: "handleKey",
                        value: function(t) {
                            var e = this.player,
                                i = e.elements,
                                n = t.keyCode ? t.keyCode : t.which,
                                r = "keydown" === t.type,
                                a = r && n === this.lastKey;
                            if (!(t.altKey || t.ctrlKey || t.metaKey || t.shiftKey) && X(n))
                                if (r) {
                                    var s = document.activeElement;
                                    if (K(s)) {
                                        var o = e.config.selectors.editable;
                                        if (s !== i.inputs.seek && yt(s, o)) return;
                                        if (32 === t.which && yt(s, 'button, [role^="menuitem"]')) return
                                    }
                                    switch ([32, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 56, 57, 67, 70, 73, 75, 76, 77, 79].includes(n) && (t.preventDefault(), t.stopPropagation()), n) {
                                        case 48:
                                        case 49:
                                        case 50:
                                        case 51:
                                        case 52:
                                        case 53:
                                        case 54:
                                        case 55:
                                        case 56:
                                        case 57:
                                            a || (e.currentTime = e.duration / 10 * (n - 48));
                                            break;
                                        case 32:
                                        case 75:
                                            a || Lt(e.togglePlay());
                                            break;
                                        case 38:
                                            e.increaseVolume(.1);
                                            break;
                                        case 40:
                                            e.decreaseVolume(.1);
                                            break;
                                        case 77:
                                            a || (e.muted = !e.muted);
                                            break;
                                        case 39:
                                            e.forward();
                                            break;
                                        case 37:
                                            e.rewind();
                                            break;
                                        case 70:
                                            e.fullscreen.toggle();
                                            break;
                                        case 67:
                                            a || e.toggleCaptions();
                                            break;
                                        case 76:
                                            e.loop = !e.loop
                                    }
                                    27 === n && !e.fullscreen.usingNative && e.fullscreen.active && e.fullscreen.toggle(), this.lastKey = n
                                } else this.lastKey = null
                        }
                    }, {
                        key: "toggleMenu",
                        value: function(t) {
                            Kt.toggleMenu.call(this.player, t)
                        }
                    }, {
                        key: "firstTouch",
                        value: function() {
                            var t = this.player,
                                e = t.elements;
                            t.touch = !0, gt(e.container, t.config.classNames.isTouch, !0)
                        }
                    }, {
                        key: "setTabFocus",
                        value: function(t) {
                            var e, i, n = this.player,
                                r = n.elements;
                            clearTimeout(this.focusTimer), "keydown" === t.type && 9 !== t.which || ("keydown" === t.type && (this.lastKeyDown = t.timeStamp), i = t.timeStamp - this.lastKeyDown <= 20, "focus" === t.type && !i || (e = n.config.classNames.tabFocus, gt(bt.call(n, ".".concat(e)), e, !1), "focusout" !== t.type && (this.focusTimer = setTimeout(function() {
                                var t = document.activeElement;
                                r.container.contains(t) && gt(document.activeElement, n.config.classNames.tabFocus, !0)
                            }, 10))))
                        }
                    }, {
                        key: "global",
                        value: function(t) {
                            var e = !(0 < arguments.length && void 0 !== t) || t,
                                i = this.player;
                            i.config.keyboard.global && Ct.call(i, window, "keydown keyup", this.handleKey, e, !1), Ct.call(i, document.body, "click", this.toggleMenu, e), Dt.call(i, document.body, "touchstart", this.firstTouch), Ct.call(i, document.body, "keydown focus blur focusout", this.setTabFocus, e, !1, !0)
                        }
                    }, {
                        key: "container",
                        value: function() {
                            var d = this.player,
                                t = d.config,
                                f = d.elements,
                                n = d.timers;

                            function m(t) {
                                if (!t) return It.call(d);
                                var e = f.container.getBoundingClientRect(),
                                    i = e.width,
                                    n = e.height;
                                return It.call(d, "".concat(i, ":").concat(n))
                            }

                            function g() {
                                clearTimeout(n.resized), n.resized = setTimeout(m, 50)
                            }!t.keyboard.global && t.keyboard.focused && At.call(d, f.container, "keydown keyup", this.handleKey, !1), At.call(d, f.container, "mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen", function(t) {
                                var e = f.controls;
                                e && "enterfullscreen" === t.type && (e.pressed = !1, e.hover = !1);
                                var i = 0;
                                ["touchstart", "touchmove", "mousemove"].includes(t.type) && (pe.toggleControls.call(d, !0), i = d.touch ? 3e3 : 2e3), clearTimeout(n.controls), n.controls = setTimeout(function() {
                                    return pe.toggleControls.call(d, !1)
                                }, i)
                            }), At.call(d, f.container, "enterfullscreen exitfullscreen", function(t) {
                                var e, i, n, r, a, s, o, l, h, u = d.fullscreen,
                                    c = u.target,
                                    p = u.usingNative;
                                c !== f.container || !d.isEmbed && tt(d.config.ratio) || (e = "enterfullscreen" === t.type, (i = m(e)).padding, n = i.ratio, r = e, d.isVimeo && !d.config.vimeo.premium && (a = d.elements.wrapper.firstChild, s = _(n, 2)[1], l = (o = _(Ft.call(d), 2))[0], h = o[1], a.style.maxWidth = r ? "".concat(s / h * l, "px") : null, a.style.margin = r ? "0 auto" : null), p || (e ? At.call(d, window, "resize", g) : Et.call(d, window, "resize", g)))
                            })
                        }
                    }, {
                        key: "media",
                        value: function() {
                            var e = this,
                                n = this.player,
                                r = n.elements;
                            if (At.call(n, n.media, "timeupdate seeking seeked", function(t) {
                                    return Kt.timeUpdate.call(n, t)
                                }), At.call(n, n.media, "durationchange loadeddata loadedmetadata", function(t) {
                                    return Kt.durationUpdate.call(n, t)
                                }), At.call(n, n.media, "ended", function() {
                                    n.isHTML5 && n.isVideo && n.config.resetOnEnd && (n.restart(), n.pause())
                                }), At.call(n, n.media, "progress playing seeking seeked", function(t) {
                                    return Kt.updateProgress.call(n, t)
                                }), At.call(n, n.media, "volumechange", function(t) {
                                    return Kt.updateVolume.call(n, t)
                                }), At.call(n, n.media, "playing play pause ended emptied timeupdate", function(t) {
                                    return pe.checkPlaying.call(n, t)
                                }), At.call(n, n.media, "waiting canplay seeked playing", function(t) {
                                    return pe.checkLoading.call(n, t)
                                }), n.supported.ui && n.config.clickToPlay && !n.isAudio) {
                                var i = xt.call(n, ".".concat(n.config.classNames.video));
                                if (!K(i)) return;
                                At.call(n, r.container, "click", function(t) {
                                    ([r.container, i].includes(t.target) || i.contains(t.target)) && (n.touch && n.config.hideControls || (n.ended ? (e.proxy(t, n.restart, "restart"), e.proxy(t, function() {
                                        Lt(n.play())
                                    }, "play")) : e.proxy(t, function() {
                                        Lt(n.togglePlay())
                                    }, "play")))
                                })
                            }
                            n.supported.ui && n.config.disableContextMenu && At.call(n, r.wrapper, "contextmenu", function(t) {
                                t.preventDefault()
                            }, !1), At.call(n, n.media, "volumechange", function() {
                                n.storage.set({
                                    volume: n.volume,
                                    muted: n.muted
                                })
                            }), At.call(n, n.media, "ratechange", function() {
                                Kt.updateSetting.call(n, "speed"), n.storage.set({
                                    speed: n.speed
                                })
                            }), At.call(n, n.media, "qualitychange", function(t) {
                                Kt.updateSetting.call(n, "quality", null, t.detail.quality)
                            }), At.call(n, n.media, "ready qualitychange", function() {
                                Kt.setDownloadUrl.call(n)
                            });
                            var t = n.config.events.concat(["keyup", "keydown"]).join(" ");
                            At.call(n, n.media, t, function(t) {
                                var e = t.detail,
                                    i = void 0 === e ? {} : e;
                                "error" === t.type && (i = n.media.error), Pt.call(n, r.container, t.type, !0, i)
                            })
                        }
                    }, {
                        key: "proxy",
                        value: function(t, e, i) {
                            var n = this.player,
                                r = n.config.listeners[i],
                                a = !0;
                            J(r) && (a = r.call(n, t)), !1 !== a && J(e) && e.call(n, t)
                        }
                    }, {
                        key: "bind",
                        value: function(t, e, i, n, r) {
                            var a = this,
                                s = !(4 < arguments.length && void 0 !== r) || r,
                                o = this.player,
                                l = o.config.listeners[n],
                                h = J(l);
                            At.call(o, t, e, function(t) {
                                return a.proxy(t, i, n)
                            }, s && !h)
                        }
                    }, {
                        key: "controls",
                        value: function() {
                            var t, n = this,
                                o = this.player,
                                r = o.elements,
                                e = rt.isIE ? "change" : "input";
                            r.buttons.play && Array.from(r.buttons.play).forEach(function(t) {
                                n.bind(t, "click", function() {
                                    Lt(o.togglePlay())
                                }, "play")
                            }), this.bind(r.buttons.restart, "click", o.restart, "restart"), this.bind(r.buttons.rewind, "click", o.rewind, "rewind"), this.bind(r.buttons.fastForward, "click", o.forward, "fastForward"), this.bind(r.buttons.mute, "click", function() {
                                o.muted = !o.muted
                            }, "mute"), this.bind(r.buttons.captions, "click", function() {
                                return o.toggleCaptions()
                            }), this.bind(r.buttons.download, "click", function() {
                                Pt.call(o, o.media, "download")
                            }, "download"), this.bind(r.buttons.fullscreen, "click", function() {
                                o.fullscreen.toggle()
                            }, "fullscreen"), this.bind(r.buttons.pip, "click", function() {
                                o.pip = "toggle"
                            }, "pip"), this.bind(r.buttons.airplay, "click", o.airplay, "airplay"), this.bind(r.buttons.settings, "click", function(t) {
                                t.stopPropagation(), t.preventDefault(), Kt.toggleMenu.call(o, t)
                            }, null, !1), this.bind(r.buttons.settings, "keyup", function(t) {
                                var e = t.which;
                                [13, 32].includes(e) && (13 !== e ? (t.preventDefault(), t.stopPropagation(), Kt.toggleMenu.call(o, t)) : Kt.focusFirstMenuItem.call(o, null, !0))
                            }, null, !1), this.bind(r.settings.menu, "keydown", function(t) {
                                27 === t.which && Kt.toggleMenu.call(o, t)
                            }), this.bind(r.inputs.seek, "mousedown mousemove", function(t) {
                                var e = r.progress.getBoundingClientRect(),
                                    i = 100 / e.width * (t.pageX - e.left);
                                t.currentTarget.setAttribute("seek-value", i)
                            }), this.bind(r.inputs.seek, "mousedown mouseup keydown keyup touchstart touchend", function(t) {
                                var e, i, n = t.currentTarget,
                                    r = t.keyCode ? t.keyCode : t.which;
                                N(t) && 39 !== r && 37 !== r || (o.lastSeekTime = Date.now(), e = n.hasAttribute("play-on-seeked"), i = ["mouseup", "touchend", "keyup"].includes(t.type), e && i ? (n.removeAttribute("play-on-seeked"), Lt(o.play())) : !i && o.playing && (n.setAttribute("play-on-seeked", ""), o.pause()))
                            }), rt.isIos && (t = bt.call(o, 'input[type="range"]'), Array.from(t).forEach(function(t) {
                                return n.bind(t, e, function(t) {
                                    return nt(t.target)
                                })
                            })), this.bind(r.inputs.seek, e, function(t) {
                                var e = t.currentTarget,
                                    i = e.getAttribute("seek-value");
                                tt(i) && (i = e.value), e.removeAttribute("seek-value"), o.currentTime = i / e.max * o.duration
                            }, "seek"), this.bind(r.progress, "mouseenter mouseleave mousemove", function(t) {
                                return Kt.updateSeekTooltip.call(o, t)
                            }), this.bind(r.progress, "mousemove touchmove", function(t) {
                                var e = o.previewThumbnails;
                                e && e.loaded && e.startMove(t)
                            }), this.bind(r.progress, "mouseleave touchend click", function() {
                                var t = o.previewThumbnails;
                                t && t.loaded && t.endMove(!1, !0)
                            }), this.bind(r.progress, "mousedown touchstart", function(t) {
                                var e = o.previewThumbnails;
                                e && e.loaded && e.startScrubbing(t)
                            }), this.bind(r.progress, "mouseup touchend", function(t) {
                                var e = o.previewThumbnails;
                                e && e.loaded && e.endScrubbing(t)
                            }), rt.isWebkit && Array.from(bt.call(o, 'input[type="range"]')).forEach(function(t) {
                                n.bind(t, "input", function(t) {
                                    return Kt.updateRangeFill.call(o, t.target)
                                })
                            }), o.config.toggleInvert && !K(r.display.duration) && this.bind(r.display.currentTime, "click", function() {
                                0 !== o.currentTime && (o.config.invertTime = !o.config.invertTime, Kt.timeUpdate.call(o))
                            }), this.bind(r.inputs.volume, e, function(t) {
                                o.volume = t.target.value
                            }, "volume"), this.bind(r.controls, "mouseenter mouseleave", function(t) {
                                r.controls.hover = !o.touch && "mouseenter" === t.type
                            }), r.fullscreen && Array.from(r.fullscreen.children).filter(function(t) {
                                return !t.contains(r.container)
                            }).forEach(function(t) {
                                n.bind(t, "mouseenter mouseleave", function(t) {
                                    r.controls.hover = !o.touch && "mouseenter" === t.type
                                })
                            }), this.bind(r.controls, "mousedown mouseup touchstart touchend touchcancel", function(t) {
                                r.controls.pressed = ["mousedown", "touchstart"].includes(t.type)
                            }), this.bind(r.controls, "focusin", function() {
                                var t = o.config,
                                    e = o.timers;
                                gt(r.controls, t.classNames.noTransition, !0), pe.toggleControls.call(o, !0), setTimeout(function() {
                                    gt(r.controls, t.classNames.noTransition, !1)
                                }, 0);
                                var i = n.touch ? 3e3 : 4e3;
                                clearTimeout(e.controls), e.controls = setTimeout(function() {
                                    return pe.toggleControls.call(o, !1)
                                }, i)
                            }), this.bind(r.inputs.volume, "wheel", function(t) {
                                var e = t.webkitDirectionInvertedFromDevice,
                                    i = _([t.deltaX, -t.deltaY].map(function(t) {
                                        return e ? -t : t
                                    }), 2),
                                    n = i[0],
                                    r = i[1],
                                    a = Math.sign(Math.abs(n) > Math.abs(r) ? n : r);
                                o.increaseVolume(a / 50);
                                var s = o.media.volume;
                                (1 === a && s < 1 || -1 === a && 0 < s) && t.preventDefault()
                            }, "volume", !1)
                        }
                    }]), fe);

                function fe(t) {
                    h(this, fe), this.player = t, this.lastKey = null, this.focusTimer = null, this.lastKeyDown = null, this.handleKey = this.handleKey.bind(this), this.toggleMenu = this.toggleMenu.bind(this), this.setTabFocus = this.setTabFocus.bind(this), this.firstTouch = this.firstTouch.bind(this)
                }
                var me, ge = ((me = {
                    exports: {}
                }).exports = function() {
                    var d = function() {},
                        r = {},
                        l = {},
                        h = {};

                    function c(t, e) {
                        if (t) {
                            var i = h[t];
                            if (l[t] = e, i)
                                for (; i.length;) i[0](t, e), i.splice(0, 1)
                        }
                    }

                    function p(t, e) {
                        t.call && (t = {
                            success: t
                        }), e.length ? (t.error || d)(e) : (t.success || d)(t)
                    }

                    function e(t, e, i) {
                        var h, u;
                        if (e && e.trim && (h = e), u = (h ? i : e) || {}, h) {
                            if (h in r) throw "LoadJS";
                            r[h] = !0
                        }

                        function n(o, l) {
                            ! function(t, e) {
                                for (var r = (t = t.push ? t : [t]).length, i = r, a = [], n = function(t, e, i) {
                                        if ("e" == e && a.push(t), "b" == e) {
                                            if (!i) return;
                                            a.push(t)
                                        }
                                        var n;
                                        --r || (p(u, n = a), o && p({
                                            success: o,
                                            error: l
                                        }, n), c(h, n))
                                    }, s = 0; s < i; s++) ! function i(n, r, a, s) {
                                    var o, l, t = document,
                                        e = a.async,
                                        h = (a.numRetries || 0) + 1,
                                        u = a.before || d,
                                        c = n.replace(/[\?|#].*$/, ""),
                                        p = n.replace(/^(css|img)!/, "");
                                    s = s || 0, /(^css!|\.css$)/.test(c) ? ((l = t.createElement("link")).rel = "stylesheet", l.href = p, (o = "hideFocus" in l) && l.relList && (o = 0, l.rel = "preload", l.as = "style")) : /(^img!|\.(png|gif|jpg|svg|webp)$)/.test(c) ? (l = t.createElement("img")).src = p : ((l = t.createElement("script")).src = n, l.async = void 0 === e || e), !(l.onload = l.onerror = l.onbeforeload = function(t) {
                                        var e = t.type[0];
                                        if (o) try {
                                            l.sheet.cssText.length || (e = "e")
                                        } catch (t) {
                                            18 != t.code && (e = "e")
                                        }
                                        if ("e" == e) {
                                            if ((s += 1) < h) return i(n, r, a, s)
                                        } else if ("preload" == l.rel && "style" == l.as) return l.rel = "stylesheet";
                                        r(n, e, t.defaultPrevented)
                                    }) !== u(n, l) && t.head.appendChild(l)
                                }(t[s], n, e)
                            }(t, u)
                        }
                        if (u.returnPromise) return new Promise(n);
                        n()
                    }
                    return e.ready = function(t, o) {
                        return function(t) {
                            t = t.push ? t : [t];
                            for (var e, i, n = [], r = t.length, a = r, s = function(t, e) {
                                    e.length && n.push(t), --a || p(o, n)
                                }; r--;) e = t[r], (i = l[e]) ? s(e, i) : (h[e] = h[e] || []).push(s)
                        }(t), e
                    }, e.done = function(t) {
                        c(t, [])
                    }, e.reset = function() {
                        r = {}, l = {}, h = {}
                    }, e.isDefined = function(t) {
                        return t in r
                    }, e
                }(), me.exports);

                function ve(i) {
                    return new Promise(function(t, e) {
                        ge(i, {
                            success: t,
                            error: e
                        })
                    })
                }

                function ye(t) {
                    t && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === t && (this.media.paused = !t, Pt.call(this, this.media, t ? "play" : "pause"))
                }
                var be = {
                    setup: function() {
                        var e = this;
                        gt(e.elements.wrapper, e.config.classNames.embed, !0), e.options.speed = e.config.speed.options, It.call(e), q(window.Vimeo) ? be.ready.call(e) : ve(e.config.urls.vimeo.sdk).then(function() {
                            be.ready.call(e)
                        }).catch(function(t) {
                            e.debug.warn("Vimeo SDK (player.js) failed to load", t)
                        })
                    },
                    ready: function() {
                        var r = this,
                            s = this,
                            t = s.config.vimeo,
                            e = t.premium,
                            i = t.referrerPolicy,
                            n = function(t, e) {
                                if (null == t) return {};
                                var i, n = function(t, e) {
                                    if (null == t) return {};
                                    for (var i, n = {}, r = Object.keys(t), a = 0; a < r.length; a++) i = r[a], 0 <= e.indexOf(i) || (n[i] = t[i]);
                                    return n
                                }(t, e);
                                if (Object.getOwnPropertySymbols)
                                    for (var r = Object.getOwnPropertySymbols(t), a = 0; a < r.length; a++) i = r[a], 0 <= e.indexOf(i) || Object.prototype.propertyIsEnumerable.call(t, i) && (n[i] = t[i]);
                                return n
                            }(t, ["premium", "referrerPolicy"]);
                        e && Object.assign(n, {
                            controls: !1,
                            sidedock: !1
                        });
                        var a = te(x({
                                loop: s.config.loop.active,
                                autoplay: s.autoplay,
                                muted: s.muted,
                                gesture: "media",
                                playsinline: !this.config.fullscreen.iosNative
                            }, n)),
                            o = s.media.getAttribute("src");
                        tt(o) && (o = s.media.getAttribute(s.config.attributes.embed.id));
                        var l, h = tt(l = o) ? null : !X(Number(l)) && l.match(/^.*(vimeo.com\/|video\/)(\d+).*/) ? RegExp.$2 : l,
                            u = ht("iframe"),
                            c = Rt(s.config.urls.vimeo.iframe, h, a);
                        u.setAttribute("src", c), u.setAttribute("allowfullscreen", ""), u.setAttribute("allow", "autoplay,fullscreen,picture-in-picture"), tt(i) || u.setAttribute("referrerPolicy", i);
                        var p, d = s.poster;
                        e ? (u.setAttribute("data-poster", d), s.media = dt(u, s.media)) : ((p = ht("div", {
                            class: s.config.classNames.embedContainer,
                            "data-poster": d
                        })).appendChild(u), s.media = dt(p, s.media)), qt(Rt(s.config.urls.vimeo.api, h), "json").then(function(t) {
                            var e;
                            tt(t) || ((e = new URL(t[0].thumbnail_large)).pathname = "".concat(e.pathname.split("_")[0], ".jpg"), pe.setPoster.call(s, e.href).catch(function() {}))
                        }), s.embed = new window.Vimeo.Player(u, {
                            autopause: s.config.autopause,
                            muted: s.muted
                        }), s.media.paused = !0, s.media.currentTime = 0, s.supported.ui && s.embed.disableTextTrack(), s.media.play = function() {
                            return ye.call(s, !0), s.embed.play()
                        }, s.media.pause = function() {
                            return ye.call(s, !1), s.embed.pause()
                        }, s.media.stop = function() {
                            s.pause(), s.currentTime = 0
                        };
                        var f = s.media.currentTime;
                        Object.defineProperty(s.media, "currentTime", {
                            get: function() {
                                return f
                            },
                            set: function(t) {
                                var e = s.embed,
                                    i = s.media,
                                    n = s.paused,
                                    r = s.volume,
                                    a = n && !e.hasPlayed;
                                i.seeking = !0, Pt.call(s, i, "seeking"), Promise.resolve(a && e.setVolume(0)).then(function() {
                                    return e.setCurrentTime(t)
                                }).then(function() {
                                    return a && e.pause()
                                }).then(function() {
                                    return a && e.setVolume(r)
                                }).catch(function() {})
                            }
                        });
                        var m = s.config.speed.selected;
                        Object.defineProperty(s.media, "playbackRate", {
                            get: function() {
                                return m
                            },
                            set: function(t) {
                                s.embed.setPlaybackRate(t).then(function() {
                                    m = t, Pt.call(s, s.media, "ratechange")
                                }).catch(function() {
                                    s.options.speed = [1]
                                })
                            }
                        });
                        var g = s.config.volume;
                        Object.defineProperty(s.media, "volume", {
                            get: function() {
                                return g
                            },
                            set: function(t) {
                                s.embed.setVolume(t).then(function() {
                                    g = t, Pt.call(s, s.media, "volumechange")
                                })
                            }
                        });
                        var v = s.config.muted;
                        Object.defineProperty(s.media, "muted", {
                            get: function() {
                                return v
                            },
                            set: function(t) {
                                var e = !!F(t) && t;
                                s.embed.setVolume(e ? 0 : s.config.volume).then(function() {
                                    v = e, Pt.call(s, s.media, "volumechange")
                                })
                            }
                        });
                        var y, b = s.config.loop;
                        Object.defineProperty(s.media, "loop", {
                            get: function() {
                                return b
                            },
                            set: function(t) {
                                var e = F(t) ? t : s.config.loop.active;
                                s.embed.setLoop(e).then(function() {
                                    b = e
                                })
                            }
                        }), s.embed.getVideoUrl().then(function(t) {
                            y = t, Kt.setDownloadUrl.call(s)
                        }).catch(function(t) {
                            r.debug.warn(t)
                        }), Object.defineProperty(s.media, "currentSrc", {
                            get: function() {
                                return y
                            }
                        }), Object.defineProperty(s.media, "ended", {
                            get: function() {
                                return s.currentTime === s.duration
                            }
                        }), Promise.all([s.embed.getVideoWidth(), s.embed.getVideoHeight()]).then(function(t) {
                            var e = _(t, 2),
                                i = e[0],
                                n = e[1];
                            s.embed.ratio = [i, n], It.call(r)
                        }), s.embed.setAutopause(s.config.autopause).then(function(t) {
                            s.config.autopause = t
                        }), s.embed.getVideoTitle().then(function(t) {
                            s.config.title = t, pe.setTitle.call(r)
                        }), s.embed.getCurrentTime().then(function(t) {
                            f = t, Pt.call(s, s.media, "timeupdate")
                        }), s.embed.getDuration().then(function(t) {
                            s.media.duration = t, Pt.call(s, s.media, "durationchange")
                        }), s.embed.getTextTracks().then(function(t) {
                            s.media.textTracks = t, ie.setup.call(s)
                        }), s.embed.on("cuechange", function(t) {
                            var e = t.cues,
                                i = (void 0 === e ? [] : e).map(function(t) {
                                    return e = t.text, i = document.createDocumentFragment(), n = document.createElement("div"), i.appendChild(n), n.innerHTML = e, i.firstChild.innerText;
                                    var e, i, n
                                });
                            ie.updateCues.call(s, i)
                        }), s.embed.on("loaded", function() {
                            s.embed.getPaused().then(function(t) {
                                ye.call(s, !t), t || Pt.call(s, s.media, "playing")
                            }), K(s.embed.element) && s.supported.ui && s.embed.element.setAttribute("tabindex", -1)
                        }), s.embed.on("bufferstart", function() {
                            Pt.call(s, s.media, "waiting")
                        }), s.embed.on("bufferend", function() {
                            Pt.call(s, s.media, "playing")
                        }), s.embed.on("play", function() {
                            ye.call(s, !0), Pt.call(s, s.media, "playing")
                        }), s.embed.on("pause", function() {
                            ye.call(s, !1)
                        }), s.embed.on("timeupdate", function(t) {
                            s.media.seeking = !1, f = t.seconds, Pt.call(s, s.media, "timeupdate")
                        }), s.embed.on("progress", function(t) {
                            s.media.buffered = t.percent, Pt.call(s, s.media, "progress"), 1 === parseInt(t.percent, 10) && Pt.call(s, s.media, "canplaythrough"), s.embed.getDuration().then(function(t) {
                                t !== s.media.duration && (s.media.duration = t, Pt.call(s, s.media, "durationchange"))
                            })
                        }), s.embed.on("seeked", function() {
                            s.media.seeking = !1, Pt.call(s, s.media, "seeked")
                        }), s.embed.on("ended", function() {
                            s.media.paused = !0, Pt.call(s, s.media, "ended")
                        }), s.embed.on("error", function(t) {
                            s.media.error = t, Pt.call(s, s.media, "error")
                        }), setTimeout(function() {
                            return pe.build.call(s)
                        }, 0)
                    }
                };

                function xe(t) {
                    t && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === t && (this.media.paused = !t, Pt.call(this, this.media, t ? "play" : "pause"))
                }

                function _e(t, e) {
                    var i = {};
                    return t > e.width / e.height ? (i.width = e.width, i.height = 1 / t * e.width) : (i.height = e.height, i.width = t * e.height), i
                }
                var we = {
                        setup: function() {
                            var t, e = this;
                            gt(this.elements.wrapper, this.config.classNames.embed, !0), q(window.YT) && J(window.YT.Player) ? we.ready.call(this) : (t = window.onYouTubeIframeAPIReady, window.onYouTubeIframeAPIReady = function() {
                                J(t) && t(), we.ready.call(e)
                            }, ve(this.config.urls.youtube.sdk).catch(function(t) {
                                e.debug.warn("YouTube API failed to load", t)
                            }))
                        },
                        getTitle: function(t) {
                            var r = this;
                            qt(Rt(this.config.urls.youtube.api, t)).then(function(t) {
                                var e, i, n;
                                q(t) && (e = t.title, i = t.height, n = t.width, r.config.title = e, pe.setTitle.call(r), r.embed.ratio = [n, i]), It.call(r)
                            }).catch(function() {
                                It.call(r)
                            })
                        },
                        ready: function() {
                            var t, e, i, a, n, r, s, o, l = this,
                                h = l.media && l.media.getAttribute("id");
                            !tt(h) && h.startsWith("youtube-") || (t = l.media.getAttribute("src"), tt(t) && (t = l.media.getAttribute(this.config.attributes.embed.id)), a = tt(e = t) ? null : e.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/) ? RegExp.$2 : e, i = l.provider, r = ht("div", {
                                id: n = "".concat(i, "-").concat(Math.floor(1e4 * Math.random())),
                                "data-poster": l.poster
                            }), l.media = dt(r, l.media), ce((s = function(t) {
                                return "https://i.ytimg.com/vi/".concat(a, "/").concat(t, "default.jpg")
                            })("maxres"), 121).catch(function() {
                                return ce(s("sd"), 121)
                            }).catch(function() {
                                return ce(s("hq"))
                            }).then(function(t) {
                                return pe.setPoster.call(l, t.src)
                            }).then(function(t) {
                                t.includes("maxres") || (l.elements.poster.style.backgroundSize = "cover")
                            }).catch(function() {}), o = l.config.youtube, l.embed = new window.YT.Player(n, {
                                videoId: a,
                                host: o.noCookie ? "https://www.youtube-nocookie.com" : "http:" === window.location.protocol ? "http://www.youtube.com" : void 0,
                                playerVars: st({}, {
                                    autoplay: l.config.autoplay ? 1 : 0,
                                    hl: l.config.hl,
                                    controls: l.supported.ui ? 0 : 1,
                                    disablekb: 1,
                                    playsinline: l.config.fullscreen.iosNative ? 0 : 1,
                                    cc_load_policy: l.captions.active ? 1 : 0,
                                    cc_lang_pref: l.config.captions.language,
                                    widget_referrer: window ? window.location.href : null
                                }, o),
                                events: {
                                    onError: function(t) {
                                        var e, i;
                                        l.media.error || (i = {
                                            2: "The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.",
                                            5: "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.",
                                            100: "The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.",
                                            101: "The owner of the requested video does not allow it to be played in embedded players.",
                                            150: "The owner of the requested video does not allow it to be played in embedded players."
                                        }[e = t.data] || "An unknown error occured", l.media.error = {
                                            code: e,
                                            message: i
                                        }, Pt.call(l, l.media, "error"))
                                    },
                                    onPlaybackRateChange: function(t) {
                                        var e = t.target;
                                        l.media.playbackRate = e.getPlaybackRate(), Pt.call(l, l.media, "ratechange")
                                    },
                                    onReady: function(t) {
                                        var i, e, n, r;
                                        J(l.media.play) || (i = t.target, we.getTitle.call(l, a), l.media.play = function() {
                                            xe.call(l, !0), i.playVideo()
                                        }, l.media.pause = function() {
                                            xe.call(l, !1), i.pauseVideo()
                                        }, l.media.stop = function() {
                                            i.stopVideo()
                                        }, l.media.duration = i.getDuration(), l.media.paused = !0, l.media.currentTime = 0, Object.defineProperty(l.media, "currentTime", {
                                            get: function() {
                                                return Number(i.getCurrentTime())
                                            },
                                            set: function(t) {
                                                l.paused && !l.embed.hasPlayed && l.embed.mute(), l.media.seeking = !0, Pt.call(l, l.media, "seeking"), i.seekTo(t)
                                            }
                                        }), Object.defineProperty(l.media, "playbackRate", {
                                            get: function() {
                                                return i.getPlaybackRate()
                                            },
                                            set: function(t) {
                                                i.setPlaybackRate(t)
                                            }
                                        }), e = l.config.volume, Object.defineProperty(l.media, "volume", {
                                            get: function() {
                                                return e
                                            },
                                            set: function(t) {
                                                e = t, i.setVolume(100 * e), Pt.call(l, l.media, "volumechange")
                                            }
                                        }), n = l.config.muted, Object.defineProperty(l.media, "muted", {
                                            get: function() {
                                                return n
                                            },
                                            set: function(t) {
                                                var e = F(t) ? t : n;
                                                i[(n = e) ? "mute" : "unMute"](), Pt.call(l, l.media, "volumechange")
                                            }
                                        }), Object.defineProperty(l.media, "currentSrc", {
                                            get: function() {
                                                return i.getVideoUrl()
                                            }
                                        }), Object.defineProperty(l.media, "ended", {
                                            get: function() {
                                                return l.currentTime === l.duration
                                            }
                                        }), r = i.getAvailablePlaybackRates(), l.options.speed = r.filter(function(t) {
                                            return l.config.speed.options.includes(t)
                                        }), l.supported.ui && l.media.setAttribute("tabindex", -1), Pt.call(l, l.media, "timeupdate"), Pt.call(l, l.media, "durationchange"), clearInterval(l.timers.buffering), l.timers.buffering = setInterval(function() {
                                            l.media.buffered = i.getVideoLoadedFraction(), (null === l.media.lastBuffered || l.media.lastBuffered < l.media.buffered) && Pt.call(l, l.media, "progress"), l.media.lastBuffered = l.media.buffered, 1 === l.media.buffered && (clearInterval(l.timers.buffering), Pt.call(l, l.media, "canplaythrough"))
                                        }, 200), setTimeout(function() {
                                            return pe.build.call(l)
                                        }, 50))
                                    },
                                    onStateChange: function(t) {
                                        var e = t.target;
                                        switch (clearInterval(l.timers.playing), l.media.seeking && [1, 2].includes(t.data) && (l.media.seeking = !1, Pt.call(l, l.media, "seeked")), t.data) {
                                            case -1:
                                                Pt.call(l, l.media, "timeupdate"), l.media.buffered = e.getVideoLoadedFraction(), Pt.call(l, l.media, "progress");
                                                break;
                                            case 0:
                                                xe.call(l, !1), l.media.loop ? (e.stopVideo(), e.playVideo()) : Pt.call(l, l.media, "ended");
                                                break;
                                            case 1:
                                                l.config.autoplay || !l.media.paused || l.embed.hasPlayed ? (xe.call(l, !0), Pt.call(l, l.media, "playing"), l.timers.playing = setInterval(function() {
                                                    Pt.call(l, l.media, "timeupdate")
                                                }, 50), l.media.duration !== e.getDuration() && (l.media.duration = e.getDuration(), Pt.call(l, l.media, "durationchange"))) : l.media.pause();
                                                break;
                                            case 2:
                                                l.muted || l.embed.unMute(), xe.call(l, !1);
                                                break;
                                            case 3:
                                                Pt.call(l, l.media, "waiting")
                                        }
                                        Pt.call(l, l.elements.container, "statechange", !1, {
                                            code: t.data
                                        })
                                    }
                                }
                            }))
                        }
                    },
                    Se = {
                        setup: function() {
                            this.media ? (gt(this.elements.container, this.config.classNames.type.replace("{0}", this.type), !0), gt(this.elements.container, this.config.classNames.provider.replace("{0}", this.provider), !0), this.isEmbed && gt(this.elements.container, this.config.classNames.type.replace("{0}", "video"), !0), this.isVideo && (this.elements.wrapper = ht("div", {
                                class: this.config.classNames.video
                            }), ot(this.media, this.elements.wrapper), this.elements.poster = ht("div", {
                                class: this.config.classNames.poster
                            }), this.elements.wrapper.appendChild(this.elements.poster)), this.isHTML5 ? Nt.setup.call(this) : this.isYouTube ? we.setup.call(this) : this.isVimeo && be.setup.call(this)) : this.debug.warn("No media element found!")
                        }
                    },
                    Me = (t(Ee, [{
                        key: "load",
                        value: function() {
                            var t = this;
                            this.enabled && (q(window.google) && q(window.google.ima) ? this.ready() : ve(this.player.config.urls.googleIMA.sdk).then(function() {
                                t.ready()
                            }).catch(function() {
                                t.trigger("error", new Error("Google IMA SDK failed to load"))
                            }))
                        }
                    }, {
                        key: "ready",
                        value: function() {
                            var t = this;
                            this.enabled || (this.manager && this.manager.destroy(), this.elements.displayContainer && this.elements.displayContainer.destroy(), this.elements.container.remove()), this.startSafetyTimer(12e3, "ready()"), this.managerPromise.then(function() {
                                t.clearSafetyTimer("onAdsManagerLoaded()")
                            }), this.listeners(), this.setupIMA()
                        }
                    }, {
                        key: "setupIMA",
                        value: function() {
                            var e = this;
                            this.elements.container = ht("div", {
                                class: this.player.config.classNames.ads
                            }), this.player.elements.container.appendChild(this.elements.container), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale(this.player.config.ads.language), google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline), this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media), this.loader = new google.ima.AdsLoader(this.elements.displayContainer), this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, function(t) {
                                return e.onAdsManagerLoaded(t)
                            }, !1), this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, function(t) {
                                return e.onAdError(t)
                            }, !1), this.requestAds()
                        }
                    }, {
                        key: "requestAds",
                        value: function() {
                            var t = this.player.elements.container;
                            try {
                                var e = new google.ima.AdsRequest;
                                e.adTagUrl = this.tagUrl, e.linearAdSlotWidth = t.offsetWidth, e.linearAdSlotHeight = t.offsetHeight, e.nonLinearAdSlotWidth = t.offsetWidth, e.nonLinearAdSlotHeight = t.offsetHeight, e.forceNonLinearFullSlot = !1, e.setAdWillPlayMuted(!this.player.muted), this.loader.requestAds(e)
                            } catch (t) {
                                this.onAdError(t)
                            }
                        }
                    }, {
                        key: "pollCountdown",
                        value: function(t) {
                            var i = this;
                            if (!(0 < arguments.length && void 0 !== t && t)) return clearInterval(this.countdownTimer), void this.elements.container.removeAttribute("data-badge-text");
                            this.countdownTimer = setInterval(function() {
                                var t = $t(Math.max(i.manager.getRemainingTime(), 0)),
                                    e = "".concat(Ut("advertisement", i.player.config), " - ").concat(t);
                                i.elements.container.setAttribute("data-badge-text", e)
                            }, 100)
                        }
                    }, {
                        key: "onAdsManagerLoaded",
                        value: function(t) {
                            var e, i = this;
                            this.enabled && ((e = new google.ima.AdsRenderingSettings).restoreCustomPlaybackStateOnAdBreakComplete = !0, e.enablePreloading = !0, this.manager = t.getAdsManager(this.player, e), this.cuePoints = this.manager.getCuePoints(), this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, function(t) {
                                return i.onAdError(t)
                            }), Object.keys(google.ima.AdEvent.Type).forEach(function(t) {
                                i.manager.addEventListener(google.ima.AdEvent.Type[t], function(t) {
                                    return i.onAdEvent(t)
                                })
                            }), this.trigger("loaded"))
                        }
                    }, {
                        key: "addCuePoints",
                        value: function() {
                            var r = this;
                            tt(this.cuePoints) || this.cuePoints.forEach(function(t) {
                                var e, i, n;
                                0 !== t && -1 !== t && t < r.player.duration && (e = r.player.elements.progress, K(e) && (i = 100 / r.player.duration * t, (n = ht("span", {
                                    class: r.player.config.classNames.cues
                                })).style.left = "".concat(i.toString(), "%"), e.appendChild(n)))
                            })
                        }
                    }, {
                        key: "onAdEvent",
                        value: function(t) {
                            var e, i = this,
                                n = this.player.elements.container,
                                r = t.getAd(),
                                a = t.getAdData();
                            switch (e = t.type, Pt.call(i.player, i.player.media, "ads".concat(e.replace(/_/g, "").toLowerCase())), t.type) {
                                case google.ima.AdEvent.Type.LOADED:
                                    this.trigger("loaded"), this.pollCountdown(!0), r.isLinear() || (r.width = n.offsetWidth, r.height = n.offsetHeight);
                                    break;
                                case google.ima.AdEvent.Type.STARTED:
                                    this.manager.setVolume(this.player.volume);
                                    break;
                                case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
                                    this.player.ended ? this.loadAds() : this.loader.contentComplete();
                                    break;
                                case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
                                    this.pauseContent();
                                    break;
                                case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
                                    this.pollCountdown(), this.resumeContent();
                                    break;
                                case google.ima.AdEvent.Type.LOG:
                                    a.adError && this.player.debug.warn("Non-fatal ad error: ".concat(a.adError.getMessage()))
                            }
                        }
                    }, {
                        key: "onAdError",
                        value: function(t) {
                            this.cancel(), this.player.debug.warn("Ads error", t)
                        }
                    }, {
                        key: "listeners",
                        value: function() {
                            var n, r = this,
                                t = this.player.elements.container;
                            this.player.on("canplay", function() {
                                r.addCuePoints()
                            }), this.player.on("ended", function() {
                                r.loader.contentComplete()
                            }), this.player.on("timeupdate", function() {
                                n = r.player.currentTime
                            }), this.player.on("seeked", function() {
                                var i = r.player.currentTime;
                                tt(r.cuePoints) || r.cuePoints.forEach(function(t, e) {
                                    n < t && t < i && (r.manager.discardAdBreak(), r.cuePoints.splice(e, 1))
                                })
                            }), window.addEventListener("resize", function() {
                                r.manager && r.manager.resize(t.offsetWidth, t.offsetHeight, google.ima.ViewMode.NORMAL)
                            })
                        }
                    }, {
                        key: "play",
                        value: function() {
                            var e = this,
                                t = this.player.elements.container;
                            this.managerPromise || this.resumeContent(), this.managerPromise.then(function() {
                                e.manager.setVolume(e.player.volume), e.elements.displayContainer.initialize();
                                try {
                                    e.initialized || (e.manager.init(t.offsetWidth, t.offsetHeight, google.ima.ViewMode.NORMAL), e.manager.start()), e.initialized = !0
                                } catch (t) {
                                    e.onAdError(t)
                                }
                            }).catch(function() {})
                        }
                    }, {
                        key: "resumeContent",
                        value: function() {
                            this.elements.container.style.zIndex = "", this.playing = !1, Lt(this.player.media.play())
                        }
                    }, {
                        key: "pauseContent",
                        value: function() {
                            this.elements.container.style.zIndex = 3, this.playing = !0, this.player.media.pause()
                        }
                    }, {
                        key: "cancel",
                        value: function() {
                            this.initialized && this.resumeContent(), this.trigger("error"), this.loadAds()
                        }
                    }, {
                        key: "loadAds",
                        value: function() {
                            var e = this;
                            this.managerPromise.then(function() {
                                e.manager && e.manager.destroy(), e.managerPromise = new Promise(function(t) {
                                    e.on("loaded", t), e.player.debug.log(e.manager)
                                }), e.initialized = !1, e.requestAds()
                            }).catch(function() {})
                        }
                    }, {
                        key: "trigger",
                        value: function(t) {
                            for (var e = this, i = arguments.length, n = new Array(1 < i ? i - 1 : 0), r = 1; r < i; r++) n[r - 1] = arguments[r];
                            var a = this.events[t];
                            Z(a) && a.forEach(function(t) {
                                J(t) && t.apply(e, n)
                            })
                        }
                    }, {
                        key: "on",
                        value: function(t, e) {
                            return Z(this.events[t]) || (this.events[t] = []), this.events[t].push(e), this
                        }
                    }, {
                        key: "startSafetyTimer",
                        value: function(t, e) {
                            var i = this;
                            this.player.debug.log("Safety timer invoked from: ".concat(e)), this.safetyTimer = setTimeout(function() {
                                i.cancel(), i.clearSafetyTimer("startSafetyTimer()")
                            }, t)
                        }
                    }, {
                        key: "clearSafetyTimer",
                        value: function(t) {
                            W(this.safetyTimer) || (this.player.debug.log("Safety timer cleared from: ".concat(t)), clearTimeout(this.safetyTimer), this.safetyTimer = null)
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            var t = this.config;
                            return this.player.isHTML5 && this.player.isVideo && t.enabled && (!tt(t.publisherId) || R(t.tagUrl))
                        }
                    }, {
                        key: "tagUrl",
                        get: function() {
                            var t = this.config;
                            if (R(t.tagUrl)) return t.tagUrl;
                            var e = {
                                AV_PUBLISHERID: "58c25bb0073ef448b1087ad6",
                                AV_CHANNELID: "5a0458dc28a06145e4519d21",
                                AV_URL: window.location.hostname,
                                cb: Date.now(),
                                AV_WIDTH: 640,
                                AV_HEIGHT: 480,
                                AV_CDIM2: t.publisherId
                            };
                            return "".concat("https://go.aniview.com/api/adserver6/vast/", "?").concat(te(e))
                        }
                    }]), Ee),
                    Te = (t(Ae, [{
                        key: "load",
                        value: function() {
                            var t = this;
                            this.player.elements.display.seekTooltip && (this.player.elements.display.seekTooltip.hidden = this.enabled), this.enabled && this.getThumbnails().then(function() {
                                t.enabled && (t.render(), t.determineContainerAutoSizing(), t.loaded = !0)
                            })
                        }
                    }, {
                        key: "getThumbnails",
                        value: function() {
                            var r = this;
                            return new Promise(function(t) {
                                var e, i = r.player.config.previewThumbnails.src;
                                if (tt(i)) throw new Error("Missing previewThumbnails.src config attribute");

                                function n() {
                                    r.thumbnails.sort(function(t, e) {
                                        return t.height - e.height
                                    }), r.player.debug.log("Preview thumbnails", r.thumbnails), t()
                                }
                                J(i) ? i(function(t) {
                                    r.thumbnails = t, n()
                                }) : (e = (Y(i) ? [i] : i).map(function(t) {
                                    return r.getThumbnail(t)
                                }), Promise.all(e).then(n))
                            })
                        }
                    }, {
                        key: "getThumbnail",
                        value: function(a) {
                            var s = this;
                            return new Promise(function(r) {
                                qt(a).then(function(t) {
                                    var e, i = {
                                        frames: (e = [], t.split(/\r\n\r\n|\n\n|\r\r/).forEach(function(t) {
                                            var a = {};
                                            t.split(/\r\n|\n|\r/).forEach(function(t) {
                                                var e, i, n, r;
                                                X(a.startTime) ? !tt(t.trim()) && tt(a.text) && (i = _(e = t.trim().split("#xywh="), 1), a.text = i[0], e[1] && (n = _(e[1].split(","), 4), a.x = n[0], a.y = n[1], a.w = n[2], a.h = n[3])) : (r = t.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/)) && (a.startTime = 60 * Number(r[1] || 0) * 60 + 60 * Number(r[2]) + Number(r[3]) + Number("0.".concat(r[4])), a.endTime = 60 * Number(r[6] || 0) * 60 + 60 * Number(r[7]) + Number(r[8]) + Number("0.".concat(r[9])))
                                            }), a.text && e.push(a)
                                        }), e),
                                        height: null,
                                        urlPrefix: ""
                                    };
                                    i.frames[0].text.startsWith("/") || i.frames[0].text.startsWith("http://") || i.frames[0].text.startsWith("https://") || (i.urlPrefix = a.substring(0, a.lastIndexOf("/") + 1));
                                    var n = new Image;
                                    n.onload = function() {
                                        i.height = n.naturalHeight, i.width = n.naturalWidth, s.thumbnails.push(i), r()
                                    }, n.src = i.urlPrefix + i.frames[0].text
                                })
                            })
                        }
                    }, {
                        key: "startMove",
                        value: function(t) {
                            var e, i;
                            this.loaded && I(t) && ["touchmove", "mousemove"].includes(t.type) && this.player.media.duration && ("touchmove" === t.type ? this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100) : (i = 100 / (e = this.player.elements.progress.getBoundingClientRect()).width * (t.pageX - e.left), this.seekTime = this.player.media.duration * (i / 100), this.seekTime < 0 && (this.seekTime = 0), this.seekTime > this.player.media.duration - 1 && (this.seekTime = this.player.media.duration - 1), this.mousePosX = t.pageX, this.elements.thumb.time.innerText = $t(this.seekTime)), this.showImageAtCurrentTime())
                        }
                    }, {
                        key: "endMove",
                        value: function() {
                            this.toggleThumbContainer(!1, !0)
                        }
                    }, {
                        key: "startScrubbing",
                        value: function(t) {
                            !W(t.button) && !1 !== t.button && 0 !== t.button || (this.mouseDown = !0, this.player.media.duration && (this.toggleScrubbingContainer(!0), this.toggleThumbContainer(!1, !0), this.showImageAtCurrentTime()))
                        }
                    }, {
                        key: "endScrubbing",
                        value: function() {
                            var t = this;
                            this.mouseDown = !1, Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime) ? this.toggleScrubbingContainer(!1) : Dt.call(this.player, this.player.media, "timeupdate", function() {
                                t.mouseDown || t.toggleScrubbingContainer(!1)
                            })
                        }
                    }, {
                        key: "listeners",
                        value: function() {
                            var t = this;
                            this.player.on("play", function() {
                                t.toggleThumbContainer(!1, !0)
                            }), this.player.on("seeked", function() {
                                t.toggleThumbContainer(!1)
                            }), this.player.on("timeupdate", function() {
                                t.lastTime = t.player.media.currentTime
                            })
                        }
                    }, {
                        key: "render",
                        value: function() {
                            this.elements.thumb.container = ht("div", {
                                class: this.player.config.classNames.previewThumbnails.thumbContainer
                            }), this.elements.thumb.imageContainer = ht("div", {
                                class: this.player.config.classNames.previewThumbnails.imageContainer
                            }), this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);
                            var t = ht("div", {
                                class: this.player.config.classNames.previewThumbnails.timeContainer
                            });
                            this.elements.thumb.time = ht("span", {}, "00:00"), t.appendChild(this.elements.thumb.time), this.elements.thumb.container.appendChild(t), K(this.player.elements.progress) && this.player.elements.progress.appendChild(this.elements.thumb.container), this.elements.scrubbing.container = ht("div", {
                                class: this.player.config.classNames.previewThumbnails.scrubbingContainer
                            }), this.player.elements.wrapper.appendChild(this.elements.scrubbing.container)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.elements.thumb.container && this.elements.thumb.container.remove(), this.elements.scrubbing.container && this.elements.scrubbing.container.remove()
                        }
                    }, {
                        key: "showImageAtCurrentTime",
                        value: function() {
                            var i = this;
                            this.mouseDown ? this.setScrubbingContainerSize() : this.setThumbContainerSizeAndPos();
                            var n = this.thumbnails[0].frames.findIndex(function(t) {
                                    return i.seekTime >= t.startTime && i.seekTime <= t.endTime
                                }),
                                t = 0 <= n,
                                r = 0;
                            this.mouseDown || this.toggleThumbContainer(t), t && (this.thumbnails.forEach(function(t, e) {
                                i.loadedImages.includes(t.frames[n].text) && (r = e)
                            }), n !== this.showingThumb && (this.showingThumb = n, this.loadImage(r)))
                        }
                    }, {
                        key: "loadImage",
                        value: function(t) {
                            var e, i = this,
                                n = 0 < arguments.length && void 0 !== t ? t : 0,
                                r = this.showingThumb,
                                a = this.thumbnails[n],
                                s = a.urlPrefix,
                                o = a.frames[r],
                                l = a.frames[r].text,
                                h = s + l;
                            this.currentImageElement && this.currentImageElement.dataset.filename === l ? (this.showImage(this.currentImageElement, o, n, r, l, !1), this.currentImageElement.dataset.index = r, this.removeOldImages(this.currentImageElement)) : (this.loadingImage && this.usingSprites && (this.loadingImage.onload = null), (e = new Image).src = h, e.dataset.index = r, e.dataset.filename = l, this.showingThumbFilename = l, this.player.debug.log("Loading image: ".concat(h)), e.onload = function() {
                                return i.showImage(e, o, n, r, l, !0)
                            }, this.loadingImage = e, this.removeOldImages(e))
                        }
                    }, {
                        key: "showImage",
                        value: function(t, e, i, n, r, a) {
                            var s = !(5 < arguments.length && void 0 !== a) || a;
                            this.player.debug.log("Showing thumb: ".concat(r, ". num: ").concat(n, ". qual: ").concat(i, ". newimg: ").concat(s)), this.setImageSizeAndOffset(t, e), s && (this.currentImageContainer.appendChild(t), this.currentImageElement = t, this.loadedImages.includes(r) || this.loadedImages.push(r)), this.preloadNearby(n, !0).then(this.preloadNearby(n, !1)).then(this.getHigherQuality(i, t, e, r))
                        }
                    }, {
                        key: "removeOldImages",
                        value: function(n) {
                            var r = this;
                            Array.from(this.currentImageContainer.children).forEach(function(t) {
                                var e, i;
                                "img" === t.tagName.toLowerCase() && (e = r.usingSprites ? 500 : 1e3, t.dataset.index === n.dataset.index || t.dataset.deleting || (t.dataset.deleting = !0, i = r.currentImageContainer, setTimeout(function() {
                                    i.removeChild(t), r.player.debug.log("Removing thumb: ".concat(t.dataset.filename))
                                }, e)))
                            })
                        }
                    }, {
                        key: "preloadNearby",
                        value: function(e, t) {
                            var o = this,
                                i = !(1 < arguments.length && void 0 !== t) || t;
                            return new Promise(function(s) {
                                setTimeout(function() {
                                    var t, r, a = o.thumbnails[0].frames[e].text;
                                    o.showingThumbFilename === a && (t = i ? o.thumbnails[0].frames.slice(e) : o.thumbnails[0].frames.slice(0, e).reverse(), r = !1, t.forEach(function(t) {
                                        var e, i, n = t.text;
                                        n === a || o.loadedImages.includes(n) || (r = !0, o.player.debug.log("Preloading thumb filename: ".concat(n)), e = o.thumbnails[0].urlPrefix + n, (i = new Image).src = e, i.onload = function() {
                                            o.player.debug.log("Preloaded thumb filename: ".concat(n)), o.loadedImages.includes(n) || o.loadedImages.push(n), s()
                                        })
                                    }), r || s())
                                }, 300)
                            })
                        }
                    }, {
                        key: "getHigherQuality",
                        value: function(t, e, i, n) {
                            var r, a = this;
                            t < this.thumbnails.length - 1 && (r = e.naturalHeight, this.usingSprites && (r = i.h), r < this.thumbContainerHeight && setTimeout(function() {
                                a.showingThumbFilename === n && (a.player.debug.log("Showing higher quality thumb for: ".concat(n)), a.loadImage(t + 1))
                            }, 300))
                        }
                    }, {
                        key: "toggleThumbContainer",
                        value: function(t, e) {
                            var i = 0 < arguments.length && void 0 !== t && t,
                                n = 1 < arguments.length && void 0 !== e && e,
                                r = this.player.config.classNames.previewThumbnails.thumbContainerShown;
                            this.elements.thumb.container.classList.toggle(r, i), !i && n && (this.showingThumb = null, this.showingThumbFilename = null)
                        }
                    }, {
                        key: "toggleScrubbingContainer",
                        value: function(t) {
                            var e = 0 < arguments.length && void 0 !== t && t,
                                i = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;
                            this.elements.scrubbing.container.classList.toggle(i, e), e || (this.showingThumb = null, this.showingThumbFilename = null)
                        }
                    }, {
                        key: "determineContainerAutoSizing",
                        value: function() {
                            (20 < this.elements.thumb.imageContainer.clientHeight || 20 < this.elements.thumb.imageContainer.clientWidth) && (this.sizeSpecifiedInCSS = !0)
                        }
                    }, {
                        key: "setThumbContainerSizeAndPos",
                        value: function() {
                            var t, e, i;
                            this.sizeSpecifiedInCSS ? 20 < this.elements.thumb.imageContainer.clientHeight && this.elements.thumb.imageContainer.clientWidth < 20 ? (t = Math.floor(this.elements.thumb.imageContainer.clientHeight * this.thumbAspectRatio), this.elements.thumb.imageContainer.style.width = "".concat(t, "px")) : this.elements.thumb.imageContainer.clientHeight < 20 && 20 < this.elements.thumb.imageContainer.clientWidth && (e = Math.floor(this.elements.thumb.imageContainer.clientWidth / this.thumbAspectRatio), this.elements.thumb.imageContainer.style.height = "".concat(e, "px")) : (i = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio), this.elements.thumb.imageContainer.style.height = "".concat(this.thumbContainerHeight, "px"), this.elements.thumb.imageContainer.style.width = "".concat(i, "px")), this.setThumbContainerPos()
                        }
                    }, {
                        key: "setThumbContainerPos",
                        value: function() {
                            var t = this.player.elements.progress.getBoundingClientRect(),
                                e = this.player.elements.container.getBoundingClientRect(),
                                i = this.elements.thumb.container,
                                n = e.left - t.left + 10,
                                r = e.right - t.left - i.clientWidth - 10,
                                a = this.mousePosX - t.left - i.clientWidth / 2;
                            a < n && (a = n), r < a && (a = r), i.style.left = "".concat(a, "px")
                        }
                    }, {
                        key: "setScrubbingContainerSize",
                        value: function() {
                            var t = _e(this.thumbAspectRatio, {
                                    width: this.player.media.clientWidth,
                                    height: this.player.media.clientHeight
                                }),
                                e = t.width,
                                i = t.height;
                            this.elements.scrubbing.container.style.width = "".concat(e, "px"), this.elements.scrubbing.container.style.height = "".concat(i, "px")
                        }
                    }, {
                        key: "setImageSizeAndOffset",
                        value: function(t, e) {
                            var i;
                            this.usingSprites && (i = this.thumbContainerHeight / e.h, t.style.height = "".concat(t.naturalHeight * i, "px"), t.style.width = "".concat(t.naturalWidth * i, "px"), t.style.left = "-".concat(e.x * i, "px"), t.style.top = "-".concat(e.y * i, "px"))
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled
                        }
                    }, {
                        key: "currentImageContainer",
                        get: function() {
                            return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer
                        }
                    }, {
                        key: "usingSprites",
                        get: function() {
                            return Object.keys(this.thumbnails[0].frames[0]).includes("w")
                        }
                    }, {
                        key: "thumbAspectRatio",
                        get: function() {
                            return this.usingSprites ? this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h : this.thumbnails[0].width / this.thumbnails[0].height
                        }
                    }, {
                        key: "thumbContainerHeight",
                        get: function() {
                            return this.mouseDown ? _e(this.thumbAspectRatio, {
                                width: this.player.media.clientWidth,
                                height: this.player.media.clientHeight
                            }).height : this.sizeSpecifiedInCSS ? this.elements.thumb.imageContainer.clientHeight : Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4)
                        }
                    }, {
                        key: "currentImageElement",
                        get: function() {
                            return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement
                        },
                        set: function(t) {
                            this.mouseDown ? this.currentScrubbingImageElement = t : this.currentThumbnailImageElement = t
                        }
                    }]), Ae),
                    Ce = {
                        insertElements: function(e, t) {
                            var i = this;
                            Y(t) ? ut(e, this.media, {
                                src: t
                            }) : Z(t) && t.forEach(function(t) {
                                ut(e, i.media, t)
                            })
                        },
                        change: function(l) {
                            var h = this;
                            at(l, "sources.length") ? (Nt.cancelRequests.call(this), this.destroy.call(this, function() {
                                h.options.quality = [], ct(h.media), h.media = null, K(h.elements.container) && h.elements.container.removeAttribute("class");
                                var t = l.sources,
                                    e = l.type,
                                    i = _(t, 1)[0],
                                    n = i.provider,
                                    r = void 0 === n ? ae.html5 : n,
                                    a = i.src,
                                    s = "html5" === r ? e : "div",
                                    o = "html5" === r ? {} : {
                                        src: a
                                    };
                                Object.assign(h, {
                                    provider: r,
                                    type: e,
                                    supported: Mt.check(e, r, h.config.playsinline),
                                    media: ht(s, o)
                                }), h.elements.container.appendChild(h.media), F(l.autoplay) && (h.config.autoplay = l.autoplay), h.isHTML5 && (h.config.crossorigin && h.media.setAttribute("crossorigin", ""), h.config.autoplay && h.media.setAttribute("autoplay", ""), tt(l.poster) || (h.poster = l.poster), h.config.loop.active && h.media.setAttribute("loop", ""), h.config.muted && h.media.setAttribute("muted", ""), h.config.playsinline && h.media.setAttribute("playsinline", "")), pe.addStyleHook.call(h), h.isHTML5 && Ce.insertElements.call(h, "source", t), h.config.title = l.title, Se.setup.call(h), h.isHTML5 && Object.keys(l).includes("tracks") && Ce.insertElements.call(h, "track", l.tracks), (h.isHTML5 || h.isEmbed && !h.supported.ui) && pe.build.call(h), h.isHTML5 && h.media.load(), tt(l.previewThumbnails) || (Object.assign(h.config.previewThumbnails, l.previewThumbnails), h.previewThumbnails && h.previewThumbnails.loaded && (h.previewThumbnails.destroy(), h.previewThumbnails = null), h.config.previewThumbnails.enabled && (h.previewThumbnails = new Te(h))), h.fullscreen.update()
                            }, !0)) : this.debug.warn("Invalid source format")
                        }
                    };

                function Ae(t) {
                    h(this, Ae), this.player = t, this.thumbnails = [], this.loaded = !1, this.lastMouseMoveTime = Date.now(), this.mouseDown = !1, this.loadedImages = [], this.elements = {
                        thumb: {},
                        scrubbing: {}
                    }, this.load()
                }

                function Ee(t) {
                    var i = this;
                    h(this, Ee), this.player = t, this.config = t.config.ads, this.playing = !1, this.initialized = !1, this.elements = {
                        container: null,
                        displayContainer: null
                    }, this.manager = null, this.loader = null, this.cuePoints = null, this.events = {}, this.safetyTimer = null, this.countdownTimer = null, this.managerPromise = new Promise(function(t, e) {
                        i.on("loaded", t), i.on("error", e)
                    }), this.load()
                }
                var De = (t(Pe, [{
                    key: "play",
                    value: function() {
                        var t = this;
                        return J(this.media.play) ? (this.ads && this.ads.enabled && this.ads.managerPromise.then(function() {
                            return t.ads.play()
                        }).catch(function() {
                            return Lt(t.media.play())
                        }), this.media.play()) : null
                    }
                }, {
                    key: "pause",
                    value: function() {
                        return this.playing && J(this.media.pause) ? this.media.pause() : null
                    }
                }, {
                    key: "togglePlay",
                    value: function(t) {
                        return (F(t) ? t : !this.playing) ? this.play() : this.pause()
                    }
                }, {
                    key: "stop",
                    value: function() {
                        this.isHTML5 ? (this.pause(), this.restart()) : J(this.media.stop) && this.media.stop()
                    }
                }, {
                    key: "restart",
                    value: function() {
                        this.currentTime = 0
                    }
                }, {
                    key: "rewind",
                    value: function(t) {
                        this.currentTime -= X(t) ? t : this.config.seekTime
                    }
                }, {
                    key: "forward",
                    value: function(t) {
                        this.currentTime += X(t) ? t : this.config.seekTime
                    }
                }, {
                    key: "increaseVolume",
                    value: function(t) {
                        var e = this.media.muted ? 0 : this.volume;
                        this.volume = e + (X(t) ? t : 0)
                    }
                }, {
                    key: "decreaseVolume",
                    value: function(t) {
                        this.increaseVolume(-t)
                    }
                }, {
                    key: "toggleCaptions",
                    value: function(t) {
                        ie.toggle.call(this, t, !1)
                    }
                }, {
                    key: "airplay",
                    value: function() {
                        Mt.airplay && this.media.webkitShowPlaybackTargetPicker()
                    }
                }, {
                    key: "toggleControls",
                    value: function(t) {
                        if (!this.supported.ui || this.isAudio) return !1;
                        var e, i = vt(this.elements.container, this.config.classNames.hideControls),
                            n = void 0 === t ? void 0 : !t,
                            r = gt(this.elements.container, this.config.classNames.hideControls, n);
                        return r && Z(this.config.controls) && this.config.controls.includes("settings") && !tt(this.config.settings) && Kt.toggleMenu.call(this, !1), r !== i && (e = r ? "controlshidden" : "controlsshown", Pt.call(this, this.media, e)), !r
                    }
                }, {
                    key: "on",
                    value: function(t, e) {
                        At.call(this, this.elements.container, t, e)
                    }
                }, {
                    key: "once",
                    value: function(t, e) {
                        Dt.call(this, this.elements.container, t, e)
                    }
                }, {
                    key: "off",
                    value: function(t, e) {
                        Et(this.elements.container, t, e)
                    }
                }, {
                    key: "destroy",
                    value: function(t, e) {
                        var i, n = this,
                            r = 1 < arguments.length && void 0 !== e && e;
                        this.ready && (i = function() {
                            document.body.style.overflow = "", n.embed = null, r ? (Object.keys(n.elements).length && (ct(n.elements.buttons.play), ct(n.elements.captions), ct(n.elements.controls), ct(n.elements.wrapper), n.elements.buttons.play = null, n.elements.captions = null, n.elements.controls = null, n.elements.wrapper = null), J(t) && t()) : (function() {
                                this && this.eventListeners && (this.eventListeners.forEach(function(t) {
                                    var e = t.element,
                                        i = t.type,
                                        n = t.callback,
                                        r = t.options;
                                    e.removeEventListener(i, n, r)
                                }), this.eventListeners = [])
                            }.call(n), dt(n.elements.original, n.elements.container), Pt.call(n, n.elements.original, "destroyed", !0), J(t) && t.call(n.elements.original), n.ready = !1, setTimeout(function() {
                                n.elements = null, n.media = null
                            }, 200))
                        }, this.stop(), clearTimeout(this.timers.loading), clearTimeout(this.timers.controls), clearTimeout(this.timers.resized), this.isHTML5 ? (pe.toggleNativeControls.call(this, !0), i()) : this.isYouTube ? (clearInterval(this.timers.buffering), clearInterval(this.timers.playing), null !== this.embed && J(this.embed.destroy) && this.embed.destroy(), i()) : this.isVimeo && (null !== this.embed && this.embed.unload().then(i), setTimeout(i, 200)))
                    }
                }, {
                    key: "supports",
                    value: function(t) {
                        return Mt.mime.call(this, t)
                    }
                }, {
                    key: "isHTML5",
                    get: function() {
                        return this.provider === ae.html5
                    }
                }, {
                    key: "isEmbed",
                    get: function() {
                        return this.isYouTube || this.isVimeo
                    }
                }, {
                    key: "isYouTube",
                    get: function() {
                        return this.provider === ae.youtube
                    }
                }, {
                    key: "isVimeo",
                    get: function() {
                        return this.provider === ae.vimeo
                    }
                }, {
                    key: "isVideo",
                    get: function() {
                        return this.type === se
                    }
                }, {
                    key: "isAudio",
                    get: function() {
                        return "audio" === this.type
                    }
                }, {
                    key: "playing",
                    get: function() {
                        return Boolean(this.ready && !this.paused && !this.ended)
                    }
                }, {
                    key: "paused",
                    get: function() {
                        return Boolean(this.media.paused)
                    }
                }, {
                    key: "stopped",
                    get: function() {
                        return Boolean(this.paused && 0 === this.currentTime)
                    }
                }, {
                    key: "ended",
                    get: function() {
                        return Boolean(this.media.ended)
                    }
                }, {
                    key: "currentTime",
                    set: function(t) {
                        var e;
                        this.duration && (e = X(t) && 0 < t, this.media.currentTime = e ? Math.min(t, this.duration) : 0, this.debug.log("Seeking to ".concat(this.currentTime, " seconds")))
                    },
                    get: function() {
                        return Number(this.media.currentTime)
                    }
                }, {
                    key: "buffered",
                    get: function() {
                        var t = this.media.buffered;
                        return X(t) ? t : t && t.length && 0 < this.duration ? t.end(0) / this.duration : 0
                    }
                }, {
                    key: "seeking",
                    get: function() {
                        return Boolean(this.media.seeking)
                    }
                }, {
                    key: "duration",
                    get: function() {
                        var t = parseFloat(this.config.duration),
                            e = (this.media || {}).duration,
                            i = X(e) && e !== 1 / 0 ? e : 0;
                        return t || i
                    }
                }, {
                    key: "volume",
                    set: function(t) {
                        var e = t;
                        Y(e) && (e = Number(e)), X(e) || (e = this.storage.get("volume")), X(e) || (e = this.config.volume), 1 < e && (e = 1), e < 0 && (e = 0), this.config.volume = e, this.media.volume = e, !tt(t) && this.muted && 0 < e && (this.muted = !1)
                    },
                    get: function() {
                        return Number(this.media.volume)
                    }
                }, {
                    key: "muted",
                    set: function(t) {
                        var e = t;
                        F(e) || (e = this.storage.get("muted")), F(e) || (e = this.config.muted), this.config.muted = e, this.media.muted = e
                    },
                    get: function() {
                        return Boolean(this.media.muted)
                    }
                }, {
                    key: "hasAudio",
                    get: function() {
                        return !this.isHTML5 || !!this.isAudio || Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length)
                    }
                }, {
                    key: "speed",
                    set: function(t) {
                        var e = this,
                            i = null;
                        X(t) && (i = t), X(i) || (i = this.storage.get("speed")), X(i) || (i = this.config.speed.selected);
                        var n = this.minimumSpeed,
                            r = this.maximumSpeed,
                            i = function(t, e, i) {
                                var n = 0 < arguments.length && void 0 !== t ? t : 0,
                                    r = 1 < arguments.length && void 0 !== e ? e : 0,
                                    a = 2 < arguments.length && void 0 !== i ? i : 255;
                                return Math.min(Math.max(n, r), a)
                            }(i, n, r);
                        this.config.speed.selected = i, setTimeout(function() {
                            e.media.playbackRate = i
                        }, 0)
                    },
                    get: function() {
                        return Number(this.media.playbackRate)
                    }
                }, {
                    key: "minimumSpeed",
                    get: function() {
                        return this.isYouTube ? Math.min.apply(Math, u(this.options.speed)) : this.isVimeo ? .5 : .0625
                    }
                }, {
                    key: "maximumSpeed",
                    get: function() {
                        return this.isYouTube ? Math.max.apply(Math, u(this.options.speed)) : this.isVimeo ? 2 : 16
                    }
                }, {
                    key: "quality",
                    set: function(t) {
                        var e, i, n, r, a, s = this.config.quality,
                            o = this.options.quality;
                        o.length && (e = [!tt(t) && Number(t), this.storage.get("quality"), s.selected, s.default].find(X), i = !0, o.includes(e) || (a = e, n = Z(r = o) && r.length ? r.reduce(function(t, e) {
                            return Math.abs(e - a) < Math.abs(t - a) ? e : t
                        }) : null, this.debug.warn("Unsupported quality option: ".concat(e, ", using ").concat(n, " instead")), e = n, i = !1), s.selected = e, this.media.quality = e, i && this.storage.set({
                            quality: e
                        }))
                    },
                    get: function() {
                        return this.media.quality
                    }
                }, {
                    key: "loop",
                    set: function(t) {
                        var e = F(t) ? t : this.config.loop.active;
                        this.config.loop.active = e, this.media.loop = e
                    },
                    get: function() {
                        return Boolean(this.media.loop)
                    }
                }, {
                    key: "source",
                    set: function(t) {
                        Ce.change.call(this, t)
                    },
                    get: function() {
                        return this.media.currentSrc
                    }
                }, {
                    key: "download",
                    get: function() {
                        var t = this.config.urls.download;
                        return R(t) ? t : this.source
                    },
                    set: function(t) {
                        R(t) && (this.config.urls.download = t, Kt.setDownloadUrl.call(this))
                    }
                }, {
                    key: "poster",
                    set: function(t) {
                        this.isVideo ? pe.setPoster.call(this, t, !1).catch(function() {}) : this.debug.warn("Poster can only be set for video")
                    },
                    get: function() {
                        return this.isVideo ? this.media.getAttribute("poster") || this.media.getAttribute("data-poster") : null
                    }
                }, {
                    key: "ratio",
                    get: function() {
                        if (!this.isVideo) return null;
                        var t = Ot(Ft.call(this));
                        return Z(t) ? t.join(":") : t
                    },
                    set: function(t) {
                        this.isVideo ? Y(t) && kt(t) ? (this.config.ratio = t, It.call(this)) : this.debug.error("Invalid aspect ratio specified (".concat(t, ")")) : this.debug.warn("Aspect ratio can only be set for video")
                    }
                }, {
                    key: "autoplay",
                    set: function(t) {
                        var e = F(t) ? t : this.config.autoplay;
                        this.config.autoplay = e
                    },
                    get: function() {
                        return Boolean(this.config.autoplay)
                    }
                }, {
                    key: "currentTrack",
                    set: function(t) {
                        ie.set.call(this, t, !1)
                    },
                    get: function() {
                        var t = this.captions,
                            e = t.toggled,
                            i = t.currentTrack;
                        return e ? i : -1
                    }
                }, {
                    key: "language",
                    set: function(t) {
                        ie.setLanguage.call(this, t, !1)
                    },
                    get: function() {
                        return (ie.getCurrentTrack.call(this) || {}).language
                    }
                }, {
                    key: "pip",
                    set: function(t) {
                        var e;
                        Mt.pip && (e = F(t) ? t : !this.pip, J(this.media.webkitSetPresentationMode) && this.media.webkitSetPresentationMode(e ? re : "inline"), J(this.media.requestPictureInPicture) && (!this.pip && e ? this.media.requestPictureInPicture() : this.pip && !e && document.exitPictureInPicture()))
                    },
                    get: function() {
                        return Mt.pip ? tt(this.media.webkitPresentationMode) ? this.media === document.pictureInPictureElement : this.media.webkitPresentationMode === re : null
                    }
                }], [{
                    key: "supported",
                    value: function(t, e, i) {
                        return Mt.check(t, e, i)
                    }
                }, {
                    key: "loadSprite",
                    value: Xt
                }, {
                    key: "setup",
                    value: function(t, e) {
                        var i = 1 < arguments.length && void 0 !== e ? e : {},
                            n = null;
                        return Y(t) ? n = Array.from(document.querySelectorAll(t)) : $(t) ? n = Array.from(t) : Z(t) && (n = t.filter(K)), tt(n) ? null : n.map(function(t) {
                            return new Pe(t, i)
                        })
                    }
                }]), Pe);

                function Pe(t, e) {
                    var i, n = this;
                    if (h(this, Pe), this.timers = {}, this.ready = !1, this.loading = !1, this.failed = !1, this.touch = Mt.touch, this.media = t, Y(this.media) && (this.media = document.querySelectorAll(this.media)), (window.jQuery && this.media instanceof jQuery || $(this.media) || Z(this.media)) && (this.media = this.media[0]), this.config = st({}, ne, Pe.defaults, e || {}, function() {
                            try {
                                return JSON.parse(n.media.getAttribute("data-plyr-config"))
                            } catch (t) {
                                return {}
                            }
                        }()), this.elements = {
                            container: null,
                            fullscreen: null,
                            captions: null,
                            buttons: {},
                            display: {},
                            progress: {},
                            inputs: {},
                            settings: {
                                popup: null,
                                menu: null,
                                panels: {},
                                buttons: {}
                            }
                        }, this.captions = {
                            active: null,
                            currentTrack: -1,
                            meta: new WeakMap
                        }, this.fullscreen = {
                            active: !1
                        }, this.options = {
                            speed: [],
                            quality: []
                        }, this.debug = new oe(this.config.debug), this.debug.log("Config", this.config), this.debug.log("Support", Mt), !W(this.media) && K(this.media))
                        if (this.media.plyr) this.debug.warn("Target already setup");
                        else if (this.config.enabled)
                        if (Mt.check().api) {
                            var r = this.media.cloneNode(!0);
                            r.autoplay = !1, this.elements.original = r;
                            var a = this.media.tagName.toLowerCase(),
                                s = null,
                                o = null;
                            switch (a) {
                                case "div":
                                    var l, s = this.media.querySelector("iframe");
                                    if (K(s) ? (o = Qt(s.getAttribute("src")), this.provider = (i = o.toString(), /^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(i) ? ae.youtube : /^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(i) ? ae.vimeo : null), this.elements.container = this.media, this.media = s, this.elements.container.className = "", o.search.length && ((l = ["1", "true"]).includes(o.searchParams.get("autoplay")) && (this.config.autoplay = !0), l.includes(o.searchParams.get("loop")) && (this.config.loop.active = !0), this.isYouTube ? (this.config.playsinline = l.includes(o.searchParams.get("playsinline")), this.config.youtube.hl = o.searchParams.get("hl")) : this.config.playsinline = !0)) : (this.provider = this.media.getAttribute(this.config.attributes.embed.provider), this.media.removeAttribute(this.config.attributes.embed.provider)), tt(this.provider) || !Object.keys(ae).includes(this.provider)) return void this.debug.error("Setup failed: Invalid provider");
                                    this.type = se;
                                    break;
                                case "video":
                                case "audio":
                                    this.type = a, this.provider = ae.html5, this.media.hasAttribute("crossorigin") && (this.config.crossorigin = !0), this.media.hasAttribute("autoplay") && (this.config.autoplay = !0), (this.media.hasAttribute("playsinline") || this.media.hasAttribute("webkit-playsinline")) && (this.config.playsinline = !0), this.media.hasAttribute("muted") && (this.config.muted = !0), this.media.hasAttribute("loop") && (this.config.loop.active = !0);
                                    break;
                                default:
                                    return void this.debug.error("Setup failed: unsupported type")
                            }
                            this.supported = Mt.check(this.type, this.provider, this.config.playsinline), this.supported.api ? (this.eventListeners = [], this.listeners = new de(this), this.storage = new Ht(this), this.media.plyr = this, K(this.elements.container) || (this.elements.container = ht("div", {
                                tabindex: 0
                            }), ot(this.media, this.elements.container)), pe.migrateStyles.call(this), pe.addStyleHook.call(this), Se.setup.call(this), this.config.debug && At.call(this, this.elements.container, this.config.events.join(" "), function(t) {
                                n.debug.log("event: ".concat(t.type))
                            }), this.fullscreen = new le(this), (this.isHTML5 || this.isEmbed && !this.supported.ui) && pe.build.call(this), this.listeners.container(), this.listeners.global(), this.config.ads.enabled && (this.ads = new Me(this)), this.isHTML5 && this.config.autoplay && setTimeout(function() {
                                return Lt(n.play())
                            }, 10), this.lastSeekTime = 0, this.config.previewThumbnails.enabled && (this.previewThumbnails = new Te(this))) : this.debug.error("Setup failed: no support")
                        } else this.debug.error("Setup failed: no support");
                    else this.debug.error("Setup failed: disabled by config");
                    else this.debug.error("Setup failed: no suitable element passed")
                }
                return De.defaults = JSON.parse(JSON.stringify(ne)), De
            }, "object" == ((i = void 0) === a ? "undefined" : e(a)) && void 0 !== r ? r.exports = n() : "function" == typeof define && define.amd ? define("Plyr", n) : (i = i || self).Plyr = n())
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    "slim-select": [function(t, e, i) {
        "use strict";

        function o(t) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        var n, r;
        n = window, r = function() {
            return n = {}, r.m = i = [function(t, e, i) {
                function n(t, e) {
                    e = e || {
                        bubbles: !1,
                        cancelable: !1,
                        detail: void 0
                    };
                    var i = document.createEvent("CustomEvent");
                    return i.initCustomEvent(t, e.bubbles, e.cancelable, e.detail), i
                }
                var r;
                e.__esModule = !0, e.hasClassInTree = function(t, e) {
                    function n(t, e) {
                        return e && t && t.classList && t.classList.contains(e) ? t : null
                    }
                    return n(t, e) || function t(e, i) {
                        return e && e !== document ? n(e, i) ? e : t(e.parentNode, i) : null
                    }(t, e)
                }, e.ensureElementInView = function(t, e) {
                    var i = t.scrollTop + t.offsetTop,
                        n = i + t.clientHeight,
                        r = e.offsetTop,
                        a = r + e.clientHeight;
                    r < i ? t.scrollTop -= i - r : n < a && (t.scrollTop += a - n)
                }, e.putContent = function(t, e, i) {
                    var n = t.offsetHeight,
                        r = t.getBoundingClientRect(),
                        a = i ? r.top : r.top - n,
                        s = i ? r.bottom : r.bottom + n;
                    return a <= 0 ? "below" : s >= window.innerHeight ? "above" : i ? e : "below"
                }, e.debounce = function(r, a, s) {
                    var o;
                    return void 0 === a && (a = 100), void 0 === s && (s = !1),
                        function() {
                            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
                            var i = self,
                                n = s && !o;
                            clearTimeout(o), o = setTimeout(function() {
                                o = null, s || r.apply(i, t)
                            }, a), n && r.apply(i, t)
                        }
                }, e.isValueInArrayOfObjects = function(t, e, i) {
                    if (!Array.isArray(t)) return t[e] === i;
                    for (var n = 0, r = t; n < r.length; n++) {
                        var a = r[n];
                        if (a && a[e] && a[e] === i) return !0
                    }
                    return !1
                }, e.highlight = function(t, e, i) {
                    var n = t,
                        r = new RegExp("(" + e.trim() + ")(?![^<]*>[^<>]*</)", "i");
                    if (!t.match(r)) return t;
                    var a = t.match(r).index,
                        s = a + t.match(r)[0].toString().length,
                        o = t.substring(a, s);
                    return n.replace(r, '<mark class="' + i + '">' + o + "</mark>")
                }, e.kebabCase = function(t) {
                    var e = t.replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, function(t) {
                        return "-" + t.toLowerCase()
                    });
                    return t[0] === t[0].toUpperCase() ? e.substring(1) : e
                }, "function" != typeof(r = window).CustomEvent && (n.prototype = r.Event.prototype, r.CustomEvent = n)
            }, function(t, e, i) {
                e.__esModule = !0;
                var n = (r.prototype.newOption = function(t) {
                    return {
                        id: t.id ? t.id : String(Math.floor(1e8 * Math.random())),
                        value: t.value ? t.value : "",
                        text: t.text ? t.text : "",
                        innerHTML: t.innerHTML ? t.innerHTML : "",
                        selected: !!t.selected && t.selected,
                        display: void 0 === t.display || t.display,
                        disabled: !!t.disabled && t.disabled,
                        placeholder: !!t.placeholder && t.placeholder,
                        class: t.class ? t.class : void 0,
                        data: t.data ? t.data : {},
                        mandatory: !!t.mandatory && t.mandatory
                    }
                }, r.prototype.add = function(t) {
                    this.data.push({
                        id: String(Math.floor(1e8 * Math.random())),
                        value: t.value,
                        text: t.text,
                        innerHTML: "",
                        selected: !1,
                        display: !0,
                        disabled: !1,
                        placeholder: !1,
                        class: void 0,
                        mandatory: t.mandatory,
                        data: {}
                    })
                }, r.prototype.parseSelectData = function() {
                    this.data = [];
                    for (var t = 0, e = this.main.select.element.childNodes; t < e.length; t++) {
                        var i = e[t];
                        if ("OPTGROUP" === i.nodeName) {
                            for (var n = {
                                    label: i.label,
                                    options: []
                                }, r = 0, a = i.childNodes; r < a.length; r++) {
                                var s, o = a[r];
                                "OPTION" === o.nodeName && (s = this.pullOptionData(o), n.options.push(s), s.placeholder && "" !== s.text.trim() && (this.main.config.placeholderText = s.text))
                            }
                            this.data.push(n)
                        } else "OPTION" === i.nodeName && (s = this.pullOptionData(i), this.data.push(s), s.placeholder && "" !== s.text.trim() && (this.main.config.placeholderText = s.text))
                    }
                }, r.prototype.pullOptionData = function(t) {
                    return {
                        id: !!t.dataset && t.dataset.id || String(Math.floor(1e8 * Math.random())),
                        value: t.value,
                        text: t.text,
                        innerHTML: t.innerHTML,
                        selected: t.selected,
                        disabled: t.disabled,
                        placeholder: "true" === t.dataset.placeholder,
                        class: t.className,
                        style: t.style.cssText,
                        data: t.dataset,
                        mandatory: !!t.dataset && "true" === t.dataset.mandatory
                    }
                }, r.prototype.setSelectedFromSelect = function() {
                    if (this.main.config.isMultiple) {
                        for (var t = [], e = 0, i = this.main.select.element.options; e < i.length; e++) {
                            var n, r = i[e];
                            !r.selected || (n = this.getObjectFromData(r.value, "value")) && n.id && t.push(n.id)
                        }
                        this.setSelected(t, "id")
                    } else {
                        var a, s = this.main.select.element; - 1 !== s.selectedIndex && (a = s.options[s.selectedIndex].value, this.setSelected(a, "value"))
                    }
                }, r.prototype.setSelected = function(t, e) {
                    void 0 === e && (e = "id");
                    for (var i = 0, n = this.data; i < n.length; i++) {
                        var r = n[i];
                        if (r.hasOwnProperty("label")) {
                            if (r.hasOwnProperty("options")) {
                                var a = r.options;
                                if (a)
                                    for (var s = 0, o = a; s < o.length; s++) {
                                        var l = o[s];
                                        l.placeholder || (l.selected = this.shouldBeSelected(l, t, e))
                                    }
                            }
                        } else r.selected = this.shouldBeSelected(r, t, e)
                    }
                }, r.prototype.shouldBeSelected = function(t, e, i) {
                    if (void 0 === i && (i = "id"), Array.isArray(e))
                        for (var n = 0, r = e; n < r.length; n++) {
                            var a = r[n];
                            if (i in t && String(t[i]) === String(a)) return !0
                        } else if (i in t && String(t[i]) === String(e)) return !0;
                    return !1
                }, r.prototype.getSelected = function() {
                    for (var t = {
                            text: "",
                            placeholder: this.main.config.placeholderText
                        }, e = [], i = 0, n = this.data; i < n.length; i++) {
                        var r = n[i];
                        if (r.hasOwnProperty("label")) {
                            if (r.hasOwnProperty("options")) {
                                var a = r.options;
                                if (a)
                                    for (var s = 0, o = a; s < o.length; s++) {
                                        var l = o[s];
                                        l.selected && (this.main.config.isMultiple ? e.push(l) : t = l)
                                    }
                            }
                        } else r.selected && (this.main.config.isMultiple ? e.push(r) : t = r)
                    }
                    return this.main.config.isMultiple ? e : t
                }, r.prototype.addToSelected = function(t, e) {
                    if (void 0 === e && (e = "id"), this.main.config.isMultiple) {
                        var i = [],
                            n = this.getSelected();
                        if (Array.isArray(n))
                            for (var r = 0, a = n; r < a.length; r++) {
                                var s = a[r];
                                i.push(s[e])
                            }
                        i.push(t), this.setSelected(i, e)
                    }
                }, r.prototype.removeFromSelected = function(t, e) {
                    if (void 0 === e && (e = "id"), this.main.config.isMultiple) {
                        for (var i = [], n = 0, r = this.getSelected(); n < r.length; n++) {
                            var a = r[n];
                            String(a[e]) !== String(t) && i.push(a[e])
                        }
                        this.setSelected(i, e)
                    }
                }, r.prototype.onDataChange = function() {
                    this.main.onChange && this.isOnChangeEnabled && this.main.onChange(JSON.parse(JSON.stringify(this.getSelected())))
                }, r.prototype.getObjectFromData = function(t, e) {
                    void 0 === e && (e = "id");
                    for (var i = 0, n = this.data; i < n.length; i++) {
                        var r = n[i];
                        if (e in r && String(r[e]) === String(t)) return r;
                        if (r.hasOwnProperty("options") && r.options)
                            for (var a = 0, s = r.options; a < s.length; a++) {
                                var o = s[a];
                                if (String(o[e]) === String(t)) return o
                            }
                    }
                    return null
                }, r.prototype.search = function(r) {
                    var a, t, e;
                    "" !== (this.searchValue = r).trim() ? (a = this.main.config.searchFilter, t = this.data.slice(0), r = r.trim(), e = t.map(function(t) {
                        if (t.hasOwnProperty("options")) {
                            var e = t,
                                i = [];
                            if (e.options && (i = e.options.filter(function(t) {
                                    return a(t, r)
                                })), 0 !== i.length) {
                                var n = Object.assign({}, e);
                                return n.options = i, n
                            }
                        }
                        return t.hasOwnProperty("text") && a(t, r) ? t : null
                    }), this.filtered = e.filter(function(t) {
                        return t
                    })) : this.filtered = null
                }, r);

                function r(t) {
                    this.contentOpen = !1, this.contentPosition = "below", this.isOnChangeEnabled = !0, this.main = t.main, this.searchValue = "", this.data = [], this.filtered = null, this.parseSelectData(), this.setSelectedFromSelect()
                }

                function l(t) {
                    return void 0 !== t.text || !1
                }
                e.Data = n, e.validateData = function(t) {
                    if (!t) return !1;
                    for (var e = 0, i = 0, n = t; i < n.length; i++) {
                        var r = n[i];
                        if (r.hasOwnProperty("label")) {
                            if (r.hasOwnProperty("options")) {
                                var a = r.options;
                                if (a)
                                    for (var s = 0, o = a; s < o.length; s++) l(o[s]) || e++
                            }
                        } else l(r) || e++
                    }
                    return 0 === e
                }, e.validateOption = l
            }, function(t, e, i) {
                e.__esModule = !0;
                var n = i(3),
                    r = i(4),
                    a = i(5),
                    s = i(1),
                    o = i(0),
                    l = (h.prototype.validate = function(t) {
                        var e = "string" == typeof t.select ? document.querySelector(t.select) : t.select;
                        if (!e) throw new Error("Could not find select element");
                        if ("SELECT" !== e.tagName) throw new Error("Element isnt of type select");
                        return e
                    }, h.prototype.selected = function() {
                        if (this.config.isMultiple) {
                            for (var t = [], e = 0, i = r = this.data.getSelected(); e < i.length; e++) {
                                var n = i[e];
                                t.push(n.value)
                            }
                            return t
                        }
                        var r;
                        return (r = this.data.getSelected()) ? r.value : ""
                    }, h.prototype.set = function(t, e, i, n) {
                        void 0 === e && (e = "value"), void 0 === i && (i = !0), void 0 === n && (n = !0), this.config.isMultiple && !Array.isArray(t) ? this.data.addToSelected(t, e) : this.data.setSelected(t, e), this.select.setValue(), this.data.onDataChange(), this.render(), i && this.close()
                    }, h.prototype.setSelected = function(t, e, i, n) {
                        void 0 === e && (e = "value"), void 0 === i && (i = !0), void 0 === n && (n = !0), this.set(t, e, i, n)
                    }, h.prototype.setData = function(t) {
                        if (s.validateData(t)) {
                            var e = JSON.parse(JSON.stringify(t)),
                                i = this.data.getSelected();
                            if (this.config.isAjax && i)
                                if (this.config.isMultiple)
                                    for (var n = 0, r = i.reverse(); n < r.length; n++) {
                                        var a = r[n];
                                        e.unshift(a)
                                    } else e.unshift(this.data.getSelected()), e.unshift({
                                        text: "",
                                        placeholder: !0
                                    });
                            this.select.create(e), this.data.parseSelectData(), this.data.setSelectedFromSelect()
                        }
                    }, h.prototype.addData = function(t) {
                        s.validateData([t]) && (this.data.add(this.data.newOption(t)), this.select.create(this.data.data), this.data.parseSelectData(), this.data.setSelectedFromSelect(), this.render())
                    }, h.prototype.open = function() {
                        var t, e, i, n, r = this;
                        this.config.isEnabled && !this.data.contentOpen && (this.beforeOpen && this.beforeOpen(), this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.plus.classList.add("ss-cross") : this.slim.singleSelected && (this.slim.singleSelected.arrowIcon.arrow.classList.remove("arrow-down"), this.slim.singleSelected.arrowIcon.arrow.classList.add("arrow-up")), this.slim[this.config.isMultiple ? "multiSelected" : "singleSelected"].container.classList.add("above" === this.data.contentPosition ? this.config.openAbove : this.config.openBelow), this.config.addToBody && (t = this.slim.container.getBoundingClientRect(), this.slim.content.style.top = t.top + t.height + window.scrollY + "px", this.slim.content.style.left = t.left + window.scrollX + "px", this.slim.content.style.width = t.width + "px"), this.slim.content.classList.add(this.config.open), "up" === this.config.showContent.toLowerCase() || "down" !== this.config.showContent.toLowerCase() && "above" === o.putContent(this.slim.content, this.data.contentPosition, this.data.contentOpen) ? this.moveContentAbove() : this.moveContentBelow(), this.config.isMultiple || (e = this.data.getSelected()) && (i = e.id, (n = this.slim.list.querySelector('[data-id="' + i + '"]')) && o.ensureElementInView(this.slim.list, n)), setTimeout(function() {
                            r.data.contentOpen = !0, r.config.searchFocus && r.slim.search.input.focus(), r.afterOpen && r.afterOpen()
                        }, this.config.timeoutDelay))
                    }, h.prototype.close = function() {
                        var t = this;
                        this.data.contentOpen && (this.beforeClose && this.beforeClose(), this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openAbove), this.slim.multiSelected.container.classList.remove(this.config.openBelow), this.slim.multiSelected.plus.classList.remove("ss-cross")) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openAbove), this.slim.singleSelected.container.classList.remove(this.config.openBelow), this.slim.singleSelected.arrowIcon.arrow.classList.add("arrow-down"), this.slim.singleSelected.arrowIcon.arrow.classList.remove("arrow-up")), this.slim.content.classList.remove(this.config.open), this.data.contentOpen = !1, this.search(""), setTimeout(function() {
                            t.slim.content.removeAttribute("style"), t.data.contentPosition = "below", t.config.isMultiple && t.slim.multiSelected ? (t.slim.multiSelected.container.classList.remove(t.config.openAbove), t.slim.multiSelected.container.classList.remove(t.config.openBelow)) : t.slim.singleSelected && (t.slim.singleSelected.container.classList.remove(t.config.openAbove), t.slim.singleSelected.container.classList.remove(t.config.openBelow)), t.slim.search.input.blur(), t.afterClose && t.afterClose()
                        }, this.config.timeoutDelay))
                    }, h.prototype.moveContentAbove = function() {
                        var t = 0;
                        this.config.isMultiple && this.slim.multiSelected ? t = this.slim.multiSelected.container.offsetHeight : this.slim.singleSelected && (t = this.slim.singleSelected.container.offsetHeight);
                        var e = t + this.slim.content.offsetHeight - 1;
                        this.slim.content.style.margin = "-" + e + "px 0 0 0", this.slim.content.style.height = e - t + 1 + "px", this.slim.content.style.transformOrigin = "center bottom", this.data.contentPosition = "above", this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openBelow), this.slim.multiSelected.container.classList.add(this.config.openAbove)) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openBelow), this.slim.singleSelected.container.classList.add(this.config.openAbove))
                    }, h.prototype.moveContentBelow = function() {
                        this.data.contentPosition = "below", this.config.isMultiple && this.slim.multiSelected ? (this.slim.multiSelected.container.classList.remove(this.config.openAbove), this.slim.multiSelected.container.classList.add(this.config.openBelow)) : this.slim.singleSelected && (this.slim.singleSelected.container.classList.remove(this.config.openAbove), this.slim.singleSelected.container.classList.add(this.config.openBelow))
                    }, h.prototype.enable = function() {
                        this.config.isEnabled = !0, this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.container.classList.remove(this.config.disabled) : this.slim.singleSelected && this.slim.singleSelected.container.classList.remove(this.config.disabled), this.select.triggerMutationObserver = !1, this.select.element.disabled = !1, this.slim.search.input.disabled = !1, this.select.triggerMutationObserver = !0
                    }, h.prototype.disable = function() {
                        this.config.isEnabled = !1, this.config.isMultiple && this.slim.multiSelected ? this.slim.multiSelected.container.classList.add(this.config.disabled) : this.slim.singleSelected && this.slim.singleSelected.container.classList.add(this.config.disabled), this.select.triggerMutationObserver = !1, this.select.element.disabled = !0, this.slim.search.input.disabled = !0, this.select.triggerMutationObserver = !0
                    }, h.prototype.search = function(e) {
                        var i;
                        this.data.searchValue !== e && (this.slim.search.input.value = e, this.config.isAjax ? ((i = this).config.isSearching = !0, this.render(), this.ajax && this.ajax(e, function(t) {
                            i.config.isSearching = !1, Array.isArray(t) ? (t.unshift({
                                text: "",
                                placeholder: !0
                            }), i.setData(t), i.data.search(e), i.render()) : "string" == typeof t ? i.slim.options(t) : i.render()
                        })) : (this.data.search(e), this.render()))
                    }, h.prototype.setSearchText = function(t) {
                        this.config.searchText = t
                    }, h.prototype.render = function() {
                        this.config.isMultiple ? this.slim.values() : (this.slim.placeholder(), this.slim.deselect()), this.slim.options()
                    }, h.prototype.destroy = function(t) {
                        void 0 === t && (t = null);
                        var e = t ? document.querySelector("." + t + ".ss-main") : this.slim.container,
                            i = t ? document.querySelector("[data-ssid=" + t + "]") : this.select.element;
                        if (e && i && (i.style.display = "", delete i.dataset.ssid, i.slim = null, e.parentElement && e.parentElement.removeChild(e), this.config.addToBody)) {
                            var n = t ? document.querySelector("." + t + ".ss-content") : this.slim.content;
                            if (!n) return;
                            document.body.removeChild(n)
                        }
                    }, h);

                function h(t) {
                    var e = this;
                    this.ajax = null, this.addable = null, this.beforeOnChange = null, this.onChange = null, this.beforeOpen = null, this.afterOpen = null, this.beforeClose = null, this.afterClose = null;
                    var i = this.validate(t);
                    i.dataset.ssid && this.destroy(i.dataset.ssid), t.ajax && (this.ajax = t.ajax), t.addable && (this.addable = t.addable), this.config = new n.Config({
                        select: i,
                        isAjax: !!t.ajax,
                        showSearch: t.showSearch,
                        searchPlaceholder: t.searchPlaceholder,
                        searchText: t.searchText,
                        searchingText: t.searchingText,
                        searchFocus: t.searchFocus,
                        searchHighlight: t.searchHighlight,
                        searchFilter: t.searchFilter,
                        closeOnSelect: t.closeOnSelect,
                        showContent: t.showContent,
                        placeholderText: t.placeholder,
                        allowDeselect: t.allowDeselect,
                        allowDeselectOption: t.allowDeselectOption,
                        hideSelectedOption: t.hideSelectedOption,
                        deselectLabel: t.deselectLabel,
                        isEnabled: t.isEnabled,
                        valuesUseText: t.valuesUseText,
                        showOptionTooltips: t.showOptionTooltips,
                        selectByGroup: t.selectByGroup,
                        limit: t.limit,
                        timeoutDelay: t.timeoutDelay,
                        addToBody: t.addToBody
                    }), this.select = new r.Select({
                        select: i,
                        main: this
                    }), this.data = new s.Data({
                        main: this
                    }), this.slim = new a.Slim({
                        main: this
                    }), this.select.element.parentNode && this.select.element.parentNode.insertBefore(this.slim.container, this.select.element.nextSibling), t.data ? this.setData(t.data) : this.render(), document.addEventListener("click", function(t) {
                        t.target && !o.hasClassInTree(t.target, e.config.id) && e.close()
                    }), "auto" === this.config.showContent && window.addEventListener("scroll", o.debounce(function(t) {
                        e.data.contentOpen && ("above" === o.putContent(e.slim.content, e.data.contentPosition, e.data.contentOpen) ? e.moveContentAbove() : e.moveContentBelow())
                    }), !1), t.beforeOnChange && (this.beforeOnChange = t.beforeOnChange), t.onChange && (this.onChange = t.onChange), t.beforeOpen && (this.beforeOpen = t.beforeOpen), t.afterOpen && (this.afterOpen = t.afterOpen), t.beforeClose && (this.beforeClose = t.beforeClose), t.afterClose && (this.afterClose = t.afterClose), this.config.isEnabled || this.disable()
                }
                e.default = l
            }, function(t, e, i) {
                e.__esModule = !0;
                var n = (r.prototype.searchFilter = function(t, e) {
                    return -1 !== t.text.toLowerCase().indexOf(e.toLowerCase())
                }, r);

                function r(t) {
                    this.id = "", this.isMultiple = !1, this.isAjax = !1, this.isSearching = !1, this.showSearch = !0, this.searchFocus = !0, this.searchHighlight = !1, this.closeOnSelect = !0, this.showContent = "auto", this.searchPlaceholder = "Search", this.searchText = "No Results", this.searchingText = "Searching...", this.placeholderText = "Select Value", this.allowDeselect = !1, this.allowDeselectOption = !1, this.hideSelectedOption = !1, this.deselectLabel = "x", this.isEnabled = !0, this.valuesUseText = !1, this.showOptionTooltips = !1, this.selectByGroup = !1, this.limit = 0, this.timeoutDelay = 200, this.addToBody = !1, this.main = "ss-main", this.singleSelected = "ss-single-selected", this.arrow = "ss-arrow", this.multiSelected = "ss-multi-selected", this.add = "ss-add", this.plus = "ss-plus", this.values = "ss-values", this.value = "ss-value", this.valueText = "ss-value-text", this.valueDelete = "ss-value-delete", this.content = "ss-content", this.open = "ss-open", this.openAbove = "ss-open-above", this.openBelow = "ss-open-below", this.search = "ss-search", this.searchHighlighter = "ss-search-highlight", this.addable = "ss-addable", this.list = "ss-list", this.optgroup = "ss-optgroup", this.optgroupLabel = "ss-optgroup-label", this.optgroupLabelSelectable = "ss-optgroup-label-selectable", this.option = "ss-option", this.optionSelected = "ss-option-selected", this.highlighted = "ss-highlighted", this.disabled = "ss-disabled", this.hide = "ss-hide", this.id = "ss-" + Math.floor(1e5 * Math.random()), this.style = t.select.style.cssText, this.class = t.select.className.split(" "), this.isMultiple = t.select.multiple, this.isAjax = t.isAjax, this.showSearch = !1 !== t.showSearch, this.searchFocus = !1 !== t.searchFocus, this.searchHighlight = !0 === t.searchHighlight, this.closeOnSelect = !1 !== t.closeOnSelect, t.showContent && (this.showContent = t.showContent), this.isEnabled = !1 !== t.isEnabled, t.searchPlaceholder && (this.searchPlaceholder = t.searchPlaceholder), t.searchText && (this.searchText = t.searchText), t.searchingText && (this.searchingText = t.searchingText), t.placeholderText && (this.placeholderText = t.placeholderText), this.allowDeselect = !0 === t.allowDeselect, this.allowDeselectOption = !0 === t.allowDeselectOption, this.hideSelectedOption = !0 === t.hideSelectedOption, t.deselectLabel && (this.deselectLabel = t.deselectLabel), t.valuesUseText && (this.valuesUseText = t.valuesUseText), t.showOptionTooltips && (this.showOptionTooltips = t.showOptionTooltips), t.selectByGroup && (this.selectByGroup = t.selectByGroup), t.limit && (this.limit = t.limit), t.searchFilter && (this.searchFilter = t.searchFilter), null != t.timeoutDelay && (this.timeoutDelay = t.timeoutDelay), this.addToBody = !0 === t.addToBody
                }
                e.Config = n
            }, function(t, e, i) {
                e.__esModule = !0;
                var n = i(0),
                    r = (a.prototype.setValue = function() {
                        if (this.main.data.getSelected()) {
                            if (this.main.config.isMultiple)
                                for (var t = this.main.data.getSelected(), e = 0, i = this.element.options; e < i.length; e++) {
                                    var n = i[e];
                                    n.selected = !1;
                                    for (var r = 0, a = t; r < a.length; r++) a[r].value === n.value && (n.selected = !0)
                                } else t = this.main.data.getSelected(), this.element.value = t ? t.value : "";
                            this.main.data.isOnChangeEnabled = !1, this.element.dispatchEvent(new CustomEvent("change", {
                                bubbles: !0
                            })), this.main.data.isOnChangeEnabled = !0
                        }
                    }, a.prototype.addAttributes = function() {
                        this.element.tabIndex = -1, this.element.style.display = "none", this.element.dataset.ssid = this.main.config.id
                    }, a.prototype.addEventListeners = function() {
                        var e = this;
                        this.element.addEventListener("change", function(t) {
                            e.main.data.setSelectedFromSelect(), e.main.render()
                        })
                    }, a.prototype.addMutationObserver = function() {
                        var e = this;
                        this.main.config.isAjax || (this.mutationObserver = new MutationObserver(function(t) {
                            e.triggerMutationObserver && (e.main.data.parseSelectData(), e.main.data.setSelectedFromSelect(), e.main.render(), t.forEach(function(t) {
                                "class" === t.attributeName && e.main.slim.updateContainerDivClass(e.main.slim.container)
                            }))
                        }), this.observeMutationObserver())
                    }, a.prototype.observeMutationObserver = function() {
                        this.mutationObserver && this.mutationObserver.observe(this.element, {
                            attributes: !0,
                            childList: !0,
                            characterData: !0
                        })
                    }, a.prototype.disconnectMutationObserver = function() {
                        this.mutationObserver && this.mutationObserver.disconnect()
                    }, a.prototype.create = function(t) {
                        this.element.innerHTML = "";
                        for (var e = 0, i = t; e < i.length; e++) {
                            var n = i[e];
                            if (n.hasOwnProperty("options")) {
                                var r = n,
                                    a = document.createElement("optgroup");
                                if (a.label = r.label, r.options)
                                    for (var s = 0, o = r.options; s < o.length; s++) {
                                        var l = o[s];
                                        a.appendChild(this.createOption(l))
                                    }
                                this.element.appendChild(a)
                            } else this.element.appendChild(this.createOption(n))
                        }
                    }, a.prototype.createOption = function(e) {
                        var i = document.createElement("option");
                        return i.value = "" !== e.value ? e.value : e.text, i.innerHTML = e.innerHTML || e.text, e.selected && (i.selected = e.selected), !1 === e.display && (i.style.display = "none"), e.disabled && (i.disabled = !0), e.placeholder && i.setAttribute("data-placeholder", "true"), e.mandatory && i.setAttribute("data-mandatory", "true"), e.class && e.class.split(" ").forEach(function(t) {
                            i.classList.add(t)
                        }), e.data && "object" == o(e.data) && Object.keys(e.data).forEach(function(t) {
                            i.setAttribute("data-" + n.kebabCase(t), e.data[t])
                        }), i
                    }, a);

                function a(t) {
                    this.triggerMutationObserver = !0, this.element = t.select, this.main = t.main, this.element.disabled && (this.main.config.isEnabled = !1), this.addAttributes(), this.addEventListeners(), this.mutationObserver = null, this.addMutationObserver(), this.element.slim = t.main
                }
                e.Select = r
            }, function(t, e, i) {
                e.__esModule = !0;
                var a = i(0),
                    s = i(1),
                    n = (r.prototype.containerDiv = function() {
                        var t = document.createElement("div");
                        return t.style.cssText = this.main.config.style, this.updateContainerDivClass(t), t
                    }, r.prototype.updateContainerDivClass = function(t) {
                        this.main.config.class = this.main.select.element.className.split(" "), t.className = "", t.classList.add(this.main.config.id), t.classList.add(this.main.config.main);
                        for (var e = 0, i = this.main.config.class; e < i.length; e++) {
                            var n = i[e];
                            "" !== n.trim() && t.classList.add(n)
                        }
                    }, r.prototype.singleSelectedDiv = function() {
                        var e = this,
                            t = document.createElement("div");
                        t.classList.add(this.main.config.singleSelected);
                        var i = document.createElement("span");
                        i.classList.add("placeholder"), t.appendChild(i);
                        var n = document.createElement("span");
                        n.innerHTML = this.main.config.deselectLabel, n.classList.add("ss-deselect"), n.onclick = function(t) {
                            t.stopPropagation(), e.main.config.isEnabled && e.main.set("")
                        }, t.appendChild(n);
                        var r = document.createElement("span");
                        r.classList.add(this.main.config.arrow);
                        var a = document.createElement("span");
                        return a.classList.add("arrow-down"), r.appendChild(a), t.appendChild(r), t.onclick = function() {
                            e.main.config.isEnabled && (e.main.data.contentOpen ? e.main.close() : e.main.open())
                        }, {
                            container: t,
                            placeholder: i,
                            deselect: n,
                            arrowIcon: {
                                container: r,
                                arrow: a
                            }
                        }
                    }, r.prototype.placeholder = function() {
                        var t, e, i = this.main.data.getSelected();
                        null === i || i && i.placeholder ? ((t = document.createElement("span")).classList.add(this.main.config.disabled), t.innerHTML = this.main.config.placeholderText, this.singleSelected && (this.singleSelected.placeholder.innerHTML = t.outerHTML)) : (e = "", i && (e = i.innerHTML && !0 !== this.main.config.valuesUseText ? i.innerHTML : i.text), this.singleSelected && (this.singleSelected.placeholder.innerHTML = i ? e : ""))
                    }, r.prototype.deselect = function() {
                        if (this.singleSelected) {
                            if (!this.main.config.allowDeselect) return void this.singleSelected.deselect.classList.add("ss-hide");
                            "" === this.main.selected() ? this.singleSelected.deselect.classList.add("ss-hide") : this.singleSelected.deselect.classList.remove("ss-hide")
                        }
                    }, r.prototype.multiSelectedDiv = function() {
                        var e = this,
                            t = document.createElement("div");
                        t.classList.add(this.main.config.multiSelected);
                        var i = document.createElement("div");
                        i.classList.add(this.main.config.values), t.appendChild(i);
                        var n = document.createElement("div");
                        n.classList.add(this.main.config.add);
                        var r = document.createElement("span");
                        return r.classList.add(this.main.config.plus), r.onclick = function(t) {
                            e.main.data.contentOpen && (e.main.close(), t.stopPropagation())
                        }, n.appendChild(r), t.appendChild(n), t.onclick = function(t) {
                            e.main.config.isEnabled && (t.target.classList.contains(e.main.config.valueDelete) || (e.main.data.contentOpen ? e.main.close() : e.main.open()))
                        }, {
                            container: t,
                            values: i,
                            add: n,
                            plus: r
                        }
                    }, r.prototype.values = function() {
                        if (this.multiSelected) {
                            for (var t = this.multiSelected.values.childNodes, e = this.main.data.getSelected(), i = [], n = 0, r = t; n < r.length; n++) {
                                for (var a = r[n], s = !0, o = 0, l = e; o < l.length; o++) {
                                    var h = l[o];
                                    String(h.id) === String(a.dataset.id) && (s = !1)
                                }
                                s && i.push(a)
                            }
                            for (var u, c = 0, p = i; c < p.length; c++) {
                                var d = p[c];
                                d.classList.add("ss-out"), this.multiSelected.values.removeChild(d)
                            }
                            for (t = this.multiSelected.values.childNodes, h = 0; h < e.length; h++) {
                                s = !1;
                                for (var f = 0, m = t; f < m.length; f++) a = m[f], String(e[h].id) === String(a.dataset.id) && (s = !0);
                                s || (0 !== t.length && HTMLElement.prototype.insertAdjacentElement ? 0 === h ? this.multiSelected.values.insertBefore(this.valueDiv(e[h]), t[h]) : t[h - 1].insertAdjacentElement("afterend", this.valueDiv(e[h])) : this.multiSelected.values.appendChild(this.valueDiv(e[h])))
                            }
                            0 === e.length && ((u = document.createElement("span")).classList.add(this.main.config.disabled), u.innerHTML = this.main.config.placeholderText, this.multiSelected.values.innerHTML = u.outerHTML)
                        }
                    }, r.prototype.valueDiv = function(a) {
                        var s = this,
                            t = document.createElement("div");
                        t.classList.add(this.main.config.value), t.dataset.id = a.id;
                        var e, i = document.createElement("span");
                        return i.classList.add(this.main.config.valueText), i.innerHTML = a.innerHTML && !0 !== this.main.config.valuesUseText ? a.innerHTML : a.text, t.appendChild(i), a.mandatory || ((e = document.createElement("span")).classList.add(this.main.config.valueDelete), e.innerHTML = this.main.config.deselectLabel, e.onclick = function(t) {
                            t.preventDefault(), t.stopPropagation();
                            var e = !1;
                            if (s.main.beforeOnChange || (e = !0), s.main.beforeOnChange) {
                                for (var i = s.main.data.getSelected(), n = JSON.parse(JSON.stringify(i)), r = 0; r < n.length; r++) n[r].id === a.id && n.splice(r, 1);
                                !1 !== s.main.beforeOnChange(n) && (e = !0)
                            }
                            e && (s.main.data.removeFromSelected(a.id, "id"), s.main.render(), s.main.select.setValue(), s.main.data.onDataChange())
                        }, t.appendChild(e)), t
                    }, r.prototype.contentDiv = function() {
                        var t = document.createElement("div");
                        return t.classList.add(this.main.config.content), t
                    }, r.prototype.searchDiv = function() {
                        var r = this,
                            t = document.createElement("div"),
                            n = document.createElement("input"),
                            a = document.createElement("div");
                        t.classList.add(this.main.config.search);
                        var e = {
                            container: t,
                            input: n
                        };
                        return this.main.config.showSearch || (t.classList.add(this.main.config.hide), n.readOnly = !0), n.type = "search", n.placeholder = this.main.config.searchPlaceholder, n.tabIndex = 0, n.setAttribute("aria-label", this.main.config.searchPlaceholder), n.setAttribute("autocapitalize", "off"), n.setAttribute("autocomplete", "off"), n.setAttribute("autocorrect", "off"), n.onclick = function(t) {
                            setTimeout(function() {
                                "" === t.target.value && r.main.search("")
                            }, 10)
                        }, n.onkeydown = function(t) {
                            "ArrowUp" === t.key ? (r.main.open(), r.highlightUp(), t.preventDefault()) : "ArrowDown" === t.key ? (r.main.open(), r.highlightDown(), t.preventDefault()) : "Tab" === t.key ? r.main.data.contentOpen ? r.main.close() : setTimeout(function() {
                                r.main.close()
                            }, r.main.config.timeoutDelay) : "Enter" === t.key && t.preventDefault()
                        }, n.onkeyup = function(t) {
                            var e = t.target;
                            if ("Enter" === t.key) {
                                if (r.main.addable && t.ctrlKey) return a.click(), t.preventDefault(), void t.stopPropagation();
                                var i = r.list.querySelector("." + r.main.config.highlighted);
                                i && i.click()
                            } else "ArrowUp" === t.key || "ArrowDown" === t.key || ("Escape" === t.key ? r.main.close() : r.main.config.showSearch && r.main.data.contentOpen ? r.main.search(e.value) : n.value = "");
                            t.preventDefault(), t.stopPropagation()
                        }, n.onfocus = function() {
                            r.main.open()
                        }, t.appendChild(n), this.main.addable && (a.classList.add(this.main.config.addable), a.innerHTML = "+", a.onclick = function(t) {
                            if (r.main.addable) {
                                t.preventDefault(), t.stopPropagation();
                                var e = r.search.input.value;
                                if ("" === e.trim()) return void r.search.input.focus();
                                var i = r.main.addable(e),
                                    n = "";
                                if (!i) return;
                                "object" == o(i) ? s.validateOption(i) && (r.main.addData(i), n = i.value ? i.value : i.text) : (r.main.addData(r.main.data.newOption({
                                    text: i,
                                    value: i
                                })), n = i), r.main.search(""), setTimeout(function() {
                                    r.main.set(n, "value", !1, !1)
                                }, 100), r.main.config.closeOnSelect && setTimeout(function() {
                                    r.main.close()
                                }, 100)
                            }
                        }, t.appendChild(a), e.addable = a), e
                    }, r.prototype.highlightUp = function() {
                        var t, e, i = this.list.querySelector("." + this.main.config.highlighted),
                            n = null;
                        if (i)
                            for (n = i.previousSibling; null !== n && n.classList.contains(this.main.config.disabled);) n = n.previousSibling;
                        else var r = this.list.querySelectorAll("." + this.main.config.option + ":not(." + this.main.config.disabled + ")"),
                            n = r[r.length - 1];
                        n && n.classList.contains(this.main.config.optgroupLabel) && (n = null), null === n && (t = i.parentNode).classList.contains(this.main.config.optgroup) && t.previousSibling && ((e = t.previousSibling.querySelectorAll("." + this.main.config.option + ":not(." + this.main.config.disabled + ")")).length && (n = e[e.length - 1])), n && (i && i.classList.remove(this.main.config.highlighted), n.classList.add(this.main.config.highlighted), a.ensureElementInView(this.list, n))
                    }, r.prototype.highlightDown = function() {
                        var t, e = this.list.querySelector("." + this.main.config.highlighted),
                            i = null;
                        if (e)
                            for (i = e.nextSibling; null !== i && i.classList.contains(this.main.config.disabled);) i = i.nextSibling;
                        else i = this.list.querySelector("." + this.main.config.option + ":not(." + this.main.config.disabled + ")");
                        null !== i || null === e || (t = e.parentNode).classList.contains(this.main.config.optgroup) && t.nextSibling && (i = t.nextSibling.querySelector("." + this.main.config.option + ":not(." + this.main.config.disabled + ")")), i && (e && e.classList.remove(this.main.config.highlighted), i.classList.add(this.main.config.highlighted), a.ensureElementInView(this.list, i))
                    }, r.prototype.listDiv = function() {
                        var t = document.createElement("div");
                        return t.classList.add(this.main.config.list), t
                    }, r.prototype.options = function(t) {
                        void 0 === t && (t = "");
                        var e, i = this.main.data.filtered || this.main.data.data;
                        if ((this.list.innerHTML = "") !== t) return (e = document.createElement("div")).classList.add(this.main.config.option), e.classList.add(this.main.config.disabled), e.innerHTML = t, void this.list.appendChild(e);
                        if (this.main.config.isAjax && this.main.config.isSearching) return (e = document.createElement("div")).classList.add(this.main.config.option), e.classList.add(this.main.config.disabled), e.innerHTML = this.main.config.searchingText, void this.list.appendChild(e);
                        if (0 === i.length) {
                            var n = document.createElement("div");
                            return n.classList.add(this.main.config.option), n.classList.add(this.main.config.disabled), n.innerHTML = this.main.config.searchText, void this.list.appendChild(n)
                        }
                        for (var h = this, r = 0, a = i; r < a.length; r++) ! function(t) {
                            if (t.hasOwnProperty("label")) {
                                var e = t,
                                    r = document.createElement("div");
                                r.classList.add(h.main.config.optgroup);
                                var i = document.createElement("div");
                                i.classList.add(h.main.config.optgroupLabel), h.main.config.selectByGroup && h.main.config.isMultiple && i.classList.add(h.main.config.optgroupLabelSelectable), i.innerHTML = e.label, r.appendChild(i);
                                var n = e.options;
                                if (n) {
                                    for (var a, s = 0, o = n; s < o.length; s++) {
                                        var l = o[s];
                                        r.appendChild(h.option(l))
                                    }
                                    h.main.config.selectByGroup && h.main.config.isMultiple && (a = h, i.addEventListener("click", function(t) {
                                        t.preventDefault(), t.stopPropagation();
                                        for (var e = 0, i = r.children; e < i.length; e++) {
                                            var n = i[e]; - 1 !== n.className.indexOf(a.main.config.option) && n.click()
                                        }
                                    }))
                                }
                                h.list.appendChild(r)
                            } else h.list.appendChild(h.option(t))
                        }(a[r])
                    }, r.prototype.option = function(l) {
                        if (l.placeholder) {
                            var t = document.createElement("div");
                            return t.classList.add(this.main.config.option), t.classList.add(this.main.config.hide), t
                        }
                        var e = document.createElement("div");
                        e.classList.add(this.main.config.option), l.class && l.class.split(" ").forEach(function(t) {
                            e.classList.add(t)
                        }), l.style && (e.style.cssText = l.style);
                        var h = this.main.data.getSelected();
                        e.dataset.id = l.id, this.main.config.searchHighlight && this.main.slim && l.innerHTML && "" !== this.main.slim.search.input.value.trim() ? e.innerHTML = a.highlight(l.innerHTML, this.main.slim.search.input.value, this.main.config.searchHighlighter) : l.innerHTML && (e.innerHTML = l.innerHTML), this.main.config.showOptionTooltips && e.textContent && e.setAttribute("title", e.textContent);
                        var u = this;
                        e.addEventListener("click", function(t) {
                            t.preventDefault(), t.stopPropagation();
                            var e, i, n = this.dataset.id;
                            if (!0 === l.selected && u.main.config.allowDeselectOption) {
                                var r = !1;
                                if (u.main.beforeOnChange && u.main.config.isMultiple || (r = !0), u.main.beforeOnChange && u.main.config.isMultiple) {
                                    for (var a = u.main.data.getSelected(), s = JSON.parse(JSON.stringify(a)), o = 0; o < s.length; o++) s[o].id === n && s.splice(o, 1);
                                    !1 !== u.main.beforeOnChange(s) && (r = !0)
                                }
                                r && (u.main.config.isMultiple ? (u.main.data.removeFromSelected(n, "id"), u.main.render(), u.main.select.setValue(), u.main.data.onDataChange()) : u.main.set(""))
                            } else {
                                if (l.disabled || l.selected) return;
                                if (u.main.config.limit && Array.isArray(h) && u.main.config.limit <= h.length) return;
                                u.main.beforeOnChange ? (e = void 0, (i = JSON.parse(JSON.stringify(u.main.data.getObjectFromData(n)))).selected = !0, u.main.config.isMultiple ? (e = JSON.parse(JSON.stringify(h))).push(i) : e = JSON.parse(JSON.stringify(i)), !1 !== u.main.beforeOnChange(e) && u.main.set(n, "id", u.main.config.closeOnSelect)) : u.main.set(n, "id", u.main.config.closeOnSelect)
                            }
                        });
                        var i = h && a.isValueInArrayOfObjects(h, "id", l.id);
                        return (l.disabled || i) && (e.onclick = null, u.main.config.allowDeselectOption || e.classList.add(this.main.config.disabled), u.main.config.hideSelectedOption && e.classList.add(this.main.config.hide)), i ? e.classList.add(this.main.config.optionSelected) : e.classList.remove(this.main.config.optionSelected), e
                    }, r);

                function r(t) {
                    this.main = t.main, this.container = this.containerDiv(), this.content = this.contentDiv(), this.search = this.searchDiv(), this.list = this.listDiv(), this.options(), this.singleSelected = null, this.multiSelected = null, this.main.config.isMultiple ? (this.multiSelected = this.multiSelectedDiv(), this.multiSelected && this.container.appendChild(this.multiSelected.container)) : (this.singleSelected = this.singleSelectedDiv(), this.container.appendChild(this.singleSelected.container)), this.main.config.addToBody ? (this.content.classList.add(this.main.config.id), document.body.appendChild(this.content)) : this.container.appendChild(this.content), this.content.appendChild(this.search.container), this.content.appendChild(this.list)
                }
                e.Slim = n
            }], r.c = n, r.d = function(t, e, i) {
                r.o(t, e) || Object.defineProperty(t, e, {
                    enumerable: !0,
                    get: i
                })
            }, r.r = function(t) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }, r.t = function(e, t) {
                if (1 & t && (e = r(e)), 8 & t) return e;
                if (4 & t && "object" == o(e) && e && e.__esModule) return e;
                var i = Object.create(null);
                if (r.r(i), Object.defineProperty(i, "default", {
                        enumerable: !0,
                        value: e
                    }), 2 & t && "string" != typeof e)
                    for (var n in e) r.d(i, n, function(t) {
                        return e[t]
                    }.bind(null, n));
                return i
            }, r.n = function(t) {
                var e = t && t.__esModule ? function() {
                    return t.default
                } : function() {
                    return t
                };
                return r.d(e, "a", e), e
            }, r.o = function(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }, r.p = "", r(r.s = 2).default;

            function r(t) {
                if (n[t]) return n[t].exports;
                var e = n[t] = {
                    i: t,
                    l: !1,
                    exports: {}
                };
                return i[t].call(e.exports, e, e.exports, r), e.l = !0, e.exports
            }
            var i, n
        }, "object" == (void 0 === i ? "undefined" : o(i)) && "object" == (void 0 === e ? "undefined" : o(e)) ? e.exports = r() : "function" == typeof define && define.amd ? define([], r) : "object" == (void 0 === i ? "undefined" : o(i)) ? i.SlimSelect = r() : n.SlimSelect = r()
    }, {}],
    swiper: [function(t, e, i) {
        "use strict";

        function bt(t) {
            return (bt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        var n, r;
        r = function() {
            function n(t) {
                return null !== t && "object" === bt(t) && "constructor" in t && t.constructor === Object
            }

            function r(e, i) {
                void 0 === e && (e = {}), void 0 === i && (i = {}), Object.keys(i).forEach(function(t) {
                    void 0 === e[t] ? e[t] = i[t] : n(i[t]) && n(e[t]) && 0 < Object.keys(i[t]).length && r(e[t], i[t])
                })
            }
            var b = "undefined" != typeof document ? document : {},
                t = {
                    body: {},
                    addEventListener: function() {},
                    removeEventListener: function() {},
                    activeElement: {
                        blur: function() {},
                        nodeName: ""
                    },
                    querySelector: function() {
                        return null
                    },
                    querySelectorAll: function() {
                        return []
                    },
                    getElementById: function() {
                        return null
                    },
                    createEvent: function() {
                        return {
                            initEvent: function() {}
                        }
                    },
                    createElement: function() {
                        return {
                            children: [],
                            childNodes: [],
                            style: {},
                            setAttribute: function() {},
                            getElementsByTagName: function() {
                                return []
                            }
                        }
                    },
                    createElementNS: function() {
                        return {}
                    },
                    importNode: function() {
                        return null
                    },
                    location: {
                        hash: "",
                        host: "",
                        hostname: "",
                        href: "",
                        origin: "",
                        pathname: "",
                        protocol: "",
                        search: ""
                    }
                };
            r(b, t);
            var at = "undefined" != typeof window ? window : {};
            r(at, {
                document: t,
                navigator: {
                    userAgent: ""
                },
                location: {
                    hash: "",
                    host: "",
                    hostname: "",
                    href: "",
                    origin: "",
                    pathname: "",
                    protocol: "",
                    search: ""
                },
                history: {
                    replaceState: function() {},
                    pushState: function() {},
                    go: function() {},
                    back: function() {}
                },
                CustomEvent: function() {
                    return this
                },
                addEventListener: function() {},
                removeEventListener: function() {},
                getComputedStyle: function() {
                    return {
                        getPropertyValue: function() {
                            return ""
                        }
                    }
                },
                Image: function() {},
                Date: function() {},
                screen: {},
                setTimeout: function() {},
                clearTimeout: function() {},
                matchMedia: function() {
                    return {}
                }
            });
            var l = function(t) {
                for (var e = 0; e < t.length; e += 1) this[e] = t[e];
                return this.length = t.length, this
            };

            function L(t, e) {
                var i = [],
                    n = 0;
                if (t && !e && t instanceof l) return t;
                if (t)
                    if ("string" == typeof t) {
                        var r, a, s = t.trim();
                        if (0 <= s.indexOf("<") && 0 <= s.indexOf(">")) {
                            var o = "div";
                            for (0 === s.indexOf("<li") && (o = "ul"), 0 === s.indexOf("<tr") && (o = "tbody"), 0 !== s.indexOf("<td") && 0 !== s.indexOf("<th") || (o = "tr"), 0 === s.indexOf("<tbody") && (o = "table"), 0 === s.indexOf("<option") && (o = "select"), (a = b.createElement(o)).innerHTML = s, n = 0; n < a.childNodes.length; n += 1) i.push(a.childNodes[n])
                        } else
                            for (r = e || "#" !== t[0] || t.match(/[ .<>:~]/) ? (e || b).querySelectorAll(t.trim()) : [b.getElementById(t.trim().split("#")[1])], n = 0; n < r.length; n += 1) r[n] && i.push(r[n])
                    } else if (t.nodeType || t === at || t === b) i.push(t);
                else if (0 < t.length && t[0].nodeType)
                    for (n = 0; n < t.length; n += 1) i.push(t[n]);
                return new l(i)
            }

            function a(t) {
                for (var e = [], i = 0; i < t.length; i += 1) - 1 === e.indexOf(t[i]) && e.push(t[i]);
                return e
            }
            L.fn = l.prototype, L.Class = l, L.Dom7 = l;
            var e = {
                addClass: function(t) {
                    if (void 0 === t) return this;
                    for (var e = t.split(" "), i = 0; i < e.length; i += 1)
                        for (var n = 0; n < this.length; n += 1) void 0 !== this[n] && void 0 !== this[n].classList && this[n].classList.add(e[i]);
                    return this
                },
                removeClass: function(t) {
                    for (var e = t.split(" "), i = 0; i < e.length; i += 1)
                        for (var n = 0; n < this.length; n += 1) void 0 !== this[n] && void 0 !== this[n].classList && this[n].classList.remove(e[i]);
                    return this
                },
                hasClass: function(t) {
                    return !!this[0] && this[0].classList.contains(t)
                },
                toggleClass: function(t) {
                    for (var e = t.split(" "), i = 0; i < e.length; i += 1)
                        for (var n = 0; n < this.length; n += 1) void 0 !== this[n] && void 0 !== this[n].classList && this[n].classList.toggle(e[i]);
                    return this
                },
                attr: function(t, e) {
                    var i = arguments;
                    if (1 === arguments.length && "string" == typeof t) return this[0] ? this[0].getAttribute(t) : void 0;
                    for (var n = 0; n < this.length; n += 1)
                        if (2 === i.length) this[n].setAttribute(t, e);
                        else
                            for (var r in t) this[n][r] = t[r], this[n].setAttribute(r, t[r]);
                    return this
                },
                removeAttr: function(t) {
                    for (var e = 0; e < this.length; e += 1) this[e].removeAttribute(t);
                    return this
                },
                data: function(t, e) {
                    var i;
                    if (void 0 !== e) {
                        for (var n = 0; n < this.length; n += 1)(i = this[n]).dom7ElementDataStorage || (i.dom7ElementDataStorage = {}), i.dom7ElementDataStorage[t] = e;
                        return this
                    }
                    if (i = this[0]) {
                        if (i.dom7ElementDataStorage && t in i.dom7ElementDataStorage) return i.dom7ElementDataStorage[t];
                        var r = i.getAttribute("data-" + t);
                        return r ? r : void 0
                    }
                },
                transform: function(t) {
                    for (var e = 0; e < this.length; e += 1) {
                        var i = this[e].style;
                        i.webkitTransform = t, i.transform = t
                    }
                    return this
                },
                transition: function(t) {
                    "string" != typeof t && (t += "ms");
                    for (var e = 0; e < this.length; e += 1) {
                        var i = this[e].style;
                        i.webkitTransitionDuration = t, i.transitionDuration = t
                    }
                    return this
                },
                on: function() {
                    for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                    var i = t[0],
                        a = t[1],
                        s = t[2],
                        n = t[3];

                    function r(t) {
                        var e = t.target;
                        if (e) {
                            var i = t.target.dom7EventData || [];
                            if (i.indexOf(t) < 0 && i.unshift(t), L(e).is(a)) s.apply(e, i);
                            else
                                for (var n = L(e).parents(), r = 0; r < n.length; r += 1) L(n[r]).is(a) && s.apply(n[r], i)
                        }
                    }

                    function o(t) {
                        var e = t && t.target && t.target.dom7EventData || [];
                        e.indexOf(t) < 0 && e.unshift(t), s.apply(this, e)
                    }
                    "function" == typeof t[1] && (i = t[0], s = t[1], n = t[2], a = void 0), n = n || !1;
                    for (var l, h = i.split(" "), u = 0; u < this.length; u += 1) {
                        var c = this[u];
                        if (a)
                            for (l = 0; l < h.length; l += 1) {
                                var p = h[l];
                                c.dom7LiveListeners || (c.dom7LiveListeners = {}), c.dom7LiveListeners[p] || (c.dom7LiveListeners[p] = []), c.dom7LiveListeners[p].push({
                                    listener: s,
                                    proxyListener: r
                                }), c.addEventListener(p, r, n)
                            } else
                                for (l = 0; l < h.length; l += 1) {
                                    var d = h[l];
                                    c.dom7Listeners || (c.dom7Listeners = {}), c.dom7Listeners[d] || (c.dom7Listeners[d] = []), c.dom7Listeners[d].push({
                                        listener: s,
                                        proxyListener: o
                                    }), c.addEventListener(d, o, n)
                                }
                    }
                    return this
                },
                off: function() {
                    for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                    var i = t[0],
                        n = t[1],
                        r = t[2],
                        a = t[3];
                    "function" == typeof t[1] && (i = t[0], r = t[1], a = t[2], n = void 0), a = a || !1;
                    for (var s = i.split(" "), o = 0; o < s.length; o += 1)
                        for (var l = s[o], h = 0; h < this.length; h += 1) {
                            var u = this[h],
                                c = void 0;
                            if (!n && u.dom7Listeners ? c = u.dom7Listeners[l] : n && u.dom7LiveListeners && (c = u.dom7LiveListeners[l]), c && c.length)
                                for (var p = c.length - 1; 0 <= p; --p) {
                                    var d = c[p];
                                    (!r || d.listener !== r) && !(r && d.listener && d.listener.dom7proxy && d.listener.dom7proxy === r) && r || (u.removeEventListener(l, d.proxyListener, a), c.splice(p, 1))
                                }
                        }
                    return this
                },
                trigger: function() {
                    for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                    for (var i = t[0].split(" "), n = t[1], r = 0; r < i.length; r += 1)
                        for (var a = i[r], s = 0; s < this.length; s += 1) {
                            var o = this[s],
                                l = void 0;
                            try {
                                l = new at.CustomEvent(a, {
                                    detail: n,
                                    bubbles: !0,
                                    cancelable: !0
                                })
                            } catch (t) {
                                (l = b.createEvent("Event")).initEvent(a, !0, !0), l.detail = n
                            }
                            o.dom7EventData = t.filter(function(t, e) {
                                return 0 < e
                            }), o.dispatchEvent(l), o.dom7EventData = [], delete o.dom7EventData
                        }
                    return this
                },
                transitionEnd: function(e) {
                    var i, n = ["webkitTransitionEnd", "transitionend"],
                        r = this;

                    function a(t) {
                        if (t.target === this)
                            for (e.call(this, t), i = 0; i < n.length; i += 1) r.off(n[i], a)
                    }
                    if (e)
                        for (i = 0; i < n.length; i += 1) r.on(n[i], a);
                    return this
                },
                outerWidth: function(t) {
                    if (0 < this.length) {
                        if (t) {
                            var e = this.styles();
                            return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left"))
                        }
                        return this[0].offsetWidth
                    }
                    return null
                },
                outerHeight: function(t) {
                    if (0 < this.length) {
                        if (t) {
                            var e = this.styles();
                            return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom"))
                        }
                        return this[0].offsetHeight
                    }
                    return null
                },
                offset: function() {
                    if (0 < this.length) {
                        var t = this[0],
                            e = t.getBoundingClientRect(),
                            i = b.body,
                            n = t.clientTop || i.clientTop || 0,
                            r = t.clientLeft || i.clientLeft || 0,
                            a = t === at ? at.scrollY : t.scrollTop,
                            s = t === at ? at.scrollX : t.scrollLeft;
                        return {
                            top: e.top + a - n,
                            left: e.left + s - r
                        }
                    }
                    return null
                },
                css: function(t, e) {
                    var i;
                    if (1 === arguments.length) {
                        if ("string" != typeof t) {
                            for (i = 0; i < this.length; i += 1)
                                for (var n in t) this[i].style[n] = t[n];
                            return this
                        }
                        if (this[0]) return at.getComputedStyle(this[0], null).getPropertyValue(t)
                    }
                    if (2 !== arguments.length || "string" != typeof t) return this;
                    for (i = 0; i < this.length; i += 1) this[i].style[t] = e;
                    return this
                },
                each: function(t) {
                    if (!t) return this;
                    for (var e = 0; e < this.length; e += 1)
                        if (!1 === t.call(this[e], e, this[e])) return this;
                    return this
                },
                html: function(t) {
                    if (void 0 === t) return this[0] ? this[0].innerHTML : void 0;
                    for (var e = 0; e < this.length; e += 1) this[e].innerHTML = t;
                    return this
                },
                text: function(t) {
                    if (void 0 === t) return this[0] ? this[0].textContent.trim() : null;
                    for (var e = 0; e < this.length; e += 1) this[e].textContent = t;
                    return this
                },
                is: function(t) {
                    var e, i, n = this[0];
                    if (!n || void 0 === t) return !1;
                    if ("string" == typeof t) {
                        if (n.matches) return n.matches(t);
                        if (n.webkitMatchesSelector) return n.webkitMatchesSelector(t);
                        if (n.msMatchesSelector) return n.msMatchesSelector(t);
                        for (e = L(t), i = 0; i < e.length; i += 1)
                            if (e[i] === n) return !0;
                        return !1
                    }
                    if (t === b) return n === b;
                    if (t === at) return n === at;
                    if (t.nodeType || t instanceof l) {
                        for (e = t.nodeType ? [t] : t, i = 0; i < e.length; i += 1)
                            if (e[i] === n) return !0;
                        return !1
                    }
                    return !1
                },
                index: function() {
                    var t, e = this[0];
                    if (e) {
                        for (t = 0; null !== (e = e.previousSibling);) 1 === e.nodeType && (t += 1);
                        return t
                    }
                },
                eq: function(t) {
                    if (void 0 === t) return this;
                    var e, i = this.length;
                    return new l(i - 1 < t ? [] : t < 0 ? (e = i + t) < 0 ? [] : [this[e]] : [this[t]])
                },
                append: function() {
                    for (var t, e = [], i = arguments.length; i--;) e[i] = arguments[i];
                    for (var n = 0; n < e.length; n += 1) {
                        t = e[n];
                        for (var r = 0; r < this.length; r += 1)
                            if ("string" == typeof t) {
                                var a = b.createElement("div");
                                for (a.innerHTML = t; a.firstChild;) this[r].appendChild(a.firstChild)
                            } else if (t instanceof l)
                            for (var s = 0; s < t.length; s += 1) this[r].appendChild(t[s]);
                        else this[r].appendChild(t)
                    }
                    return this
                },
                prepend: function(t) {
                    for (var e, i = 0; i < this.length; i += 1)
                        if ("string" == typeof t) {
                            var n = b.createElement("div");
                            for (n.innerHTML = t, e = n.childNodes.length - 1; 0 <= e; --e) this[i].insertBefore(n.childNodes[e], this[i].childNodes[0])
                        } else if (t instanceof l)
                        for (e = 0; e < t.length; e += 1) this[i].insertBefore(t[e], this[i].childNodes[0]);
                    else this[i].insertBefore(t, this[i].childNodes[0]);
                    return this
                },
                next: function(t) {
                    return 0 < this.length ? t ? this[0].nextElementSibling && L(this[0].nextElementSibling).is(t) ? new l([this[0].nextElementSibling]) : new l([]) : this[0].nextElementSibling ? new l([this[0].nextElementSibling]) : new l([]) : new l([])
                },
                nextAll: function(t) {
                    var e = [],
                        i = this[0];
                    if (!i) return new l([]);
                    for (; i.nextElementSibling;) {
                        var n = i.nextElementSibling;
                        (!t || L(n).is(t)) && e.push(n), i = n
                    }
                    return new l(e)
                },
                prev: function(t) {
                    if (0 < this.length) {
                        var e = this[0];
                        return t ? e.previousElementSibling && L(e.previousElementSibling).is(t) ? new l([e.previousElementSibling]) : new l([]) : e.previousElementSibling ? new l([e.previousElementSibling]) : new l([])
                    }
                    return new l([])
                },
                prevAll: function(t) {
                    var e = [],
                        i = this[0];
                    if (!i) return new l([]);
                    for (; i.previousElementSibling;) {
                        var n = i.previousElementSibling;
                        (!t || L(n).is(t)) && e.push(n), i = n
                    }
                    return new l(e)
                },
                parent: function(t) {
                    for (var e = [], i = 0; i < this.length; i += 1) null === this[i].parentNode || t && !L(this[i].parentNode).is(t) || e.push(this[i].parentNode);
                    return L(a(e))
                },
                parents: function(t) {
                    for (var e = [], i = 0; i < this.length; i += 1)
                        for (var n = this[i].parentNode; n;) t && !L(n).is(t) || e.push(n), n = n.parentNode;
                    return L(a(e))
                },
                closest: function(t) {
                    var e = this;
                    return void 0 === t ? new l([]) : (e.is(t) || (e = e.parents(t).eq(0)), e)
                },
                find: function(t) {
                    for (var e = [], i = 0; i < this.length; i += 1)
                        for (var n = this[i].querySelectorAll(t), r = 0; r < n.length; r += 1) e.push(n[r]);
                    return new l(e)
                },
                children: function(t) {
                    for (var e = [], i = 0; i < this.length; i += 1)
                        for (var n = this[i].childNodes, r = 0; r < n.length; r += 1) t ? 1 === n[r].nodeType && L(n[r]).is(t) && e.push(n[r]) : 1 === n[r].nodeType && e.push(n[r]);
                    return new l(a(e))
                },
                filter: function(t) {
                    for (var e = [], i = 0; i < this.length; i += 1) t.call(this[i], i, this[i]) && e.push(this[i]);
                    return new l(e)
                },
                remove: function() {
                    for (var t = 0; t < this.length; t += 1) this[t].parentNode && this[t].parentNode.removeChild(this[t]);
                    return this
                },
                add: function() {
                    for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                    for (var i = 0; i < t.length; i += 1)
                        for (var n = L(t[i]), r = 0; r < n.length; r += 1) this[this.length] = n[r], this.length += 1;
                    return this
                },
                styles: function() {
                    return this[0] ? at.getComputedStyle(this[0], null) : {}
                }
            };
            Object.keys(e).forEach(function(t) {
                L.fn[t] = L.fn[t] || e[t]
            });

            function i(t) {
                void 0 === t && (t = {});
                var e = this;
                e.params = t, e.eventsListeners = {}, e.params && e.params.on && Object.keys(e.params.on).forEach(function(t) {
                    e.on(t, e.params.on[t])
                })
            }
            var st = {
                    deleteProps: function(t) {
                        var e = t;
                        Object.keys(e).forEach(function(t) {
                            try {
                                e[t] = null
                            } catch (t) {}
                            try {
                                delete e[t]
                            } catch (t) {}
                        })
                    },
                    nextTick: function(t, e) {
                        return void 0 === e && (e = 0), setTimeout(t, e)
                    },
                    now: function() {
                        return Date.now()
                    },
                    getTranslate: function(t, e) {
                        var i, n, r;
                        void 0 === e && (e = "x");
                        var a = at.getComputedStyle(t, null);
                        return at.WebKitCSSMatrix ? (6 < (n = a.transform || a.webkitTransform).split(",").length && (n = n.split(", ").map(function(t) {
                            return t.replace(",", ".")
                        }).join(", ")), r = new at.WebKitCSSMatrix("none" === n ? "" : n)) : i = (r = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,")).toString().split(","), "x" === e && (n = at.WebKitCSSMatrix ? r.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])), "y" === e && (n = at.WebKitCSSMatrix ? r.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])), n || 0
                    },
                    parseUrlQuery: function(t) {
                        var e, i, n, r, a = {},
                            s = t || at.location.href;
                        if ("string" == typeof s && s.length)
                            for (r = (i = (s = -1 < s.indexOf("?") ? s.replace(/\S*\?/, "") : "").split("&").filter(function(t) {
                                    return "" !== t
                                })).length, e = 0; e < r; e += 1) n = i[e].replace(/#\S+/g, "").split("="), a[decodeURIComponent(n[0])] = void 0 === n[1] ? void 0 : decodeURIComponent(n[1]) || "";
                        return a
                    },
                    isObject: function(t) {
                        return "object" === bt(t) && null !== t && t.constructor && t.constructor === Object
                    },
                    extend: function() {
                        for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                        for (var i = Object(t[0]), n = 1; n < t.length; n += 1) {
                            var r = t[n];
                            if (null != r)
                                for (var a = Object.keys(Object(r)), s = 0, o = a.length; s < o; s += 1) {
                                    var l = a[s],
                                        h = Object.getOwnPropertyDescriptor(r, l);
                                    void 0 !== h && h.enumerable && (st.isObject(i[l]) && st.isObject(r[l]) ? st.extend(i[l], r[l]) : !st.isObject(i[l]) && st.isObject(r[l]) ? (i[l] = {}, st.extend(i[l], r[l])) : i[l] = r[l])
                                }
                        }
                        return i
                    }
                },
                C = {
                    touch: !!("ontouchstart" in at || at.DocumentTouch && b instanceof at.DocumentTouch),
                    pointerEvents: !!at.PointerEvent && "maxTouchPoints" in at.navigator && 0 <= at.navigator.maxTouchPoints,
                    observer: "MutationObserver" in at || "WebkitMutationObserver" in at,
                    passiveListener: function() {
                        var t = !1;
                        try {
                            var e = Object.defineProperty({}, "passive", {
                                get: function() {
                                    t = !0
                                }
                            });
                            at.addEventListener("testPassiveListener", null, e)
                        } catch (t) {}
                        return t
                    }(),
                    gestures: "ongesturestart" in at
                },
                s = {
                    components: {
                        configurable: !0
                    }
                };
            i.prototype.on = function(t, e, i) {
                var n = this;
                if ("function" != typeof e) return n;
                var r = i ? "unshift" : "push";
                return t.split(" ").forEach(function(t) {
                    n.eventsListeners[t] || (n.eventsListeners[t] = []), n.eventsListeners[t][r](e)
                }), n
            }, i.prototype.once = function(i, n, t) {
                var r = this;
                if ("function" != typeof n) return r;

                function a() {
                    for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                    r.off(i, a), a.f7proxy && delete a.f7proxy, n.apply(r, t)
                }
                return a.f7proxy = n, r.on(i, a, t)
            }, i.prototype.off = function(t, n) {
                var r = this;
                return r.eventsListeners && t.split(" ").forEach(function(i) {
                    void 0 === n ? r.eventsListeners[i] = [] : r.eventsListeners[i] && r.eventsListeners[i].length && r.eventsListeners[i].forEach(function(t, e) {
                        (t === n || t.f7proxy && t.f7proxy === n) && r.eventsListeners[i].splice(e, 1)
                    })
                }), r
            }, i.prototype.emit = function() {
                for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                var i, n, r, a = this;
                return a.eventsListeners && (r = "string" == typeof t[0] || Array.isArray(t[0]) ? (i = t[0], n = t.slice(1, t.length), a) : (i = t[0].events, n = t[0].data, t[0].context || a), (Array.isArray(i) ? i : i.split(" ")).forEach(function(t) {
                    var e;
                    a.eventsListeners && a.eventsListeners[t] && (e = [], a.eventsListeners[t].forEach(function(t) {
                        e.push(t)
                    }), e.forEach(function(t) {
                        t.apply(r, n)
                    }))
                })), a
            }, i.prototype.useModulesParams = function(i) {
                var n = this;
                n.modules && Object.keys(n.modules).forEach(function(t) {
                    var e = n.modules[t];
                    e.params && st.extend(i, e.params)
                })
            }, i.prototype.useModules = function(n) {
                void 0 === n && (n = {});
                var r = this;
                r.modules && Object.keys(r.modules).forEach(function(t) {
                    var i = r.modules[t],
                        e = n[t] || {};
                    i.instance && Object.keys(i.instance).forEach(function(t) {
                        var e = i.instance[t];
                        r[t] = "function" == typeof e ? e.bind(r) : e
                    }), i.on && r.on && Object.keys(i.on).forEach(function(t) {
                        r.on(t, i.on[t])
                    }), i.create && i.create.bind(r)(e)
                })
            }, s.components.set = function(t) {
                this.use && this.use(t)
            }, i.installModule = function(e) {
                for (var t = [], i = arguments.length - 1; 0 < i--;) t[i] = arguments[i + 1];
                var n = this;
                n.prototype.modules || (n.prototype.modules = {});
                var r = e.name || Object.keys(n.prototype.modules).length + "_" + st.now();
                return (n.prototype.modules[r] = e).proto && Object.keys(e.proto).forEach(function(t) {
                    n.prototype[t] = e.proto[t]
                }), e.static && Object.keys(e.static).forEach(function(t) {
                    n[t] = e.static[t]
                }), e.install && e.install.apply(n, t), n
            }, i.use = function(t) {
                for (var e = [], i = arguments.length - 1; 0 < i--;) e[i] = arguments[i + 1];
                var n = this;
                return Array.isArray(t) ? (t.forEach(function(t) {
                    return n.installModule(t)
                }), n) : n.installModule.apply(n, [t].concat(e))
            }, Object.defineProperties(i, s);
            var o = {
                updateSize: function() {
                    var t = this.$el,
                        e = void 0 !== this.params.width ? this.params.width : t[0].clientWidth,
                        i = void 0 !== this.params.height ? this.params.height : t[0].clientHeight;
                    0 === e && this.isHorizontal() || 0 === i && this.isVertical() || (e = e - parseInt(t.css("padding-left"), 10) - parseInt(t.css("padding-right"), 10), i = i - parseInt(t.css("padding-top"), 10) - parseInt(t.css("padding-bottom"), 10), st.extend(this, {
                        width: e,
                        height: i,
                        size: this.isHorizontal() ? e : i
                    }))
                },
                updateSlides: function() {
                    var t = this,
                        e = t.params,
                        i = t.$wrapperEl,
                        n = t.size,
                        r = t.rtlTranslate,
                        a = t.wrongRTL,
                        s = t.virtual && e.virtual.enabled,
                        o = s ? t.virtual.slides.length : t.slides.length,
                        l = i.children("." + t.params.slideClass),
                        h = s ? t.virtual.slides.length : l.length,
                        u = [],
                        c = [],
                        p = [];

                    function d(t) {
                        return !e.cssMode || t !== l.length - 1
                    }
                    var f = e.slidesOffsetBefore;
                    "function" == typeof f && (f = e.slidesOffsetBefore.call(t));
                    var m = e.slidesOffsetAfter;
                    "function" == typeof m && (m = e.slidesOffsetAfter.call(t));
                    var g, v = t.snapGrid.length,
                        y = t.snapGrid.length,
                        b = e.spaceBetween,
                        x = -f,
                        _ = 0,
                        w = 0;
                    if (void 0 !== n) {
                        "string" == typeof b && 0 <= b.indexOf("%") && (b = parseFloat(b.replace("%", "")) / 100 * n), t.virtualSize = -b, r ? l.css({
                            marginLeft: "",
                            marginTop: ""
                        }) : l.css({
                            marginRight: "",
                            marginBottom: ""
                        }), 1 < e.slidesPerColumn && (g = Math.floor(h / e.slidesPerColumn) === h / t.params.slidesPerColumn ? h : Math.ceil(h / e.slidesPerColumn) * e.slidesPerColumn, "auto" !== e.slidesPerView && "row" === e.slidesPerColumnFill && (g = Math.max(g, e.slidesPerView * e.slidesPerColumn)));
                        for (var S, M, T, C, A, E = e.slidesPerColumn, D = g / E, P = Math.floor(h / e.slidesPerColumn), L = 0; L < h; L += 1) {
                            X = 0;
                            var k, O, F, I, N, B, R, z, G, V, U, j, H, W, q, X, Y, J, Z, $, K, Q, tt = l.eq(L);
                            1 < e.slidesPerColumn && (I = N = B = void 0, "row" === e.slidesPerColumnFill && 1 < e.slidesPerGroup ? (k = Math.floor(L / (e.slidesPerGroup * e.slidesPerColumn)), O = L - e.slidesPerColumn * e.slidesPerGroup * k, F = 0 === k ? e.slidesPerGroup : Math.min(Math.ceil((h - k * E * e.slidesPerGroup) / E), e.slidesPerGroup), B = (N = O - (I = Math.floor(O / F)) * F + k * e.slidesPerGroup) + I * g / E, tt.css({
                                "-webkit-box-ordinal-group": B,
                                "-moz-box-ordinal-group": B,
                                "-ms-flex-order": B,
                                "-webkit-order": B,
                                order: B
                            })) : "column" === e.slidesPerColumnFill ? (I = L - (N = Math.floor(L / E)) * E, (P < N || N === P && I === E - 1) && E <= (I += 1) && (I = 0, N += 1)) : N = L - (I = Math.floor(L / D)) * D, tt.css("margin-" + (t.isHorizontal() ? "top" : "left"), 0 !== I && e.spaceBetween && e.spaceBetween + "px")), "none" !== tt.css("display") && ("auto" === e.slidesPerView ? (R = at.getComputedStyle(tt[0], null), z = tt[0].style.transform, G = tt[0].style.webkitTransform, z && (tt[0].style.transform = "none"), G && (tt[0].style.webkitTransform = "none"), X = e.roundLengths ? t.isHorizontal() ? tt.outerWidth(!0) : tt.outerHeight(!0) : t.isHorizontal() ? (V = parseFloat(R.getPropertyValue("width")), U = parseFloat(R.getPropertyValue("padding-left")), j = parseFloat(R.getPropertyValue("padding-right")), H = parseFloat(R.getPropertyValue("margin-left")), W = parseFloat(R.getPropertyValue("margin-right")), (q = R.getPropertyValue("box-sizing")) && "border-box" === q ? V + H + W : V + U + j + H + W) : (Y = parseFloat(R.getPropertyValue("height")), J = parseFloat(R.getPropertyValue("padding-top")), Z = parseFloat(R.getPropertyValue("padding-bottom")), $ = parseFloat(R.getPropertyValue("margin-top")), K = parseFloat(R.getPropertyValue("margin-bottom")), (Q = R.getPropertyValue("box-sizing")) && "border-box" === Q ? Y + $ + K : Y + J + Z + $ + K), z && (tt[0].style.transform = z), G && (tt[0].style.webkitTransform = G), e.roundLengths && (X = Math.floor(X))) : (X = (n - (e.slidesPerView - 1) * b) / e.slidesPerView, e.roundLengths && (X = Math.floor(X)), l[L] && (t.isHorizontal() ? l[L].style.width = X + "px" : l[L].style.height = X + "px")), l[L] && (l[L].swiperSlideSize = X), p.push(X), e.centeredSlides ? (x = x + X / 2 + _ / 2 + b, 0 === _ && 0 !== L && (x = x - n / 2 - b), 0 === L && (x = x - n / 2 - b), Math.abs(x) < .001 && (x = 0), e.roundLengths && (x = Math.floor(x)), w % e.slidesPerGroup == 0 && u.push(x), c.push(x)) : (e.roundLengths && (x = Math.floor(x)), (w - Math.min(t.params.slidesPerGroupSkip, w)) % t.params.slidesPerGroup == 0 && u.push(x), c.push(x), x = x + X + b), t.virtualSize += X + b, _ = X, w += 1)
                        }
                        if (t.virtualSize = Math.max(t.virtualSize, n) + m, r && a && ("slide" === e.effect || "coverflow" === e.effect) && i.css({
                                width: t.virtualSize + e.spaceBetween + "px"
                            }), e.setWrapperSize && (t.isHorizontal() ? i.css({
                                width: t.virtualSize + e.spaceBetween + "px"
                            }) : i.css({
                                height: t.virtualSize + e.spaceBetween + "px"
                            })), 1 < e.slidesPerColumn && (t.virtualSize = (X + e.spaceBetween) * g, t.virtualSize = Math.ceil(t.virtualSize / e.slidesPerColumn) - e.spaceBetween, t.isHorizontal() ? i.css({
                                width: t.virtualSize + e.spaceBetween + "px"
                            }) : i.css({
                                height: t.virtualSize + e.spaceBetween + "px"
                            }), e.centeredSlides)) {
                            S = [];
                            for (var et = 0; et < u.length; et += 1) {
                                var it = u[et];
                                e.roundLengths && (it = Math.floor(it)), u[et] < t.virtualSize + u[0] && S.push(it)
                            }
                            u = S
                        }
                        if (!e.centeredSlides) {
                            S = [];
                            for (var nt = 0; nt < u.length; nt += 1) {
                                var rt = u[nt];
                                e.roundLengths && (rt = Math.floor(rt)), u[nt] <= t.virtualSize - n && S.push(rt)
                            }
                            u = S, 1 < Math.floor(t.virtualSize - n) - Math.floor(u[u.length - 1]) && u.push(t.virtualSize - n)
                        }
                        0 === u.length && (u = [0]), 0 !== e.spaceBetween && (t.isHorizontal() ? r ? l.filter(d).css({
                            marginLeft: b + "px"
                        }) : l.filter(d).css({
                            marginRight: b + "px"
                        }) : l.filter(d).css({
                            marginBottom: b + "px"
                        })), e.centeredSlides && e.centeredSlidesBounds && (M = 0, p.forEach(function(t) {
                            M += t + (e.spaceBetween ? e.spaceBetween : 0)
                        }), T = (M -= e.spaceBetween) - n, u = u.map(function(t) {
                            return t < 0 ? -f : T < t ? T + m : t
                        })), e.centerInsufficientSlides && (C = 0, p.forEach(function(t) {
                            C += t + (e.spaceBetween ? e.spaceBetween : 0)
                        }), (C -= e.spaceBetween) < n && (A = (n - C) / 2, u.forEach(function(t, e) {
                            u[e] = t - A
                        }), c.forEach(function(t, e) {
                            c[e] = t + A
                        }))), st.extend(t, {
                            slides: l,
                            snapGrid: u,
                            slidesGrid: c,
                            slidesSizesGrid: p
                        }), h !== o && t.emit("slidesLengthChange"), u.length !== v && (t.params.watchOverflow && t.checkOverflow(), t.emit("snapGridLengthChange")), c.length !== y && t.emit("slidesGridLengthChange"), (e.watchSlidesProgress || e.watchSlidesVisibility) && t.updateSlidesOffset()
                    }
                },
                updateAutoHeight: function(t) {
                    var e, i, n = this,
                        r = [],
                        a = 0;
                    if ("number" == typeof t ? n.setTransition(t) : !0 === t && n.setTransition(n.params.speed), "auto" !== n.params.slidesPerView && 1 < n.params.slidesPerView)
                        if (n.params.centeredSlides) n.visibleSlides.each(function(t, e) {
                            r.push(e)
                        });
                        else
                            for (e = 0; e < Math.ceil(n.params.slidesPerView); e += 1) {
                                var s = n.activeIndex + e;
                                if (s > n.slides.length) break;
                                r.push(n.slides.eq(s)[0])
                            } else r.push(n.slides.eq(n.activeIndex)[0]);
                    for (e = 0; e < r.length; e += 1) {
                        void 0 !== r[e] && (a = a < (i = r[e].offsetHeight) ? i : a)
                    }
                    a && n.$wrapperEl.css("height", a + "px")
                },
                updateSlidesOffset: function() {
                    for (var t = this.slides, e = 0; e < t.length; e += 1) t[e].swiperSlideOffset = this.isHorizontal() ? t[e].offsetLeft : t[e].offsetTop
                },
                updateSlidesProgress: function(t) {
                    void 0 === t && (t = this && this.translate || 0);
                    var e = this,
                        i = e.params,
                        n = e.slides,
                        r = e.rtlTranslate;
                    if (0 !== n.length) {
                        void 0 === n[0].swiperSlideOffset && e.updateSlidesOffset();
                        var a = r ? t : -t;
                        n.removeClass(i.slideVisibleClass), e.visibleSlidesIndexes = [], e.visibleSlides = [];
                        for (var s = 0; s < n.length; s += 1) {
                            var o, l, h = n[s],
                                u = (a + (i.centeredSlides ? e.minTranslate() : 0) - h.swiperSlideOffset) / (h.swiperSlideSize + i.spaceBetween);
                            (i.watchSlidesVisibility || i.centeredSlides && i.autoHeight) && (l = (o = -(a - h.swiperSlideOffset)) + e.slidesSizesGrid[s], (0 <= o && o < e.size - 1 || 1 < l && l <= e.size || o <= 0 && l >= e.size) && (e.visibleSlides.push(h), e.visibleSlidesIndexes.push(s), n.eq(s).addClass(i.slideVisibleClass))), h.progress = r ? -u : u
                        }
                        e.visibleSlides = L(e.visibleSlides)
                    }
                },
                updateProgress: function(t) {
                    var e, i = this;
                    void 0 === t && (e = i.rtlTranslate ? -1 : 1, t = i && i.translate && i.translate * e || 0);
                    var n = i.params,
                        r = i.maxTranslate() - i.minTranslate(),
                        a = i.progress,
                        s = i.isBeginning,
                        o = s,
                        l = h = i.isEnd,
                        h = 0 == r ? s = !(a = 0) : (s = (a = (t - i.minTranslate()) / r) <= 0, 1 <= a);
                    st.extend(i, {
                        progress: a,
                        isBeginning: s,
                        isEnd: h
                    }), (n.watchSlidesProgress || n.watchSlidesVisibility || n.centeredSlides && n.autoHeight) && i.updateSlidesProgress(t), s && !o && i.emit("reachBeginning toEdge"), h && !l && i.emit("reachEnd toEdge"), (o && !s || l && !h) && i.emit("fromEdge"), i.emit("progress", a)
                },
                updateSlidesClasses: function() {
                    var t, e = this.slides,
                        i = this.params,
                        n = this.$wrapperEl,
                        r = this.activeIndex,
                        a = this.realIndex,
                        s = this.virtual && i.virtual.enabled;
                    e.removeClass(i.slideActiveClass + " " + i.slideNextClass + " " + i.slidePrevClass + " " + i.slideDuplicateActiveClass + " " + i.slideDuplicateNextClass + " " + i.slideDuplicatePrevClass), (t = s ? this.$wrapperEl.find("." + i.slideClass + '[data-swiper-slide-index="' + r + '"]') : e.eq(r)).addClass(i.slideActiveClass), i.loop && (t.hasClass(i.slideDuplicateClass) ? n.children("." + i.slideClass + ":not(." + i.slideDuplicateClass + ')[data-swiper-slide-index="' + a + '"]').addClass(i.slideDuplicateActiveClass) : n.children("." + i.slideClass + "." + i.slideDuplicateClass + '[data-swiper-slide-index="' + a + '"]').addClass(i.slideDuplicateActiveClass));
                    var o = t.nextAll("." + i.slideClass).eq(0).addClass(i.slideNextClass);
                    i.loop && 0 === o.length && (o = e.eq(0)).addClass(i.slideNextClass);
                    var l = t.prevAll("." + i.slideClass).eq(0).addClass(i.slidePrevClass);
                    i.loop && 0 === l.length && (l = e.eq(-1)).addClass(i.slidePrevClass), i.loop && (o.hasClass(i.slideDuplicateClass) ? n.children("." + i.slideClass + ":not(." + i.slideDuplicateClass + ')[data-swiper-slide-index="' + o.attr("data-swiper-slide-index") + '"]').addClass(i.slideDuplicateNextClass) : n.children("." + i.slideClass + "." + i.slideDuplicateClass + '[data-swiper-slide-index="' + o.attr("data-swiper-slide-index") + '"]').addClass(i.slideDuplicateNextClass), l.hasClass(i.slideDuplicateClass) ? n.children("." + i.slideClass + ":not(." + i.slideDuplicateClass + ')[data-swiper-slide-index="' + l.attr("data-swiper-slide-index") + '"]').addClass(i.slideDuplicatePrevClass) : n.children("." + i.slideClass + "." + i.slideDuplicateClass + '[data-swiper-slide-index="' + l.attr("data-swiper-slide-index") + '"]').addClass(i.slideDuplicatePrevClass))
                },
                updateActiveIndex: function(t) {
                    var e, i, n, r = this,
                        a = r.rtlTranslate ? r.translate : -r.translate,
                        s = r.slidesGrid,
                        o = r.snapGrid,
                        l = r.params,
                        h = r.activeIndex,
                        u = r.realIndex,
                        c = r.snapIndex,
                        p = t;
                    if (void 0 === p) {
                        for (var d = 0; d < s.length; d += 1) void 0 !== s[d + 1] ? a >= s[d] && a < s[d + 1] - (s[d + 1] - s[d]) / 2 ? p = d : a >= s[d] && a < s[d + 1] && (p = d + 1) : a >= s[d] && (p = d);
                        l.normalizeSlideIndex && (p < 0 || void 0 === p) && (p = 0)
                    }(i = 0 <= o.indexOf(a) ? o.indexOf(a) : (e = Math.min(l.slidesPerGroupSkip, p)) + Math.floor((p - e) / l.slidesPerGroup)) >= o.length && (i = o.length - 1), p !== h ? (n = parseInt(r.slides.eq(p).attr("data-swiper-slide-index") || p, 10), st.extend(r, {
                        snapIndex: i,
                        realIndex: n,
                        previousIndex: h,
                        activeIndex: p
                    }), r.emit("activeIndexChange"), r.emit("snapIndexChange"), u !== n && r.emit("realIndexChange"), (r.initialized || r.params.runCallbacksOnInit) && r.emit("slideChange")) : i !== c && (r.snapIndex = i, r.emit("snapIndexChange"))
                },
                updateClickedSlide: function(t) {
                    var e = this,
                        i = e.params,
                        n = L(t.target).closest("." + i.slideClass)[0],
                        r = !1;
                    if (n)
                        for (var a = 0; a < e.slides.length; a += 1) e.slides[a] === n && (r = !0);
                    if (!n || !r) return e.clickedSlide = void 0, void(e.clickedIndex = void 0);
                    e.clickedSlide = n, e.virtual && e.params.virtual.enabled ? e.clickedIndex = parseInt(L(n).attr("data-swiper-slide-index"), 10) : e.clickedIndex = L(n).index(), i.slideToClickedSlide && void 0 !== e.clickedIndex && e.clickedIndex !== e.activeIndex && e.slideToClickedSlide()
                }
            };
            var h = {
                getTranslate: function(t) {
                    void 0 === t && (t = this.isHorizontal() ? "x" : "y");
                    var e = this.params,
                        i = this.rtlTranslate,
                        n = this.translate,
                        r = this.$wrapperEl;
                    if (e.virtualTranslate) return i ? -n : n;
                    if (e.cssMode) return n;
                    var a = st.getTranslate(r[0], t);
                    return i && (a = -a), a || 0
                },
                setTranslate: function(t, e) {
                    var i = this,
                        n = i.rtlTranslate,
                        r = i.params,
                        a = i.$wrapperEl,
                        s = i.wrapperEl,
                        o = i.progress,
                        l = 0,
                        h = 0;
                    i.isHorizontal() ? l = n ? -t : t : h = t, r.roundLengths && (l = Math.floor(l), h = Math.floor(h)), r.cssMode ? s[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -l : -h : r.virtualTranslate || a.transform("translate3d(" + l + "px, " + h + "px, 0px)"), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? l : h;
                    var u = i.maxTranslate() - i.minTranslate();
                    (0 == u ? 0 : (t - i.minTranslate()) / u) !== o && i.updateProgress(t), i.emit("setTranslate", i.translate, e)
                },
                minTranslate: function() {
                    return -this.snapGrid[0]
                },
                maxTranslate: function() {
                    return -this.snapGrid[this.snapGrid.length - 1]
                },
                translateTo: function(t, e, i, n, r) {
                    var a;
                    void 0 === t && (t = 0), void 0 === e && (e = this.params.speed), void 0 === i && (i = !0), void 0 === n && (n = !0);
                    var s = this,
                        o = s.params,
                        l = s.wrapperEl;
                    if (s.animating && o.preventInteractionOnTransition) return !1;
                    var h = s.minTranslate(),
                        u = s.maxTranslate(),
                        c = n && h < t ? h : n && t < u ? u : t;
                    if (s.updateProgress(c), o.cssMode) {
                        var p = s.isHorizontal();
                        return 0 !== e && l.scrollTo ? l.scrollTo(((a = {})[p ? "left" : "top"] = -c, a.behavior = "smooth", a)) : l[p ? "scrollLeft" : "scrollTop"] = -c, !0
                    }
                    return 0 === e ? (s.setTransition(0), s.setTranslate(c), i && (s.emit("beforeTransitionStart", e, r), s.emit("transitionEnd"))) : (s.setTransition(e), s.setTranslate(c), i && (s.emit("beforeTransitionStart", e, r), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function(t) {
                        s && !s.destroyed && t.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, i && s.emit("transitionEnd"))
                    }), s.$wrapperEl[0].addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd))), !0
                }
            };
            var u = {
                setTransition: function(t, e) {
                    this.params.cssMode || this.$wrapperEl.transition(t), this.emit("setTransition", t, e)
                },
                transitionStart: function(t, e) {
                    void 0 === t && (t = !0);
                    var i = this.activeIndex,
                        n = this.params,
                        r = this.previousIndex;
                    if (!n.cssMode) {
                        n.autoHeight && this.updateAutoHeight();
                        var a = (a = e) || (r < i ? "next" : i < r ? "prev" : "reset");
                        if (this.emit("transitionStart"), t && i !== r) {
                            if ("reset" === a) return void this.emit("slideResetTransitionStart");
                            this.emit("slideChangeTransitionStart"), "next" === a ? this.emit("slideNextTransitionStart") : this.emit("slidePrevTransitionStart")
                        }
                    }
                },
                transitionEnd: function(t, e) {
                    void 0 === t && (t = !0);
                    var i = this,
                        n = i.activeIndex,
                        r = i.previousIndex,
                        a = i.params;
                    if (i.animating = !1, !a.cssMode) {
                        i.setTransition(0);
                        var s = (s = e) || (r < n ? "next" : n < r ? "prev" : "reset");
                        if (i.emit("transitionEnd"), t && n !== r) {
                            if ("reset" === s) return void i.emit("slideResetTransitionEnd");
                            i.emit("slideChangeTransitionEnd"), "next" === s ? i.emit("slideNextTransitionEnd") : i.emit("slidePrevTransitionEnd")
                        }
                    }
                }
            };
            var c = {
                slideTo: function(t, e, i, n) {
                    var r;
                    void 0 === t && (t = 0), void 0 === e && (e = this.params.speed), void 0 === i && (i = !0);
                    var a = this,
                        s = t;
                    s < 0 && (s = 0);
                    var o = a.params,
                        l = a.snapGrid,
                        h = a.slidesGrid,
                        u = a.previousIndex,
                        c = a.activeIndex,
                        p = a.rtlTranslate,
                        d = a.wrapperEl;
                    if (a.animating && o.preventInteractionOnTransition) return !1;
                    var f = Math.min(a.params.slidesPerGroupSkip, s),
                        m = f + Math.floor((s - f) / a.params.slidesPerGroup);
                    m >= l.length && (m = l.length - 1), (c || o.initialSlide || 0) === (u || 0) && i && a.emit("beforeSlideChangeStart");
                    var g, v = -l[m];
                    if (a.updateProgress(v), o.normalizeSlideIndex)
                        for (var y = 0; y < h.length; y += 1) - Math.floor(100 * v) >= Math.floor(100 * h[y]) && (s = y);
                    if (a.initialized && s !== c) {
                        if (!a.allowSlideNext && v < a.translate && v < a.minTranslate()) return !1;
                        if (!a.allowSlidePrev && v > a.translate && v > a.maxTranslate() && (c || 0) !== s) return !1
                    }
                    if (g = c < s ? "next" : s < c ? "prev" : "reset", p && -v === a.translate || !p && v === a.translate) return a.updateActiveIndex(s), o.autoHeight && a.updateAutoHeight(), a.updateSlidesClasses(), "slide" !== o.effect && a.setTranslate(v), "reset" !== g && (a.transitionStart(i, g), a.transitionEnd(i, g)), !1;
                    if (o.cssMode) {
                        var b = a.isHorizontal(),
                            x = -v;
                        return p && (x = d.scrollWidth - d.offsetWidth - x), 0 !== e && d.scrollTo ? d.scrollTo(((r = {})[b ? "left" : "top"] = x, r.behavior = "smooth", r)) : d[b ? "scrollLeft" : "scrollTop"] = x, !0
                    }
                    return 0 === e ? (a.setTransition(0), a.setTranslate(v), a.updateActiveIndex(s), a.updateSlidesClasses(), a.emit("beforeTransitionStart", e, n), a.transitionStart(i, g), a.transitionEnd(i, g)) : (a.setTransition(e), a.setTranslate(v), a.updateActiveIndex(s), a.updateSlidesClasses(), a.emit("beforeTransitionStart", e, n), a.transitionStart(i, g), a.animating || (a.animating = !0, a.onSlideToWrapperTransitionEnd || (a.onSlideToWrapperTransitionEnd = function(t) {
                        a && !a.destroyed && t.target === this && (a.$wrapperEl[0].removeEventListener("transitionend", a.onSlideToWrapperTransitionEnd), a.$wrapperEl[0].removeEventListener("webkitTransitionEnd", a.onSlideToWrapperTransitionEnd), a.onSlideToWrapperTransitionEnd = null, delete a.onSlideToWrapperTransitionEnd, a.transitionEnd(i, g))
                    }), a.$wrapperEl[0].addEventListener("transitionend", a.onSlideToWrapperTransitionEnd), a.$wrapperEl[0].addEventListener("webkitTransitionEnd", a.onSlideToWrapperTransitionEnd))), !0
                },
                slideToLoop: function(t, e, i, n) {
                    void 0 === t && (t = 0), void 0 === e && (e = this.params.speed), void 0 === i && (i = !0);
                    var r = t;
                    return this.params.loop && (r += this.loopedSlides), this.slideTo(r, e, i, n)
                },
                slideNext: function(t, e, i) {
                    void 0 === t && (t = this.params.speed), void 0 === e && (e = !0);
                    var n = this.params,
                        r = this.animating,
                        a = this.activeIndex < n.slidesPerGroupSkip ? 1 : n.slidesPerGroup;
                    if (n.loop) {
                        if (r) return !1;
                        this.loopFix(), this._clientLeft = this.$wrapperEl[0].clientLeft
                    }
                    return this.slideTo(this.activeIndex + a, t, e, i)
                },
                slidePrev: function(t, e, i) {
                    void 0 === t && (t = this.params.speed), void 0 === e && (e = !0);
                    var n = this,
                        r = n.params,
                        a = n.animating,
                        s = n.snapGrid,
                        o = n.slidesGrid,
                        l = n.rtlTranslate;
                    if (r.loop) {
                        if (a) return !1;
                        n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft
                    }

                    function h(t) {
                        return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t)
                    }
                    var u, c = h(l ? n.translate : -n.translate),
                        p = s.map(h),
                        d = (o.map(h), s[p.indexOf(c)], s[p.indexOf(c) - 1]);
                    return void 0 === d && r.cssMode && s.forEach(function(t) {
                        !d && t <= c && (d = t)
                    }), void 0 !== d && (u = o.indexOf(d)) < 0 && (u = n.activeIndex - 1), n.slideTo(u, t, e, i)
                },
                slideReset: function(t, e, i) {
                    return void 0 === t && (t = this.params.speed), void 0 === e && (e = !0), this.slideTo(this.activeIndex, t, e, i)
                },
                slideToClosest: function(t, e, i, n) {
                    void 0 === t && (t = this.params.speed), void 0 === e && (e = !0), void 0 === n && (n = .5);
                    var r, a, s = this,
                        o = s.activeIndex,
                        l = Math.min(s.params.slidesPerGroupSkip, o),
                        h = l + Math.floor((o - l) / s.params.slidesPerGroup),
                        u = s.rtlTranslate ? s.translate : -s.translate;
                    return u >= s.snapGrid[h] ? (r = s.snapGrid[h], (s.snapGrid[h + 1] - r) * n < u - r && (o += s.params.slidesPerGroup)) : u - (a = s.snapGrid[h - 1]) <= (s.snapGrid[h] - a) * n && (o -= s.params.slidesPerGroup), o = Math.max(o, 0), o = Math.min(o, s.slidesGrid.length - 1), s.slideTo(o, t, e, i)
                },
                slideToClickedSlide: function() {
                    var t, e = this,
                        i = e.params,
                        n = e.$wrapperEl,
                        r = "auto" === i.slidesPerView ? e.slidesPerViewDynamic() : i.slidesPerView,
                        a = e.clickedIndex;
                    if (i.loop) {
                        if (e.animating) return;
                        t = parseInt(L(e.clickedSlide).attr("data-swiper-slide-index"), 10), i.centeredSlides ? a < e.loopedSlides - r / 2 || a > e.slides.length - e.loopedSlides + r / 2 ? (e.loopFix(), a = n.children("." + i.slideClass + '[data-swiper-slide-index="' + t + '"]:not(.' + i.slideDuplicateClass + ")").eq(0).index(), st.nextTick(function() {
                            e.slideTo(a)
                        })) : e.slideTo(a) : a > e.slides.length - r ? (e.loopFix(), a = n.children("." + i.slideClass + '[data-swiper-slide-index="' + t + '"]:not(.' + i.slideDuplicateClass + ")").eq(0).index(), st.nextTick(function() {
                            e.slideTo(a)
                        })) : e.slideTo(a)
                    } else e.slideTo(a)
                }
            };
            var p = {
                loopCreate: function() {
                    var n = this,
                        t = n.params,
                        e = n.$wrapperEl;
                    e.children("." + t.slideClass + "." + t.slideDuplicateClass).remove();
                    var r = e.children("." + t.slideClass);
                    if (t.loopFillGroupWithBlank) {
                        var i = t.slidesPerGroup - r.length % t.slidesPerGroup;
                        if (i !== t.slidesPerGroup) {
                            for (var a = 0; a < i; a += 1) {
                                var s = L(b.createElement("div")).addClass(t.slideClass + " " + t.slideBlankClass);
                                e.append(s)
                            }
                            r = e.children("." + t.slideClass)
                        }
                    }
                    "auto" !== t.slidesPerView || t.loopedSlides || (t.loopedSlides = r.length), n.loopedSlides = Math.ceil(parseFloat(t.loopedSlides || t.slidesPerView, 10)), n.loopedSlides += t.loopAdditionalSlides, n.loopedSlides > r.length && (n.loopedSlides = r.length);
                    var o = [],
                        l = [];
                    r.each(function(t, e) {
                        var i = L(e);
                        t < n.loopedSlides && l.push(e), t < r.length && t >= r.length - n.loopedSlides && o.push(e), i.attr("data-swiper-slide-index", t)
                    });
                    for (var h = 0; h < l.length; h += 1) e.append(L(l[h].cloneNode(!0)).addClass(t.slideDuplicateClass));
                    for (var u = o.length - 1; 0 <= u; --u) e.prepend(L(o[u].cloneNode(!0)).addClass(t.slideDuplicateClass))
                },
                loopFix: function() {
                    var t = this;
                    t.emit("beforeLoopFix");
                    var e = t.activeIndex,
                        i = t.slides,
                        n = t.loopedSlides,
                        r = t.allowSlidePrev,
                        a = t.allowSlideNext,
                        s = t.snapGrid,
                        o = t.rtlTranslate;
                    t.allowSlidePrev = !0, t.allowSlideNext = !0;
                    var l, h = -s[e] - t.getTranslate();
                    e < n ? (l = i.length - 3 * n + e, l += n, t.slideTo(l, 0, !1, !0) && 0 != h && t.setTranslate((o ? -t.translate : t.translate) - h)) : e >= i.length - n && (l = -i.length + e + n, l += n, t.slideTo(l, 0, !1, !0) && 0 != h && t.setTranslate((o ? -t.translate : t.translate) - h)), t.allowSlidePrev = r, t.allowSlideNext = a, t.emit("loopFix")
                },
                loopDestroy: function() {
                    var t = this.$wrapperEl,
                        e = this.params,
                        i = this.slides;
                    t.children("." + e.slideClass + "." + e.slideDuplicateClass + ",." + e.slideClass + "." + e.slideBlankClass).remove(), i.removeAttr("data-swiper-slide-index")
                }
            };
            var d = {
                setGrabCursor: function(t) {
                    var e;
                    C.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked || this.params.cssMode || ((e = this.el).style.cursor = "move", e.style.cursor = t ? "-webkit-grabbing" : "-webkit-grab", e.style.cursor = t ? "-moz-grabbin" : "-moz-grab", e.style.cursor = t ? "grabbing" : "grab")
                },
                unsetGrabCursor: function() {
                    C.touch || this.params.watchOverflow && this.isLocked || this.params.cssMode || (this.el.style.cursor = "")
                }
            };
            var f, m, g, v, y, x, _, w, S, M, T, A, E, D, P, k = {
                    appendSlide: function(t) {
                        var e = this.$wrapperEl,
                            i = this.params;
                        if (i.loop && this.loopDestroy(), "object" === bt(t) && "length" in t)
                            for (var n = 0; n < t.length; n += 1) t[n] && e.append(t[n]);
                        else e.append(t);
                        i.loop && this.loopCreate(), i.observer && C.observer || this.update()
                    },
                    prependSlide: function(t) {
                        var e = this.params,
                            i = this.$wrapperEl,
                            n = this.activeIndex;
                        e.loop && this.loopDestroy();
                        var r = n + 1;
                        if ("object" === bt(t) && "length" in t) {
                            for (var a = 0; a < t.length; a += 1) t[a] && i.prepend(t[a]);
                            r = n + t.length
                        } else i.prepend(t);
                        e.loop && this.loopCreate(), e.observer && C.observer || this.update(), this.slideTo(r, 0, !1)
                    },
                    addSlide: function(t, e) {
                        var i = this,
                            n = i.$wrapperEl,
                            r = i.params,
                            a = i.activeIndex;
                        r.loop && (a -= i.loopedSlides, i.loopDestroy(), i.slides = n.children("." + r.slideClass));
                        var s = i.slides.length;
                        if (t <= 0) i.prependSlide(e);
                        else if (s <= t) i.appendSlide(e);
                        else {
                            for (var o = t < a ? a + 1 : a, l = [], h = s - 1; t <= h; --h) {
                                var u = i.slides.eq(h);
                                u.remove(), l.unshift(u)
                            }
                            if ("object" === bt(e) && "length" in e) {
                                for (var c = 0; c < e.length; c += 1) e[c] && n.append(e[c]);
                                o = t < a ? a + e.length : a
                            } else n.append(e);
                            for (var p = 0; p < l.length; p += 1) n.append(l[p]);
                            r.loop && i.loopCreate(), r.observer && C.observer || i.update(), r.loop ? i.slideTo(o + i.loopedSlides, 0, !1) : i.slideTo(o, 0, !1)
                        }
                    },
                    removeSlide: function(t) {
                        var e = this,
                            i = e.params,
                            n = e.$wrapperEl,
                            r = e.activeIndex;
                        i.loop && (r -= e.loopedSlides, e.loopDestroy(), e.slides = n.children("." + i.slideClass));
                        var a, s = r;
                        if ("object" === bt(t) && "length" in t) {
                            for (var o = 0; o < t.length; o += 1) a = t[o], e.slides[a] && e.slides.eq(a).remove(), a < s && --s;
                            s = Math.max(s, 0)
                        } else a = t, e.slides[a] && e.slides.eq(a).remove(), a < s && --s, s = Math.max(s, 0);
                        i.loop && e.loopCreate(), i.observer && C.observer || e.update(), i.loop ? e.slideTo(s + e.loopedSlides, 0, !1) : e.slideTo(s, 0, !1)
                    },
                    removeAllSlides: function() {
                        for (var t = [], e = 0; e < this.slides.length; e += 1) t.push(e);
                        this.removeSlide(t)
                    }
                },
                O = (f = at.navigator.platform, m = at.navigator.userAgent, g = {
                    ios: !1,
                    android: !1,
                    androidChrome: !1,
                    desktop: !1,
                    iphone: !1,
                    ipod: !1,
                    ipad: !1,
                    edge: !1,
                    ie: !1,
                    firefox: !1,
                    macos: !1,
                    windows: !1,
                    cordova: !(!at.cordova && !at.phonegap),
                    phonegap: !(!at.cordova && !at.phonegap),
                    electron: !1
                }, v = at.screen.width, y = at.screen.height, x = m.match(/(Android);?[\s\/]+([\d.]+)?/), _ = m.match(/(iPad).*OS\s([\d_]+)/), w = m.match(/(iPod)(.*OS\s([\d_]+))?/), S = !_ && m.match(/(iPhone\sOS|iOS)\s([\d_]+)/), M = 0 <= m.indexOf("MSIE ") || 0 <= m.indexOf("Trident/"), T = 0 <= m.indexOf("Edge/"), A = 0 <= m.indexOf("Gecko/") && 0 <= m.indexOf("Firefox/"), E = "Win32" === f, D = 0 <= m.toLowerCase().indexOf("electron"), P = "MacIntel" === f, !_ && P && C.touch && (1024 === v && 1366 === y || 834 === v && 1194 === y || 834 === v && 1112 === y || 768 === v && 1024 === y) && (_ = m.match(/(Version)\/([\d.]+)/), P = !1), g.ie = M, g.edge = T, g.firefox = A, x && !E && (g.os = "android", g.osVersion = x[2], g.android = !0, g.androidChrome = 0 <= m.toLowerCase().indexOf("chrome")), (_ || S || w) && (g.os = "ios", g.ios = !0), S && !w && (g.osVersion = S[2].replace(/_/g, "."), g.iphone = !0), _ && (g.osVersion = _[2].replace(/_/g, "."), g.ipad = !0), w && (g.osVersion = w[3] ? w[3].replace(/_/g, ".") : null, g.ipod = !0), g.ios && g.osVersion && 0 <= m.indexOf("Version/") && "10" === g.osVersion.split(".")[0] && (g.osVersion = m.toLowerCase().split("version/")[1].split(" ")[0]), g.webView = !(!(S || _ || w) || !m.match(/.*AppleWebKit(?!.*Safari)/i) && !at.navigator.standalone) || at.matchMedia && at.matchMedia("(display-mode: standalone)").matches, g.webview = g.webView, g.standalone = g.webView, g.desktop = !(g.ios || g.android) || D, g.desktop && (g.electron = D, g.macos = P, g.windows = E, g.macos && (g.os = "macos"), g.windows && (g.os = "windows")), g.pixelRatio = at.devicePixelRatio || 1, g);

            function F() {
                var t, e, i, n = this,
                    r = n.params,
                    a = n.el;
                a && 0 === a.offsetWidth || (r.breakpoints && n.setBreakpoint(), t = n.allowSlideNext, e = n.allowSlidePrev, i = n.snapGrid, n.allowSlideNext = !0, n.allowSlidePrev = !0, n.updateSize(), n.updateSlides(), n.updateSlidesClasses(), ("auto" === r.slidesPerView || 1 < r.slidesPerView) && n.isEnd && !n.isBeginning && !n.params.centeredSlides ? n.slideTo(n.slides.length - 1, 0, !1, !0) : n.slideTo(n.activeIndex, 0, !1, !0), n.autoplay && n.autoplay.running && n.autoplay.paused && n.autoplay.run(), n.allowSlidePrev = e, n.allowSlideNext = t, n.params.watchOverflow && i !== n.snapGrid && n.checkOverflow())
            }
            var I = !1;

            function N() {}
            var B, R = {
                    init: !0,
                    direction: "horizontal",
                    touchEventsTarget: "container",
                    initialSlide: 0,
                    speed: 300,
                    cssMode: !1,
                    updateOnWindowResize: !0,
                    preventInteractionOnTransition: !1,
                    edgeSwipeDetection: !1,
                    edgeSwipeThreshold: 20,
                    freeMode: !1,
                    freeModeMomentum: !0,
                    freeModeMomentumRatio: 1,
                    freeModeMomentumBounce: !0,
                    freeModeMomentumBounceRatio: 1,
                    freeModeMomentumVelocityRatio: 1,
                    freeModeSticky: !1,
                    freeModeMinimumVelocity: .02,
                    autoHeight: !1,
                    setWrapperSize: !1,
                    virtualTranslate: !1,
                    effect: "slide",
                    breakpoints: void 0,
                    spaceBetween: 0,
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerColumnFill: "column",
                    slidesPerGroup: 1,
                    slidesPerGroupSkip: 0,
                    centeredSlides: !1,
                    centeredSlidesBounds: !1,
                    slidesOffsetBefore: 0,
                    slidesOffsetAfter: 0,
                    normalizeSlideIndex: !0,
                    centerInsufficientSlides: !1,
                    watchOverflow: !1,
                    roundLengths: !1,
                    touchRatio: 1,
                    touchAngle: 45,
                    simulateTouch: !0,
                    shortSwipes: !0,
                    longSwipes: !0,
                    longSwipesRatio: .5,
                    longSwipesMs: 300,
                    followFinger: !0,
                    allowTouchMove: !0,
                    threshold: 0,
                    touchMoveStopPropagation: !1,
                    touchStartPreventDefault: !0,
                    touchStartForcePreventDefault: !1,
                    touchReleaseOnEdges: !1,
                    uniqueNavElements: !0,
                    resistance: !0,
                    resistanceRatio: .85,
                    watchSlidesProgress: !1,
                    watchSlidesVisibility: !1,
                    grabCursor: !1,
                    preventClicks: !0,
                    preventClicksPropagation: !0,
                    slideToClickedSlide: !1,
                    preloadImages: !0,
                    updateOnImagesReady: !0,
                    loop: !1,
                    loopAdditionalSlides: 0,
                    loopedSlides: null,
                    loopFillGroupWithBlank: !1,
                    allowSlidePrev: !0,
                    allowSlideNext: !0,
                    swipeHandler: null,
                    noSwiping: !0,
                    noSwipingClass: "swiper-no-swiping",
                    noSwipingSelector: null,
                    passiveListeners: !0,
                    containerModifierClass: "swiper-container-",
                    slideClass: "swiper-slide",
                    slideBlankClass: "swiper-slide-invisible-blank",
                    slideActiveClass: "swiper-slide-active",
                    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
                    slideVisibleClass: "swiper-slide-visible",
                    slideDuplicateClass: "swiper-slide-duplicate",
                    slideNextClass: "swiper-slide-next",
                    slideDuplicateNextClass: "swiper-slide-duplicate-next",
                    slidePrevClass: "swiper-slide-prev",
                    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
                    wrapperClass: "swiper-wrapper",
                    runCallbacksOnInit: !0
                },
                z = {
                    update: o,
                    translate: h,
                    transition: u,
                    slide: c,
                    loop: p,
                    grabCursor: d,
                    manipulation: k,
                    events: {
                        attachEvents: function() {
                            var t = this,
                                e = t.params,
                                i = t.touchEvents,
                                n = t.el,
                                r = t.wrapperEl;
                            t.onTouchStart = function(t) {
                                var e, i, n, r, a, s, o, l, h = this,
                                    u = h.touchEventsData,
                                    c = h.params,
                                    p = h.touches;
                                h.animating && c.preventInteractionOnTransition || ((e = t).originalEvent && (e = e.originalEvent), i = L(e.target), "wrapper" === c.touchEventsTarget && !i.closest(h.wrapperEl).length || (u.isTouchEvent = "touchstart" === e.type, !u.isTouchEvent && "which" in e && 3 === e.which || !u.isTouchEvent && "button" in e && 0 < e.button || u.isTouched && u.isMoved || (c.noSwiping && i.closest(c.noSwipingSelector ? c.noSwipingSelector : "." + c.noSwipingClass)[0] ? h.allowClick = !0 : c.swipeHandler && !i.closest(c.swipeHandler)[0] || (p.currentX = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, p.currentY = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY, n = p.currentX, r = p.currentY, a = c.edgeSwipeDetection || c.iOSEdgeSwipeDetection, s = c.edgeSwipeThreshold || c.iOSEdgeSwipeThreshold, a && (n <= s || n >= at.screen.width - s) || (st.extend(u, {
                                    isTouched: !0,
                                    isMoved: !1,
                                    allowTouchCallbacks: !0,
                                    isScrolling: void 0,
                                    startMoving: void 0
                                }), p.startX = n, p.startY = r, u.touchStartTime = st.now(), h.allowClick = !0, h.updateSize(), h.swipeDirection = void 0, 0 < c.threshold && (u.allowThresholdMove = !1), "touchstart" !== e.type && (o = !0, i.is(u.formElements) && (o = !1), b.activeElement && L(b.activeElement).is(u.formElements) && b.activeElement !== i[0] && b.activeElement.blur(), l = o && h.allowTouchMove && c.touchStartPreventDefault, (c.touchStartForcePreventDefault || l) && e.preventDefault()), h.emit("touchStart", e))))))
                            }.bind(t), t.onTouchMove = function(t) {
                                var e = this,
                                    i = e.touchEventsData,
                                    n = e.params,
                                    r = e.touches,
                                    a = e.rtlTranslate,
                                    s = t;
                                if (s.originalEvent && (s = s.originalEvent), i.isTouched) {
                                    if (!i.isTouchEvent || "touchmove" === s.type) {
                                        var o = "touchmove" === s.type && s.targetTouches && (s.targetTouches[0] || s.changedTouches[0]),
                                            l = "touchmove" === s.type ? o.pageX : s.pageX,
                                            h = "touchmove" === s.type ? o.pageY : s.pageY;
                                        if (s.preventedByNestedSwiper) return r.startX = l, void(r.startY = h);
                                        if (!e.allowTouchMove) return e.allowClick = !1, void(i.isTouched && (st.extend(r, {
                                            startX: l,
                                            startY: h,
                                            currentX: l,
                                            currentY: h
                                        }), i.touchStartTime = st.now()));
                                        if (i.isTouchEvent && n.touchReleaseOnEdges && !n.loop)
                                            if (e.isVertical()) {
                                                if (h < r.startY && e.translate <= e.maxTranslate() || h > r.startY && e.translate >= e.minTranslate()) return i.isTouched = !1, void(i.isMoved = !1)
                                            } else if (l < r.startX && e.translate <= e.maxTranslate() || l > r.startX && e.translate >= e.minTranslate()) return;
                                        if (i.isTouchEvent && b.activeElement && s.target === b.activeElement && L(s.target).is(i.formElements)) return i.isMoved = !0, void(e.allowClick = !1);
                                        if (i.allowTouchCallbacks && e.emit("touchMove", s), !(s.targetTouches && 1 < s.targetTouches.length)) {
                                            r.currentX = l, r.currentY = h;
                                            var u, c = r.currentX - r.startX,
                                                p = r.currentY - r.startY;
                                            if (!(e.params.threshold && Math.sqrt(Math.pow(c, 2) + Math.pow(p, 2)) < e.params.threshold))
                                                if (void 0 === i.isScrolling && (e.isHorizontal() && r.currentY === r.startY || e.isVertical() && r.currentX === r.startX ? i.isScrolling = !1 : 25 <= c * c + p * p && (u = 180 * Math.atan2(Math.abs(p), Math.abs(c)) / Math.PI, i.isScrolling = e.isHorizontal() ? u > n.touchAngle : 90 - u > n.touchAngle)), i.isScrolling && e.emit("touchMoveOpposite", s), void 0 === i.startMoving && (r.currentX === r.startX && r.currentY === r.startY || (i.startMoving = !0)), i.isScrolling) i.isTouched = !1;
                                                else if (i.startMoving) {
                                                e.allowClick = !1, !n.cssMode && s.cancelable && s.preventDefault(), n.touchMoveStopPropagation && !n.nested && s.stopPropagation(), i.isMoved || (n.loop && e.loopFix(), i.startTranslate = e.getTranslate(), e.setTransition(0), e.animating && e.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !n.grabCursor || !0 !== e.allowSlideNext && !0 !== e.allowSlidePrev || e.setGrabCursor(!0), e.emit("sliderFirstMove", s)), e.emit("sliderMove", s), i.isMoved = !0;
                                                var d = e.isHorizontal() ? c : p;
                                                r.diff = d, d *= n.touchRatio, a && (d = -d), e.swipeDirection = 0 < d ? "prev" : "next", i.currentTranslate = d + i.startTranslate;
                                                var f = !0,
                                                    m = n.resistanceRatio;
                                                if (n.touchReleaseOnEdges && (m = 0), 0 < d && i.currentTranslate > e.minTranslate() ? (f = !1, n.resistance && (i.currentTranslate = e.minTranslate() - 1 + Math.pow(-e.minTranslate() + i.startTranslate + d, m))) : d < 0 && i.currentTranslate < e.maxTranslate() && (f = !1, n.resistance && (i.currentTranslate = e.maxTranslate() + 1 - Math.pow(e.maxTranslate() - i.startTranslate - d, m))), f && (s.preventedByNestedSwiper = !0), !e.allowSlideNext && "next" === e.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !e.allowSlidePrev && "prev" === e.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), 0 < n.threshold) {
                                                    if (!(Math.abs(d) > n.threshold || i.allowThresholdMove)) return void(i.currentTranslate = i.startTranslate);
                                                    if (!i.allowThresholdMove) return i.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, i.currentTranslate = i.startTranslate, void(r.diff = e.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY)
                                                }
                                                n.followFinger && !n.cssMode && ((n.freeMode || n.watchSlidesProgress || n.watchSlidesVisibility) && (e.updateActiveIndex(), e.updateSlidesClasses()), n.freeMode && (0 === i.velocities.length && i.velocities.push({
                                                    position: r[e.isHorizontal() ? "startX" : "startY"],
                                                    time: i.touchStartTime
                                                }), i.velocities.push({
                                                    position: r[e.isHorizontal() ? "currentX" : "currentY"],
                                                    time: st.now()
                                                })), e.updateProgress(i.currentTranslate), e.setTranslate(i.currentTranslate))
                                            }
                                        }
                                    }
                                } else i.startMoving && i.isScrolling && e.emit("touchMoveOpposite", s)
                            }.bind(t), t.onTouchEnd = function(t) {
                                var e = this,
                                    i = e.touchEventsData,
                                    n = e.params,
                                    r = e.touches,
                                    a = e.rtlTranslate,
                                    s = e.$wrapperEl,
                                    o = e.slidesGrid,
                                    l = e.snapGrid,
                                    h = t;
                                if (h.originalEvent && (h = h.originalEvent), i.allowTouchCallbacks && e.emit("touchEnd", h), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && n.grabCursor && e.setGrabCursor(!1), i.isMoved = !1, void(i.startMoving = !1);
                                n.grabCursor && i.isMoved && i.isTouched && (!0 === e.allowSlideNext || !0 === e.allowSlidePrev) && e.setGrabCursor(!1);
                                var u, c, p, d, f, m = st.now(),
                                    g = m - i.touchStartTime;
                                if (e.allowClick && (e.updateClickedSlide(h), e.emit("tap click", h), g < 300 && m - i.lastClickTime < 300 && e.emit("doubleTap doubleClick", h)), i.lastClickTime = st.now(), st.nextTick(function() {
                                        e.destroyed || (e.allowClick = !0)
                                    }), !i.isTouched || !i.isMoved || !e.swipeDirection || 0 === r.diff || i.currentTranslate === i.startTranslate) return i.isTouched = !1, i.isMoved = !1, void(i.startMoving = !1);
                                if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, u = n.followFinger ? a ? e.translate : -e.translate : -i.currentTranslate, !n.cssMode)
                                    if (n.freeMode) {
                                        if (u < -e.minTranslate()) return void e.slideTo(e.activeIndex);
                                        if (u > -e.maxTranslate()) return void(e.slides.length < l.length ? e.slideTo(l.length - 1) : e.slideTo(e.slides.length - 1));
                                        if (n.freeModeMomentum) {
                                            1 < i.velocities.length ? (c = i.velocities.pop(), p = i.velocities.pop(), d = c.position - p.position, f = c.time - p.time, e.velocity = d / f, e.velocity /= 2, Math.abs(e.velocity) < n.freeModeMinimumVelocity && (e.velocity = 0), (150 < f || 300 < st.now() - c.time) && (e.velocity = 0)) : e.velocity = 0, e.velocity *= n.freeModeMomentumVelocityRatio, i.velocities.length = 0;
                                            var v = 1e3 * n.freeModeMomentumRatio,
                                                y = e.velocity * v,
                                                b = e.translate + y;
                                            a && (b = -b);
                                            var x, _, w, S, M = !1,
                                                T = 20 * Math.abs(e.velocity) * n.freeModeMomentumBounceRatio;
                                            if (b < e.maxTranslate()) n.freeModeMomentumBounce ? (b + e.maxTranslate() < -T && (b = e.maxTranslate() - T), x = e.maxTranslate(), M = !0, i.allowMomentumBounce = !0) : b = e.maxTranslate(), n.loop && n.centeredSlides && (_ = !0);
                                            else if (b > e.minTranslate()) n.freeModeMomentumBounce ? (b - e.minTranslate() > T && (b = e.minTranslate() + T), x = e.minTranslate(), M = !0, i.allowMomentumBounce = !0) : b = e.minTranslate(), n.loop && n.centeredSlides && (_ = !0);
                                            else if (n.freeModeSticky) {
                                                for (var C, A = 0; A < l.length; A += 1)
                                                    if (l[A] > -b) {
                                                        C = A;
                                                        break
                                                    }
                                                b = -(b = Math.abs(l[C] - b) < Math.abs(l[C - 1] - b) || "next" === e.swipeDirection ? l[C] : l[C - 1])
                                            }
                                            if (_ && e.once("transitionEnd", function() {
                                                    e.loopFix()
                                                }), 0 !== e.velocity) v = a ? Math.abs((-b - e.translate) / e.velocity) : Math.abs((b - e.translate) / e.velocity), n.freeModeSticky && (v = (w = Math.abs((a ? -b : b) - e.translate)) < (S = e.slidesSizesGrid[e.activeIndex]) ? n.speed : w < 2 * S ? 1.5 * n.speed : 2.5 * n.speed);
                                            else if (n.freeModeSticky) return void e.slideToClosest();
                                            n.freeModeMomentumBounce && M ? (e.updateProgress(x), e.setTransition(v), e.setTranslate(b), e.transitionStart(!0, e.swipeDirection), e.animating = !0, s.transitionEnd(function() {
                                                e && !e.destroyed && i.allowMomentumBounce && (e.emit("momentumBounce"), e.setTransition(n.speed), setTimeout(function() {
                                                    e.setTranslate(x), s.transitionEnd(function() {
                                                        e && !e.destroyed && e.transitionEnd()
                                                    })
                                                }, 0))
                                            })) : e.velocity ? (e.updateProgress(b), e.setTransition(v), e.setTranslate(b), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, s.transitionEnd(function() {
                                                e && !e.destroyed && e.transitionEnd()
                                            }))) : e.updateProgress(b), e.updateActiveIndex(), e.updateSlidesClasses()
                                        } else if (n.freeModeSticky) return void e.slideToClosest();
                                        (!n.freeModeMomentum || g >= n.longSwipesMs) && (e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses())
                                    } else {
                                        for (var E = 0, D = e.slidesSizesGrid[0], P = 0; P < o.length; P += P < n.slidesPerGroupSkip ? 1 : n.slidesPerGroup) {
                                            var L = P < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup;
                                            void 0 !== o[P + L] ? u >= o[P] && u < o[P + L] && (D = o[(E = P) + L] - o[P]) : u >= o[P] && (E = P, D = o[o.length - 1] - o[o.length - 2])
                                        }
                                        var k = (u - o[E]) / D,
                                            O = E < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup;
                                        if (g > n.longSwipesMs) {
                                            if (!n.longSwipes) return void e.slideTo(e.activeIndex);
                                            "next" === e.swipeDirection && (k >= n.longSwipesRatio ? e.slideTo(E + O) : e.slideTo(E)), "prev" === e.swipeDirection && (k > 1 - n.longSwipesRatio ? e.slideTo(E + O) : e.slideTo(E))
                                        } else {
                                            if (!n.shortSwipes) return void e.slideTo(e.activeIndex);
                                            e.navigation && (h.target === e.navigation.nextEl || h.target === e.navigation.prevEl) ? h.target === e.navigation.nextEl ? e.slideTo(E + O) : e.slideTo(E) : ("next" === e.swipeDirection && e.slideTo(E + O), "prev" === e.swipeDirection && e.slideTo(E))
                                        }
                                    }
                            }.bind(t), e.cssMode && (t.onScroll = function() {
                                var t = this,
                                    e = t.wrapperEl,
                                    i = t.rtlTranslate;
                                t.previousTranslate = t.translate, t.isHorizontal() ? t.translate = i ? e.scrollWidth - e.offsetWidth - e.scrollLeft : -e.scrollLeft : t.translate = -e.scrollTop, -0 === t.translate && (t.translate = 0), t.updateActiveIndex(), t.updateSlidesClasses();
                                var n = t.maxTranslate() - t.minTranslate();
                                (0 == n ? 0 : (t.translate - t.minTranslate()) / n) !== t.progress && t.updateProgress(i ? -t.translate : t.translate), t.emit("setTranslate", t.translate, !1)
                            }.bind(t)), t.onClick = function(t) {
                                this.allowClick || (this.params.preventClicks && t.preventDefault(), this.params.preventClicksPropagation && this.animating && (t.stopPropagation(), t.stopImmediatePropagation()))
                            }.bind(t);
                            var a, s = !!e.nested;
                            !C.touch && C.pointerEvents ? (n.addEventListener(i.start, t.onTouchStart, !1), b.addEventListener(i.move, t.onTouchMove, s), b.addEventListener(i.end, t.onTouchEnd, !1)) : (C.touch && (a = !("touchstart" !== i.start || !C.passiveListener || !e.passiveListeners) && {
                                passive: !0,
                                capture: !1
                            }, n.addEventListener(i.start, t.onTouchStart, a), n.addEventListener(i.move, t.onTouchMove, C.passiveListener ? {
                                passive: !1,
                                capture: s
                            } : s), n.addEventListener(i.end, t.onTouchEnd, a), i.cancel && n.addEventListener(i.cancel, t.onTouchEnd, a), I || (b.addEventListener("touchstart", N), I = !0)), (e.simulateTouch && !O.ios && !O.android || e.simulateTouch && !C.touch && O.ios) && (n.addEventListener("mousedown", t.onTouchStart, !1), b.addEventListener("mousemove", t.onTouchMove, s), b.addEventListener("mouseup", t.onTouchEnd, !1))), (e.preventClicks || e.preventClicksPropagation) && n.addEventListener("click", t.onClick, !0), e.cssMode && r.addEventListener("scroll", t.onScroll), e.updateOnWindowResize ? t.on(O.ios || O.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", F, !0) : t.on("observerUpdate", F, !0)
                        },
                        detachEvents: function() {
                            var t, e = this,
                                i = e.params,
                                n = e.touchEvents,
                                r = e.el,
                                a = e.wrapperEl,
                                s = !!i.nested;
                            !C.touch && C.pointerEvents ? (r.removeEventListener(n.start, e.onTouchStart, !1), b.removeEventListener(n.move, e.onTouchMove, s), b.removeEventListener(n.end, e.onTouchEnd, !1)) : (C.touch && (t = !("onTouchStart" !== n.start || !C.passiveListener || !i.passiveListeners) && {
                                passive: !0,
                                capture: !1
                            }, r.removeEventListener(n.start, e.onTouchStart, t), r.removeEventListener(n.move, e.onTouchMove, s), r.removeEventListener(n.end, e.onTouchEnd, t), n.cancel && r.removeEventListener(n.cancel, e.onTouchEnd, t)), (i.simulateTouch && !O.ios && !O.android || i.simulateTouch && !C.touch && O.ios) && (r.removeEventListener("mousedown", e.onTouchStart, !1), b.removeEventListener("mousemove", e.onTouchMove, s), b.removeEventListener("mouseup", e.onTouchEnd, !1))), (i.preventClicks || i.preventClicksPropagation) && r.removeEventListener("click", e.onClick, !0), i.cssMode && a.removeEventListener("scroll", e.onScroll), e.off(O.ios || O.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", F)
                        }
                    },
                    breakpoints: {
                        setBreakpoint: function() {
                            var t = this,
                                e = t.activeIndex,
                                i = t.initialized,
                                n = t.loopedSlides;
                            void 0 === n && (n = 0);
                            var r, a, s, o, l, h, u, c = t.params,
                                p = t.$el,
                                d = c.breakpoints;
                            !d || d && 0 === Object.keys(d).length || (r = t.getBreakpoint(d)) && t.currentBreakpoint !== r && ((a = r in d ? d[r] : void 0) && ["slidesPerView", "spaceBetween", "slidesPerGroup", "slidesPerGroupSkip", "slidesPerColumn"].forEach(function(t) {
                                var e = a[t];
                                void 0 !== e && (a[t] = "slidesPerView" !== t || "AUTO" !== e && "auto" !== e ? "slidesPerView" === t ? parseFloat(e) : parseInt(e, 10) : "auto")
                            }), s = a || t.originalParams, o = 1 < c.slidesPerColumn, l = 1 < s.slidesPerColumn, o && !l ? p.removeClass(c.containerModifierClass + "multirow " + c.containerModifierClass + "multirow-column") : !o && l && (p.addClass(c.containerModifierClass + "multirow"), "column" === s.slidesPerColumnFill && p.addClass(c.containerModifierClass + "multirow-column")), h = s.direction && s.direction !== c.direction, u = c.loop && (s.slidesPerView !== c.slidesPerView || h), h && i && t.changeDirection(), st.extend(t.params, s), st.extend(t, {
                                allowTouchMove: t.params.allowTouchMove,
                                allowSlideNext: t.params.allowSlideNext,
                                allowSlidePrev: t.params.allowSlidePrev
                            }), t.currentBreakpoint = r, u && i && (t.loopDestroy(), t.loopCreate(), t.updateSlides(), t.slideTo(e - n + t.loopedSlides, 0, !1)), t.emit("breakpoint", s))
                        },
                        getBreakpoint: function(t) {
                            if (t) {
                                var e = !1,
                                    i = Object.keys(t).map(function(t) {
                                        if ("string" != typeof t || 0 !== t.indexOf("@")) return {
                                            value: t,
                                            point: t
                                        };
                                        var e = parseFloat(t.substr(1));
                                        return {
                                            value: at.innerHeight * e,
                                            point: t
                                        }
                                    });
                                i.sort(function(t, e) {
                                    return parseInt(t.value, 10) - parseInt(e.value, 10)
                                });
                                for (var n = 0; n < i.length; n += 1) {
                                    var r = i[n],
                                        a = r.point;
                                    r.value <= at.innerWidth && (e = a)
                                }
                                return e || "max"
                            }
                        }
                    },
                    checkOverflow: {
                        checkOverflow: function() {
                            var t = this,
                                e = t.params,
                                i = t.isLocked,
                                n = 0 < t.slides.length && e.slidesOffsetBefore + e.spaceBetween * (t.slides.length - 1) + t.slides[0].offsetWidth * t.slides.length;
                            e.slidesOffsetBefore && e.slidesOffsetAfter && n ? t.isLocked = n <= t.size : t.isLocked = 1 === t.snapGrid.length, t.allowSlideNext = !t.isLocked, t.allowSlidePrev = !t.isLocked, i !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock"), i && i !== t.isLocked && (t.isEnd = !1, t.navigation && t.navigation.update())
                        }
                    },
                    classes: {
                        addClasses: function() {
                            var e = this.classNames,
                                i = this.params,
                                t = this.rtl,
                                n = this.$el,
                                r = [];
                            r.push("initialized"), r.push(i.direction), i.freeMode && r.push("free-mode"), i.autoHeight && r.push("autoheight"), t && r.push("rtl"), 1 < i.slidesPerColumn && (r.push("multirow"), "column" === i.slidesPerColumnFill && r.push("multirow-column")), O.android && r.push("android"), O.ios && r.push("ios"), i.cssMode && r.push("css-mode"), r.forEach(function(t) {
                                e.push(i.containerModifierClass + t)
                            }), n.addClass(e.join(" "))
                        },
                        removeClasses: function() {
                            var t = this.$el,
                                e = this.classNames;
                            t.removeClass(e.join(" "))
                        }
                    },
                    images: {
                        loadImage: function(t, e, i, n, r, a) {
                            var s;

                            function o() {
                                a && a()
                            }!(L(t).parent("picture")[0] || t.complete && r) && e ? ((s = new at.Image).onload = o, s.onerror = o, n && (s.sizes = n), i && (s.srcset = i), e && (s.src = e)) : o()
                        },
                        preloadImages: function() {
                            var t = this;

                            function e() {
                                null != t && t && !t.destroyed && (void 0 !== t.imagesLoaded && (t.imagesLoaded += 1), t.imagesLoaded === t.imagesToLoad.length && (t.params.updateOnImagesReady && t.update(), t.emit("imagesReady")))
                            }
                            t.imagesToLoad = t.$el.find("img");
                            for (var i = 0; i < t.imagesToLoad.length; i += 1) {
                                var n = t.imagesToLoad[i];
                                t.loadImage(n, n.currentSrc || n.getAttribute("src"), n.srcset || n.getAttribute("srcset"), n.sizes || n.getAttribute("sizes"), !0, e)
                            }
                        }
                    }
                },
                G = {},
                V = function(c) {
                    function p() {
                        for (var r, t = [], e = arguments.length; e--;) t[e] = arguments[e];
                        r = (r = 1 === t.length && t[0].constructor && t[0].constructor === Object ? t[0] : (n = t[0], t[1])) || {}, r = st.extend({}, r), n && !r.el && (r.el = n), c.call(this, r), Object.keys(z).forEach(function(e) {
                            Object.keys(z[e]).forEach(function(t) {
                                p.prototype[t] || (p.prototype[t] = z[e][t])
                            })
                        });
                        var a = this;
                        void 0 === a.modules && (a.modules = {}), Object.keys(a.modules).forEach(function(t) {
                            var e = a.modules[t];
                            if (e.params) {
                                var i = Object.keys(e.params)[0],
                                    n = e.params[i];
                                if ("object" !== bt(n) || null === n) return;
                                if (!(i in r && "enabled" in n)) return;
                                !0 === r[i] && (r[i] = {
                                    enabled: !0
                                }), "object" !== bt(r[i]) || "enabled" in r[i] || (r[i].enabled = !0), r[i] || (r[i] = {
                                    enabled: !1
                                })
                            }
                        });
                        var i = st.extend({}, R);
                        a.useModulesParams(i), a.params = st.extend({}, i, G, r), a.originalParams = st.extend({}, a.params), a.passedParams = st.extend({}, r);
                        var n, s, o, l, h = (a.$ = L)(a.params.el);
                        if (n = h[0]) {
                            if (1 < h.length) {
                                var u = [];
                                return h.each(function(t, e) {
                                    var i = st.extend({}, r, {
                                        el: e
                                    });
                                    u.push(new p(i))
                                }), u
                            }
                            return n.swiper = a, h.data("swiper", a), n && n.shadowRoot && n.shadowRoot.querySelector ? (s = L(n.shadowRoot.querySelector("." + a.params.wrapperClass))).children = function(t) {
                                return h.children(t)
                            } : s = h.children("." + a.params.wrapperClass), st.extend(a, {
                                $el: h,
                                el: n,
                                $wrapperEl: s,
                                wrapperEl: s[0],
                                classNames: [],
                                slides: L(),
                                slidesGrid: [],
                                snapGrid: [],
                                slidesSizesGrid: [],
                                isHorizontal: function() {
                                    return "horizontal" === a.params.direction
                                },
                                isVertical: function() {
                                    return "vertical" === a.params.direction
                                },
                                rtl: "rtl" === n.dir.toLowerCase() || "rtl" === h.css("direction"),
                                rtlTranslate: "horizontal" === a.params.direction && ("rtl" === n.dir.toLowerCase() || "rtl" === h.css("direction")),
                                wrongRTL: "-webkit-box" === s.css("display"),
                                activeIndex: 0,
                                realIndex: 0,
                                isBeginning: !0,
                                isEnd: !1,
                                translate: 0,
                                previousTranslate: 0,
                                progress: 0,
                                velocity: 0,
                                animating: !1,
                                allowSlideNext: a.params.allowSlideNext,
                                allowSlidePrev: a.params.allowSlidePrev,
                                touchEvents: (o = ["touchstart", "touchmove", "touchend", "touchcancel"], l = ["mousedown", "mousemove", "mouseup"], C.pointerEvents && (l = ["pointerdown", "pointermove", "pointerup"]), a.touchEventsTouch = {
                                    start: o[0],
                                    move: o[1],
                                    end: o[2],
                                    cancel: o[3]
                                }, a.touchEventsDesktop = {
                                    start: l[0],
                                    move: l[1],
                                    end: l[2]
                                }, C.touch || !a.params.simulateTouch ? a.touchEventsTouch : a.touchEventsDesktop),
                                touchEventsData: {
                                    isTouched: void 0,
                                    isMoved: void 0,
                                    allowTouchCallbacks: void 0,
                                    touchStartTime: void 0,
                                    isScrolling: void 0,
                                    currentTranslate: void 0,
                                    startTranslate: void 0,
                                    allowThresholdMove: void 0,
                                    formElements: "input, select, option, textarea, button, video, label",
                                    lastClickTime: st.now(),
                                    clickTimeout: void 0,
                                    velocities: [],
                                    allowMomentumBounce: void 0,
                                    isTouchEvent: void 0,
                                    startMoving: void 0
                                },
                                allowClick: !0,
                                allowTouchMove: a.params.allowTouchMove,
                                touches: {
                                    startX: 0,
                                    startY: 0,
                                    currentX: 0,
                                    currentY: 0,
                                    diff: 0
                                },
                                imagesToLoad: [],
                                imagesLoaded: 0
                            }), a.useModules(), a.params.init && a.init(), a
                        }
                    }
                    c && (p.__proto__ = c), p.prototype = Object.create(c && c.prototype);
                    var t = {
                        extendedDefaults: {
                            configurable: !0
                        },
                        defaults: {
                            configurable: !0
                        },
                        Class: {
                            configurable: !0
                        },
                        $: {
                            configurable: !0
                        }
                    };
                    return (p.prototype.constructor = p).prototype.slidesPerViewDynamic = function() {
                        var t = this.params,
                            e = this.slides,
                            i = this.slidesGrid,
                            n = this.size,
                            r = this.activeIndex,
                            a = 1;
                        if (t.centeredSlides) {
                            for (var s, o = e[r].swiperSlideSize, l = r + 1; l < e.length; l += 1) e[l] && !s && (a += 1, n < (o += e[l].swiperSlideSize) && (s = !0));
                            for (var h = r - 1; 0 <= h; --h) e[h] && !s && (a += 1, n < (o += e[h].swiperSlideSize) && (s = !0))
                        } else
                            for (var u = r + 1; u < e.length; u += 1) i[u] - i[r] < n && (a += 1);
                        return a
                    }, p.prototype.update = function() {
                        var t, e, i = this;

                        function n() {
                            var t = i.rtlTranslate ? -1 * i.translate : i.translate,
                                e = Math.min(Math.max(t, i.maxTranslate()), i.minTranslate());
                            i.setTranslate(e), i.updateActiveIndex(), i.updateSlidesClasses()
                        }
                        i && !i.destroyed && (t = i.snapGrid, (e = i.params).breakpoints && i.setBreakpoint(), i.updateSize(), i.updateSlides(), i.updateProgress(), i.updateSlidesClasses(), i.params.freeMode ? (n(), i.params.autoHeight && i.updateAutoHeight()) : (("auto" === i.params.slidesPerView || 1 < i.params.slidesPerView) && i.isEnd && !i.params.centeredSlides ? i.slideTo(i.slides.length - 1, 0, !1, !0) : i.slideTo(i.activeIndex, 0, !1, !0)) || n(), e.watchOverflow && t !== i.snapGrid && i.checkOverflow(), i.emit("update"))
                    }, p.prototype.changeDirection = function(i, t) {
                        void 0 === t && (t = !0);
                        var e = this,
                            n = e.params.direction;
                        return (i = i || ("horizontal" === n ? "vertical" : "horizontal")) === n || "horizontal" !== i && "vertical" !== i || (e.$el.removeClass("" + e.params.containerModifierClass + n).addClass("" + e.params.containerModifierClass + i), e.params.direction = i, e.slides.each(function(t, e) {
                            "vertical" === i ? e.style.width = "" : e.style.height = ""
                        }), e.emit("changeDirection"), t && e.update()), e
                    }, p.prototype.init = function() {
                        var t = this;
                        t.initialized || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit), t.attachEvents(), t.initialized = !0, t.emit("init"))
                    }, p.prototype.destroy = function(t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = !0);
                        var i = this,
                            n = i.params,
                            r = i.$el,
                            a = i.$wrapperEl,
                            s = i.slides;
                        return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), n.loop && i.loopDestroy(), e && (i.removeClasses(), r.removeAttr("style"), a.removeAttr("style"), s && s.length && s.removeClass([n.slideVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(function(t) {
                            i.off(t)
                        }), !1 !== t && (i.$el[0].swiper = null, i.$el.data("swiper", null), st.deleteProps(i)), i.destroyed = !0), null
                    }, p.extendDefaults = function(t) {
                        st.extend(G, t)
                    }, t.extendedDefaults.get = function() {
                        return G
                    }, t.defaults.get = function() {
                        return R
                    }, t.Class.get = function() {
                        return c
                    }, t.$.get = function() {
                        return L
                    }, Object.defineProperties(p, t), p
                }(i),
                U = {
                    name: "device",
                    proto: {
                        device: O
                    },
                    static: {
                        device: O
                    }
                },
                j = {
                    name: "support",
                    proto: {
                        support: C
                    },
                    static: {
                        support: C
                    }
                },
                H = {
                    isEdge: !!at.navigator.userAgent.match(/Edge/g),
                    isSafari: 0 <= (B = at.navigator.userAgent.toLowerCase()).indexOf("safari") && B.indexOf("chrome") < 0 && B.indexOf("android") < 0,
                    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(at.navigator.userAgent)
                },
                W = {
                    name: "browser",
                    proto: {
                        browser: H
                    },
                    static: {
                        browser: H
                    }
                },
                q = {
                    name: "resize",
                    create: function() {
                        var t = this;
                        st.extend(t, {
                            resize: {
                                resizeHandler: function() {
                                    t && !t.destroyed && t.initialized && (t.emit("beforeResize"), t.emit("resize"))
                                },
                                orientationChangeHandler: function() {
                                    t && !t.destroyed && t.initialized && t.emit("orientationchange")
                                }
                            }
                        })
                    },
                    on: {
                        init: function() {
                            at.addEventListener("resize", this.resize.resizeHandler), at.addEventListener("orientationchange", this.resize.orientationChangeHandler)
                        },
                        destroy: function() {
                            at.removeEventListener("resize", this.resize.resizeHandler), at.removeEventListener("orientationchange", this.resize.orientationChangeHandler)
                        }
                    }
                },
                X = {
                    func: at.MutationObserver || at.WebkitMutationObserver,
                    attach: function(t, e) {
                        void 0 === e && (e = {});
                        var i = this,
                            n = new X.func(function(t) {
                                var e;
                                1 !== t.length ? (e = function() {
                                    i.emit("observerUpdate", t[0])
                                }, at.requestAnimationFrame ? at.requestAnimationFrame(e) : at.setTimeout(e, 0)) : i.emit("observerUpdate", t[0])
                            });
                        n.observe(t, {
                            attributes: void 0 === e.attributes || e.attributes,
                            childList: void 0 === e.childList || e.childList,
                            characterData: void 0 === e.characterData || e.characterData
                        }), i.observer.observers.push(n)
                    },
                    init: function() {
                        if (C.observer && this.params.observer) {
                            if (this.params.observeParents)
                                for (var t = this.$el.parents(), e = 0; e < t.length; e += 1) this.observer.attach(t[e]);
                            this.observer.attach(this.$el[0], {
                                childList: this.params.observeSlideChildren
                            }), this.observer.attach(this.$wrapperEl[0], {
                                attributes: !1
                            })
                        }
                    },
                    destroy: function() {
                        this.observer.observers.forEach(function(t) {
                            t.disconnect()
                        }), this.observer.observers = []
                    }
                },
                Y = {
                    name: "observer",
                    params: {
                        observer: !1,
                        observeParents: !1,
                        observeSlideChildren: !1
                    },
                    create: function() {
                        st.extend(this, {
                            observer: {
                                init: X.init.bind(this),
                                attach: X.attach.bind(this),
                                destroy: X.destroy.bind(this),
                                observers: []
                            }
                        })
                    },
                    on: {
                        init: function() {
                            this.observer.init()
                        },
                        destroy: function() {
                            this.observer.destroy()
                        }
                    }
                },
                J = {
                    update: function(t) {
                        var e = this,
                            i = e.params,
                            n = i.slidesPerView,
                            r = i.slidesPerGroup,
                            a = i.centeredSlides,
                            s = e.params.virtual,
                            o = s.addSlidesBefore,
                            l = s.addSlidesAfter,
                            h = e.virtual,
                            u = h.from,
                            c = h.to,
                            p = h.slides,
                            d = h.slidesGrid,
                            f = h.renderSlide,
                            m = h.offset;
                        e.updateActiveIndex();
                        var g, v = e.activeIndex || 0,
                            y = e.rtlTranslate ? "right" : e.isHorizontal() ? "left" : "top",
                            b = a ? (g = Math.floor(n / 2) + r + o, Math.floor(n / 2) + r + l) : (g = n + (r - 1) + o, r + l),
                            x = Math.max((v || 0) - b, 0),
                            _ = Math.min((v || 0) + g, p.length - 1),
                            w = (e.slidesGrid[x] || 0) - (e.slidesGrid[0] || 0);

                        function S() {
                            e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.lazy && e.params.lazy.enabled && e.lazy.load()
                        }
                        if (st.extend(e.virtual, {
                                from: x,
                                to: _,
                                offset: w,
                                slidesGrid: e.slidesGrid
                            }), u === x && c === _ && !t) return e.slidesGrid !== d && w !== m && e.slides.css(y, w + "px"), void e.updateProgress();
                        if (e.params.virtual.renderExternal) return e.params.virtual.renderExternal.call(e, {
                            offset: w,
                            from: x,
                            to: _,
                            slides: function() {
                                for (var t = [], e = x; e <= _; e += 1) t.push(p[e]);
                                return t
                            }()
                        }), void S();
                        var M = [],
                            T = [];
                        if (t) e.$wrapperEl.find("." + e.params.slideClass).remove();
                        else
                            for (var C = u; C <= c; C += 1)(C < x || _ < C) && e.$wrapperEl.find("." + e.params.slideClass + '[data-swiper-slide-index="' + C + '"]').remove();
                        for (var A = 0; A < p.length; A += 1) x <= A && A <= _ && (void 0 === c || t ? T.push(A) : (c < A && T.push(A), A < u && M.push(A)));
                        T.forEach(function(t) {
                            e.$wrapperEl.append(f(p[t], t))
                        }), M.sort(function(t, e) {
                            return e - t
                        }).forEach(function(t) {
                            e.$wrapperEl.prepend(f(p[t], t))
                        }), e.$wrapperEl.children(".swiper-slide").css(y, w + "px"), S()
                    },
                    renderSlide: function(t, e) {
                        var i = this.params.virtual;
                        if (i.cache && this.virtual.cache[e]) return this.virtual.cache[e];
                        var n = i.renderSlide ? L(i.renderSlide.call(this, t, e)) : L('<div class="' + this.params.slideClass + '" data-swiper-slide-index="' + e + '">' + t + "</div>");
                        return n.attr("data-swiper-slide-index") || n.attr("data-swiper-slide-index", e), i.cache && (this.virtual.cache[e] = n), n
                    },
                    appendSlide: function(t) {
                        if ("object" === bt(t) && "length" in t)
                            for (var e = 0; e < t.length; e += 1) t[e] && this.virtual.slides.push(t[e]);
                        else this.virtual.slides.push(t);
                        this.virtual.update(!0)
                    },
                    prependSlide: function(t) {
                        var n, r, e = this.activeIndex,
                            i = e + 1,
                            a = 1;
                        if (Array.isArray(t)) {
                            for (var s = 0; s < t.length; s += 1) t[s] && this.virtual.slides.unshift(t[s]);
                            i = e + t.length, a = t.length
                        } else this.virtual.slides.unshift(t);
                        this.params.virtual.cache && (n = this.virtual.cache, r = {}, Object.keys(n).forEach(function(t) {
                            var e = n[t],
                                i = e.attr("data-swiper-slide-index");
                            i && e.attr("data-swiper-slide-index", parseInt(i, 10) + 1), r[parseInt(t, 10) + a] = e
                        }), this.virtual.cache = r), this.virtual.update(!0), this.slideTo(i, 0)
                    },
                    removeSlide: function(t) {
                        if (null != t) {
                            var e = this.activeIndex;
                            if (Array.isArray(t))
                                for (var i = t.length - 1; 0 <= i; --i) this.virtual.slides.splice(t[i], 1), this.params.virtual.cache && delete this.virtual.cache[t[i]], t[i] < e && --e, e = Math.max(e, 0);
                            else this.virtual.slides.splice(t, 1), this.params.virtual.cache && delete this.virtual.cache[t], t < e && --e, e = Math.max(e, 0);
                            this.virtual.update(!0), this.slideTo(e, 0)
                        }
                    },
                    removeAllSlides: function() {
                        this.virtual.slides = [], this.params.virtual.cache && (this.virtual.cache = {}), this.virtual.update(!0), this.slideTo(0, 0)
                    }
                },
                Z = {
                    name: "virtual",
                    params: {
                        virtual: {
                            enabled: !1,
                            slides: [],
                            cache: !0,
                            renderSlide: null,
                            renderExternal: null,
                            addSlidesBefore: 0,
                            addSlidesAfter: 0
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            virtual: {
                                update: J.update.bind(this),
                                appendSlide: J.appendSlide.bind(this),
                                prependSlide: J.prependSlide.bind(this),
                                removeSlide: J.removeSlide.bind(this),
                                removeAllSlides: J.removeAllSlides.bind(this),
                                renderSlide: J.renderSlide.bind(this),
                                slides: this.params.virtual.slides,
                                cache: {}
                            }
                        })
                    },
                    on: {
                        beforeInit: function() {
                            var t;
                            this.params.virtual.enabled && (this.classNames.push(this.params.containerModifierClass + "virtual"), t = {
                                watchSlidesProgress: !0
                            }, st.extend(this.params, t), st.extend(this.originalParams, t), this.params.initialSlide || this.virtual.update())
                        },
                        setTranslate: function() {
                            this.params.virtual.enabled && this.virtual.update()
                        }
                    }
                },
                $ = {
                    handle: function(t) {
                        var e = this,
                            i = e.rtlTranslate,
                            n = t;
                        n.originalEvent && (n = n.originalEvent);
                        var r = n.keyCode || n.charCode,
                            a = e.params.keyboard.pageUpDown,
                            s = a && 33 === r,
                            o = a && 34 === r,
                            l = 37 === r,
                            h = 39 === r,
                            u = 38 === r,
                            c = 40 === r;
                        if (!e.allowSlideNext && (e.isHorizontal() && h || e.isVertical() && c || o)) return !1;
                        if (!e.allowSlidePrev && (e.isHorizontal() && l || e.isVertical() && u || s)) return !1;
                        if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey || b.activeElement && b.activeElement.nodeName && ("input" === b.activeElement.nodeName.toLowerCase() || "textarea" === b.activeElement.nodeName.toLowerCase()))) {
                            if (e.params.keyboard.onlyInViewport && (s || o || l || h || u || c)) {
                                var p = !1;
                                if (0 < e.$el.parents("." + e.params.slideClass).length && 0 === e.$el.parents("." + e.params.slideActiveClass).length) return;
                                var d = at.innerWidth,
                                    f = at.innerHeight,
                                    m = e.$el.offset();
                                i && (m.left -= e.$el[0].scrollLeft);
                                for (var g = [
                                        [m.left, m.top],
                                        [m.left + e.width, m.top],
                                        [m.left, m.top + e.height],
                                        [m.left + e.width, m.top + e.height]
                                    ], v = 0; v < g.length; v += 1) {
                                    var y = g[v];
                                    0 <= y[0] && y[0] <= d && 0 <= y[1] && y[1] <= f && (p = !0)
                                }
                                if (!p) return
                            }
                            e.isHorizontal() ? ((s || o || l || h) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), ((o || h) && !i || (s || l) && i) && e.slideNext(), ((s || l) && !i || (o || h) && i) && e.slidePrev()) : ((s || o || u || c) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (o || c) && e.slideNext(), (s || u) && e.slidePrev()), e.emit("keyPress", r)
                        }
                    },
                    enable: function() {
                        this.keyboard.enabled || (L(b).on("keydown", this.keyboard.handle), this.keyboard.enabled = !0)
                    },
                    disable: function() {
                        this.keyboard.enabled && (L(b).off("keydown", this.keyboard.handle), this.keyboard.enabled = !1)
                    }
                },
                K = {
                    name: "keyboard",
                    params: {
                        keyboard: {
                            enabled: !1,
                            onlyInViewport: !0,
                            pageUpDown: !0
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            keyboard: {
                                enabled: !1,
                                enable: $.enable.bind(this),
                                disable: $.disable.bind(this),
                                handle: $.handle.bind(this)
                            }
                        })
                    },
                    on: {
                        init: function() {
                            this.params.keyboard.enabled && this.keyboard.enable()
                        },
                        destroy: function() {
                            this.keyboard.enabled && this.keyboard.disable()
                        }
                    }
                };
            var Q = {
                    lastScrollTime: st.now(),
                    lastEventBeforeSnap: void 0,
                    recentWheelEvents: [],
                    event: function() {
                        return -1 < at.navigator.userAgent.indexOf("firefox") ? "DOMMouseScroll" : ((i = (e = "onwheel") in b) || ((t = b.createElement("div")).setAttribute(e, "return;"), i = "function" == typeof t[e]), !i && b.implementation && b.implementation.hasFeature && !0 !== b.implementation.hasFeature("", "") && (i = b.implementation.hasFeature("Events.wheel", "3.0")), i ? "wheel" : "mousewheel");
                        var t, e, i
                    },
                    normalize: function(t) {
                        var e = 0,
                            i = 0,
                            n = 0,
                            r = 0;
                        return "detail" in t && (i = t.detail), "wheelDelta" in t && (i = -t.wheelDelta / 120), "wheelDeltaY" in t && (i = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = i, i = 0), n = 10 * e, r = 10 * i, "deltaY" in t && (r = t.deltaY), "deltaX" in t && (n = t.deltaX), t.shiftKey && !n && (n = r, r = 0), (n || r) && t.deltaMode && (1 === t.deltaMode ? (n *= 40, r *= 40) : (n *= 800, r *= 800)), n && !e && (e = n < 1 ? -1 : 1), r && !i && (i = r < 1 ? -1 : 1), {
                            spinX: e,
                            spinY: i,
                            pixelX: n,
                            pixelY: r
                        }
                    },
                    handleMouseEnter: function() {
                        this.mouseEntered = !0
                    },
                    handleMouseLeave: function() {
                        this.mouseEntered = !1
                    },
                    handle: function(t) {
                        var e = t,
                            i = this,
                            n = i.params.mousewheel;
                        i.params.cssMode && e.preventDefault();
                        var r = i.$el;
                        if ("container" !== i.params.mousewheel.eventsTarged && (r = L(i.params.mousewheel.eventsTarged)), !i.mouseEntered && !r[0].contains(e.target) && !n.releaseOnEdges) return !0;
                        e.originalEvent && (e = e.originalEvent);
                        var a = 0,
                            s = i.rtlTranslate ? -1 : 1,
                            o = Q.normalize(e);
                        if (n.forceToAxis)
                            if (i.isHorizontal()) {
                                if (!(Math.abs(o.pixelX) > Math.abs(o.pixelY))) return !0;
                                a = -o.pixelX * s
                            } else {
                                if (!(Math.abs(o.pixelY) > Math.abs(o.pixelX))) return !0;
                                a = -o.pixelY
                            }
                        else a = Math.abs(o.pixelX) > Math.abs(o.pixelY) ? -o.pixelX * s : -o.pixelY;
                        if (0 === a) return !0;
                        if (n.invert && (a = -a), i.params.freeMode) {
                            var l = {
                                    time: st.now(),
                                    delta: Math.abs(a),
                                    direction: Math.sign(a)
                                },
                                h = i.mousewheel.lastEventBeforeSnap,
                                u = h && l.time < h.time + 500 && l.delta <= h.delta && l.direction === h.direction;
                            if (!u) {
                                i.mousewheel.lastEventBeforeSnap = void 0, i.params.loop && i.loopFix();
                                var c, p, d, f, m = i.getTranslate() + a * n.sensitivity,
                                    g = i.isBeginning,
                                    v = i.isEnd;
                                if (m >= i.minTranslate() && (m = i.minTranslate()), m <= i.maxTranslate() && (m = i.maxTranslate()), i.setTransition(0), i.setTranslate(m), i.updateProgress(), i.updateActiveIndex(), i.updateSlidesClasses(), (!g && i.isBeginning || !v && i.isEnd) && i.updateSlidesClasses(), i.params.freeModeSticky && (clearTimeout(i.mousewheel.timeout), i.mousewheel.timeout = void 0, 15 <= (c = i.mousewheel.recentWheelEvents).length && c.shift(), p = c.length ? c[c.length - 1] : void 0, d = c[0], c.push(l), p && (l.delta > p.delta || l.direction !== p.direction) ? c.splice(0) : 15 <= c.length && l.time - d.time < 500 && 1 <= d.delta - l.delta && l.delta <= 6 && (f = 0 < a ? .8 : .2, i.mousewheel.lastEventBeforeSnap = l, c.splice(0), i.mousewheel.timeout = st.nextTick(function() {
                                        i.slideToClosest(i.params.speed, !0, void 0, f)
                                    }, 0)), i.mousewheel.timeout || (i.mousewheel.timeout = st.nextTick(function() {
                                        i.mousewheel.lastEventBeforeSnap = l, c.splice(0), i.slideToClosest(i.params.speed, !0, void 0, .5)
                                    }, 500))), u || i.emit("scroll", e), i.params.autoplay && i.params.autoplayDisableOnInteraction && i.autoplay.stop(), m === i.minTranslate() || m === i.maxTranslate()) return !0
                            }
                        } else {
                            var y = {
                                    time: st.now(),
                                    delta: Math.abs(a),
                                    direction: Math.sign(a),
                                    raw: t
                                },
                                b = i.mousewheel.recentWheelEvents;
                            2 <= b.length && b.shift();
                            var x = b.length ? b[b.length - 1] : void 0;
                            if (b.push(y), (!x || y.direction !== x.direction || y.delta > x.delta || y.time > x.time + 150) && i.mousewheel.animateSlider(y), i.mousewheel.releaseScroll(y)) return !0
                        }
                        return e.preventDefault ? e.preventDefault() : e.returnValue = !1, !1
                    },
                    animateSlider: function(t) {
                        var e = this;
                        return 6 <= t.delta && st.now() - e.mousewheel.lastScrollTime < 60 || (t.direction < 0 ? e.isEnd && !e.params.loop || e.animating || (e.slideNext(), e.emit("scroll", t.raw)) : e.isBeginning && !e.params.loop || e.animating || (e.slidePrev(), e.emit("scroll", t.raw)), e.mousewheel.lastScrollTime = (new at.Date).getTime(), !1)
                    },
                    releaseScroll: function(t) {
                        var e = this.params.mousewheel;
                        if (t.direction < 0) {
                            if (this.isEnd && !this.params.loop && e.releaseOnEdges) return !0
                        } else if (this.isBeginning && !this.params.loop && e.releaseOnEdges) return !0;
                        return !1
                    },
                    enable: function() {
                        var t = this,
                            e = Q.event();
                        if (t.params.cssMode) return t.wrapperEl.removeEventListener(e, t.mousewheel.handle), !0;
                        if (!e) return !1;
                        if (t.mousewheel.enabled) return !1;
                        var i = t.$el;
                        return "container" !== t.params.mousewheel.eventsTarged && (i = L(t.params.mousewheel.eventsTarged)), i.on("mouseenter", t.mousewheel.handleMouseEnter), i.on("mouseleave", t.mousewheel.handleMouseLeave), i.on(e, t.mousewheel.handle), t.mousewheel.enabled = !0
                    },
                    disable: function() {
                        var t = Q.event();
                        if (this.params.cssMode) return this.wrapperEl.addEventListener(t, this.mousewheel.handle), !0;
                        if (!t) return !1;
                        if (!this.mousewheel.enabled) return !1;
                        var e = this.$el;
                        return "container" !== this.params.mousewheel.eventsTarged && (e = L(this.params.mousewheel.eventsTarged)), e.off(t, this.mousewheel.handle), !(this.mousewheel.enabled = !1)
                    }
                },
                tt = {
                    update: function() {
                        var t, e, i, n = this.params.navigation;
                        this.params.loop || (e = (t = this.navigation).$nextEl, (i = t.$prevEl) && 0 < i.length && (this.isBeginning ? i.addClass(n.disabledClass) : i.removeClass(n.disabledClass), i[this.params.watchOverflow && this.isLocked ? "addClass" : "removeClass"](n.lockClass)), e && 0 < e.length && (this.isEnd ? e.addClass(n.disabledClass) : e.removeClass(n.disabledClass), e[this.params.watchOverflow && this.isLocked ? "addClass" : "removeClass"](n.lockClass)))
                    },
                    onPrevClick: function(t) {
                        t.preventDefault(), this.isBeginning && !this.params.loop || this.slidePrev()
                    },
                    onNextClick: function(t) {
                        t.preventDefault(), this.isEnd && !this.params.loop || this.slideNext()
                    },
                    init: function() {
                        var t, e, i = this,
                            n = i.params.navigation;
                        (n.nextEl || n.prevEl) && (n.nextEl && (t = L(n.nextEl), i.params.uniqueNavElements && "string" == typeof n.nextEl && 1 < t.length && 1 === i.$el.find(n.nextEl).length && (t = i.$el.find(n.nextEl))), n.prevEl && (e = L(n.prevEl), i.params.uniqueNavElements && "string" == typeof n.prevEl && 1 < e.length && 1 === i.$el.find(n.prevEl).length && (e = i.$el.find(n.prevEl))), t && 0 < t.length && t.on("click", i.navigation.onNextClick), e && 0 < e.length && e.on("click", i.navigation.onPrevClick), st.extend(i.navigation, {
                            $nextEl: t,
                            nextEl: t && t[0],
                            $prevEl: e,
                            prevEl: e && e[0]
                        }))
                    },
                    destroy: function() {
                        var t = this.navigation,
                            e = t.$nextEl,
                            i = t.$prevEl;
                        e && e.length && (e.off("click", this.navigation.onNextClick), e.removeClass(this.params.navigation.disabledClass)), i && i.length && (i.off("click", this.navigation.onPrevClick), i.removeClass(this.params.navigation.disabledClass))
                    }
                },
                et = {
                    update: function() {
                        var t = this,
                            e = t.rtl,
                            r = t.params.pagination;
                        if (r.el && t.pagination.el && t.pagination.$el && 0 !== t.pagination.$el.length) {
                            var a, i, n, s, o, l = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                                h = t.pagination.$el,
                                u = t.params.loop ? Math.ceil((l - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;
                            if (t.params.loop ? ((a = Math.ceil((t.activeIndex - t.loopedSlides) / t.params.slidesPerGroup)) > l - 1 - 2 * t.loopedSlides && (a -= l - 2 * t.loopedSlides), u - 1 < a && (a -= u), a < 0 && "bullets" !== t.params.paginationType && (a = u + a)) : a = void 0 !== t.snapIndex ? t.snapIndex : t.activeIndex || 0, "bullets" === r.type && t.pagination.bullets && 0 < t.pagination.bullets.length) {
                                var c, p, d, f, m, g, v = t.pagination.bullets;
                                if (r.dynamicBullets && (t.pagination.bulletSize = v.eq(0)[t.isHorizontal() ? "outerWidth" : "outerHeight"](!0), h.css(t.isHorizontal() ? "width" : "height", t.pagination.bulletSize * (r.dynamicMainBullets + 4) + "px"), 1 < r.dynamicMainBullets && void 0 !== t.previousIndex && (t.pagination.dynamicBulletIndex += a - t.previousIndex, t.pagination.dynamicBulletIndex > r.dynamicMainBullets - 1 ? t.pagination.dynamicBulletIndex = r.dynamicMainBullets - 1 : t.pagination.dynamicBulletIndex < 0 && (t.pagination.dynamicBulletIndex = 0)), c = a - t.pagination.dynamicBulletIndex, d = ((p = c + (Math.min(v.length, r.dynamicMainBullets) - 1)) + c) / 2), v.removeClass(r.bulletActiveClass + " " + r.bulletActiveClass + "-next " + r.bulletActiveClass + "-next-next " + r.bulletActiveClass + "-prev " + r.bulletActiveClass + "-prev-prev " + r.bulletActiveClass + "-main"), 1 < h.length) v.each(function(t, e) {
                                    var i = L(e),
                                        n = i.index();
                                    n === a && i.addClass(r.bulletActiveClass), r.dynamicBullets && (c <= n && n <= p && i.addClass(r.bulletActiveClass + "-main"), n === c && i.prev().addClass(r.bulletActiveClass + "-prev").prev().addClass(r.bulletActiveClass + "-prev-prev"), n === p && i.next().addClass(r.bulletActiveClass + "-next").next().addClass(r.bulletActiveClass + "-next-next"))
                                });
                                else {
                                    var y = v.eq(a),
                                        b = y.index();
                                    if (y.addClass(r.bulletActiveClass), r.dynamicBullets) {
                                        for (var x = v.eq(c), _ = v.eq(p), w = c; w <= p; w += 1) v.eq(w).addClass(r.bulletActiveClass + "-main");
                                        if (t.params.loop)
                                            if (b >= v.length - r.dynamicMainBullets) {
                                                for (var S = r.dynamicMainBullets; 0 <= S; --S) v.eq(v.length - S).addClass(r.bulletActiveClass + "-main");
                                                v.eq(v.length - r.dynamicMainBullets - 1).addClass(r.bulletActiveClass + "-prev")
                                            } else x.prev().addClass(r.bulletActiveClass + "-prev").prev().addClass(r.bulletActiveClass + "-prev-prev"), _.next().addClass(r.bulletActiveClass + "-next").next().addClass(r.bulletActiveClass + "-next-next");
                                        else x.prev().addClass(r.bulletActiveClass + "-prev").prev().addClass(r.bulletActiveClass + "-prev-prev"), _.next().addClass(r.bulletActiveClass + "-next").next().addClass(r.bulletActiveClass + "-next-next")
                                    }
                                }
                                r.dynamicBullets && (f = Math.min(v.length, r.dynamicMainBullets + 4), m = (t.pagination.bulletSize * f - t.pagination.bulletSize) / 2 - d * t.pagination.bulletSize, g = e ? "right" : "left", v.css(t.isHorizontal() ? g : "top", m + "px"))
                            }
                            "fraction" === r.type && (h.find("." + r.currentClass).text(r.formatFractionCurrent(a + 1)), h.find("." + r.totalClass).text(r.formatFractionTotal(u))), "progressbar" === r.type && (i = r.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical", n = (a + 1) / u, o = s = 1, "horizontal" === i ? s = n : o = n, h.find("." + r.progressbarFillClass).transform("translate3d(0,0,0) scaleX(" + s + ") scaleY(" + o + ")").transition(t.params.speed)), "custom" === r.type && r.renderCustom ? (h.html(r.renderCustom(t, a + 1, u)), t.emit("paginationRender", t, h[0])) : t.emit("paginationUpdate", t, h[0]), h[t.params.watchOverflow && t.isLocked ? "addClass" : "removeClass"](r.lockClass)
                        }
                    },
                    render: function() {
                        var t = this,
                            e = t.params.pagination;
                        if (e.el && t.pagination.el && t.pagination.$el && 0 !== t.pagination.$el.length) {
                            var i = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                                n = t.pagination.$el,
                                r = "";
                            if ("bullets" === e.type) {
                                for (var a = t.params.loop ? Math.ceil((i - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length, s = 0; s < a; s += 1) e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += "<" + e.bulletElement + ' class="' + e.bulletClass + '"></' + e.bulletElement + ">";
                                n.html(r), t.pagination.bullets = n.find("." + e.bulletClass)
                            }
                            "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : '<span class="' + e.currentClass + '"></span> / <span class="' + e.totalClass + '"></span>', n.html(r)), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : '<span class="' + e.progressbarFillClass + '"></span>', n.html(r)), "custom" !== e.type && t.emit("paginationRender", t.pagination.$el[0])
                        }
                    },
                    init: function() {
                        var t, i = this,
                            e = i.params.pagination;
                        !e.el || 0 !== (t = L(e.el)).length && (i.params.uniqueNavElements && "string" == typeof e.el && 1 < t.length && (t = i.$el.find(e.el)), "bullets" === e.type && e.clickable && t.addClass(e.clickableClass), t.addClass(e.modifierClass + e.type), "bullets" === e.type && e.dynamicBullets && (t.addClass("" + e.modifierClass + e.type + "-dynamic"), i.pagination.dynamicBulletIndex = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && t.addClass(e.progressbarOppositeClass), e.clickable && t.on("click", "." + e.bulletClass, function(t) {
                            t.preventDefault();
                            var e = L(this).index() * i.params.slidesPerGroup;
                            i.params.loop && (e += i.loopedSlides), i.slideTo(e)
                        }), st.extend(i.pagination, {
                            $el: t,
                            el: t[0]
                        }))
                    },
                    destroy: function() {
                        var t, e = this.params.pagination;
                        e.el && this.pagination.el && this.pagination.$el && 0 !== this.pagination.$el.length && ((t = this.pagination.$el).removeClass(e.hiddenClass), t.removeClass(e.modifierClass + e.type), this.pagination.bullets && this.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && t.off("click", "." + e.bulletClass))
                    }
                },
                it = {
                    setTranslate: function() {
                        var t, e, i, n, r, a, s, o, l, h;
                        this.params.scrollbar.el && this.scrollbar.el && (t = this.scrollbar, e = this.rtlTranslate, i = this.progress, n = t.dragSize, r = t.trackSize, a = t.$dragEl, s = t.$el, o = this.params.scrollbar, h = (r - (l = n)) * i, e ? 0 < (h = -h) ? (l = n - h, h = 0) : r < -h + n && (l = r + h) : h < 0 ? (l = n + h, h = 0) : r < h + n && (l = r - h), this.isHorizontal() ? (a.transform("translate3d(" + h + "px, 0, 0)"), a[0].style.width = l + "px") : (a.transform("translate3d(0px, " + h + "px, 0)"), a[0].style.height = l + "px"), o.hide && (clearTimeout(this.scrollbar.timeout), s[0].style.opacity = 1, this.scrollbar.timeout = setTimeout(function() {
                            s[0].style.opacity = 0, s.transition(400)
                        }, 1e3)))
                    },
                    setTransition: function(t) {
                        this.params.scrollbar.el && this.scrollbar.el && this.scrollbar.$dragEl.transition(t)
                    },
                    updateSize: function() {
                        var t, e, i, n, r, a, s, o = this;
                        o.params.scrollbar.el && o.scrollbar.el && (e = (t = o.scrollbar).$dragEl, i = t.$el, e[0].style.width = "", e[0].style.height = "", n = o.isHorizontal() ? i[0].offsetWidth : i[0].offsetHeight, a = (r = o.size / o.virtualSize) * (n / o.size), s = "auto" === o.params.scrollbar.dragSize ? n * r : parseInt(o.params.scrollbar.dragSize, 10), o.isHorizontal() ? e[0].style.width = s + "px" : e[0].style.height = s + "px", i[0].style.display = 1 <= r ? "none" : "", o.params.scrollbar.hide && (i[0].style.opacity = 0), st.extend(t, {
                            trackSize: n,
                            divider: r,
                            moveDivider: a,
                            dragSize: s
                        }), t.$el[o.params.watchOverflow && o.isLocked ? "addClass" : "removeClass"](o.params.scrollbar.lockClass))
                    },
                    getPointerPosition: function(t) {
                        return this.isHorizontal() ? "touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0].clientX : t.clientX : "touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0].clientY : t.clientY
                    },
                    setDragPosition: function(t) {
                        var e = this,
                            i = e.scrollbar,
                            n = e.rtlTranslate,
                            r = i.$el,
                            a = i.dragSize,
                            s = i.trackSize,
                            o = i.dragStartPos,
                            l = (i.getPointerPosition(t) - r.offset()[e.isHorizontal() ? "left" : "top"] - (null !== o ? o : a / 2)) / (s - a);
                        l = Math.max(Math.min(l, 1), 0), n && (l = 1 - l);
                        var h = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * l;
                        e.updateProgress(h), e.setTranslate(h), e.updateActiveIndex(), e.updateSlidesClasses()
                    },
                    onDragStart: function(t) {
                        var e = this,
                            i = e.params.scrollbar,
                            n = e.scrollbar,
                            r = e.$wrapperEl,
                            a = n.$el,
                            s = n.$dragEl;
                        e.scrollbar.isTouched = !0, e.scrollbar.dragStartPos = t.target === s[0] || t.target === s ? n.getPointerPosition(t) - t.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, t.preventDefault(), t.stopPropagation(), r.transition(100), s.transition(100), n.setDragPosition(t), clearTimeout(e.scrollbar.dragTimeout), a.transition(0), i.hide && a.css("opacity", 1), e.params.cssMode && e.$wrapperEl.css("scroll-snap-type", "none"), e.emit("scrollbarDragStart", t)
                    },
                    onDragMove: function(t) {
                        var e = this.scrollbar,
                            i = this.$wrapperEl,
                            n = e.$el,
                            r = e.$dragEl;
                        this.scrollbar.isTouched && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, e.setDragPosition(t), i.transition(0), n.transition(0), r.transition(0), this.emit("scrollbarDragMove", t))
                    },
                    onDragEnd: function(t) {
                        var e = this,
                            i = e.params.scrollbar,
                            n = e.scrollbar,
                            r = e.$wrapperEl,
                            a = n.$el;
                        e.scrollbar.isTouched && (e.scrollbar.isTouched = !1, e.params.cssMode && (e.$wrapperEl.css("scroll-snap-type", ""), r.transition("")), i.hide && (clearTimeout(e.scrollbar.dragTimeout), e.scrollbar.dragTimeout = st.nextTick(function() {
                            a.css("opacity", 0), a.transition(400)
                        }, 1e3)), e.emit("scrollbarDragEnd", t), i.snapOnRelease && e.slideToClosest())
                    },
                    enableDraggable: function() {
                        var t, e, i, n, r, a, s, o = this;
                        o.params.scrollbar.el && (t = o.scrollbar, e = o.touchEventsTouch, i = o.touchEventsDesktop, n = o.params, r = t.$el[0], a = !(!C.passiveListener || !n.passiveListeners) && {
                            passive: !1,
                            capture: !1
                        }, s = !(!C.passiveListener || !n.passiveListeners) && {
                            passive: !0,
                            capture: !1
                        }, C.touch ? (r.addEventListener(e.start, o.scrollbar.onDragStart, a), r.addEventListener(e.move, o.scrollbar.onDragMove, a), r.addEventListener(e.end, o.scrollbar.onDragEnd, s)) : (r.addEventListener(i.start, o.scrollbar.onDragStart, a), b.addEventListener(i.move, o.scrollbar.onDragMove, a), b.addEventListener(i.end, o.scrollbar.onDragEnd, s)))
                    },
                    disableDraggable: function() {
                        var t, e, i, n, r, a, s, o = this;
                        o.params.scrollbar.el && (t = o.scrollbar, e = o.touchEventsTouch, i = o.touchEventsDesktop, n = o.params, r = t.$el[0], a = !(!C.passiveListener || !n.passiveListeners) && {
                            passive: !1,
                            capture: !1
                        }, s = !(!C.passiveListener || !n.passiveListeners) && {
                            passive: !0,
                            capture: !1
                        }, C.touch ? (r.removeEventListener(e.start, o.scrollbar.onDragStart, a), r.removeEventListener(e.move, o.scrollbar.onDragMove, a), r.removeEventListener(e.end, o.scrollbar.onDragEnd, s)) : (r.removeEventListener(i.start, o.scrollbar.onDragStart, a), b.removeEventListener(i.move, o.scrollbar.onDragMove, a), b.removeEventListener(i.end, o.scrollbar.onDragEnd, s)))
                    },
                    init: function() {
                        var t, e, i, n, r;
                        this.params.scrollbar.el && (t = this.scrollbar, e = this.$el, n = L((i = this.params.scrollbar).el), this.params.uniqueNavElements && "string" == typeof i.el && 1 < n.length && 1 === e.find(i.el).length && (n = e.find(i.el)), 0 === (r = n.find("." + this.params.scrollbar.dragClass)).length && (r = L('<div class="' + this.params.scrollbar.dragClass + '"></div>'), n.append(r)), st.extend(t, {
                            $el: n,
                            el: n[0],
                            $dragEl: r,
                            dragEl: r[0]
                        }), i.draggable && t.enableDraggable())
                    },
                    destroy: function() {
                        this.scrollbar.disableDraggable()
                    }
                },
                nt = {
                    setTransform: function(t, e) {
                        var i, n, r = this.rtl,
                            a = L(t),
                            s = r ? -1 : 1,
                            o = a.attr("data-swiper-parallax") || "0",
                            l = a.attr("data-swiper-parallax-x"),
                            h = a.attr("data-swiper-parallax-y"),
                            u = a.attr("data-swiper-parallax-scale"),
                            c = a.attr("data-swiper-parallax-opacity");
                        l || h ? (l = l || "0", h = h || "0") : this.isHorizontal() ? (l = o, h = "0") : (h = o, l = "0"), l = 0 <= l.indexOf("%") ? parseInt(l, 10) * e * s + "%" : l * e * s + "px", h = 0 <= h.indexOf("%") ? parseInt(h, 10) * e + "%" : h * e + "px", null != c && (i = c - (c - 1) * (1 - Math.abs(e)), a[0].style.opacity = i), null == u ? a.transform("translate3d(" + l + ", " + h + ", 0px)") : (n = u - (u - 1) * (1 - Math.abs(e)), a.transform("translate3d(" + l + ", " + h + ", 0px) scale(" + n + ")"))
                    },
                    setTranslate: function() {
                        var n = this,
                            t = n.$el,
                            e = n.slides,
                            r = n.progress,
                            a = n.snapGrid;
                        t.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(function(t, e) {
                            n.parallax.setTransform(e, r)
                        }), e.each(function(t, e) {
                            var i = e.progress;
                            1 < n.params.slidesPerGroup && "auto" !== n.params.slidesPerView && (i += Math.ceil(t / 2) - r * (a.length - 1)), i = Math.min(Math.max(i, -1), 1), L(e).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(function(t, e) {
                                n.parallax.setTransform(e, i)
                            })
                        })
                    },
                    setTransition: function(r) {
                        void 0 === r && (r = this.params.speed);
                        this.$el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(function(t, e) {
                            var i = L(e),
                                n = parseInt(i.attr("data-swiper-parallax-duration"), 10) || r;
                            0 === r && (n = 0), i.transition(n)
                        })
                    }
                },
                rt = {
                    getDistanceBetweenTouches: function(t) {
                        if (t.targetTouches.length < 2) return 1;
                        var e = t.targetTouches[0].pageX,
                            i = t.targetTouches[0].pageY,
                            n = t.targetTouches[1].pageX,
                            r = t.targetTouches[1].pageY;
                        return Math.sqrt(Math.pow(n - e, 2) + Math.pow(r - i, 2))
                    },
                    onGestureStart: function(t) {
                        var e = this.params.zoom,
                            i = this.zoom,
                            n = i.gesture;
                        if (i.fakeGestureTouched = !1, i.fakeGestureMoved = !1, !C.gestures) {
                            if ("touchstart" !== t.type || "touchstart" === t.type && t.targetTouches.length < 2) return;
                            i.fakeGestureTouched = !0, n.scaleStart = rt.getDistanceBetweenTouches(t)
                        }
                        n.$slideEl && n.$slideEl.length || (n.$slideEl = L(t.target).closest("." + this.params.slideClass), 0 === n.$slideEl.length && (n.$slideEl = this.slides.eq(this.activeIndex)), n.$imageEl = n.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), n.$imageWrapEl = n.$imageEl.parent("." + e.containerClass), n.maxRatio = n.$imageWrapEl.attr("data-swiper-zoom") || e.maxRatio, 0 !== n.$imageWrapEl.length) ? (n.$imageEl && n.$imageEl.transition(0), this.zoom.isScaling = !0) : n.$imageEl = void 0
                    },
                    onGestureChange: function(t) {
                        var e = this.params.zoom,
                            i = this.zoom,
                            n = i.gesture;
                        if (!C.gestures) {
                            if ("touchmove" !== t.type || "touchmove" === t.type && t.targetTouches.length < 2) return;
                            i.fakeGestureMoved = !0, n.scaleMove = rt.getDistanceBetweenTouches(t)
                        }
                        n.$imageEl && 0 !== n.$imageEl.length && (C.gestures ? i.scale = t.scale * i.currentScale : i.scale = n.scaleMove / n.scaleStart * i.currentScale, i.scale > n.maxRatio && (i.scale = n.maxRatio - 1 + Math.pow(i.scale - n.maxRatio + 1, .5)), i.scale < e.minRatio && (i.scale = e.minRatio + 1 - Math.pow(e.minRatio - i.scale + 1, .5)), n.$imageEl.transform("translate3d(0,0,0) scale(" + i.scale + ")"))
                    },
                    onGestureEnd: function(t) {
                        var e = this.params.zoom,
                            i = this.zoom,
                            n = i.gesture;
                        if (!C.gestures) {
                            if (!i.fakeGestureTouched || !i.fakeGestureMoved) return;
                            if ("touchend" !== t.type || "touchend" === t.type && t.changedTouches.length < 2 && !O.android) return;
                            i.fakeGestureTouched = !1, i.fakeGestureMoved = !1
                        }
                        n.$imageEl && 0 !== n.$imageEl.length && (i.scale = Math.max(Math.min(i.scale, n.maxRatio), e.minRatio), n.$imageEl.transition(this.params.speed).transform("translate3d(0,0,0) scale(" + i.scale + ")"), i.currentScale = i.scale, i.isScaling = !1, 1 === i.scale && (n.$slideEl = void 0))
                    },
                    onTouchStart: function(t) {
                        var e = this.zoom,
                            i = e.gesture,
                            n = e.image;
                        i.$imageEl && 0 !== i.$imageEl.length && (n.isTouched || (O.android && t.cancelable && t.preventDefault(), n.isTouched = !0, n.touchesStart.x = "touchstart" === t.type ? t.targetTouches[0].pageX : t.pageX, n.touchesStart.y = "touchstart" === t.type ? t.targetTouches[0].pageY : t.pageY))
                    },
                    onTouchMove: function(t) {
                        var e = this.zoom,
                            i = e.gesture,
                            n = e.image,
                            r = e.velocity;
                        if (i.$imageEl && 0 !== i.$imageEl.length && (this.allowClick = !1, n.isTouched && i.$slideEl)) {
                            n.isMoved || (n.width = i.$imageEl[0].offsetWidth, n.height = i.$imageEl[0].offsetHeight, n.startX = st.getTranslate(i.$imageWrapEl[0], "x") || 0, n.startY = st.getTranslate(i.$imageWrapEl[0], "y") || 0, i.slideWidth = i.$slideEl[0].offsetWidth, i.slideHeight = i.$slideEl[0].offsetHeight, i.$imageWrapEl.transition(0), this.rtl && (n.startX = -n.startX, n.startY = -n.startY));
                            var a = n.width * e.scale,
                                s = n.height * e.scale;
                            if (!(a < i.slideWidth && s < i.slideHeight)) {
                                if (n.minX = Math.min(i.slideWidth / 2 - a / 2, 0), n.maxX = -n.minX, n.minY = Math.min(i.slideHeight / 2 - s / 2, 0), n.maxY = -n.minY, n.touchesCurrent.x = "touchmove" === t.type ? t.targetTouches[0].pageX : t.pageX, n.touchesCurrent.y = "touchmove" === t.type ? t.targetTouches[0].pageY : t.pageY, !n.isMoved && !e.isScaling) {
                                    if (this.isHorizontal() && (Math.floor(n.minX) === Math.floor(n.startX) && n.touchesCurrent.x < n.touchesStart.x || Math.floor(n.maxX) === Math.floor(n.startX) && n.touchesCurrent.x > n.touchesStart.x)) return void(n.isTouched = !1);
                                    if (!this.isHorizontal() && (Math.floor(n.minY) === Math.floor(n.startY) && n.touchesCurrent.y < n.touchesStart.y || Math.floor(n.maxY) === Math.floor(n.startY) && n.touchesCurrent.y > n.touchesStart.y)) return void(n.isTouched = !1)
                                }
                                t.cancelable && t.preventDefault(), t.stopPropagation(), n.isMoved = !0, n.currentX = n.touchesCurrent.x - n.touchesStart.x + n.startX, n.currentY = n.touchesCurrent.y - n.touchesStart.y + n.startY, n.currentX < n.minX && (n.currentX = n.minX + 1 - Math.pow(n.minX - n.currentX + 1, .8)), n.currentX > n.maxX && (n.currentX = n.maxX - 1 + Math.pow(n.currentX - n.maxX + 1, .8)), n.currentY < n.minY && (n.currentY = n.minY + 1 - Math.pow(n.minY - n.currentY + 1, .8)), n.currentY > n.maxY && (n.currentY = n.maxY - 1 + Math.pow(n.currentY - n.maxY + 1, .8)), r.prevPositionX || (r.prevPositionX = n.touchesCurrent.x), r.prevPositionY || (r.prevPositionY = n.touchesCurrent.y), r.prevTime || (r.prevTime = Date.now()), r.x = (n.touchesCurrent.x - r.prevPositionX) / (Date.now() - r.prevTime) / 2, r.y = (n.touchesCurrent.y - r.prevPositionY) / (Date.now() - r.prevTime) / 2, Math.abs(n.touchesCurrent.x - r.prevPositionX) < 2 && (r.x = 0), Math.abs(n.touchesCurrent.y - r.prevPositionY) < 2 && (r.y = 0), r.prevPositionX = n.touchesCurrent.x, r.prevPositionY = n.touchesCurrent.y, r.prevTime = Date.now(), i.$imageWrapEl.transform("translate3d(" + n.currentX + "px, " + n.currentY + "px,0)")
                            }
                        }
                    },
                    onTouchEnd: function() {
                        var t = this.zoom,
                            e = t.gesture,
                            i = t.image,
                            n = t.velocity;
                        if (e.$imageEl && 0 !== e.$imageEl.length) {
                            if (!i.isTouched || !i.isMoved) return i.isTouched = !1, void(i.isMoved = !1);
                            i.isTouched = !1, i.isMoved = !1;
                            var r = 300,
                                a = 300,
                                s = n.x * r,
                                o = i.currentX + s,
                                l = n.y * a,
                                h = i.currentY + l;
                            0 !== n.x && (r = Math.abs((o - i.currentX) / n.x)), 0 !== n.y && (a = Math.abs((h - i.currentY) / n.y));
                            var u = Math.max(r, a);
                            i.currentX = o, i.currentY = h;
                            var c = i.width * t.scale,
                                p = i.height * t.scale;
                            i.minX = Math.min(e.slideWidth / 2 - c / 2, 0), i.maxX = -i.minX, i.minY = Math.min(e.slideHeight / 2 - p / 2, 0), i.maxY = -i.minY, i.currentX = Math.max(Math.min(i.currentX, i.maxX), i.minX), i.currentY = Math.max(Math.min(i.currentY, i.maxY), i.minY), e.$imageWrapEl.transition(u).transform("translate3d(" + i.currentX + "px, " + i.currentY + "px,0)")
                        }
                    },
                    onTransitionEnd: function() {
                        var t = this.zoom,
                            e = t.gesture;
                        e.$slideEl && this.previousIndex !== this.activeIndex && (e.$imageEl && e.$imageEl.transform("translate3d(0,0,0) scale(1)"), e.$imageWrapEl && e.$imageWrapEl.transform("translate3d(0,0,0)"), t.scale = 1, t.currentScale = 1, e.$slideEl = void 0, e.$imageEl = void 0, e.$imageWrapEl = void 0)
                    },
                    toggle: function(t) {
                        var e = this.zoom;
                        e.scale && 1 !== e.scale ? e.out() : e.in(t)
                    },
                    in: function(t) {
                        var e, i, n, r, a, s, o, l, h, u, c, p, d, f, m, g, v = this.zoom,
                            y = this.params.zoom,
                            b = v.gesture,
                            x = v.image;
                        b.$slideEl || (this.params.virtual && this.params.virtual.enabled && this.virtual ? b.$slideEl = this.$wrapperEl.children("." + this.params.slideActiveClass) : b.$slideEl = this.slides.eq(this.activeIndex), b.$imageEl = b.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), b.$imageWrapEl = b.$imageEl.parent("." + y.containerClass)), b.$imageEl && 0 !== b.$imageEl.length && (b.$slideEl.addClass("" + y.zoomedSlideClass), i = void 0 === x.touchesStart.x && t ? (e = "touchend" === t.type ? t.changedTouches[0].pageX : t.pageX, "touchend" === t.type ? t.changedTouches[0].pageY : t.pageY) : (e = x.touchesStart.x, x.touchesStart.y), v.scale = b.$imageWrapEl.attr("data-swiper-zoom") || y.maxRatio, v.currentScale = b.$imageWrapEl.attr("data-swiper-zoom") || y.maxRatio, t ? (m = b.$slideEl[0].offsetWidth, g = b.$slideEl[0].offsetHeight, n = b.$slideEl.offset().left + m / 2 - e, r = b.$slideEl.offset().top + g / 2 - i, o = b.$imageEl[0].offsetWidth, l = b.$imageEl[0].offsetHeight, h = o * v.scale, u = l * v.scale, d = -(c = Math.min(m / 2 - h / 2, 0)), f = -(p = Math.min(g / 2 - u / 2, 0)), (a = n * v.scale) < c && (a = c), d < a && (a = d), (s = r * v.scale) < p && (s = p), f < s && (s = f)) : s = a = 0, b.$imageWrapEl.transition(300).transform("translate3d(" + a + "px, " + s + "px,0)"), b.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + v.scale + ")"))
                    },
                    out: function() {
                        var t = this.zoom,
                            e = this.params.zoom,
                            i = t.gesture;
                        i.$slideEl || (this.params.virtual && this.params.virtual.enabled && this.virtual ? i.$slideEl = this.$wrapperEl.children("." + this.params.slideActiveClass) : i.$slideEl = this.slides.eq(this.activeIndex), i.$imageEl = i.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), i.$imageWrapEl = i.$imageEl.parent("." + e.containerClass)), i.$imageEl && 0 !== i.$imageEl.length && (t.scale = 1, t.currentScale = 1, i.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), i.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), i.$slideEl.removeClass("" + e.zoomedSlideClass), i.$slideEl = void 0)
                    },
                    enable: function() {
                        var t, e, i, n = this,
                            r = n.zoom;
                        r.enabled || (r.enabled = !0, t = !("touchstart" !== n.touchEvents.start || !C.passiveListener || !n.params.passiveListeners) && {
                            passive: !0,
                            capture: !1
                        }, e = !C.passiveListener || {
                            passive: !1,
                            capture: !0
                        }, i = "." + n.params.slideClass, C.gestures ? (n.$wrapperEl.on("gesturestart", i, r.onGestureStart, t), n.$wrapperEl.on("gesturechange", i, r.onGestureChange, t), n.$wrapperEl.on("gestureend", i, r.onGestureEnd, t)) : "touchstart" === n.touchEvents.start && (n.$wrapperEl.on(n.touchEvents.start, i, r.onGestureStart, t), n.$wrapperEl.on(n.touchEvents.move, i, r.onGestureChange, e), n.$wrapperEl.on(n.touchEvents.end, i, r.onGestureEnd, t), n.touchEvents.cancel && n.$wrapperEl.on(n.touchEvents.cancel, i, r.onGestureEnd, t)), n.$wrapperEl.on(n.touchEvents.move, "." + n.params.zoom.containerClass, r.onTouchMove, e))
                    },
                    disable: function() {
                        var t, e, i, n = this,
                            r = n.zoom;
                        r.enabled && (n.zoom.enabled = !1, t = !("touchstart" !== n.touchEvents.start || !C.passiveListener || !n.params.passiveListeners) && {
                            passive: !0,
                            capture: !1
                        }, e = !C.passiveListener || {
                            passive: !1,
                            capture: !0
                        }, i = "." + n.params.slideClass, C.gestures ? (n.$wrapperEl.off("gesturestart", i, r.onGestureStart, t), n.$wrapperEl.off("gesturechange", i, r.onGestureChange, t), n.$wrapperEl.off("gestureend", i, r.onGestureEnd, t)) : "touchstart" === n.touchEvents.start && (n.$wrapperEl.off(n.touchEvents.start, i, r.onGestureStart, t), n.$wrapperEl.off(n.touchEvents.move, i, r.onGestureChange, e), n.$wrapperEl.off(n.touchEvents.end, i, r.onGestureEnd, t), n.touchEvents.cancel && n.$wrapperEl.off(n.touchEvents.cancel, i, r.onGestureEnd, t)), n.$wrapperEl.off(n.touchEvents.move, "." + n.params.zoom.containerClass, r.onTouchMove, e))
                    }
                },
                ot = {
                    loadInSlide: function(t, h) {
                        void 0 === h && (h = !0);
                        var u, e, c = this,
                            p = c.params.lazy;
                        void 0 !== t && 0 !== c.slides.length && (e = (u = c.virtual && c.params.virtual.enabled ? c.$wrapperEl.children("." + c.params.slideClass + '[data-swiper-slide-index="' + t + '"]') : c.slides.eq(t)).find("." + p.elementClass + ":not(." + p.loadedClass + "):not(." + p.loadingClass + ")"), !u.hasClass(p.elementClass) || u.hasClass(p.loadedClass) || u.hasClass(p.loadingClass) || (e = e.add(u[0])), 0 !== e.length && e.each(function(t, e) {
                            var n = L(e);
                            n.addClass(p.loadingClass);
                            var r = n.attr("data-background"),
                                a = n.attr("data-src"),
                                s = n.attr("data-srcset"),
                                o = n.attr("data-sizes"),
                                l = n.parent("picture");
                            c.loadImage(n[0], a || r, s, o, !1, function() {
                                var t, e, i;
                                null == c || !c || c && !c.params || c.destroyed || (r ? (n.css("background-image", 'url("' + r + '")'), n.removeAttr("data-background")) : (s && (n.attr("srcset", s), n.removeAttr("data-srcset")), o && (n.attr("sizes", o), n.removeAttr("data-sizes")), l.length && l.children("source").each(function(t, e) {
                                    var i = L(e);
                                    i.attr("data-srcset") && (i.attr("srcset", i.attr("data-srcset")), i.removeAttr("data-srcset"))
                                }), a && (n.attr("src", a), n.removeAttr("data-src"))), n.addClass(p.loadedClass).removeClass(p.loadingClass), u.find("." + p.preloaderClass).remove(), c.params.loop && h && (t = u.attr("data-swiper-slide-index"), u.hasClass(c.params.slideDuplicateClass) ? (e = c.$wrapperEl.children('[data-swiper-slide-index="' + t + '"]:not(.' + c.params.slideDuplicateClass + ")"), c.lazy.loadInSlide(e.index(), !1)) : (i = c.$wrapperEl.children("." + c.params.slideDuplicateClass + '[data-swiper-slide-index="' + t + '"]'), c.lazy.loadInSlide(i.index(), !1))), c.emit("lazyImageReady", u[0], n[0]), c.params.autoHeight && c.updateAutoHeight())
                            }), c.emit("lazyImageLoad", u[0], n[0])
                        }))
                    },
                    load: function() {
                        var n = this,
                            e = n.$wrapperEl,
                            i = n.params,
                            r = n.slides,
                            t = n.activeIndex,
                            a = n.virtual && i.virtual.enabled,
                            s = i.lazy,
                            o = i.slidesPerView;

                        function l(t) {
                            if (a) {
                                if (e.children("." + i.slideClass + '[data-swiper-slide-index="' + t + '"]').length) return 1
                            } else if (r[t]) return 1
                        }

                        function h(t) {
                            return a ? L(t).attr("data-swiper-slide-index") : L(t).index()
                        }
                        if ("auto" === o && (o = 0), n.lazy.initialImageLoaded || (n.lazy.initialImageLoaded = !0), n.params.watchSlidesVisibility) e.children("." + i.slideVisibleClass).each(function(t, e) {
                            var i = a ? L(e).attr("data-swiper-slide-index") : L(e).index();
                            n.lazy.loadInSlide(i)
                        });
                        else if (1 < o)
                            for (var u = t; u < t + o; u += 1) l(u) && n.lazy.loadInSlide(u);
                        else n.lazy.loadInSlide(t);
                        if (s.loadPrevNext)
                            if (1 < o || s.loadPrevNextAmount && 1 < s.loadPrevNextAmount) {
                                for (var c = s.loadPrevNextAmount, p = o, d = Math.min(t + p + Math.max(c, p), r.length), f = Math.max(t - Math.max(p, c), 0), m = t + o; m < d; m += 1) l(m) && n.lazy.loadInSlide(m);
                                for (var g = f; g < t; g += 1) l(g) && n.lazy.loadInSlide(g)
                            } else {
                                var v = e.children("." + i.slideNextClass);
                                0 < v.length && n.lazy.loadInSlide(h(v));
                                var y = e.children("." + i.slidePrevClass);
                                0 < y.length && n.lazy.loadInSlide(h(y))
                            }
                    }
                },
                lt = {
                    LinearSpline: function(t, e) {
                        var i, n, r, a, s, o = function(t, e) {
                            for (n = -1, i = t.length; 1 < i - n;) t[r = i + n >> 1] <= e ? n = r : i = r;
                            return i
                        };
                        return this.x = t, this.y = e, this.lastIndex = t.length - 1, this.interpolate = function(t) {
                            return t ? (s = o(this.x, t), a = s - 1, (t - this.x[a]) * (this.y[s] - this.y[a]) / (this.x[s] - this.x[a]) + this.y[a]) : 0
                        }, this
                    },
                    getInterpolateFunction: function(t) {
                        this.controller.spline || (this.controller.spline = this.params.loop ? new lt.LinearSpline(this.slidesGrid, t.slidesGrid) : new lt.LinearSpline(this.snapGrid, t.snapGrid))
                    },
                    setTranslate: function(t, e) {
                        var i, n, r = this,
                            a = r.controller.control;

                        function s(t) {
                            var e = r.rtlTranslate ? -r.translate : r.translate;
                            "slide" === r.params.controller.by && (r.controller.getInterpolateFunction(t), n = -r.controller.spline.interpolate(-e)), n && "container" !== r.params.controller.by || (i = (t.maxTranslate() - t.minTranslate()) / (r.maxTranslate() - r.minTranslate()), n = (e - r.minTranslate()) * i + t.minTranslate()), r.params.controller.inverse && (n = t.maxTranslate() - n), t.updateProgress(n), t.setTranslate(n, r), t.updateActiveIndex(), t.updateSlidesClasses()
                        }
                        if (Array.isArray(a))
                            for (var o = 0; o < a.length; o += 1) a[o] !== e && a[o] instanceof V && s(a[o]);
                        else a instanceof V && e !== a && s(a)
                    },
                    setTransition: function(e, t) {
                        var i, n = this,
                            r = n.controller.control;

                        function a(t) {
                            t.setTransition(e, n), 0 !== e && (t.transitionStart(), t.params.autoHeight && st.nextTick(function() {
                                t.updateAutoHeight()
                            }), t.$wrapperEl.transitionEnd(function() {
                                r && (t.params.loop && "slide" === n.params.controller.by && t.loopFix(), t.transitionEnd())
                            }))
                        }
                        if (Array.isArray(r))
                            for (i = 0; i < r.length; i += 1) r[i] !== t && r[i] instanceof V && a(r[i]);
                        else r instanceof V && t !== r && a(r)
                    }
                },
                ht = {
                    makeElFocusable: function(t) {
                        return t.attr("tabIndex", "0"), t
                    },
                    makeElNotFocusable: function(t) {
                        return t.attr("tabIndex", "-1"), t
                    },
                    addElRole: function(t, e) {
                        return t.attr("role", e), t
                    },
                    addElLabel: function(t, e) {
                        return t.attr("aria-label", e), t
                    },
                    disableEl: function(t) {
                        return t.attr("aria-disabled", !0), t
                    },
                    enableEl: function(t) {
                        return t.attr("aria-disabled", !1), t
                    },
                    onEnterKey: function(t) {
                        var e, i = this,
                            n = i.params.a11y;
                        13 === t.keyCode && (e = L(t.target), i.navigation && i.navigation.$nextEl && e.is(i.navigation.$nextEl) && (i.isEnd && !i.params.loop || i.slideNext(), i.isEnd ? i.a11y.notify(n.lastSlideMessage) : i.a11y.notify(n.nextSlideMessage)), i.navigation && i.navigation.$prevEl && e.is(i.navigation.$prevEl) && (i.isBeginning && !i.params.loop || i.slidePrev(), i.isBeginning ? i.a11y.notify(n.firstSlideMessage) : i.a11y.notify(n.prevSlideMessage)), i.pagination && e.is("." + i.params.pagination.bulletClass) && e[0].click())
                    },
                    notify: function(t) {
                        var e = this.a11y.liveRegion;
                        0 !== e.length && (e.html(""), e.html(t))
                    },
                    updateNavigation: function() {
                        var t, e, i, n = this;
                        !n.params.loop && n.navigation && (e = (t = n.navigation).$nextEl, (i = t.$prevEl) && 0 < i.length && (n.isBeginning ? (n.a11y.disableEl(i), n.a11y.makeElNotFocusable(i)) : (n.a11y.enableEl(i), n.a11y.makeElFocusable(i))), e && 0 < e.length && (n.isEnd ? (n.a11y.disableEl(e), n.a11y.makeElNotFocusable(e)) : (n.a11y.enableEl(e), n.a11y.makeElFocusable(e))))
                    },
                    updatePagination: function() {
                        var n = this,
                            r = n.params.a11y;
                        n.pagination && n.params.pagination.clickable && n.pagination.bullets && n.pagination.bullets.length && n.pagination.bullets.each(function(t, e) {
                            var i = L(e);
                            n.a11y.makeElFocusable(i), n.a11y.addElRole(i, "button"), n.a11y.addElLabel(i, r.paginationBulletMessage.replace(/\{\{index\}\}/, i.index() + 1))
                        })
                    },
                    init: function() {
                        var t = this;
                        t.$el.append(t.a11y.liveRegion);
                        var e, i, n = t.params.a11y;
                        t.navigation && t.navigation.$nextEl && (e = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (i = t.navigation.$prevEl), e && (t.a11y.makeElFocusable(e), t.a11y.addElRole(e, "button"), t.a11y.addElLabel(e, n.nextSlideMessage), e.on("keydown", t.a11y.onEnterKey)), i && (t.a11y.makeElFocusable(i), t.a11y.addElRole(i, "button"), t.a11y.addElLabel(i, n.prevSlideMessage), i.on("keydown", t.a11y.onEnterKey)), t.pagination && t.params.pagination.clickable && t.pagination.bullets && t.pagination.bullets.length && t.pagination.$el.on("keydown", "." + t.params.pagination.bulletClass, t.a11y.onEnterKey)
                    },
                    destroy: function() {
                        var t, e, i = this;
                        i.a11y.liveRegion && 0 < i.a11y.liveRegion.length && i.a11y.liveRegion.remove(), i.navigation && i.navigation.$nextEl && (t = i.navigation.$nextEl), i.navigation && i.navigation.$prevEl && (e = i.navigation.$prevEl), t && t.off("keydown", i.a11y.onEnterKey), e && e.off("keydown", i.a11y.onEnterKey), i.pagination && i.params.pagination.clickable && i.pagination.bullets && i.pagination.bullets.length && i.pagination.$el.off("keydown", "." + i.params.pagination.bulletClass, i.a11y.onEnterKey)
                    }
                },
                ut = {
                    init: function() {
                        if (this.params.history) {
                            if (!at.history || !at.history.pushState) return this.params.history.enabled = !1, void(this.params.hashNavigation.enabled = !0);
                            var t = this.history;
                            t.initialized = !0, t.paths = ut.getPathValues(), (t.paths.key || t.paths.value) && (t.scrollToSlide(0, t.paths.value, this.params.runCallbacksOnInit), this.params.history.replaceState || at.addEventListener("popstate", this.history.setHistoryPopState))
                        }
                    },
                    destroy: function() {
                        this.params.history.replaceState || at.removeEventListener("popstate", this.history.setHistoryPopState)
                    },
                    setHistoryPopState: function() {
                        this.history.paths = ut.getPathValues(), this.history.scrollToSlide(this.params.speed, this.history.paths.value, !1)
                    },
                    getPathValues: function() {
                        var t = at.location.pathname.slice(1).split("/").filter(function(t) {
                                return "" !== t
                            }),
                            e = t.length;
                        return {
                            key: t[e - 2],
                            value: t[e - 1]
                        }
                    },
                    setHistory: function(t, e) {
                        var i, n, r;
                        this.history.initialized && this.params.history.enabled && (i = this.slides.eq(e), n = ut.slugify(i.attr("data-history")), at.location.pathname.includes(t) || (n = t + "/" + n), (r = at.history.state) && r.value === n || (this.params.history.replaceState ? at.history.replaceState({
                            value: n
                        }, null, n) : at.history.pushState({
                            value: n
                        }, null, n)))
                    },
                    slugify: function(t) {
                        return t.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "")
                    },
                    scrollToSlide: function(t, e, i) {
                        if (e)
                            for (var n = 0, r = this.slides.length; n < r; n += 1) {
                                var a, s = this.slides.eq(n);
                                ut.slugify(s.attr("data-history")) !== e || s.hasClass(this.params.slideDuplicateClass) || (a = s.index(), this.slideTo(a, t, i))
                            } else this.slideTo(0, t, i)
                    }
                },
                ct = {
                    onHashCange: function() {
                        this.emit("hashChange");
                        var t = b.location.hash.replace("#", "");
                        if (t !== this.slides.eq(this.activeIndex).attr("data-hash")) {
                            var e = this.$wrapperEl.children("." + this.params.slideClass + '[data-hash="' + t + '"]').index();
                            if (void 0 === e) return;
                            this.slideTo(e)
                        }
                    },
                    setHash: function() {
                        var t, e;
                        this.hashNavigation.initialized && this.params.hashNavigation.enabled && (this.params.hashNavigation.replaceState && at.history && at.history.replaceState ? at.history.replaceState(null, null, "#" + this.slides.eq(this.activeIndex).attr("data-hash") || "") : (e = (t = this.slides.eq(this.activeIndex)).attr("data-hash") || t.attr("data-history"), b.location.hash = e || ""), this.emit("hashSet"))
                    },
                    init: function() {
                        var t = this;
                        if (!(!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled)) {
                            t.hashNavigation.initialized = !0;
                            var e = b.location.hash.replace("#", "");
                            if (e)
                                for (var i = 0, n = t.slides.length; i < n; i += 1) {
                                    var r, a = t.slides.eq(i);
                                    (a.attr("data-hash") || a.attr("data-history")) !== e || a.hasClass(t.params.slideDuplicateClass) || (r = a.index(), t.slideTo(r, 0, t.params.runCallbacksOnInit, !0))
                                }
                            t.params.hashNavigation.watchState && L(at).on("hashchange", t.hashNavigation.onHashCange)
                        }
                    },
                    destroy: function() {
                        this.params.hashNavigation.watchState && L(at).off("hashchange", this.hashNavigation.onHashCange)
                    }
                },
                pt = {
                    run: function() {
                        var t = this,
                            e = t.slides.eq(t.activeIndex),
                            i = t.params.autoplay.delay;
                        e.attr("data-swiper-autoplay") && (i = e.attr("data-swiper-autoplay") || t.params.autoplay.delay), clearTimeout(t.autoplay.timeout), t.autoplay.timeout = st.nextTick(function() {
                            t.params.autoplay.reverseDirection ? t.params.loop ? (t.loopFix(), t.slidePrev(t.params.speed, !0, !0), t.emit("autoplay")) : t.isBeginning ? t.params.autoplay.stopOnLastSlide ? t.autoplay.stop() : (t.slideTo(t.slides.length - 1, t.params.speed, !0, !0), t.emit("autoplay")) : (t.slidePrev(t.params.speed, !0, !0), t.emit("autoplay")) : t.params.loop ? (t.loopFix(), t.slideNext(t.params.speed, !0, !0), t.emit("autoplay")) : t.isEnd ? t.params.autoplay.stopOnLastSlide ? t.autoplay.stop() : (t.slideTo(0, t.params.speed, !0, !0), t.emit("autoplay")) : (t.slideNext(t.params.speed, !0, !0), t.emit("autoplay")), t.params.cssMode && t.autoplay.running && t.autoplay.run()
                        }, i)
                    },
                    start: function() {
                        return void 0 === this.autoplay.timeout && (!this.autoplay.running && (this.autoplay.running = !0, this.emit("autoplayStart"), this.autoplay.run(), !0))
                    },
                    stop: function() {
                        return !!this.autoplay.running && (void 0 !== this.autoplay.timeout && (this.autoplay.timeout && (clearTimeout(this.autoplay.timeout), this.autoplay.timeout = void 0), this.autoplay.running = !1, this.emit("autoplayStop"), !0))
                    },
                    pause: function(t) {
                        var e = this;
                        e.autoplay.running && (e.autoplay.paused || (e.autoplay.timeout && clearTimeout(e.autoplay.timeout), e.autoplay.paused = !0, 0 !== t && e.params.autoplay.waitForTransition ? (e.$wrapperEl[0].addEventListener("transitionend", e.autoplay.onTransitionEnd), e.$wrapperEl[0].addEventListener("webkitTransitionEnd", e.autoplay.onTransitionEnd)) : (e.autoplay.paused = !1, e.autoplay.run())))
                    }
                },
                dt = {
                    setTranslate: function() {
                        for (var t = this.slides, e = 0; e < t.length; e += 1) {
                            var i = this.slides.eq(e),
                                n = -i[0].swiperSlideOffset;
                            this.params.virtualTranslate || (n -= this.translate);
                            var r = 0;
                            this.isHorizontal() || (r = n, n = 0);
                            var a = this.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(i[0].progress), 0) : 1 + Math.min(Math.max(i[0].progress, -1), 0);
                            i.css({
                                opacity: a
                            }).transform("translate3d(" + n + "px, " + r + "px, 0px)")
                        }
                    },
                    setTransition: function(t) {
                        var i, n = this,
                            e = n.slides,
                            r = n.$wrapperEl;
                        e.transition(t), n.params.virtualTranslate && 0 !== t && (i = !1, e.transitionEnd(function() {
                            if (!i && n && !n.destroyed) {
                                i = !0, n.animating = !1;
                                for (var t = ["webkitTransitionEnd", "transitionend"], e = 0; e < t.length; e += 1) r.trigger(t[e])
                            }
                        }))
                    }
                },
                ft = {
                    setTranslate: function() {
                        var t, e = this,
                            i = e.$el,
                            n = e.$wrapperEl,
                            r = e.slides,
                            a = e.width,
                            s = e.height,
                            o = e.rtlTranslate,
                            l = e.size,
                            h = e.params.cubeEffect,
                            u = e.isHorizontal(),
                            c = e.virtual && e.params.virtual.enabled,
                            p = 0;
                        h.shadow && (u ? (0 === (t = n.find(".swiper-cube-shadow")).length && (t = L('<div class="swiper-cube-shadow"></div>'), n.append(t)), t.css({
                            height: a + "px"
                        })) : 0 === (t = i.find(".swiper-cube-shadow")).length && (t = L('<div class="swiper-cube-shadow"></div>'), i.append(t)));
                        for (var d, f, m, g, v, y = 0; y < r.length; y += 1) {
                            var b = r.eq(y),
                                x = y;
                            c && (x = parseInt(b.attr("data-swiper-slide-index"), 10));
                            var _ = 90 * x,
                                w = Math.floor(_ / 360);
                            o && (_ = -_, w = Math.floor(-_ / 360));
                            var S = Math.max(Math.min(b[0].progress, 1), -1),
                                M = 0,
                                T = 0,
                                C = 0;
                            x % 4 == 0 ? (M = 4 * -w * l, C = 0) : (x - 1) % 4 == 0 ? (M = 0, C = 4 * -w * l) : (x - 2) % 4 == 0 ? (M = l + 4 * w * l, C = l) : (x - 3) % 4 == 0 && (M = -l, C = 3 * l + 4 * l * w), o && (M = -M), u || (T = M, M = 0);
                            var A, E, D = "rotateX(" + (u ? 0 : -_) + "deg) rotateY(" + (u ? _ : 0) + "deg) translate3d(" + M + "px, " + T + "px, " + C + "px)";
                            S <= 1 && -1 < S && (p = o ? 90 * -x - 90 * S : 90 * x + 90 * S), b.transform(D), h.slideShadows && (A = u ? b.find(".swiper-slide-shadow-left") : b.find(".swiper-slide-shadow-top"), E = u ? b.find(".swiper-slide-shadow-right") : b.find(".swiper-slide-shadow-bottom"), 0 === A.length && (A = L('<div class="swiper-slide-shadow-' + (u ? "left" : "top") + '"></div>'), b.append(A)), 0 === E.length && (E = L('<div class="swiper-slide-shadow-' + (u ? "right" : "bottom") + '"></div>'), b.append(E)), A.length && (A[0].style.opacity = Math.max(-S, 0)), E.length && (E[0].style.opacity = Math.max(S, 0)))
                        }
                        n.css({
                            "-webkit-transform-origin": "50% 50% -" + l / 2 + "px",
                            "-moz-transform-origin": "50% 50% -" + l / 2 + "px",
                            "-ms-transform-origin": "50% 50% -" + l / 2 + "px",
                            "transform-origin": "50% 50% -" + l / 2 + "px"
                        }), h.shadow && (u ? t.transform("translate3d(0px, " + (a / 2 + h.shadowOffset) + "px, " + -a / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + h.shadowScale + ")") : (d = Math.abs(p) - 90 * Math.floor(Math.abs(p) / 90), f = 1.5 - (Math.sin(2 * d * Math.PI / 360) / 2 + Math.cos(2 * d * Math.PI / 360) / 2), m = h.shadowScale, g = h.shadowScale / f, v = h.shadowOffset, t.transform("scale3d(" + m + ", 1, " + g + ") translate3d(0px, " + (s / 2 + v) + "px, " + -s / 2 / g + "px) rotateX(-90deg)")));
                        var P = H.isSafari || H.isWebView ? -l / 2 : 0;
                        n.transform("translate3d(0px,0," + P + "px) rotateX(" + (e.isHorizontal() ? 0 : p) + "deg) rotateY(" + (e.isHorizontal() ? -p : 0) + "deg)")
                    },
                    setTransition: function(t) {
                        var e = this.$el;
                        this.slides.transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), this.params.cubeEffect.shadow && !this.isHorizontal() && e.find(".swiper-cube-shadow").transition(t)
                    }
                },
                mt = {
                    setTranslate: function() {
                        for (var t = this.slides, e = this.rtlTranslate, i = 0; i < t.length; i += 1) {
                            var n = t.eq(i),
                                r = n[0].progress;
                            this.params.flipEffect.limitRotation && (r = Math.max(Math.min(n[0].progress, 1), -1));
                            var a, s, o = -180 * r,
                                l = 0,
                                h = -n[0].swiperSlideOffset,
                                u = 0;
                            this.isHorizontal() ? e && (o = -o) : (u = h, l = -o, o = h = 0), n[0].style.zIndex = -Math.abs(Math.round(r)) + t.length, this.params.flipEffect.slideShadows && (a = this.isHorizontal() ? n.find(".swiper-slide-shadow-left") : n.find(".swiper-slide-shadow-top"), s = this.isHorizontal() ? n.find(".swiper-slide-shadow-right") : n.find(".swiper-slide-shadow-bottom"), 0 === a.length && (a = L('<div class="swiper-slide-shadow-' + (this.isHorizontal() ? "left" : "top") + '"></div>'), n.append(a)), 0 === s.length && (s = L('<div class="swiper-slide-shadow-' + (this.isHorizontal() ? "right" : "bottom") + '"></div>'), n.append(s)), a.length && (a[0].style.opacity = Math.max(-r, 0)), s.length && (s[0].style.opacity = Math.max(r, 0))), n.transform("translate3d(" + h + "px, " + u + "px, 0px) rotateX(" + l + "deg) rotateY(" + o + "deg)")
                        }
                    },
                    setTransition: function(t) {
                        var i, n = this,
                            e = n.slides,
                            r = n.activeIndex,
                            a = n.$wrapperEl;
                        e.transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), n.params.virtualTranslate && 0 !== t && (i = !1, e.eq(r).transitionEnd(function() {
                            if (!i && n && !n.destroyed) {
                                i = !0, n.animating = !1;
                                for (var t = ["webkitTransitionEnd", "transitionend"], e = 0; e < t.length; e += 1) a.trigger(t[e])
                            }
                        }))
                    }
                },
                gt = {
                    setTranslate: function() {
                        for (var t = this.width, e = this.height, i = this.slides, n = this.$wrapperEl, r = this.slidesSizesGrid, a = this.params.coverflowEffect, s = this.isHorizontal(), o = this.translate, l = s ? t / 2 - o : e / 2 - o, h = s ? a.rotate : -a.rotate, u = a.depth, c = 0, p = i.length; c < p; c += 1) {
                            var d = i.eq(c),
                                f = r[c],
                                m = (l - d[0].swiperSlideOffset - f / 2) / f * a.modifier,
                                g = s ? h * m : 0,
                                v = s ? 0 : h * m,
                                y = -u * Math.abs(m),
                                b = a.stretch;
                            "string" == typeof b && -1 !== b.indexOf("%") && (b = parseFloat(a.stretch) / 100 * f);
                            var x = s ? 0 : b * m,
                                _ = s ? b * m : 0,
                                w = 1 - (1 - a.scale) * Math.abs(m);
                            Math.abs(_) < .001 && (_ = 0), Math.abs(x) < .001 && (x = 0), Math.abs(y) < .001 && (y = 0), Math.abs(g) < .001 && (g = 0), Math.abs(v) < .001 && (v = 0), Math.abs(w) < .001 && (w = 0);
                            var S, M, T = "translate3d(" + _ + "px," + x + "px," + y + "px)  rotateX(" + v + "deg) rotateY(" + g + "deg) scale(" + w + ")";
                            d.transform(T), d[0].style.zIndex = 1 - Math.abs(Math.round(m)), a.slideShadows && (S = s ? d.find(".swiper-slide-shadow-left") : d.find(".swiper-slide-shadow-top"), M = s ? d.find(".swiper-slide-shadow-right") : d.find(".swiper-slide-shadow-bottom"), 0 === S.length && (S = L('<div class="swiper-slide-shadow-' + (s ? "left" : "top") + '"></div>'), d.append(S)), 0 === M.length && (M = L('<div class="swiper-slide-shadow-' + (s ? "right" : "bottom") + '"></div>'), d.append(M)), S.length && (S[0].style.opacity = 0 < m ? m : 0), M.length && (M[0].style.opacity = 0 < -m ? -m : 0))
                        }(C.pointerEvents || C.prefixedPointerEvents) && (n[0].style.perspectiveOrigin = l + "px 50%")
                    },
                    setTransition: function(t) {
                        this.slides.transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t)
                    }
                },
                vt = {
                    init: function() {
                        var t = this,
                            e = t.params.thumbs,
                            i = t.constructor;
                        e.swiper instanceof i ? (t.thumbs.swiper = e.swiper, st.extend(t.thumbs.swiper.originalParams, {
                            watchSlidesProgress: !0,
                            slideToClickedSlide: !1
                        }), st.extend(t.thumbs.swiper.params, {
                            watchSlidesProgress: !0,
                            slideToClickedSlide: !1
                        })) : st.isObject(e.swiper) && (t.thumbs.swiper = new i(st.extend({}, e.swiper, {
                            watchSlidesVisibility: !0,
                            watchSlidesProgress: !0,
                            slideToClickedSlide: !1
                        })), t.thumbs.swiperCreated = !0), t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", t.thumbs.onThumbClick)
                    },
                    onThumbClick: function() {
                        var t, e, i, n, r, a, s = this,
                            o = s.thumbs.swiper;
                        o && (t = o.clickedIndex, (e = o.clickedSlide) && L(e).hasClass(s.params.thumbs.slideThumbActiveClass) || null != t && (a = o.params.loop ? parseInt(L(o.clickedSlide).attr("data-swiper-slide-index"), 10) : t, s.params.loop && (i = s.activeIndex, s.slides.eq(i).hasClass(s.params.slideDuplicateClass) && (s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft, i = s.activeIndex), n = s.slides.eq(i).prevAll('[data-swiper-slide-index="' + a + '"]').eq(0).index(), r = s.slides.eq(i).nextAll('[data-swiper-slide-index="' + a + '"]').eq(0).index(), a = void 0 === n || void 0 !== r && r - i < i - n ? r : n), s.slideTo(a)))
                    },
                    update: function(t) {
                        var e = this,
                            i = e.thumbs.swiper;
                        if (i) {
                            var n, r, a, s, o, l = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView,
                                h = e.params.thumbs.autoScrollOffset,
                                u = h && !i.params.loop;
                            e.realIndex === i.realIndex && !u || (n = i.activeIndex, o = i.params.loop ? (i.slides.eq(n).hasClass(i.params.slideDuplicateClass) && (i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft, n = i.activeIndex), r = i.slides.eq(n).prevAll('[data-swiper-slide-index="' + e.realIndex + '"]').eq(0).index(), a = i.slides.eq(n).nextAll('[data-swiper-slide-index="' + e.realIndex + '"]').eq(0).index(), s = void 0 === r ? a : void 0 === a ? r : a - n == n - r ? n : a - n < n - r ? a : r, e.activeIndex > e.previousIndex ? "next" : "prev") : (s = e.realIndex) > e.previousIndex ? "next" : "prev", u && (s += "next" === o ? h : -1 * h), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(s) < 0 && (i.params.centeredSlides ? s = n < s ? s - Math.floor(l / 2) + 1 : s + Math.floor(l / 2) - 1 : n < s && (s = s - l + 1), i.slideTo(s, t ? 0 : void 0)));
                            var c = 1,
                                p = e.params.thumbs.slideThumbActiveClass;
                            if (1 < e.params.slidesPerView && !e.params.centeredSlides && (c = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (c = 1), c = Math.floor(c), i.slides.removeClass(p), i.params.loop || i.params.virtual && i.params.virtual.enabled)
                                for (var d = 0; d < c; d += 1) i.$wrapperEl.children('[data-swiper-slide-index="' + (e.realIndex + d) + '"]').addClass(p);
                            else
                                for (var f = 0; f < c; f += 1) i.slides.eq(e.realIndex + f).addClass(p)
                        }
                    }
                },
                yt = [U, j, W, q, Y, Z, K, {
                    name: "mousewheel",
                    params: {
                        mousewheel: {
                            enabled: !1,
                            releaseOnEdges: !1,
                            invert: !1,
                            forceToAxis: !1,
                            sensitivity: 1,
                            eventsTarged: "container"
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            mousewheel: {
                                enabled: !1,
                                enable: Q.enable.bind(this),
                                disable: Q.disable.bind(this),
                                handle: Q.handle.bind(this),
                                handleMouseEnter: Q.handleMouseEnter.bind(this),
                                handleMouseLeave: Q.handleMouseLeave.bind(this),
                                animateSlider: Q.animateSlider.bind(this),
                                releaseScroll: Q.releaseScroll.bind(this),
                                lastScrollTime: st.now(),
                                lastEventBeforeSnap: void 0,
                                recentWheelEvents: []
                            }
                        })
                    },
                    on: {
                        init: function() {
                            !this.params.mousewheel.enabled && this.params.cssMode && this.mousewheel.disable(), this.params.mousewheel.enabled && this.mousewheel.enable()
                        },
                        destroy: function() {
                            this.params.cssMode && this.mousewheel.enable(), this.mousewheel.enabled && this.mousewheel.disable()
                        }
                    }
                }, {
                    name: "navigation",
                    params: {
                        navigation: {
                            nextEl: null,
                            prevEl: null,
                            hideOnClick: !1,
                            disabledClass: "swiper-button-disabled",
                            hiddenClass: "swiper-button-hidden",
                            lockClass: "swiper-button-lock"
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            navigation: {
                                init: tt.init.bind(this),
                                update: tt.update.bind(this),
                                destroy: tt.destroy.bind(this),
                                onNextClick: tt.onNextClick.bind(this),
                                onPrevClick: tt.onPrevClick.bind(this)
                            }
                        })
                    },
                    on: {
                        init: function() {
                            this.navigation.init(), this.navigation.update()
                        },
                        toEdge: function() {
                            this.navigation.update()
                        },
                        fromEdge: function() {
                            this.navigation.update()
                        },
                        destroy: function() {
                            this.navigation.destroy()
                        },
                        click: function(t) {
                            var e, i = this,
                                n = i.navigation,
                                r = n.$nextEl,
                                a = n.$prevEl;
                            !i.params.navigation.hideOnClick || L(t.target).is(a) || L(t.target).is(r) || (r ? e = r.hasClass(i.params.navigation.hiddenClass) : a && (e = a.hasClass(i.params.navigation.hiddenClass)), !0 === e ? i.emit("navigationShow", i) : i.emit("navigationHide", i), r && r.toggleClass(i.params.navigation.hiddenClass), a && a.toggleClass(i.params.navigation.hiddenClass))
                        }
                    }
                }, {
                    name: "pagination",
                    params: {
                        pagination: {
                            el: null,
                            bulletElement: "span",
                            clickable: !1,
                            hideOnClick: !1,
                            renderBullet: null,
                            renderProgressbar: null,
                            renderFraction: null,
                            renderCustom: null,
                            progressbarOpposite: !1,
                            type: "bullets",
                            dynamicBullets: !1,
                            dynamicMainBullets: 1,
                            formatFractionCurrent: function(t) {
                                return t
                            },
                            formatFractionTotal: function(t) {
                                return t
                            },
                            bulletClass: "swiper-pagination-bullet",
                            bulletActiveClass: "swiper-pagination-bullet-active",
                            modifierClass: "swiper-pagination-",
                            currentClass: "swiper-pagination-current",
                            totalClass: "swiper-pagination-total",
                            hiddenClass: "swiper-pagination-hidden",
                            progressbarFillClass: "swiper-pagination-progressbar-fill",
                            progressbarOppositeClass: "swiper-pagination-progressbar-opposite",
                            clickableClass: "swiper-pagination-clickable",
                            lockClass: "swiper-pagination-lock"
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            pagination: {
                                init: et.init.bind(this),
                                render: et.render.bind(this),
                                update: et.update.bind(this),
                                destroy: et.destroy.bind(this),
                                dynamicBulletIndex: 0
                            }
                        })
                    },
                    on: {
                        init: function() {
                            this.pagination.init(), this.pagination.render(), this.pagination.update()
                        },
                        activeIndexChange: function() {
                            !this.params.loop && void 0 !== this.snapIndex || this.pagination.update()
                        },
                        snapIndexChange: function() {
                            this.params.loop || this.pagination.update()
                        },
                        slidesLengthChange: function() {
                            this.params.loop && (this.pagination.render(), this.pagination.update())
                        },
                        snapGridLengthChange: function() {
                            this.params.loop || (this.pagination.render(), this.pagination.update())
                        },
                        destroy: function() {
                            this.pagination.destroy()
                        },
                        click: function(t) {
                            var e = this;
                            e.params.pagination.el && e.params.pagination.hideOnClick && 0 < e.pagination.$el.length && !L(t.target).hasClass(e.params.pagination.bulletClass) && (!0 === e.pagination.$el.hasClass(e.params.pagination.hiddenClass) ? e.emit("paginationShow", e) : e.emit("paginationHide", e), e.pagination.$el.toggleClass(e.params.pagination.hiddenClass))
                        }
                    }
                }, {
                    name: "scrollbar",
                    params: {
                        scrollbar: {
                            el: null,
                            dragSize: "auto",
                            hide: !1,
                            draggable: !1,
                            snapOnRelease: !0,
                            lockClass: "swiper-scrollbar-lock",
                            dragClass: "swiper-scrollbar-drag"
                        }
                    },
                    create: function() {
                        var t = this;
                        st.extend(t, {
                            scrollbar: {
                                init: it.init.bind(t),
                                destroy: it.destroy.bind(t),
                                updateSize: it.updateSize.bind(t),
                                setTranslate: it.setTranslate.bind(t),
                                setTransition: it.setTransition.bind(t),
                                enableDraggable: it.enableDraggable.bind(t),
                                disableDraggable: it.disableDraggable.bind(t),
                                setDragPosition: it.setDragPosition.bind(t),
                                getPointerPosition: it.getPointerPosition.bind(t),
                                onDragStart: it.onDragStart.bind(t),
                                onDragMove: it.onDragMove.bind(t),
                                onDragEnd: it.onDragEnd.bind(t),
                                isTouched: !1,
                                timeout: null,
                                dragTimeout: null
                            }
                        })
                    },
                    on: {
                        init: function() {
                            this.scrollbar.init(), this.scrollbar.updateSize(), this.scrollbar.setTranslate()
                        },
                        update: function() {
                            this.scrollbar.updateSize()
                        },
                        resize: function() {
                            this.scrollbar.updateSize()
                        },
                        observerUpdate: function() {
                            this.scrollbar.updateSize()
                        },
                        setTranslate: function() {
                            this.scrollbar.setTranslate()
                        },
                        setTransition: function(t) {
                            this.scrollbar.setTransition(t)
                        },
                        destroy: function() {
                            this.scrollbar.destroy()
                        }
                    }
                }, {
                    name: "parallax",
                    params: {
                        parallax: {
                            enabled: !1
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            parallax: {
                                setTransform: nt.setTransform.bind(this),
                                setTranslate: nt.setTranslate.bind(this),
                                setTransition: nt.setTransition.bind(this)
                            }
                        })
                    },
                    on: {
                        beforeInit: function() {
                            this.params.parallax.enabled && (this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0)
                        },
                        init: function() {
                            this.params.parallax.enabled && this.parallax.setTranslate()
                        },
                        setTranslate: function() {
                            this.params.parallax.enabled && this.parallax.setTranslate()
                        },
                        setTransition: function(t) {
                            this.params.parallax.enabled && this.parallax.setTransition(t)
                        }
                    }
                }, {
                    name: "zoom",
                    params: {
                        zoom: {
                            enabled: !1,
                            maxRatio: 3,
                            minRatio: 1,
                            toggle: !0,
                            containerClass: "swiper-zoom-container",
                            zoomedSlideClass: "swiper-slide-zoomed"
                        }
                    },
                    create: function() {
                        var n = this,
                            e = {
                                enabled: !1,
                                scale: 1,
                                currentScale: 1,
                                isScaling: !1,
                                gesture: {
                                    $slideEl: void 0,
                                    slideWidth: void 0,
                                    slideHeight: void 0,
                                    $imageEl: void 0,
                                    $imageWrapEl: void 0,
                                    maxRatio: 3
                                },
                                image: {
                                    isTouched: void 0,
                                    isMoved: void 0,
                                    currentX: void 0,
                                    currentY: void 0,
                                    minX: void 0,
                                    minY: void 0,
                                    maxX: void 0,
                                    maxY: void 0,
                                    width: void 0,
                                    height: void 0,
                                    startX: void 0,
                                    startY: void 0,
                                    touchesStart: {},
                                    touchesCurrent: {}
                                },
                                velocity: {
                                    x: void 0,
                                    y: void 0,
                                    prevPositionX: void 0,
                                    prevPositionY: void 0,
                                    prevTime: void 0
                                }
                            };
                        "onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out".split(" ").forEach(function(t) {
                            e[t] = rt[t].bind(n)
                        }), st.extend(n, {
                            zoom: e
                        });
                        var r = 1;
                        Object.defineProperty(n.zoom, "scale", {
                            get: function() {
                                return r
                            },
                            set: function(t) {
                                var e, i;
                                r !== t && (e = n.zoom.gesture.$imageEl ? n.zoom.gesture.$imageEl[0] : void 0, i = n.zoom.gesture.$slideEl ? n.zoom.gesture.$slideEl[0] : void 0, n.emit("zoomChange", t, e, i)), r = t
                            }
                        })
                    },
                    on: {
                        init: function() {
                            this.params.zoom.enabled && this.zoom.enable()
                        },
                        destroy: function() {
                            this.zoom.disable()
                        },
                        touchStart: function(t) {
                            this.zoom.enabled && this.zoom.onTouchStart(t)
                        },
                        touchEnd: function(t) {
                            this.zoom.enabled && this.zoom.onTouchEnd(t)
                        },
                        doubleTap: function(t) {
                            this.params.zoom.enabled && this.zoom.enabled && this.params.zoom.toggle && this.zoom.toggle(t)
                        },
                        transitionEnd: function() {
                            this.zoom.enabled && this.params.zoom.enabled && this.zoom.onTransitionEnd()
                        },
                        slideChange: function() {
                            this.zoom.enabled && this.params.zoom.enabled && this.params.cssMode && this.zoom.onTransitionEnd()
                        }
                    }
                }, {
                    name: "lazy",
                    params: {
                        lazy: {
                            enabled: !1,
                            loadPrevNext: !1,
                            loadPrevNextAmount: 1,
                            loadOnTransitionStart: !1,
                            elementClass: "swiper-lazy",
                            loadingClass: "swiper-lazy-loading",
                            loadedClass: "swiper-lazy-loaded",
                            preloaderClass: "swiper-lazy-preloader"
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            lazy: {
                                initialImageLoaded: !1,
                                load: ot.load.bind(this),
                                loadInSlide: ot.loadInSlide.bind(this)
                            }
                        })
                    },
                    on: {
                        beforeInit: function() {
                            this.params.lazy.enabled && this.params.preloadImages && (this.params.preloadImages = !1)
                        },
                        init: function() {
                            this.params.lazy.enabled && !this.params.loop && 0 === this.params.initialSlide && this.lazy.load()
                        },
                        scroll: function() {
                            this.params.freeMode && !this.params.freeModeSticky && this.lazy.load()
                        },
                        resize: function() {
                            this.params.lazy.enabled && this.lazy.load()
                        },
                        scrollbarDragMove: function() {
                            this.params.lazy.enabled && this.lazy.load()
                        },
                        transitionStart: function() {
                            this.params.lazy.enabled && (!this.params.lazy.loadOnTransitionStart && (this.params.lazy.loadOnTransitionStart || this.lazy.initialImageLoaded) || this.lazy.load())
                        },
                        transitionEnd: function() {
                            this.params.lazy.enabled && !this.params.lazy.loadOnTransitionStart && this.lazy.load()
                        },
                        slideChange: function() {
                            this.params.lazy.enabled && this.params.cssMode && this.lazy.load()
                        }
                    }
                }, {
                    name: "controller",
                    params: {
                        controller: {
                            control: void 0,
                            inverse: !1,
                            by: "slide"
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            controller: {
                                control: this.params.controller.control,
                                getInterpolateFunction: lt.getInterpolateFunction.bind(this),
                                setTranslate: lt.setTranslate.bind(this),
                                setTransition: lt.setTransition.bind(this)
                            }
                        })
                    },
                    on: {
                        update: function() {
                            this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline)
                        },
                        resize: function() {
                            this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline)
                        },
                        observerUpdate: function() {
                            this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline)
                        },
                        setTranslate: function(t, e) {
                            this.controller.control && this.controller.setTranslate(t, e)
                        },
                        setTransition: function(t, e) {
                            this.controller.control && this.controller.setTransition(t, e)
                        }
                    }
                }, {
                    name: "a11y",
                    params: {
                        a11y: {
                            enabled: !0,
                            notificationClass: "swiper-notification",
                            prevSlideMessage: "Previous slide",
                            nextSlideMessage: "Next slide",
                            firstSlideMessage: "This is the first slide",
                            lastSlideMessage: "This is the last slide",
                            paginationBulletMessage: "Go to slide {{index}}"
                        }
                    },
                    create: function() {
                        var e = this;
                        st.extend(e, {
                            a11y: {
                                liveRegion: L('<span class="' + e.params.a11y.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>')
                            }
                        }), Object.keys(ht).forEach(function(t) {
                            e.a11y[t] = ht[t].bind(e)
                        })
                    },
                    on: {
                        init: function() {
                            this.params.a11y.enabled && (this.a11y.init(), this.a11y.updateNavigation())
                        },
                        toEdge: function() {
                            this.params.a11y.enabled && this.a11y.updateNavigation()
                        },
                        fromEdge: function() {
                            this.params.a11y.enabled && this.a11y.updateNavigation()
                        },
                        paginationUpdate: function() {
                            this.params.a11y.enabled && this.a11y.updatePagination()
                        },
                        destroy: function() {
                            this.params.a11y.enabled && this.a11y.destroy()
                        }
                    }
                }, {
                    name: "history",
                    params: {
                        history: {
                            enabled: !1,
                            replaceState: !1,
                            key: "slides"
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            history: {
                                init: ut.init.bind(this),
                                setHistory: ut.setHistory.bind(this),
                                setHistoryPopState: ut.setHistoryPopState.bind(this),
                                scrollToSlide: ut.scrollToSlide.bind(this),
                                destroy: ut.destroy.bind(this)
                            }
                        })
                    },
                    on: {
                        init: function() {
                            this.params.history.enabled && this.history.init()
                        },
                        destroy: function() {
                            this.params.history.enabled && this.history.destroy()
                        },
                        transitionEnd: function() {
                            this.history.initialized && this.history.setHistory(this.params.history.key, this.activeIndex)
                        },
                        slideChange: function() {
                            this.history.initialized && this.params.cssMode && this.history.setHistory(this.params.history.key, this.activeIndex)
                        }
                    }
                }, {
                    name: "hash-navigation",
                    params: {
                        hashNavigation: {
                            enabled: !1,
                            replaceState: !1,
                            watchState: !1
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            hashNavigation: {
                                initialized: !1,
                                init: ct.init.bind(this),
                                destroy: ct.destroy.bind(this),
                                setHash: ct.setHash.bind(this),
                                onHashCange: ct.onHashCange.bind(this)
                            }
                        })
                    },
                    on: {
                        init: function() {
                            this.params.hashNavigation.enabled && this.hashNavigation.init()
                        },
                        destroy: function() {
                            this.params.hashNavigation.enabled && this.hashNavigation.destroy()
                        },
                        transitionEnd: function() {
                            this.hashNavigation.initialized && this.hashNavigation.setHash()
                        },
                        slideChange: function() {
                            this.hashNavigation.initialized && this.params.cssMode && this.hashNavigation.setHash()
                        }
                    }
                }, {
                    name: "autoplay",
                    params: {
                        autoplay: {
                            enabled: !1,
                            delay: 3e3,
                            waitForTransition: !0,
                            disableOnInteraction: !0,
                            stopOnLastSlide: !1,
                            reverseDirection: !1
                        }
                    },
                    create: function() {
                        var e = this;
                        st.extend(e, {
                            autoplay: {
                                running: !1,
                                paused: !1,
                                run: pt.run.bind(e),
                                start: pt.start.bind(e),
                                stop: pt.stop.bind(e),
                                pause: pt.pause.bind(e),
                                onVisibilityChange: function() {
                                    "hidden" === document.visibilityState && e.autoplay.running && e.autoplay.pause(), "visible" === document.visibilityState && e.autoplay.paused && (e.autoplay.run(), e.autoplay.paused = !1)
                                },
                                onTransitionEnd: function(t) {
                                    e && !e.destroyed && e.$wrapperEl && t.target === this && (e.$wrapperEl[0].removeEventListener("transitionend", e.autoplay.onTransitionEnd), e.$wrapperEl[0].removeEventListener("webkitTransitionEnd", e.autoplay.onTransitionEnd), e.autoplay.paused = !1, e.autoplay.running ? e.autoplay.run() : e.autoplay.stop())
                                }
                            }
                        })
                    },
                    on: {
                        init: function() {
                            this.params.autoplay.enabled && (this.autoplay.start(), document.addEventListener("visibilitychange", this.autoplay.onVisibilityChange))
                        },
                        beforeTransitionStart: function(t, e) {
                            this.autoplay.running && (e || !this.params.autoplay.disableOnInteraction ? this.autoplay.pause(t) : this.autoplay.stop())
                        },
                        sliderFirstMove: function() {
                            this.autoplay.running && (this.params.autoplay.disableOnInteraction ? this.autoplay.stop() : this.autoplay.pause())
                        },
                        touchEnd: function() {
                            this.params.cssMode && this.autoplay.paused && !this.params.autoplay.disableOnInteraction && this.autoplay.run()
                        },
                        destroy: function() {
                            this.autoplay.running && this.autoplay.stop(), document.removeEventListener("visibilitychange", this.autoplay.onVisibilityChange)
                        }
                    }
                }, {
                    name: "effect-fade",
                    params: {
                        fadeEffect: {
                            crossFade: !1
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            fadeEffect: {
                                setTranslate: dt.setTranslate.bind(this),
                                setTransition: dt.setTransition.bind(this)
                            }
                        })
                    },
                    on: {
                        beforeInit: function() {
                            var t;
                            "fade" === this.params.effect && (this.classNames.push(this.params.containerModifierClass + "fade"), t = {
                                slidesPerView: 1,
                                slidesPerColumn: 1,
                                slidesPerGroup: 1,
                                watchSlidesProgress: !0,
                                spaceBetween: 0,
                                virtualTranslate: !0
                            }, st.extend(this.params, t), st.extend(this.originalParams, t))
                        },
                        setTranslate: function() {
                            "fade" === this.params.effect && this.fadeEffect.setTranslate()
                        },
                        setTransition: function(t) {
                            "fade" === this.params.effect && this.fadeEffect.setTransition(t)
                        }
                    }
                }, {
                    name: "effect-cube",
                    params: {
                        cubeEffect: {
                            slideShadows: !0,
                            shadow: !0,
                            shadowOffset: 20,
                            shadowScale: .94
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            cubeEffect: {
                                setTranslate: ft.setTranslate.bind(this),
                                setTransition: ft.setTransition.bind(this)
                            }
                        })
                    },
                    on: {
                        beforeInit: function() {
                            var t;
                            "cube" === this.params.effect && (this.classNames.push(this.params.containerModifierClass + "cube"), this.classNames.push(this.params.containerModifierClass + "3d"), t = {
                                slidesPerView: 1,
                                slidesPerColumn: 1,
                                slidesPerGroup: 1,
                                watchSlidesProgress: !0,
                                resistanceRatio: 0,
                                spaceBetween: 0,
                                centeredSlides: !1,
                                virtualTranslate: !0
                            }, st.extend(this.params, t), st.extend(this.originalParams, t))
                        },
                        setTranslate: function() {
                            "cube" === this.params.effect && this.cubeEffect.setTranslate()
                        },
                        setTransition: function(t) {
                            "cube" === this.params.effect && this.cubeEffect.setTransition(t)
                        }
                    }
                }, {
                    name: "effect-flip",
                    params: {
                        flipEffect: {
                            slideShadows: !0,
                            limitRotation: !0
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            flipEffect: {
                                setTranslate: mt.setTranslate.bind(this),
                                setTransition: mt.setTransition.bind(this)
                            }
                        })
                    },
                    on: {
                        beforeInit: function() {
                            var t;
                            "flip" === this.params.effect && (this.classNames.push(this.params.containerModifierClass + "flip"), this.classNames.push(this.params.containerModifierClass + "3d"), t = {
                                slidesPerView: 1,
                                slidesPerColumn: 1,
                                slidesPerGroup: 1,
                                watchSlidesProgress: !0,
                                spaceBetween: 0,
                                virtualTranslate: !0
                            }, st.extend(this.params, t), st.extend(this.originalParams, t))
                        },
                        setTranslate: function() {
                            "flip" === this.params.effect && this.flipEffect.setTranslate()
                        },
                        setTransition: function(t) {
                            "flip" === this.params.effect && this.flipEffect.setTransition(t)
                        }
                    }
                }, {
                    name: "effect-coverflow",
                    params: {
                        coverflowEffect: {
                            rotate: 50,
                            stretch: 0,
                            depth: 100,
                            scale: 1,
                            modifier: 1,
                            slideShadows: !0
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            coverflowEffect: {
                                setTranslate: gt.setTranslate.bind(this),
                                setTransition: gt.setTransition.bind(this)
                            }
                        })
                    },
                    on: {
                        beforeInit: function() {
                            "coverflow" === this.params.effect && (this.classNames.push(this.params.containerModifierClass + "coverflow"), this.classNames.push(this.params.containerModifierClass + "3d"), this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0)
                        },
                        setTranslate: function() {
                            "coverflow" === this.params.effect && this.coverflowEffect.setTranslate()
                        },
                        setTransition: function(t) {
                            "coverflow" === this.params.effect && this.coverflowEffect.setTransition(t)
                        }
                    }
                }, {
                    name: "thumbs",
                    params: {
                        thumbs: {
                            swiper: null,
                            multipleActiveThumbs: !0,
                            autoScrollOffset: 0,
                            slideThumbActiveClass: "swiper-slide-thumb-active",
                            thumbsContainerClass: "swiper-container-thumbs"
                        }
                    },
                    create: function() {
                        st.extend(this, {
                            thumbs: {
                                swiper: null,
                                init: vt.init.bind(this),
                                update: vt.update.bind(this),
                                onThumbClick: vt.onThumbClick.bind(this)
                            }
                        })
                    },
                    on: {
                        beforeInit: function() {
                            var t = this.params.thumbs;
                            t && t.swiper && (this.thumbs.init(), this.thumbs.update(!0))
                        },
                        slideChange: function() {
                            this.thumbs.swiper && this.thumbs.update()
                        },
                        update: function() {
                            this.thumbs.swiper && this.thumbs.update()
                        },
                        resize: function() {
                            this.thumbs.swiper && this.thumbs.update()
                        },
                        observerUpdate: function() {
                            this.thumbs.swiper && this.thumbs.update()
                        },
                        setTransition: function(t) {
                            var e = this.thumbs.swiper;
                            e && e.setTransition(t)
                        },
                        beforeDestroy: function() {
                            var t = this.thumbs.swiper;
                            t && this.thumbs.swiperCreated && t && t.destroy()
                        }
                    }
                }];
            return void 0 === V.use && (V.use = V.Class.use, V.installModule = V.Class.installModule), V.use(yt), V
        }, "object" === ((n = void 0) === i ? "undefined" : bt(i)) && void 0 !== e ? e.exports = r() : "function" == typeof define && define.amd ? define(r) : (n = n || self).Swiper = r()
    }, {}],
    tabbyjs: [function(t, r, a) {
        (function(t) {
            "use strict";

            function e(t) {
                return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                })(t)
            }
            var i, n;
            Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), i = void 0 !== t ? t : "undefined" != typeof window ? window : void 0, n = function(l) {
                function h(n) {
                    var t, e, i, r, a, s, o;
                    n && "true" != n.getAttribute("aria-selected") && (t = document.querySelector(n.hash), t && (e = function() {
                        var t = n.closest('[role="tablist"]');
                        if (!t) return {};
                        var e = t.querySelector('[role="tab"][aria-selected="true"]');
                        if (!e) return {};
                        var i = document.querySelector(e.hash);
                        return e.setAttribute("aria-selected", "false"), e.setAttribute("tabindex", "-1"), i ? (i.setAttribute("hidden", "hidden"), {
                            previousTab: e,
                            previousContent: i
                        }) : {
                            previousTab: e
                        }
                    }(), o = t, (s = n).setAttribute("aria-selected", "true"), s.setAttribute("tabindex", "0"), o.removeAttribute("hidden"), s.focus(), e.tab = n, e.content = t, i = n, r = e, "function" == typeof l.CustomEvent ? a = new CustomEvent("tabby", {
                        bubbles: !0,
                        cancelable: !0,
                        detail: r
                    }) : (a = document.createEvent("CustomEvent")).initCustomEvent("tabby", !0, !0, r), i.dispatchEvent(a)))
                }
                var u = {
                    idPrefix: "tabby-toggle_",
                    default: "[data-tabby-default]"
                };
                return function(o, t) {
                    var e, i = {};
                    i.destroy = function() {
                        var t = e.querySelectorAll("a");
                        Array.prototype.forEach.call(t, function(t) {
                            var e, i, n, r = document.querySelector(t.hash);
                            r && (i = r, n = s, (e = t).id.slice(0, n.idPrefix.length) === n.idPrefix && (e.id = ""), e.removeAttribute("role"), e.removeAttribute("aria-controls"), e.removeAttribute("aria-selected"), e.removeAttribute("tabindex"), e.closest("li").removeAttribute("role"), i.removeAttribute("role"), i.removeAttribute("aria-labelledby"), i.removeAttribute("hidden"))
                        }), e.removeAttribute("role"), document.documentElement.removeEventListener("click", r, !0), e.removeEventListener("keydown", a, !0), e = s = null
                    }, i.setup = function() {
                        var t;
                        (e = document.querySelector(o)) && (t = e.querySelectorAll("a"), e.setAttribute("role", "tablist"), Array.prototype.forEach.call(t, function(t) {
                            var e, i, n, r = document.querySelector(t.hash);
                            r && (i = r, n = s, (e = t).id || (e.id = n.idPrefix + i.id), e.setAttribute("role", "tab"), e.setAttribute("aria-controls", i.id), e.closest("li").setAttribute("role", "presentation"), i.setAttribute("role", "tabpanel"), i.setAttribute("aria-labelledby", e.id), e.matches(n.default) ? e.setAttribute("aria-selected", "true") : (e.setAttribute("aria-selected", "false"), e.setAttribute("tabindex", "-1"), i.setAttribute("hidden", "hidden")))
                        }))
                    }, i.toggle = function(t) {
                        var e = t;
                        "string" == typeof t && (e = document.querySelector(o + ' [role="tab"][href*="' + t + '"]')), h(e)
                    };
                    var n, r = function(t) {
                            var e = t.target.closest(o + ' [role="tab"]');
                            e && (t.preventDefault(), h(e))
                        },
                        a = function(t) {
                            var e, i, n, r, a, s = document.activeElement;
                            s.matches(o + ' [role="tab"]') && (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Up", "Down", "Left", "Right", "Home", "End"].indexOf(t.key) < 0 || (e = s, i = t.key, a = function(t) {
                                var e = t.closest('[role="tablist"]'),
                                    i = e ? e.querySelectorAll('[role="tab"]') : null;
                                if (i) return {
                                    tabs: i,
                                    index: Array.prototype.indexOf.call(i, t)
                                }
                            }(e), a && (r = a.tabs.length - 1, -1 < ["ArrowUp", "ArrowLeft", "Up", "Left"].indexOf(i) ? n = a.index < 1 ? r : a.index - 1 : -1 < ["ArrowDown", "ArrowRight", "Down", "Right"].indexOf(i) ? n = a.index === r ? 0 : a.index + 1 : "Home" === i ? n = 0 : "End" === i && (n = r), h(a.tabs[n]))))
                        },
                        s = function() {
                            var i = {};
                            return Array.prototype.forEach.call(arguments, function(t) {
                                for (var e in t) {
                                    if (!t.hasOwnProperty(e)) return;
                                    i[e] = t[e]
                                }
                            }), i
                        }(u, t || {});
                    return i.setup(), l.location.hash.length < 1 || (n = document.querySelector(o + ' [role="tab"][href*="' + l.location.hash + '"]'), h(n)), document.documentElement.addEventListener("click", r, !0), e.addEventListener("keydown", a, !0), i
                }
            }, "function" == typeof define && define.amd ? define([], function() {
                return n(i)
            }) : "object" == (void 0 === a ? "undefined" : e(a)) ? r.exports = n(i) : i.Tabby = n(i)
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    "three/examples/jsm/postprocessing/EffectComposer": [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.Pass = i.EffectComposer = void 0;

        function n(t, e) {
            var i, n;
            this.renderer = t, void 0 === e ? (i = {
                minFilter: r.LinearFilter,
                magFilter: r.LinearFilter,
                format: r.RGBAFormat
            }, n = t.getSize(new r.Vector2), this._pixelRatio = t.getPixelRatio(), this._width = n.width, this._height = n.height, (e = new r.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, i)).texture.name = "EffectComposer.rt1") : (this._pixelRatio = 1, this._width = e.width, this._height = e.height), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], a.CopyShader, s.ShaderPass, this.copyPass = new s.ShaderPass(a.CopyShader), this.clock = new r.Clock
        }
        var r = t("../../../build/three.module.js"),
            a = t("../shaders/CopyShader.js"),
            s = t("../postprocessing/ShaderPass.js"),
            l = t("../postprocessing/MaskPass.js");
        i.EffectComposer = n, Object.assign(n.prototype, {
            swapBuffers: function() {
                var t = this.readBuffer;
                this.readBuffer = this.writeBuffer, this.writeBuffer = t
            },
            addPass: function(t) {
                this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            },
            insertPass: function(t, e) {
                this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            },
            isLastEnabledPass: function(t) {
                for (var e = t + 1; e < this.passes.length; e++)
                    if (this.passes[e].enabled) return !1;
                return !0
            },
            render: function(t) {
                void 0 === t && (t = this.clock.getDelta());
                for (var e, i, n, r = this.renderer.getRenderTarget(), a = !1, s = this.passes.length, o = 0; o < s; o++) {
                    !1 !== (e = this.passes[o]).enabled && (e.renderToScreen = this.renderToScreen && this.isLastEnabledPass(o), e.render(this.renderer, this.writeBuffer, this.readBuffer, t, a), e.needsSwap && (a && (i = this.renderer.getContext(), (n = this.renderer.state.buffers.stencil).setFunc(i.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), n.setFunc(i.EQUAL, 1, 4294967295)), this.swapBuffers()), void 0 !== l.MaskPass && (e instanceof l.MaskPass ? a = !0 : e instanceof l.ClearMaskPass && (a = !1)))
                }
                this.renderer.setRenderTarget(r)
            },
            reset: function(t) {
                var e;
                void 0 === t && (e = this.renderer.getSize(new r.Vector2), this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)), this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
            },
            setSize: function(t, e) {
                this._width = t, this._height = e;
                var i = this._width * this._pixelRatio,
                    n = this._height * this._pixelRatio;
                this.renderTarget1.setSize(i, n), this.renderTarget2.setSize(i, n);
                for (var r = 0; r < this.passes.length; r++) this.passes[r].setSize(i, n)
            },
            setPixelRatio: function(t) {
                this._pixelRatio = t, this.setSize(this._width, this._height)
            }
        });

        function o() {
            this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
        }
        var h, u;

        function c(t) {
            this._mesh = new r.Mesh(u, t)
        }
        i.Pass = o, Object.assign(o.prototype, {
            setSize: function() {},
            render: function() {}
        }), o.FullScreenQuad = (h = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1), u = new r.PlaneBufferGeometry(2, 2), Object.defineProperty(c.prototype, "material", {
            get: function() {
                return this._mesh.material
            },
            set: function(t) {
                this._mesh.material = t
            }
        }), Object.assign(c.prototype, {
            dispose: function() {
                this._mesh.geometry.dispose()
            },
            render: function(t) {
                t.render(this._mesh, h)
            }
        }), c)
    }, {
        "../../../build/three.module.js": 4,
        "../postprocessing/MaskPass.js": 5,
        "../postprocessing/ShaderPass.js": "three/examples/jsm/postprocessing/ShaderPass",
        "../shaders/CopyShader.js": "three/examples/jsm/shaders/CopyShader"
    }],
    "three/examples/jsm/postprocessing/RenderPass": [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.RenderPass = void 0;

        function n(t, e, i, n, r) {
            a.Pass.call(this), this.scene = t, this.camera = e, this.overrideMaterial = i, this.clearColor = n, this.clearAlpha = void 0 !== r ? r : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1
        }
        var a = t("../postprocessing/Pass.js");
        (i.RenderPass = n).prototype = Object.assign(Object.create(a.Pass.prototype), {
            constructor: n,
            render: function(t, e, i) {
                var n, r, a, s = t.autoClear;
                t.autoClear = !1, void 0 !== this.overrideMaterial && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (n = t.getClearColor().getHex(), r = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : i), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(n, r), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = a), t.autoClear = s
            }
        })
    }, {
        "../postprocessing/Pass.js": 6
    }],
    "three/examples/jsm/postprocessing/SavePass": [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.SavePass = void 0;

        function n(t) {
            a.Pass.call(this), s.CopyShader;
            var e = s.CopyShader;
            this.textureID = "tDiffuse", this.uniforms = r.UniformsUtils.clone(e.uniforms), this.material = new r.ShaderMaterial({
                uniforms: this.uniforms,
                vertexShader: e.vertexShader,
                fragmentShader: e.fragmentShader
            }), this.renderTarget = t, void 0 === this.renderTarget && (this.renderTarget = new r.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                minFilter: r.LinearFilter,
                magFilter: r.LinearFilter,
                format: r.RGBFormat
            }), this.renderTarget.texture.name = "SavePass.rt"), this.needsSwap = !1, this.fsQuad = new a.Pass.FullScreenQuad(this.material)
        }
        var r = t("../../../build/three.module.js"),
            a = t("../postprocessing/Pass.js"),
            s = t("../shaders/CopyShader.js");
        (i.SavePass = n).prototype = Object.assign(Object.create(a.Pass.prototype), {
            constructor: n,
            render: function(t, e, i) {
                this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), t.setRenderTarget(this.renderTarget), this.clear && t.clear(), this.fsQuad.render(t)
            }
        })
    }, {
        "../../../build/three.module.js": 4,
        "../postprocessing/Pass.js": 6,
        "../shaders/CopyShader.js": "three/examples/jsm/shaders/CopyShader"
    }],
    "three/examples/jsm/postprocessing/ShaderPass": [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.ShaderPass = void 0;

        function n(t, e) {
            a.Pass.call(this), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof r.ShaderMaterial ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = r.UniformsUtils.clone(t.uniforms), this.material = new r.ShaderMaterial({
                defines: Object.assign({}, t.defines),
                uniforms: this.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader
            })), this.fsQuad = new a.Pass.FullScreenQuad(this.material)
        }
        var r = t("../../../build/three.module.js"),
            a = t("../postprocessing/Pass.js");
        (i.ShaderPass = n).prototype = Object.assign(Object.create(a.Pass.prototype), {
            constructor: n,
            render: function(t, e, i) {
                this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? t.setRenderTarget(null) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil)), this.fsQuad.render(t)
            }
        })
    }, {
        "../../../build/three.module.js": 4,
        "../postprocessing/Pass.js": 6
    }],
    "three/examples/jsm/shaders/BlendShader": [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.BlendShader = void 0;
        var n = {
            uniforms: {
                tDiffuse1: {
                    value: null
                },
                tDiffuse2: {
                    value: null
                },
                mixRatio: {
                    value: .5
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "uniform float mixRatio;", "uniform sampler2D tDiffuse1;", "uniform sampler2D tDiffuse2;", "varying vec2 vUv;", "void main() {", "\tvec4 texel1 = texture2D( tDiffuse1, vUv );", "\tvec4 texel2 = texture2D( tDiffuse2, vUv );", "\tgl_FragColor = opacity * mix( texel1, texel2, mixRatio );", "}"].join("\n")
        };
        i.BlendShader = n
    }, {}],
    "three/examples/jsm/shaders/CopyShader": [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.CopyShader = void 0;
        var n = {
            uniforms: {
                tDiffuse: {
                    value: null
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "\tvec4 texel = texture2D( tDiffuse, vUv );", "\tgl_FragColor = opacity * texel;", "}"].join("\n")
        };
        i.CopyShader = n
    }, {}],
    three: [function(t, e, i) {
        "use strict";

        function Wp(t) {
            return (Wp = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        var n, r;
        r = function(t) {
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
                return "number" == typeof t && isFinite(t) && Math.floor(t) === t
            }), void 0 === Math.sign && (Math.sign = function(t) {
                return t < 0 ? -1 : 0 < t ? 1 : +t
            }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && (Object.assign = function(t) {
                if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), i = 1; i < arguments.length; i++) {
                    var n = arguments[i];
                    if (null != n)
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            });
            var j = 0,
                H = 1,
                W = 2,
                I = 1,
                N = 2,
                B = 3,
                k = 0,
                q = 1,
                X = 2,
                Y = 0,
                J = 1,
                Z = 2,
                $ = 3,
                K = 4,
                Q = 5,
                tt = 100,
                et = 101,
                it = 102,
                nt = 103,
                rt = 104,
                at = 200,
                st = 201,
                ot = 202,
                lt = 203,
                ht = 204,
                ut = 205,
                ct = 206,
                pt = 207,
                dt = 208,
                ft = 209,
                mt = 210,
                gt = 0,
                vt = 1,
                yt = 2,
                bt = 3,
                xt = 4,
                _t = 5,
                wt = 6,
                St = 7,
                R = 0,
                z = 1,
                G = 2,
                Tt = 0,
                V = 1,
                U = 2,
                Mt = 3,
                Ct = 4,
                At = 5,
                Et = 301,
                Dt = 302,
                u = 303,
                c = 304,
                Pt = 306,
                Lt = 307,
                kt = 1e3,
                Ot = 1001,
                Ft = 1002,
                It = 1003,
                Nt = 1004,
                Bt = 1005,
                Rt = 1006,
                zt = 1007,
                Gt = 1008,
                Vt = 1009,
                r = 1010,
                a = 1011,
                Ut = 1012,
                s = 1013,
                jt = 1014,
                Ht = 1015,
                Wt = 1016,
                o = 1017,
                l = 1018,
                h = 1019,
                qt = 1020,
                p = 1021,
                Xt = 1022,
                Yt = 1023,
                d = 1024,
                f = 1025,
                m = Yt,
                Jt = 1026,
                Zt = 1027,
                g = 1028,
                v = 1029,
                y = 1030,
                b = 1031,
                x = 1032,
                _ = 1033,
                w = 33776,
                S = 33777,
                M = 33778,
                T = 33779,
                C = 35840,
                A = 35841,
                E = 35842,
                D = 35843,
                P = 36196,
                L = 37492,
                O = 37496,
                F = 37808,
                $t = 37809,
                Kt = 37810,
                Qt = 37811,
                te = 37812,
                ee = 37813,
                ie = 37814,
                ne = 37815,
                re = 37816,
                ae = 37817,
                se = 37818,
                oe = 37819,
                le = 37820,
                he = 37821,
                ue = 36492,
                ce = 37840,
                pe = 37841,
                de = 37842,
                fe = 37843,
                me = 37844,
                ge = 37845,
                ve = 37846,
                ye = 37847,
                be = 37848,
                xe = 37849,
                _e = 37850,
                we = 37851,
                Se = 37852,
                Me = 37853,
                Te = 3e3,
                Ce = 3001,
                Ae = 3007,
                Ee = 3002,
                e = 3003,
                i = 3004,
                n = 3005,
                De = 3006,
                Pe = 3200,
                Le = 3201,
                ke = 0,
                Oe = 1,
                Fe = 7680,
                Ie = 519,
                Ne = 35044,
                Be = 35048,
                Re = "300 es";

            function ze() {}
            Object.assign(ze.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    var i = this._listeners;
                    void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var i = this._listeners;
                    return void 0 !== i[t] && -1 !== i[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    var i, n;
                    void 0 !== this._listeners && (void 0 === (i = this._listeners[t]) || -1 !== (n = i.indexOf(e)) && i.splice(n, 1))
                },
                dispatchEvent: function(t) {
                    if (void 0 !== this._listeners) {
                        var e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            for (var i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, t)
                        }
                    }
                }
            });
            for (var Ge = [], Ve = 0; Ve < 256; Ve++) Ge[Ve] = (Ve < 16 ? "0" : "") + Ve.toString(16);
            var Ue = 1234567,
                je = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        var t = 4294967295 * Math.random() | 0,
                            e = 4294967295 * Math.random() | 0,
                            i = 4294967295 * Math.random() | 0,
                            n = 4294967295 * Math.random() | 0;
                        return (Ge[255 & t] + Ge[t >> 8 & 255] + Ge[t >> 16 & 255] + Ge[t >> 24 & 255] + "-" + Ge[255 & e] + Ge[e >> 8 & 255] + "-" + Ge[e >> 16 & 15 | 64] + Ge[e >> 24 & 255] + "-" + Ge[63 & i | 128] + Ge[i >> 8 & 255] + "-" + Ge[i >> 16 & 255] + Ge[i >> 24 & 255] + Ge[255 & n] + Ge[n >> 8 & 255] + Ge[n >> 16 & 255] + Ge[n >> 24 & 255]).toUpperCase()
                    },
                    clamp: function(t, e, i) {
                        return Math.max(e, Math.min(i, t))
                    },
                    euclideanModulo: function(t, e) {
                        return (t % e + e) % e
                    },
                    mapLinear: function(t, e, i, n, r) {
                        return n + (t - e) * (r - n) / (i - e)
                    },
                    lerp: function(t, e, i) {
                        return (1 - i) * t + i * e
                    },
                    smoothstep: function(t, e, i) {
                        return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, i) {
                        return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    seededRandom: function(t) {
                        return void 0 !== t && (Ue = t % 2147483647), ((Ue = 16807 * Ue % 2147483647) - 1) / 2147483646
                    },
                    degToRad: function(t) {
                        return t * je.DEG2RAD
                    },
                    radToDeg: function(t) {
                        return t * je.RAD2DEG
                    },
                    isPowerOfTwo: function(t) {
                        return 0 == (t & t - 1) && 0 !== t
                    },
                    ceilPowerOfTwo: function(t) {
                        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                    },
                    floorPowerOfTwo: function(t) {
                        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                    },
                    setQuaternionFromProperEuler: function(t, e, i, n, r) {
                        var a = Math.cos,
                            s = Math.sin,
                            o = a(i / 2),
                            l = s(i / 2),
                            h = a((e + n) / 2),
                            u = s((e + n) / 2),
                            c = a((e - n) / 2),
                            p = s((e - n) / 2),
                            d = a((n - e) / 2),
                            f = s((n - e) / 2);
                        switch (r) {
                            case "XYX":
                                t.set(o * u, l * c, l * p, o * h);
                                break;
                            case "YZY":
                                t.set(l * p, o * u, l * c, o * h);
                                break;
                            case "ZXZ":
                                t.set(l * c, l * p, o * u, o * h);
                                break;
                            case "XZX":
                                t.set(o * u, l * f, l * d, o * h);
                                break;
                            case "YXY":
                                t.set(l * d, o * u, l * f, o * h);
                                break;
                            case "ZYZ":
                                t.set(l * f, l * d, o * u, o * h)
                        }
                    }
                },
                He = function(t, e) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), Object.defineProperty(this, "isVector2", {
                        value: !0
                    }), this.x = t, this.y = e
                },
                We = {
                    width: {
                        configurable: !0
                    },
                    height: {
                        configurable: !0
                    }
                };
            We.width.get = function() {
                return this.x
            }, We.width.set = function(t) {
                this.x = t
            }, We.height.get = function() {
                return this.y
            }, We.height.set = function(t) {
                this.y = t
            }, He.prototype.set = function(t, e) {
                return this.x = t, this.y = e, this
            }, He.prototype.setScalar = function(t) {
                return this.x = t, this.y = t, this
            }, He.prototype.setX = function(t) {
                return this.x = t, this
            }, He.prototype.setY = function(t) {
                return this.y = t, this
            }, He.prototype.setComponent = function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }, He.prototype.getComponent = function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }, He.prototype.clone = function() {
                return new this.constructor(this.x, this.y)
            }, He.prototype.copy = function(t) {
                return this.x = t.x, this.y = t.y, this
            }, He.prototype.add = function(t, e) {
                return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this)
            }, He.prototype.addScalar = function(t) {
                return this.x += t, this.y += t, this
            }, He.prototype.addVectors = function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            }, He.prototype.addScaledVector = function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            }, He.prototype.sub = function(t, e) {
                return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this)
            }, He.prototype.subScalar = function(t) {
                return this.x -= t, this.y -= t, this
            }, He.prototype.subVectors = function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            }, He.prototype.multiply = function(t) {
                return this.x *= t.x, this.y *= t.y, this
            }, He.prototype.multiplyScalar = function(t) {
                return this.x *= t, this.y *= t, this
            }, He.prototype.divide = function(t) {
                return this.x /= t.x, this.y /= t.y, this
            }, He.prototype.divideScalar = function(t) {
                return this.multiplyScalar(1 / t)
            }, He.prototype.applyMatrix3 = function(t) {
                var e = this.x,
                    i = this.y,
                    n = t.elements;
                return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
            }, He.prototype.min = function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }, He.prototype.max = function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }, He.prototype.clamp = function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }, He.prototype.clampScalar = function(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            }, He.prototype.clampLength = function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            }, He.prototype.floor = function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }, He.prototype.ceil = function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }, He.prototype.round = function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }, He.prototype.roundToZero = function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }, He.prototype.negate = function() {
                return this.x = -this.x, this.y = -this.y, this
            }, He.prototype.dot = function(t) {
                return this.x * t.x + this.y * t.y
            }, He.prototype.cross = function(t) {
                return this.x * t.y - this.y * t.x
            }, He.prototype.lengthSq = function() {
                return this.x * this.x + this.y * this.y
            }, He.prototype.length = function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }, He.prototype.manhattanLength = function() {
                return Math.abs(this.x) + Math.abs(this.y)
            }, He.prototype.normalize = function() {
                return this.divideScalar(this.length() || 1)
            }, He.prototype.angle = function() {
                var t = Math.atan2(-this.y, -this.x) + Math.PI;
                return t
            }, He.prototype.distanceTo = function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }, He.prototype.distanceToSquared = function(t) {
                var e = this.x - t.x,
                    i = this.y - t.y;
                return e * e + i * i
            }, He.prototype.manhattanDistanceTo = function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }, He.prototype.setLength = function(t) {
                return this.normalize().multiplyScalar(t)
            }, He.prototype.lerp = function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }, He.prototype.lerpVectors = function(t, e, i) {
                return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this
            }, He.prototype.equals = function(t) {
                return t.x === this.x && t.y === this.y
            }, He.prototype.fromArray = function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
            }, He.prototype.toArray = function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
            }, He.prototype.fromBufferAttribute = function(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this
            }, He.prototype.rotateAround = function(t, e) {
                var i = Math.cos(e),
                    n = Math.sin(e),
                    r = this.x - t.x,
                    a = this.y - t.y;
                return this.x = r * i - a * n + t.x, this.y = r * n + a * i + t.y, this
            }, He.prototype.random = function() {
                return this.x = Math.random(), this.y = Math.random(), this
            }, Object.defineProperties(He.prototype, We);
            var qe, Xe = function() {
                Object.defineProperty(this, "isMatrix3", {
                    value: !0
                }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
            };
            Xe.prototype.set = function(t, e, i, n, r, a, s, o, l) {
                var h = this.elements;
                return h[0] = t, h[1] = n, h[2] = s, h[3] = e, h[4] = r, h[5] = o, h[6] = i, h[7] = a, h[8] = l, this
            }, Xe.prototype.identity = function() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }, Xe.prototype.clone = function() {
                return (new this.constructor).fromArray(this.elements)
            }, Xe.prototype.copy = function(t) {
                var e = this.elements,
                    i = t.elements;
                return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
            }, Xe.prototype.extractBasis = function(t, e, i) {
                return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
            }, Xe.prototype.setFromMatrix4 = function(t) {
                var e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }, Xe.prototype.multiply = function(t) {
                return this.multiplyMatrices(this, t)
            }, Xe.prototype.premultiply = function(t) {
                return this.multiplyMatrices(t, this)
            }, Xe.prototype.multiplyMatrices = function(t, e) {
                var i = t.elements,
                    n = e.elements,
                    r = this.elements,
                    a = i[0],
                    s = i[3],
                    o = i[6],
                    l = i[1],
                    h = i[4],
                    u = i[7],
                    c = i[2],
                    p = i[5],
                    d = i[8],
                    f = n[0],
                    m = n[3],
                    g = n[6],
                    v = n[1],
                    y = n[4],
                    b = n[7],
                    x = n[2],
                    _ = n[5],
                    w = n[8];
                return r[0] = a * f + s * v + o * x, r[3] = a * m + s * y + o * _, r[6] = a * g + s * b + o * w, r[1] = l * f + h * v + u * x, r[4] = l * m + h * y + u * _, r[7] = l * g + h * b + u * w, r[2] = c * f + p * v + d * x, r[5] = c * m + p * y + d * _, r[8] = c * g + p * b + d * w, this
            }, Xe.prototype.multiplyScalar = function(t) {
                var e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            }, Xe.prototype.determinant = function() {
                var t = this.elements,
                    e = t[0],
                    i = t[1],
                    n = t[2],
                    r = t[3],
                    a = t[4],
                    s = t[5],
                    o = t[6],
                    l = t[7],
                    h = t[8];
                return e * a * h - e * s * l - i * r * h + i * s * o + n * r * l - n * a * o
            }, Xe.prototype.getInverse = function(t) {
                var e = t.elements,
                    i = this.elements,
                    n = e[0],
                    r = e[1],
                    a = e[2],
                    s = e[3],
                    o = e[4],
                    l = e[5],
                    h = e[6],
                    u = e[7],
                    c = e[8],
                    p = c * o - l * u,
                    d = l * h - c * s,
                    f = u * s - o * h,
                    m = n * p + r * d + a * f;
                if (0 == m) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                var g = 1 / m;
                return i[0] = p * g, i[1] = (a * u - c * r) * g, i[2] = (l * r - a * o) * g, i[3] = d * g, i[4] = (c * n - a * h) * g, i[5] = (a * s - l * n) * g, i[6] = f * g, i[7] = (r * h - u * n) * g, i[8] = (o * n - r * s) * g, this
            }, Xe.prototype.transpose = function() {
                var t = this.elements,
                    e = t[1];
                return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
            }, Xe.prototype.getNormalMatrix = function(t) {
                return this.setFromMatrix4(t).getInverse(this).transpose()
            }, Xe.prototype.transposeIntoArray = function(t) {
                var e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }, Xe.prototype.setUvTransform = function(t, e, i, n, r, a, s) {
                var o = Math.cos(r),
                    l = Math.sin(r);
                this.set(i * o, i * l, -i * (o * a + l * s) + a + t, -n * l, n * o, -n * (-l * a + o * s) + s + e, 0, 0, 1)
            }, Xe.prototype.scale = function(t, e) {
                var i = this.elements;
                return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
            }, Xe.prototype.rotate = function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t),
                    n = this.elements,
                    r = n[0],
                    a = n[3],
                    s = n[6],
                    o = n[1],
                    l = n[4],
                    h = n[7];
                return n[0] = e * r + i * o, n[3] = e * a + i * l, n[6] = e * s + i * h, n[1] = -i * r + e * o, n[4] = -i * a + e * l, n[7] = -i * s + e * h, this
            }, Xe.prototype.translate = function(t, e) {
                var i = this.elements;
                return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
            }, Xe.prototype.equals = function(t) {
                for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
                    if (e[n] !== i[n]) return !1;
                return !0
            }, Xe.prototype.fromArray = function(t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
                return this
            }, Xe.prototype.toArray = function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
            };
            var Ye = {
                    getDataURL: function(t) {
                        if (/^data:/i.test(t.src)) return t.src;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        var e, i = t instanceof HTMLCanvasElement ? t : (void 0 === qe && (qe = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), qe.width = t.width, qe.height = t.height, e = qe.getContext("2d"), t instanceof ImageData ? e.putImageData(t, 0, 0) : e.drawImage(t, 0, 0, t.width, t.height), qe);
                        return 2048 < i.width || 2048 < i.height ? i.toDataURL("image/jpeg", .6) : i.toDataURL("image/png")
                    }
                },
                Je = 0;

            function Ze(t, e, i, n, r, a, s, o, l, h) {
                Object.defineProperty(this, "id", {
                    value: Je++
                }), this.uuid = je.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Ze.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Ze.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : Ot, this.wrapT = void 0 !== n ? n : Ot, this.magFilter = void 0 !== r ? r : Rt, this.minFilter = void 0 !== a ? a : Gt, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== s ? s : Yt, this.internalFormat = null, this.type = void 0 !== o ? o : Vt, this.offset = new He(0, 0), this.repeat = new He(1, 1), this.center = new He(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Xe, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== h ? h : Te, this.version = 0, this.onUpdate = null
            }
            Ze.DEFAULT_IMAGE = void 0, Ze.DEFAULT_MAPPING = 300, Ze.prototype = Object.assign(Object.create(ze.prototype), {
                constructor: Ze,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    var i = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        var n, r = this.image;
                        if (void 0 === r.uuid && (r.uuid = je.generateUUID()), !e && void 0 === t.images[r.uuid]) {
                            if (Array.isArray(r)) {
                                n = [];
                                for (var a = 0, s = r.length; a < s; a++) n.push(Ye.getDataURL(r[a]))
                            } else n = Ye.getDataURL(r);
                            t.images[r.uuid] = {
                                uuid: r.uuid,
                                url: n
                            }
                        }
                        i.image = r.uuid
                    }
                    return e || (t.textures[this.uuid] = i), i
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (300 !== this.mapping) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || 1 < t.x) switch (this.wrapS) {
                        case kt:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case Ot:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case Ft:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || 1 < t.y) switch (this.wrapT) {
                        case kt:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case Ot:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case Ft:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
            }), Object.defineProperty(Ze.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            });
            var $e = function(t, e, i, n) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), Object.defineProperty(this, "isVector4", {
                        value: !0
                    }), this.x = t, this.y = e, this.z = i, this.w = n
                },
                Ke = {
                    width: {
                        configurable: !0
                    },
                    height: {
                        configurable: !0
                    }
                };

            function Qe(t, e, i) {
                this.width = t, this.height = e, this.scissor = new $e(0, 0, t, e), this.scissorTest = !1, this.viewport = new $e(0, 0, t, e), i = i || {}, this.texture = new Ze(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Rt, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
            }

            function ti(t, e, i) {
                Qe.call(this, t, e, i), this.samples = 4
            }
            Ke.width.get = function() {
                return this.z
            }, Ke.width.set = function(t) {
                this.z = t
            }, Ke.height.get = function() {
                return this.w
            }, Ke.height.set = function(t) {
                this.w = t
            }, $e.prototype.set = function(t, e, i, n) {
                return this.x = t, this.y = e, this.z = i, this.w = n, this
            }, $e.prototype.setScalar = function(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            }, $e.prototype.setX = function(t) {
                return this.x = t, this
            }, $e.prototype.setY = function(t) {
                return this.y = t, this
            }, $e.prototype.setZ = function(t) {
                return this.z = t, this
            }, $e.prototype.setW = function(t) {
                return this.w = t, this
            }, $e.prototype.setComponent = function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }, $e.prototype.getComponent = function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }, $e.prototype.clone = function() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }, $e.prototype.copy = function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            }, $e.prototype.add = function(t, e) {
                return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            }, $e.prototype.addScalar = function(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            }, $e.prototype.addVectors = function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            }, $e.prototype.addScaledVector = function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            }, $e.prototype.sub = function(t, e) {
                return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            }, $e.prototype.subScalar = function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            }, $e.prototype.subVectors = function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            }, $e.prototype.multiplyScalar = function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            }, $e.prototype.applyMatrix4 = function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = this.w,
                    a = t.elements;
                return this.x = a[0] * e + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * e + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * e + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * e + a[7] * i + a[11] * n + a[15] * r, this
            }, $e.prototype.divideScalar = function(t) {
                return this.multiplyScalar(1 / t)
            }, $e.prototype.setAxisAngleFromQuaternion = function(t) {
                this.w = 2 * Math.acos(t.w);
                var e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            }, $e.prototype.setAxisAngleFromRotationMatrix = function(t) {
                var e, i, n, r, a = t.elements,
                    s = a[0],
                    o = a[4],
                    l = a[8],
                    h = a[1],
                    u = a[5],
                    c = a[9],
                    p = a[2],
                    d = a[6],
                    f = a[10];
                if (Math.abs(o - h) < .01 && Math.abs(l - p) < .01 && Math.abs(c - d) < .01) {
                    if (Math.abs(o + h) < .1 && Math.abs(l + p) < .1 && Math.abs(c + d) < .1 && Math.abs(s + u + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    var m = (s + 1) / 2,
                        g = (u + 1) / 2,
                        v = (f + 1) / 2,
                        y = (o + h) / 4,
                        b = (l + p) / 4,
                        x = (c + d) / 4;
                    return g < m && v < m ? r = m < .01 ? (i = 0, n = .707106781) : (n = y / (i = Math.sqrt(m)), b / i) : v < g ? r = g < .01 ? (n = 0, i = .707106781) : (i = y / (n = Math.sqrt(g)), x / n) : v < .01 ? (n = i = .707106781, r = 0) : (i = b / (r = Math.sqrt(v)), n = x / r), this.set(i, n, r, e), this
                }
                var _ = Math.sqrt((d - c) * (d - c) + (l - p) * (l - p) + (h - o) * (h - o));
                return Math.abs(_) < .001 && (_ = 1), this.x = (d - c) / _, this.y = (l - p) / _, this.z = (h - o) / _, this.w = Math.acos((s + u + f - 1) / 2), this
            }, $e.prototype.min = function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            }, $e.prototype.max = function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            }, $e.prototype.clamp = function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            }, $e.prototype.clampScalar = function(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            }, $e.prototype.clampLength = function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            }, $e.prototype.floor = function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }, $e.prototype.ceil = function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }, $e.prototype.round = function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }, $e.prototype.roundToZero = function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }, $e.prototype.negate = function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }, $e.prototype.dot = function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }, $e.prototype.lengthSq = function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }, $e.prototype.length = function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }, $e.prototype.manhattanLength = function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }, $e.prototype.normalize = function() {
                return this.divideScalar(this.length() || 1)
            }, $e.prototype.setLength = function(t) {
                return this.normalize().multiplyScalar(t)
            }, $e.prototype.lerp = function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            }, $e.prototype.lerpVectors = function(t, e, i) {
                return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this
            }, $e.prototype.equals = function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }, $e.prototype.fromArray = function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            }, $e.prototype.toArray = function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            }, $e.prototype.fromBufferAttribute = function(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }, $e.prototype.random = function() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }, Object.defineProperties($e.prototype, Ke), Qe.prototype = Object.assign(Object.create(ze.prototype), {
                constructor: Qe,
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), ti.prototype = Object.assign(Object.create(Qe.prototype), {
                constructor: ti,
                isWebGLMultisampleRenderTarget: !0,
                copy: function(t) {
                    return Qe.prototype.copy.call(this, t), this.samples = t.samples, this
                }
            });
            var ei = function(t, e, i, n) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), Object.defineProperty(this, "isQuaternion", {
                        value: !0
                    }), this._x = t, this._y = e, this._z = i, this._w = n
                },
                ii = {
                    x: {
                        configurable: !0
                    },
                    y: {
                        configurable: !0
                    },
                    z: {
                        configurable: !0
                    },
                    w: {
                        configurable: !0
                    }
                };
            ei.slerp = function(t, e, i, n) {
                return i.copy(t).slerp(e, n)
            }, ei.slerpFlat = function(t, e, i, n, r, a, s) {
                var o, l, h, u, c, p, d, f, m = i[n + 0],
                    g = i[n + 1],
                    v = i[n + 2],
                    y = i[n + 3],
                    b = r[a + 0],
                    x = r[a + 1],
                    _ = r[a + 2],
                    w = r[a + 3];
                y === w && m === b && g === x && v === _ || (p = 1 - s, l = 0 <= (o = m * b + g * x + v * _ + y * w) ? 1 : -1, (h = 1 - o * o) > Number.EPSILON && (u = Math.sqrt(h), c = Math.atan2(u, o * l), p = Math.sin(p * c) / u, s = Math.sin(s * c) / u), m = m * p + b * (d = s * l), g = g * p + x * d, v = v * p + _ * d, y = y * p + w * d, p === 1 - s && (m *= f = 1 / Math.sqrt(m * m + g * g + v * v + y * y), g *= f, v *= f, y *= f)), t[e] = m, t[e + 1] = g, t[e + 2] = v, t[e + 3] = y
            }, ei.multiplyQuaternionsFlat = function(t, e, i, n, r, a) {
                var s = i[n],
                    o = i[n + 1],
                    l = i[n + 2],
                    h = i[n + 3],
                    u = r[a],
                    c = r[a + 1],
                    p = r[a + 2],
                    d = r[a + 3];
                return t[e] = s * d + h * u + o * p - l * c, t[e + 1] = o * d + h * c + l * u - s * p, t[e + 2] = l * d + h * p + s * c - o * u, t[e + 3] = h * d - s * u - o * c - l * p, t
            }, ii.x.get = function() {
                return this._x
            }, ii.x.set = function(t) {
                this._x = t, this._onChangeCallback()
            }, ii.y.get = function() {
                return this._y
            }, ii.y.set = function(t) {
                this._y = t, this._onChangeCallback()
            }, ii.z.get = function() {
                return this._z
            }, ii.z.set = function(t) {
                this._z = t, this._onChangeCallback()
            }, ii.w.get = function() {
                return this._w
            }, ii.w.set = function(t) {
                this._w = t, this._onChangeCallback()
            }, ei.prototype.set = function(t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this
            }, ei.prototype.clone = function() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }, ei.prototype.copy = function(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            }, ei.prototype.setFromEuler = function(t, e) {
                if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var i = t._x,
                    n = t._y,
                    r = t._z,
                    a = t._order,
                    s = Math.cos,
                    o = Math.sin,
                    l = s(i / 2),
                    h = s(n / 2),
                    u = s(r / 2),
                    c = o(i / 2),
                    p = o(n / 2),
                    d = o(r / 2);
                switch (a) {
                    case "XYZ":
                        this._x = c * h * u + l * p * d, this._y = l * p * u - c * h * d, this._z = l * h * d + c * p * u, this._w = l * h * u - c * p * d;
                        break;
                    case "YXZ":
                        this._x = c * h * u + l * p * d, this._y = l * p * u - c * h * d, this._z = l * h * d - c * p * u, this._w = l * h * u + c * p * d;
                        break;
                    case "ZXY":
                        this._x = c * h * u - l * p * d, this._y = l * p * u + c * h * d, this._z = l * h * d + c * p * u, this._w = l * h * u - c * p * d;
                        break;
                    case "ZYX":
                        this._x = c * h * u - l * p * d, this._y = l * p * u + c * h * d, this._z = l * h * d - c * p * u, this._w = l * h * u + c * p * d;
                        break;
                    case "YZX":
                        this._x = c * h * u + l * p * d, this._y = l * p * u + c * h * d, this._z = l * h * d - c * p * u, this._w = l * h * u - c * p * d;
                        break;
                    case "XZY":
                        this._x = c * h * u - l * p * d, this._y = l * p * u - c * h * d, this._z = l * h * d + c * p * u, this._w = l * h * u + c * p * d
                }
                return !1 !== e && this._onChangeCallback(), this
            }, ei.prototype.setFromAxisAngle = function(t, e) {
                var i = e / 2,
                    n = Math.sin(i);
                return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this
            }, ei.prototype.setFromRotationMatrix = function(t) {
                var e, i, n, r, a = t.elements,
                    s = a[0],
                    o = a[4],
                    l = a[8],
                    h = a[1],
                    u = a[5],
                    c = a[9],
                    p = a[2],
                    d = a[6],
                    f = a[10],
                    m = s + u + f;
                return 0 < m ? (e = .5 / Math.sqrt(m + 1), this._w = .25 / e, this._x = (d - c) * e, this._y = (l - p) * e, this._z = (h - o) * e) : u < s && f < s ? (i = 2 * Math.sqrt(1 + s - u - f), this._w = (d - c) / i, this._x = .25 * i, this._y = (o + h) / i, this._z = (l + p) / i) : f < u ? (n = 2 * Math.sqrt(1 + u - s - f), this._w = (l - p) / n, this._x = (o + h) / n, this._y = .25 * n, this._z = (c + d) / n) : (r = 2 * Math.sqrt(1 + f - s - u), this._w = (h - o) / r, this._x = (l + p) / r, this._y = (c + d) / r, this._z = .25 * r), this._onChangeCallback(), this
            }, ei.prototype.setFromUnitVectors = function(t, e) {
                var i = t.dot(e) + 1;
                return i < 1e-6 ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0) : (this._x = 0, this._y = -t.z, this._z = t.y)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x), this._w = i, this.normalize()
            }, ei.prototype.angleTo = function(t) {
                return 2 * Math.acos(Math.abs(je.clamp(this.dot(t), -1, 1)))
            }, ei.prototype.rotateTowards = function(t, e) {
                var i = this.angleTo(t);
                if (0 === i) return this;
                var n = Math.min(1, e / i);
                return this.slerp(t, n), this
            }, ei.prototype.identity = function() {
                return this.set(0, 0, 0, 1)
            }, ei.prototype.inverse = function() {
                return this.conjugate()
            }, ei.prototype.conjugate = function() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }, ei.prototype.dot = function(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }, ei.prototype.lengthSq = function() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }, ei.prototype.length = function() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }, ei.prototype.normalize = function() {
                var t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
            }, ei.prototype.multiply = function(t, e) {
                return void 0 !== e ? this.multiplyQuaternions(t, e) : this.multiplyQuaternions(this, t)
            }, ei.prototype.premultiply = function(t) {
                return this.multiplyQuaternions(t, this)
            }, ei.prototype.multiplyQuaternions = function(t, e) {
                var i = t._x,
                    n = t._y,
                    r = t._z,
                    a = t._w,
                    s = e._x,
                    o = e._y,
                    l = e._z,
                    h = e._w;
                return this._x = i * h + a * s + n * l - r * o, this._y = n * h + a * o + r * s - i * l, this._z = r * h + a * l + i * o - n * s, this._w = a * h - i * s - n * o - r * l, this._onChangeCallback(), this
            }, ei.prototype.slerp = function(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                var i = this._x,
                    n = this._y,
                    r = this._z,
                    a = this._w,
                    s = a * t._w + i * t._x + n * t._y + r * t._z;
                if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), 1 <= s) return this._w = a, this._x = i, this._y = n, this._z = r, this;
                var o = 1 - s * s;
                if (o <= Number.EPSILON) {
                    var l = 1 - e;
                    return this._w = l * a + e * this._w, this._x = l * i + e * this._x, this._y = l * n + e * this._y, this._z = l * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                }
                var h = Math.sqrt(o),
                    u = Math.atan2(h, s),
                    c = Math.sin((1 - e) * u) / h,
                    p = Math.sin(e * u) / h;
                return this._w = a * c + this._w * p, this._x = i * c + this._x * p, this._y = n * c + this._y * p, this._z = r * c + this._z * p, this._onChangeCallback(), this
            }, ei.prototype.equals = function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }, ei.prototype.fromArray = function(t, e) {
                return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            }, ei.prototype.toArray = function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            }, ei.prototype.fromBufferAttribute = function(t, e) {
                return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
            }, ei.prototype._onChange = function(t) {
                return this._onChangeCallback = t, this
            }, ei.prototype._onChangeCallback = function() {}, Object.defineProperties(ei.prototype, ii);
            var ni = function(t, e, i) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), Object.defineProperty(this, "isVector3", {
                    value: !0
                }), this.x = t, this.y = e, this.z = i
            };
            ni.prototype.set = function(t, e, i) {
                return void 0 === i && (i = this.z), this.x = t, this.y = e, this.z = i, this
            }, ni.prototype.setScalar = function(t) {
                return this.x = t, this.y = t, this.z = t, this
            }, ni.prototype.setX = function(t) {
                return this.x = t, this
            }, ni.prototype.setY = function(t) {
                return this.y = t, this
            }, ni.prototype.setZ = function(t) {
                return this.z = t, this
            }, ni.prototype.setComponent = function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }, ni.prototype.getComponent = function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }, ni.prototype.clone = function() {
                return new this.constructor(this.x, this.y, this.z)
            }, ni.prototype.copy = function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }, ni.prototype.add = function(t, e) {
                return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            }, ni.prototype.addScalar = function(t) {
                return this.x += t, this.y += t, this.z += t, this
            }, ni.prototype.addVectors = function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            }, ni.prototype.addScaledVector = function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            }, ni.prototype.sub = function(t, e) {
                return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            }, ni.prototype.subScalar = function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            }, ni.prototype.subVectors = function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            }, ni.prototype.multiply = function(t, e) {
                return void 0 !== e ? this.multiplyVectors(t, e) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            }, ni.prototype.multiplyScalar = function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            }, ni.prototype.multiplyVectors = function(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            }, ni.prototype.applyEuler = function(t) {
                return t && t.isEuler, this.applyQuaternion(si.setFromEuler(t))
            }, ni.prototype.applyAxisAngle = function(t, e) {
                return this.applyQuaternion(si.setFromAxisAngle(t, e))
            }, ni.prototype.applyMatrix3 = function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
            }, ni.prototype.applyNormalMatrix = function(t) {
                return this.applyMatrix3(t).normalize()
            }, ni.prototype.applyMatrix4 = function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.elements,
                    a = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * a, this
            }, ni.prototype.applyQuaternion = function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.x,
                    a = t.y,
                    s = t.z,
                    o = t.w,
                    l = o * e + a * n - s * i,
                    h = o * i + s * e - r * n,
                    u = o * n + r * i - a * e,
                    c = -r * e - a * i - s * n;
                return this.x = l * o + c * -r + h * -s - u * -a, this.y = h * o + c * -a + u * -r - l * -s, this.z = u * o + c * -s + l * -a - h * -r, this
            }, ni.prototype.project = function(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }, ni.prototype.unproject = function(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }, ni.prototype.transformDirection = function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
            }, ni.prototype.divide = function(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }, ni.prototype.divideScalar = function(t) {
                return this.multiplyScalar(1 / t)
            }, ni.prototype.min = function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }, ni.prototype.max = function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }, ni.prototype.clamp = function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }, ni.prototype.clampScalar = function(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            }, ni.prototype.clampLength = function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            }, ni.prototype.floor = function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }, ni.prototype.ceil = function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }, ni.prototype.round = function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }, ni.prototype.roundToZero = function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }, ni.prototype.negate = function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }, ni.prototype.dot = function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }, ni.prototype.lengthSq = function() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }, ni.prototype.length = function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }, ni.prototype.manhattanLength = function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }, ni.prototype.normalize = function() {
                return this.divideScalar(this.length() || 1)
            }, ni.prototype.setLength = function(t) {
                return this.normalize().multiplyScalar(t)
            }, ni.prototype.lerp = function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }, ni.prototype.lerpVectors = function(t, e, i) {
                return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this
            }, ni.prototype.cross = function(t, e) {
                return void 0 !== e ? this.crossVectors(t, e) : this.crossVectors(this, t)
            }, ni.prototype.crossVectors = function(t, e) {
                var i = t.x,
                    n = t.y,
                    r = t.z,
                    a = e.x,
                    s = e.y,
                    o = e.z;
                return this.x = n * o - r * s, this.y = r * a - i * o, this.z = i * s - n * a, this
            }, ni.prototype.projectOnVector = function(t) {
                var e = t.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                var i = t.dot(this) / e;
                return this.copy(t).multiplyScalar(i)
            }, ni.prototype.projectOnPlane = function(t) {
                return ai.copy(this).projectOnVector(t), this.sub(ai)
            }, ni.prototype.reflect = function(t) {
                return this.sub(ai.copy(t).multiplyScalar(2 * this.dot(t)))
            }, ni.prototype.angleTo = function(t) {
                var e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                var i = this.dot(t) / e;
                return Math.acos(je.clamp(i, -1, 1))
            }, ni.prototype.distanceTo = function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }, ni.prototype.distanceToSquared = function(t) {
                var e = this.x - t.x,
                    i = this.y - t.y,
                    n = this.z - t.z;
                return e * e + i * i + n * n
            }, ni.prototype.manhattanDistanceTo = function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }, ni.prototype.setFromSpherical = function(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }, ni.prototype.setFromSphericalCoords = function(t, e, i) {
                var n = Math.sin(e) * t;
                return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
            }, ni.prototype.setFromCylindrical = function(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }, ni.prototype.setFromCylindricalCoords = function(t, e, i) {
                return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
            }, ni.prototype.setFromMatrixPosition = function(t) {
                var e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }, ni.prototype.setFromMatrixScale = function(t) {
                var e = this.setFromMatrixColumn(t, 0).length(),
                    i = this.setFromMatrixColumn(t, 1).length(),
                    n = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = i, this.z = n, this
            }, ni.prototype.setFromMatrixColumn = function(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }, ni.prototype.setFromMatrix3Column = function(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }, ni.prototype.equals = function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }, ni.prototype.fromArray = function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }, ni.prototype.toArray = function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }, ni.prototype.fromBufferAttribute = function(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }, ni.prototype.random = function() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            };

            function ri(t, e) {
                Object.defineProperty(this, "isBox3", {
                    value: !0
                }), this.min = void 0 !== t ? t : new ni(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new ni(-1 / 0, -1 / 0, -1 / 0)
            }
            var ai = new ni,
                si = new ei;

            function oi(t, e, i, n, r) {
                for (var a = 0, s = t.length - 3; a <= s; a += 3) {
                    _i.fromArray(t, a);
                    var o = r.x * Math.abs(_i.x) + r.y * Math.abs(_i.y) + r.z * Math.abs(_i.z),
                        l = e.dot(_i),
                        h = i.dot(_i),
                        u = n.dot(_i);
                    if (Math.max(-Math.max(l, h, u), Math.min(l, h, u)) > o) return !1
                }
                return !0
            }
            ri.prototype.set = function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }, ri.prototype.setFromArray = function(t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, l = t.length; o < l; o += 3) {
                    var h = t[o],
                        u = t[o + 1],
                        c = t[o + 2];
                    h < e && (e = h), u < i && (i = u), c < n && (n = c), r < h && (r = h), a < u && (a = u), s < c && (s = c)
                }
                return this.min.set(e, i, n), this.max.set(r, a, s), this
            }, ri.prototype.setFromBufferAttribute = function(t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, l = t.count; o < l; o++) {
                    var h = t.getX(o),
                        u = t.getY(o),
                        c = t.getZ(o);
                    h < e && (e = h), u < i && (i = u), c < n && (n = c), r < h && (r = h), a < u && (a = u), s < c && (s = c)
                }
                return this.min.set(e, i, n), this.max.set(r, a, s), this
            }, ri.prototype.setFromPoints = function(t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            }, ri.prototype.setFromCenterAndSize = function(t, e) {
                var i = ui.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
            }, ri.prototype.setFromObject = function(t) {
                return this.makeEmpty(), this.expandByObject(t)
            }, ri.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, ri.prototype.copy = function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }, ri.prototype.makeEmpty = function() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }, ri.prototype.isEmpty = function() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }, ri.prototype.getCenter = function(t) {
                return void 0 === t && (t = new ni), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }, ri.prototype.getSize = function(t) {
                return void 0 === t && (t = new ni), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }, ri.prototype.expandByPoint = function(t) {
                return this.min.min(t), this.max.max(t), this
            }, ri.prototype.expandByVector = function(t) {
                return this.min.sub(t), this.max.add(t), this
            }, ri.prototype.expandByScalar = function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }, ri.prototype.expandByObject = function(t) {
                t.updateWorldMatrix(!1, !1);
                var e = t.geometry;
                void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), ci.copy(e.boundingBox), ci.applyMatrix4(t.matrixWorld), this.union(ci));
                for (var i = t.children, n = 0, r = i.length; n < r; n++) this.expandByObject(i[n]);
                return this
            }, ri.prototype.containsPoint = function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }, ri.prototype.containsBox = function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }, ri.prototype.getParameter = function(t, e) {
                return void 0 === e && (e = new ni), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }, ri.prototype.intersectsBox = function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }, ri.prototype.intersectsSphere = function(t) {
                return this.clampPoint(t.center, ui), ui.distanceToSquared(t.center) <= t.radius * t.radius
            }, ri.prototype.intersectsPlane = function(t) {
                var e, i = 0 < t.normal.x ? (e = t.normal.x * this.min.x, t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, t.normal.x * this.min.x);
                return 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
            }, ri.prototype.intersectsTriangle = function(t) {
                if (this.isEmpty()) return !1;
                this.getCenter(yi), bi.subVectors(this.max, yi), pi.subVectors(t.a, yi), di.subVectors(t.b, yi), fi.subVectors(t.c, yi), mi.subVectors(di, pi), gi.subVectors(fi, di), vi.subVectors(pi, fi);
                var e = [0, -mi.z, mi.y, 0, -gi.z, gi.y, 0, -vi.z, vi.y, mi.z, 0, -mi.x, gi.z, 0, -gi.x, vi.z, 0, -vi.x, -mi.y, mi.x, 0, -gi.y, gi.x, 0, -vi.y, vi.x, 0];
                return !!oi(e, pi, di, fi, bi) && (!!oi(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], pi, di, fi, bi) && (xi.crossVectors(mi, gi), oi(e = [xi.x, xi.y, xi.z], pi, di, fi, bi)))
            }, ri.prototype.clampPoint = function(t, e) {
                return void 0 === e && (e = new ni), e.copy(t).clamp(this.min, this.max)
            }, ri.prototype.distanceToPoint = function(t) {
                return ui.copy(t).clamp(this.min, this.max).sub(t).length()
            }, ri.prototype.getBoundingSphere = function(t) {
                return this.getCenter(t.center), t.radius = .5 * this.getSize(ui).length(), t
            }, ri.prototype.intersect = function(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }, ri.prototype.union = function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }, ri.prototype.applyMatrix4 = function(t) {
                return this.isEmpty() || (hi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), hi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), hi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), hi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), hi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), hi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), hi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), hi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(hi)), this
            }, ri.prototype.translate = function(t) {
                return this.min.add(t), this.max.add(t), this
            }, ri.prototype.equals = function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            };

            function li(t, e) {
                this.center = void 0 !== t ? t : new ni, this.radius = void 0 !== e ? e : -1
            }
            var hi = [new ni, new ni, new ni, new ni, new ni, new ni, new ni, new ni],
                ui = new ni,
                ci = new ri,
                pi = new ni,
                di = new ni,
                fi = new ni,
                mi = new ni,
                gi = new ni,
                vi = new ni,
                yi = new ni,
                bi = new ni,
                xi = new ni,
                _i = new ni,
                wi = new ri;
            li.prototype.set = function(t, e) {
                return this.center.copy(t), this.radius = e, this
            }, li.prototype.setFromPoints = function(t, e) {
                var i = this.center;
                void 0 !== e ? i.copy(e) : wi.setFromPoints(t).getCenter(i);
                for (var n = 0, r = 0, a = t.length; r < a; r++) n = Math.max(n, i.distanceToSquared(t[r]));
                return this.radius = Math.sqrt(n), this
            }, li.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, li.prototype.copy = function(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }, li.prototype.isEmpty = function() {
                return this.radius < 0
            }, li.prototype.makeEmpty = function() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }, li.prototype.containsPoint = function(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }, li.prototype.distanceToPoint = function(t) {
                return t.distanceTo(this.center) - this.radius
            }, li.prototype.intersectsSphere = function(t) {
                var e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }, li.prototype.intersectsBox = function(t) {
                return t.intersectsSphere(this)
            }, li.prototype.intersectsPlane = function(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }, li.prototype.clampPoint = function(t, e) {
                var i = this.center.distanceToSquared(t);
                return void 0 === e && (e = new ni), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }, li.prototype.getBoundingBox = function(t) {
                return void 0 === t && (t = new ri), this.isEmpty() ? t.makeEmpty() : (t.set(this.center, this.center), t.expandByScalar(this.radius)), t
            }, li.prototype.applyMatrix4 = function(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }, li.prototype.translate = function(t) {
                return this.center.add(t), this
            }, li.prototype.equals = function(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            };

            function Si(t, e) {
                this.origin = void 0 !== t ? t : new ni, this.direction = void 0 !== e ? e : new ni(0, 0, -1)
            }
            var Mi = new ni,
                Ti = new ni,
                Ci = new ni,
                Ai = new ni,
                Ei = new ni,
                Di = new ni,
                Pi = new ni;
            Si.prototype.set = function(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }, Si.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, Si.prototype.copy = function(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }, Si.prototype.at = function(t, e) {
                return void 0 === e && (e = new ni), e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }, Si.prototype.lookAt = function(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }, Si.prototype.recast = function(t) {
                return this.origin.copy(this.at(t, Mi)), this
            }, Si.prototype.closestPointToPoint = function(t, e) {
                void 0 === e && (e = new ni), e.subVectors(t, this.origin);
                var i = e.dot(this.direction);
                return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
            }, Si.prototype.distanceToPoint = function(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }, Si.prototype.distanceSqToPoint = function(t) {
                var e = Mi.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (Mi.copy(this.direction).multiplyScalar(e).add(this.origin), Mi.distanceToSquared(t))
            }, Si.prototype.distanceSqToSegment = function(t, e, i, n) {
                Ti.copy(t).add(e).multiplyScalar(.5), Ci.copy(e).sub(t).normalize(), Ai.copy(this.origin).sub(Ti);
                var r, a, s, o, l, h = .5 * t.distanceTo(e),
                    u = -this.direction.dot(Ci),
                    c = Ai.dot(this.direction),
                    p = -Ai.dot(Ci),
                    d = Ai.lengthSq(),
                    f = Math.abs(1 - u * u);
                return a = 0 < f ? (o = u * c - p, l = h * f, 0 <= (s = u * p - c) ? -l <= o ? o <= l ? (s *= r = 1 / f) * (s + u * (o *= r) + 2 * c) + o * (u * s + o + 2 * p) + d : (o = h, -(s = Math.max(0, -(u * o + c))) * s + o * (o + 2 * p) + d) : (o = -h, -(s = Math.max(0, -(u * o + c))) * s + o * (o + 2 * p) + d) : o <= -l ? -(s = Math.max(0, -(-u * h + c))) * s + (o = 0 < s ? -h : Math.min(Math.max(-h, -p), h)) * (o + 2 * p) + d : o <= l ? (s = 0, (o = Math.min(Math.max(-h, -p), h)) * (o + 2 * p) + d) : -(s = Math.max(0, -(u * h + c))) * s + (o = 0 < s ? h : Math.min(Math.max(-h, -p), h)) * (o + 2 * p) + d) : (o = 0 < u ? -h : h, -(s = Math.max(0, -(u * o + c))) * s + o * (o + 2 * p) + d), i && i.copy(this.direction).multiplyScalar(s).add(this.origin), n && n.copy(Ci).multiplyScalar(o).add(Ti), a
            }, Si.prototype.intersectSphere = function(t, e) {
                Mi.subVectors(t.center, this.origin);
                var i = Mi.dot(this.direction),
                    n = Mi.dot(Mi) - i * i,
                    r = t.radius * t.radius;
                if (r < n) return null;
                var a = Math.sqrt(r - n),
                    s = i - a,
                    o = i + a;
                return s < 0 && o < 0 ? null : s < 0 ? this.at(o, e) : this.at(s, e)
            }, Si.prototype.intersectsSphere = function(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }, Si.prototype.distanceToPlane = function(t) {
                var e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                var i = -(this.origin.dot(t.normal) + t.constant) / e;
                return 0 <= i ? i : null
            }, Si.prototype.intersectPlane = function(t, e) {
                var i = this.distanceToPlane(t);
                return null === i ? null : this.at(i, e)
            }, Si.prototype.intersectsPlane = function(t) {
                var e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            }, Si.prototype.intersectBox = function(t, e) {
                var i, n, r, a, s = 1 / this.direction.x,
                    o = 1 / this.direction.y,
                    l = 1 / this.direction.z,
                    h = this.origin,
                    u = 0 <= s ? (i = (t.min.x - h.x) * s, (t.max.x - h.x) * s) : (i = (t.max.x - h.x) * s, (t.min.x - h.x) * s),
                    c = 0 <= o ? (n = (t.min.y - h.y) * o, (t.max.y - h.y) * o) : (n = (t.max.y - h.y) * o, (t.min.y - h.y) * o);
                return c < i || u < n ? null : ((i < n || i != i) && (i = n), (c < u || u != u) && (u = c), (a = 0 <= l ? (r = (t.min.z - h.z) * l, (t.max.z - h.z) * l) : (r = (t.max.z - h.z) * l, (t.min.z - h.z) * l)) < i || u < r ? null : ((i < r || i != i) && (i = r), (a < u || u != u) && (u = a), u < 0 ? null : this.at(0 <= i ? i : u, e)))
            }, Si.prototype.intersectsBox = function(t) {
                return null !== this.intersectBox(t, Mi)
            }, Si.prototype.intersectTriangle = function(t, e, i, n, r) {
                Ei.subVectors(e, t), Di.subVectors(i, t), Pi.crossVectors(Ei, Di);
                var a, s = this.direction.dot(Pi);
                if (0 < s) {
                    if (n) return null;
                    a = 1
                } else {
                    if (!(s < 0)) return null;
                    a = -1, s = -s
                }
                Ai.subVectors(this.origin, t);
                var o = a * this.direction.dot(Di.crossVectors(Ai, Di));
                if (o < 0) return null;
                var l = a * this.direction.dot(Ei.cross(Ai));
                if (l < 0) return null;
                if (s < o + l) return null;
                var h = -a * Ai.dot(Pi);
                return h < 0 ? null : this.at(h / s, r)
            }, Si.prototype.applyMatrix4 = function(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            }, Si.prototype.equals = function(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            };
            var Li = function() {
                Object.defineProperty(this, "isMatrix4", {
                    value: !0
                }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
            };
            Li.prototype.set = function(t, e, i, n, r, a, s, o, l, h, u, c, p, d, f, m) {
                var g = this.elements;
                return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = h, g[10] = u, g[14] = c, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this
            }, Li.prototype.identity = function() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }, Li.prototype.clone = function() {
                return (new Li).fromArray(this.elements)
            }, Li.prototype.copy = function(t) {
                var e = this.elements,
                    i = t.elements;
                return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
            }, Li.prototype.copyPosition = function(t) {
                var e = this.elements,
                    i = t.elements;
                return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
            }, Li.prototype.extractBasis = function(t, e, i) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
            }, Li.prototype.makeBasis = function(t, e, i) {
                return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
            }, Li.prototype.extractRotation = function(t) {
                var e = this.elements,
                    i = t.elements,
                    n = 1 / ki.setFromMatrixColumn(t, 0).length(),
                    r = 1 / ki.setFromMatrixColumn(t, 1).length(),
                    a = 1 / ki.setFromMatrixColumn(t, 2).length();
                return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * a, e[9] = i[9] * a, e[10] = i[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }, Li.prototype.makeRotationFromEuler = function(t) {
                t && t.isEuler;
                var e, i, n, r, a, s, o, l, h, u, c, p, d, f, m, g, v, y, b, x, _, w, S, M, T = this.elements,
                    C = t.x,
                    A = t.y,
                    E = t.z,
                    D = Math.cos(C),
                    P = Math.sin(C),
                    L = Math.cos(A),
                    k = Math.sin(A),
                    O = Math.cos(E),
                    F = Math.sin(E);
                return "XYZ" === t.order ? (e = D * O, i = D * F, n = P * O, r = P * F, T[0] = L * O, T[4] = -L * F, T[8] = k, T[1] = i + n * k, T[5] = e - r * k, T[9] = -P * L, T[2] = r - e * k, T[6] = n + i * k, T[10] = D * L) : "YXZ" === t.order ? (a = L * O, s = L * F, o = k * O, l = k * F, T[0] = a + l * P, T[4] = o * P - s, T[8] = D * k, T[1] = D * F, T[5] = D * O, T[9] = -P, T[2] = s * P - o, T[6] = l + a * P, T[10] = D * L) : "ZXY" === t.order ? (h = L * O, u = L * F, c = k * O, p = k * F, T[0] = h - p * P, T[4] = -D * F, T[8] = c + u * P, T[1] = u + c * P, T[5] = D * O, T[9] = p - h * P, T[2] = -D * k, T[6] = P, T[10] = D * L) : "ZYX" === t.order ? (d = D * O, f = D * F, m = P * O, g = P * F, T[0] = L * O, T[4] = m * k - f, T[8] = d * k + g, T[1] = L * F, T[5] = g * k + d, T[9] = f * k - m, T[2] = -k, T[6] = P * L, T[10] = D * L) : "YZX" === t.order ? (v = D * L, y = D * k, b = P * L, x = P * k, T[0] = L * O, T[4] = x - v * F, T[8] = b * F + y, T[1] = F, T[5] = D * O, T[9] = -P * O, T[2] = -k * O, T[6] = y * F + b, T[10] = v - x * F) : "XZY" === t.order && (_ = D * L, w = D * k, S = P * L, M = P * k, T[0] = L * O, T[4] = -F, T[8] = k * O, T[1] = _ * F + M, T[5] = D * O, T[9] = w * F - S, T[2] = S * F - w, T[6] = P * O, T[10] = M * F + _), T[3] = 0, T[7] = 0, T[11] = 0, T[12] = 0, T[13] = 0, T[14] = 0, T[15] = 1, this
            }, Li.prototype.makeRotationFromQuaternion = function(t) {
                return this.compose(Fi, t, Ii)
            }, Li.prototype.lookAt = function(t, e, i) {
                var n = this.elements;
                return Ri.subVectors(t, e), 0 === Ri.lengthSq() && (Ri.z = 1), Ri.normalize(), Ni.crossVectors(i, Ri), 0 === Ni.lengthSq() && (1 === Math.abs(i.z) ? Ri.x += 1e-4 : Ri.z += 1e-4, Ri.normalize(), Ni.crossVectors(i, Ri)), Ni.normalize(), Bi.crossVectors(Ri, Ni), n[0] = Ni.x, n[4] = Bi.x, n[8] = Ri.x, n[1] = Ni.y, n[5] = Bi.y, n[9] = Ri.y, n[2] = Ni.z, n[6] = Bi.z, n[10] = Ri.z, this
            }, Li.prototype.multiply = function(t, e) {
                return void 0 !== e ? this.multiplyMatrices(t, e) : this.multiplyMatrices(this, t)
            }, Li.prototype.premultiply = function(t) {
                return this.multiplyMatrices(t, this)
            }, Li.prototype.multiplyMatrices = function(t, e) {
                var i = t.elements,
                    n = e.elements,
                    r = this.elements,
                    a = i[0],
                    s = i[4],
                    o = i[8],
                    l = i[12],
                    h = i[1],
                    u = i[5],
                    c = i[9],
                    p = i[13],
                    d = i[2],
                    f = i[6],
                    m = i[10],
                    g = i[14],
                    v = i[3],
                    y = i[7],
                    b = i[11],
                    x = i[15],
                    _ = n[0],
                    w = n[4],
                    S = n[8],
                    M = n[12],
                    T = n[1],
                    C = n[5],
                    A = n[9],
                    E = n[13],
                    D = n[2],
                    P = n[6],
                    L = n[10],
                    k = n[14],
                    O = n[3],
                    F = n[7],
                    I = n[11],
                    N = n[15];
                return r[0] = a * _ + s * T + o * D + l * O, r[4] = a * w + s * C + o * P + l * F, r[8] = a * S + s * A + o * L + l * I, r[12] = a * M + s * E + o * k + l * N, r[1] = h * _ + u * T + c * D + p * O, r[5] = h * w + u * C + c * P + p * F, r[9] = h * S + u * A + c * L + p * I, r[13] = h * M + u * E + c * k + p * N, r[2] = d * _ + f * T + m * D + g * O, r[6] = d * w + f * C + m * P + g * F, r[10] = d * S + f * A + m * L + g * I, r[14] = d * M + f * E + m * k + g * N, r[3] = v * _ + y * T + b * D + x * O, r[7] = v * w + y * C + b * P + x * F, r[11] = v * S + y * A + b * L + x * I, r[15] = v * M + y * E + b * k + x * N, this
            }, Li.prototype.multiplyScalar = function(t) {
                var e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            }, Li.prototype.determinant = function() {
                var t = this.elements,
                    e = t[0],
                    i = t[4],
                    n = t[8],
                    r = t[12],
                    a = t[1],
                    s = t[5],
                    o = t[9],
                    l = t[13],
                    h = t[2],
                    u = t[6],
                    c = t[10],
                    p = t[14];
                return t[3] * (r * o * u - n * l * u - r * s * c + i * l * c + n * s * p - i * o * p) + t[7] * (e * o * p - e * l * c + r * a * c - n * a * p + n * l * h - r * o * h) + t[11] * (e * l * u - e * s * p - r * a * u + i * a * p + r * s * h - i * l * h) + t[15] * (-n * s * h - e * o * u + e * s * c + n * a * u - i * a * c + i * o * h)
            }, Li.prototype.transpose = function() {
                var t = this.elements,
                    e = t[1];
                return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            }, Li.prototype.setPosition = function(t, e, i) {
                var n = this.elements;
                return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this
            }, Li.prototype.getInverse = function(t) {
                var e = this.elements,
                    i = t.elements,
                    n = i[0],
                    r = i[1],
                    a = i[2],
                    s = i[3],
                    o = i[4],
                    l = i[5],
                    h = i[6],
                    u = i[7],
                    c = i[8],
                    p = i[9],
                    d = i[10],
                    f = i[11],
                    m = i[12],
                    g = i[13],
                    v = i[14],
                    y = i[15],
                    b = p * v * u - g * d * u + g * h * f - l * v * f - p * h * y + l * d * y,
                    x = m * d * u - c * v * u - m * h * f + o * v * f + c * h * y - o * d * y,
                    _ = c * g * u - m * p * u + m * l * f - o * g * f - c * l * y + o * p * y,
                    w = m * p * h - c * g * h - m * l * d + o * g * d + c * l * v - o * p * v,
                    S = n * b + r * x + a * _ + s * w;
                if (0 == S) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                var M = 1 / S;
                return e[0] = b * M, e[1] = (g * d * s - p * v * s - g * a * f + r * v * f + p * a * y - r * d * y) * M, e[2] = (l * v * s - g * h * s + g * a * u - r * v * u - l * a * y + r * h * y) * M, e[3] = (p * h * s - l * d * s - p * a * u + r * d * u + l * a * f - r * h * f) * M, e[4] = x * M, e[5] = (c * v * s - m * d * s + m * a * f - n * v * f - c * a * y + n * d * y) * M, e[6] = (m * h * s - o * v * s - m * a * u + n * v * u + o * a * y - n * h * y) * M, e[7] = (o * d * s - c * h * s + c * a * u - n * d * u - o * a * f + n * h * f) * M, e[8] = _ * M, e[9] = (m * p * s - c * g * s - m * r * f + n * g * f + c * r * y - n * p * y) * M, e[10] = (o * g * s - m * l * s + m * r * u - n * g * u - o * r * y + n * l * y) * M, e[11] = (c * l * s - o * p * s - c * r * u + n * p * u + o * r * f - n * l * f) * M, e[12] = w * M, e[13] = (c * g * a - m * p * a + m * r * d - n * g * d - c * r * v + n * p * v) * M, e[14] = (m * l * a - o * g * a - m * r * h + n * g * h + o * r * v - n * l * v) * M, e[15] = (o * p * a - c * l * a + c * r * h - n * p * h - o * r * d + n * l * d) * M, this
            }, Li.prototype.scale = function(t) {
                var e = this.elements,
                    i = t.x,
                    n = t.y,
                    r = t.z;
                return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
            }, Li.prototype.getMaxScaleOnAxis = function() {
                var t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, i, n))
            }, Li.prototype.makeTranslation = function(t, e, i) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
            }, Li.prototype.makeRotationX = function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
            }, Li.prototype.makeRotationY = function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t);
                return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
            }, Li.prototype.makeRotationZ = function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t);
                return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }, Li.prototype.makeRotationAxis = function(t, e) {
                var i = Math.cos(e),
                    n = Math.sin(e),
                    r = 1 - i,
                    a = t.x,
                    s = t.y,
                    o = t.z,
                    l = r * a,
                    h = r * s;
                return this.set(l * a + i, l * s - n * o, l * o + n * s, 0, l * s + n * o, h * s + i, h * o - n * a, 0, l * o - n * s, h * o + n * a, r * o * o + i, 0, 0, 0, 0, 1), this
            }, Li.prototype.makeScale = function(t, e, i) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
            }, Li.prototype.makeShear = function(t, e, i) {
                return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
            }, Li.prototype.compose = function(t, e, i) {
                var n = this.elements,
                    r = e._x,
                    a = e._y,
                    s = e._z,
                    o = e._w,
                    l = r + r,
                    h = a + a,
                    u = s + s,
                    c = r * l,
                    p = r * h,
                    d = r * u,
                    f = a * h,
                    m = a * u,
                    g = s * u,
                    v = o * l,
                    y = o * h,
                    b = o * u,
                    x = i.x,
                    _ = i.y,
                    w = i.z;
                return n[0] = (1 - (f + g)) * x, n[1] = (p + b) * x, n[2] = (d - y) * x, n[3] = 0, n[4] = (p - b) * _, n[5] = (1 - (c + g)) * _, n[6] = (m + v) * _, n[7] = 0, n[8] = (d + y) * w, n[9] = (m - v) * w, n[10] = (1 - (c + f)) * w, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
            }, Li.prototype.decompose = function(t, e, i) {
                var n = this.elements,
                    r = ki.set(n[0], n[1], n[2]).length(),
                    a = ki.set(n[4], n[5], n[6]).length(),
                    s = ki.set(n[8], n[9], n[10]).length();
                this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], Oi.copy(this);
                var o = 1 / r,
                    l = 1 / a,
                    h = 1 / s;
                return Oi.elements[0] *= o, Oi.elements[1] *= o, Oi.elements[2] *= o, Oi.elements[4] *= l, Oi.elements[5] *= l, Oi.elements[6] *= l, Oi.elements[8] *= h, Oi.elements[9] *= h, Oi.elements[10] *= h, e.setFromRotationMatrix(Oi), i.x = r, i.y = a, i.z = s, this
            }, Li.prototype.makePerspective = function(t, e, i, n, r, a) {
                var s = this.elements,
                    o = 2 * r / (e - t),
                    l = 2 * r / (i - n),
                    h = (e + t) / (e - t),
                    u = (i + n) / (i - n),
                    c = -(a + r) / (a - r),
                    p = -2 * a * r / (a - r);
                return s[0] = o, s[4] = 0, s[8] = h, s[12] = 0, s[1] = 0, s[5] = l, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = c, s[14] = p, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
            }, Li.prototype.makeOrthographic = function(t, e, i, n, r, a) {
                var s = this.elements,
                    o = 1 / (e - t),
                    l = 1 / (i - n),
                    h = 1 / (a - r),
                    u = (e + t) * o,
                    c = (i + n) * l,
                    p = (a + r) * h;
                return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -c, s[2] = 0, s[6] = 0, s[10] = -2 * h, s[14] = -p, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
            }, Li.prototype.equals = function(t) {
                for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
                    if (e[n] !== i[n]) return !1;
                return !0
            }, Li.prototype.fromArray = function(t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
                return this
            }, Li.prototype.toArray = function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
            };
            var ki = new ni,
                Oi = new Li,
                Fi = new ni(0, 0, 0),
                Ii = new ni(1, 1, 1),
                Ni = new ni,
                Bi = new ni,
                Ri = new ni,
                zi = function t(e, i, n, r) {
                    void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === r && (r = t.DefaultOrder), Object.defineProperty(this, "isEuler", {
                        value: !0
                    }), this._x = e, this._y = i, this._z = n, this._order = r
                },
                Gi = {
                    x: {
                        configurable: !0
                    },
                    y: {
                        configurable: !0
                    },
                    z: {
                        configurable: !0
                    },
                    order: {
                        configurable: !0
                    }
                };
            Gi.x.get = function() {
                return this._x
            }, Gi.x.set = function(t) {
                this._x = t, this._onChangeCallback()
            }, Gi.y.get = function() {
                return this._y
            }, Gi.y.set = function(t) {
                this._y = t, this._onChangeCallback()
            }, Gi.z.get = function() {
                return this._z
            }, Gi.z.set = function(t) {
                this._z = t, this._onChangeCallback()
            }, Gi.order.get = function() {
                return this._order
            }, Gi.order.set = function(t) {
                this._order = t, this._onChangeCallback()
            }, zi.prototype.set = function(t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this._onChangeCallback(), this
            }, zi.prototype.clone = function() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }, zi.prototype.copy = function(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            }, zi.prototype.setFromRotationMatrix = function(t, e, i) {
                var n = je.clamp,
                    r = t.elements,
                    a = r[0],
                    s = r[4],
                    o = r[8],
                    l = r[1],
                    h = r[5],
                    u = r[9],
                    c = r[2],
                    p = r[6],
                    d = r[10];
                switch (e = e || this._order) {
                    case "XYZ":
                        this._y = Math.asin(n(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(p, h), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-n(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-c, a), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(n(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-s, h)) : (this._y = 0, this._z = Math.atan2(l, a));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-n(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-s, h));
                        break;
                    case "YZX":
                        this._z = Math.asin(n(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, h), this._y = Math.atan2(-c, a)) : (this._x = 0, this._y = Math.atan2(o, d));
                        break;
                    case "XZY":
                        this._z = Math.asin(-n(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(p, h), this._y = Math.atan2(o, a)) : (this._x = Math.atan2(-u, d), this._y = 0)
                }
                return this._order = e, !1 !== i && this._onChangeCallback(), this
            }, zi.prototype.setFromQuaternion = function(t, e, i) {
                return Vi.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Vi, e, i)
            }, zi.prototype.setFromVector3 = function(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            }, zi.prototype.reorder = function(t) {
                return Ui.setFromEuler(this), this.setFromQuaternion(Ui, t)
            }, zi.prototype.equals = function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }, zi.prototype.fromArray = function(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            }, zi.prototype.toArray = function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            }, zi.prototype.toVector3 = function(t) {
                return t ? t.set(this._x, this._y, this._z) : new ni(this._x, this._y, this._z)
            }, zi.prototype._onChange = function(t) {
                return this._onChangeCallback = t, this
            }, zi.prototype._onChangeCallback = function() {}, Object.defineProperties(zi.prototype, Gi), zi.DefaultOrder = "XYZ", zi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            var Vi = new Li,
                Ui = new ei,
                ji = function() {
                    this.mask = 1
                };
            ji.prototype.set = function(t) {
                this.mask = 1 << t | 0
            }, ji.prototype.enable = function(t) {
                this.mask |= 1 << t | 0
            }, ji.prototype.enableAll = function() {
                this.mask = -1
            }, ji.prototype.toggle = function(t) {
                this.mask ^= 1 << t | 0
            }, ji.prototype.disable = function(t) {
                this.mask &= ~(1 << t | 0)
            }, ji.prototype.disableAll = function() {
                this.mask = 0
            }, ji.prototype.test = function(t) {
                return 0 != (this.mask & t.mask)
            };
            var Hi = 0,
                Wi = new ni,
                qi = new ei,
                Xi = new Li,
                Yi = new ni,
                Ji = new ni,
                Zi = new ni,
                $i = new ei,
                Ki = new ni(1, 0, 0),
                Qi = new ni(0, 1, 0),
                tn = new ni(0, 0, 1),
                en = {
                    type: "added"
                },
                nn = {
                    type: "removed"
                };

            function rn() {
                Object.defineProperty(this, "id", {
                    value: Hi++
                }), this.uuid = je.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = rn.DefaultUp.clone();
                var t = new ni,
                    e = new zi,
                    i = new ei,
                    n = new ni(1, 1, 1);
                e._onChange(function() {
                    i.setFromEuler(e, !1)
                }), i._onChange(function() {
                    e.setFromQuaternion(i, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    modelViewMatrix: {
                        value: new Li
                    },
                    normalMatrix: {
                        value: new Xe
                    }
                }), this.matrix = new Li, this.matrixWorld = new Li, this.matrixAutoUpdate = rn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ji, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }
            rn.DefaultUp = new ni(0, 1, 0), rn.DefaultMatrixAutoUpdate = !0, rn.prototype = Object.assign(Object.create(ze.prototype), {
                constructor: rn,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix4: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function(t, e) {
                    return qi.setFromAxisAngle(t, e), this.quaternion.multiply(qi), this
                },
                rotateOnWorldAxis: function(t, e) {
                    return qi.setFromAxisAngle(t, e), this.quaternion.premultiply(qi), this
                },
                rotateX: function(t) {
                    return this.rotateOnAxis(Ki, t)
                },
                rotateY: function(t) {
                    return this.rotateOnAxis(Qi, t)
                },
                rotateZ: function(t) {
                    return this.rotateOnAxis(tn, t)
                },
                translateOnAxis: function(t, e) {
                    return Wi.copy(t).applyQuaternion(this.quaternion), this.position.add(Wi.multiplyScalar(e)), this
                },
                translateX: function(t) {
                    return this.translateOnAxis(Ki, t)
                },
                translateY: function(t) {
                    return this.translateOnAxis(Qi, t)
                },
                translateZ: function(t) {
                    return this.translateOnAxis(tn, t)
                },
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function(t) {
                    return t.applyMatrix4(Xi.getInverse(this.matrixWorld))
                },
                lookAt: function(t, e, i) {
                    t.isVector3 ? Yi.copy(t) : Yi.set(t, e, i);
                    var n = this.parent;
                    this.updateWorldMatrix(!0, !1), Ji.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Xi.lookAt(Ji, Yi, this.up) : Xi.lookAt(Yi, Ji, this.up), this.quaternion.setFromRotationMatrix(Xi), n && (Xi.extractRotation(n.matrixWorld), qi.setFromRotationMatrix(Xi), this.quaternion.premultiply(qi.inverse()))
                },
                add: function(t) {
                    if (1 < arguments.length) {
                        for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return t === this || t && t.isObject3D && (null !== t.parent && t.parent.remove(t), (t.parent = this).children.push(t), t.dispatchEvent(en)), this
                },
                remove: function(t) {
                    if (1 < arguments.length) {
                        for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    var i = this.children.indexOf(t);
                    return -1 !== i && (t.parent = null, this.children.splice(i, 1), t.dispatchEvent(nn)), this
                },
                attach: function(t) {
                    return this.updateWorldMatrix(!0, !1), Xi.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Xi.multiply(t.parent.matrixWorld)), t.applyMatrix4(Xi), t.updateWorldMatrix(!1, !1), this.add(t), this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (var i = 0, n = this.children.length; i < n; i++) {
                        var r = this.children[i].getObjectByProperty(t, e);
                        if (void 0 !== r) return r
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (t = new ni), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function(t) {
                    return void 0 === t && (t = new ei), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Ji, t, Zi), t
                },
                getWorldScale: function(t) {
                    return void 0 === t && (t = new ni), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Ji, $i, t), t
                },
                getWorldDirection: function(t) {
                    void 0 === t && (t = new ni), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 !== this.visible) {
                        t(this);
                        for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                    }
                },
                traverseAncestors: function(t) {
                    var e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t = !(this.matrixWorldNeedsUpdate = !1));
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    var i = this.parent;
                    if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                        for (var n = this.children, r = 0, a = n.length; r < a; r++) n[r].updateWorldMatrix(!1, !0)
                },
                toJSON: function(i) {
                    var t = void 0 === i || "string" == typeof i,
                        e = {};
                    t && (i = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, e.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var n, r, a, s, o, l = {};

                    function h(t, e) {
                        return void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(i)), e.uuid
                    }
                    if (l.uuid = this.uuid, l.type = this.type, "" !== this.name && (l.name = this.name), !0 === this.castShadow && (l.castShadow = !0), !0 === this.receiveShadow && (l.receiveShadow = !0), !1 === this.visible && (l.visible = !1), !1 === this.frustumCulled && (l.frustumCulled = !1), 0 !== this.renderOrder && (l.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (l.userData = this.userData), l.layers = this.layers.mask, l.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (l.matrixAutoUpdate = !1), this.isInstancedMesh && (l.type = "InstancedMesh", l.count = this.count, l.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                        l.geometry = h(i.geometries, this.geometry);
                        var u = this.geometry.parameters;
                        if (void 0 !== u && void 0 !== u.shapes) {
                            var c = u.shapes;
                            if (Array.isArray(c))
                                for (var p = 0, d = c.length; p < d; p++) {
                                    var f = c[p];
                                    h(i.shapes, f)
                                } else h(i.shapes, c)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            for (var m = [], g = 0, v = this.material.length; g < v; g++) m.push(h(i.materials, this.material[g]));
                            l.material = m
                        } else l.material = h(i.materials, this.material);
                    if (0 < this.children.length) {
                        l.children = [];
                        for (var y = 0; y < this.children.length; y++) l.children.push(this.children[y].toJSON(i).object)
                    }
                    return t && (n = b(i.geometries), r = b(i.materials), a = b(i.textures), s = b(i.images), o = b(i.shapes), 0 < n.length && (e.geometries = n), 0 < r.length && (e.materials = r), 0 < a.length && (e.textures = a), 0 < s.length && (e.images = s), 0 < o.length && (e.shapes = o)), e.object = l, e;

                    function b(t) {
                        var e = [];
                        for (var i in t) {
                            var n = t[i];
                            delete n.metadata, e.push(n)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (var i = 0; i < t.children.length; i++) {
                            var n = t.children[i];
                            this.add(n.clone())
                        }
                    return this
                }
            });
            var an = new ni,
                sn = new ni,
                on = new Xe,
                ln = function(t, e) {
                    Object.defineProperty(this, "isPlane", {
                        value: !0
                    }), this.normal = void 0 !== t ? t : new ni(1, 0, 0), this.constant = void 0 !== e ? e : 0
                };
            ln.prototype.set = function(t, e) {
                return this.normal.copy(t), this.constant = e, this
            }, ln.prototype.setComponents = function(t, e, i, n) {
                return this.normal.set(t, e, i), this.constant = n, this
            }, ln.prototype.setFromNormalAndCoplanarPoint = function(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }, ln.prototype.setFromCoplanarPoints = function(t, e, i) {
                var n = an.subVectors(i, e).cross(sn.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(n, t), this
            }, ln.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, ln.prototype.copy = function(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }, ln.prototype.normalize = function() {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }, ln.prototype.negate = function() {
                return this.constant *= -1, this.normal.negate(), this
            }, ln.prototype.distanceToPoint = function(t) {
                return this.normal.dot(t) + this.constant
            }, ln.prototype.distanceToSphere = function(t) {
                return this.distanceToPoint(t.center) - t.radius
            }, ln.prototype.projectPoint = function(t, e) {
                return void 0 === e && (e = new ni), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }, ln.prototype.intersectLine = function(t, e) {
                void 0 === e && (e = new ni);
                var i = t.delta(an),
                    n = this.normal.dot(i);
                if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
                var r = -(t.start.dot(this.normal) + this.constant) / n;
                return r < 0 || 1 < r ? void 0 : e.copy(i).multiplyScalar(r).add(t.start)
            }, ln.prototype.intersectsLine = function(t) {
                var e = this.distanceToPoint(t.start),
                    i = this.distanceToPoint(t.end);
                return e < 0 && 0 < i || i < 0 && 0 < e
            }, ln.prototype.intersectsBox = function(t) {
                return t.intersectsPlane(this)
            }, ln.prototype.intersectsSphere = function(t) {
                return t.intersectsPlane(this)
            }, ln.prototype.coplanarPoint = function(t) {
                return void 0 === t && (t = new ni), t.copy(this.normal).multiplyScalar(-this.constant)
            }, ln.prototype.applyMatrix4 = function(t, e) {
                var i = e || on.getNormalMatrix(t),
                    n = this.coplanarPoint(an).applyMatrix4(t),
                    r = this.normal.applyMatrix3(i).normalize();
                return this.constant = -n.dot(r), this
            }, ln.prototype.translate = function(t) {
                return this.constant -= t.dot(this.normal), this
            }, ln.prototype.equals = function(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            };
            var hn = new ni,
                un = new ni,
                cn = new ni,
                pn = new ni,
                dn = new ni,
                fn = new ni,
                mn = new ni,
                gn = new ni,
                vn = new ni,
                yn = new ni,
                bn = function(t, e, i) {
                    this.a = void 0 !== t ? t : new ni, this.b = void 0 !== e ? e : new ni, this.c = void 0 !== i ? i : new ni
                };
            bn.getNormal = function(t, e, i, n) {
                void 0 === n && (n = new ni), n.subVectors(i, e), hn.subVectors(t, e), n.cross(hn);
                var r = n.lengthSq();
                return 0 < r ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
            }, bn.getBarycoord = function(t, e, i, n, r) {
                hn.subVectors(n, e), un.subVectors(i, e), cn.subVectors(t, e);
                var a = hn.dot(hn),
                    s = hn.dot(un),
                    o = hn.dot(cn),
                    l = un.dot(un),
                    h = un.dot(cn),
                    u = a * l - s * s;
                if (void 0 === r && (r = new ni), 0 == u) return r.set(-2, -1, -1);
                var c = 1 / u,
                    p = (l * o - s * h) * c,
                    d = (a * h - s * o) * c;
                return r.set(1 - p - d, d, p)
            }, bn.containsPoint = function(t, e, i, n) {
                return this.getBarycoord(t, e, i, n, pn), 0 <= pn.x && 0 <= pn.y && pn.x + pn.y <= 1
            }, bn.getUV = function(t, e, i, n, r, a, s, o) {
                return this.getBarycoord(t, e, i, n, pn), o.set(0, 0), o.addScaledVector(r, pn.x), o.addScaledVector(a, pn.y), o.addScaledVector(s, pn.z), o
            }, bn.isFrontFacing = function(t, e, i, n) {
                return hn.subVectors(i, e), un.subVectors(t, e), hn.cross(un).dot(n) < 0
            }, bn.prototype.set = function(t, e, i) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
            }, bn.prototype.setFromPointsAndIndices = function(t, e, i, n) {
                return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
            }, bn.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, bn.prototype.copy = function(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            }, bn.prototype.getArea = function() {
                return hn.subVectors(this.c, this.b), un.subVectors(this.a, this.b), .5 * hn.cross(un).length()
            }, bn.prototype.getMidpoint = function(t) {
                return void 0 === t && (t = new ni), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }, bn.prototype.getNormal = function(t) {
                return bn.getNormal(this.a, this.b, this.c, t)
            }, bn.prototype.getPlane = function(t) {
                return void 0 === t && (t = new ln), t.setFromCoplanarPoints(this.a, this.b, this.c)
            }, bn.prototype.getBarycoord = function(t, e) {
                return bn.getBarycoord(t, this.a, this.b, this.c, e)
            }, bn.prototype.getUV = function(t, e, i, n, r) {
                return bn.getUV(t, this.a, this.b, this.c, e, i, n, r)
            }, bn.prototype.containsPoint = function(t) {
                return bn.containsPoint(t, this.a, this.b, this.c)
            }, bn.prototype.isFrontFacing = function(t) {
                return bn.isFrontFacing(this.a, this.b, this.c, t)
            }, bn.prototype.intersectsBox = function(t) {
                return t.intersectsTriangle(this)
            }, bn.prototype.closestPointToPoint = function(t, e) {
                void 0 === e && (e = new ni);
                var i = this.a,
                    n = this.b,
                    r = this.c;
                dn.subVectors(n, i), fn.subVectors(r, i), gn.subVectors(t, i);
                var a = dn.dot(gn),
                    s = fn.dot(gn);
                if (a <= 0 && s <= 0) return e.copy(i);
                vn.subVectors(t, n);
                var o = dn.dot(vn),
                    l = fn.dot(vn);
                if (0 <= o && l <= o) return e.copy(n);
                var h = a * l - o * s;
                if (h <= 0 && 0 <= a && o <= 0) return m = a / (a - o), e.copy(i).addScaledVector(dn, m);
                yn.subVectors(t, r);
                var u = dn.dot(yn),
                    c = fn.dot(yn);
                if (0 <= c && u <= c) return e.copy(r);
                var p = u * s - a * c;
                if (p <= 0 && 0 <= s && c <= 0) return g = s / (s - c), e.copy(i).addScaledVector(fn, g);
                var d = o * c - u * l;
                if (d <= 0 && 0 <= l - o && 0 <= u - c) return mn.subVectors(r, n), g = (l - o) / (l - o + (u - c)), e.copy(n).addScaledVector(mn, g);
                var f = 1 / (d + p + h),
                    m = p * f,
                    g = h * f;
                return e.copy(i).addScaledVector(dn, m).addScaledVector(fn, g)
            }, bn.prototype.equals = function(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            };
            var xn = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                _n = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                wn = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function Sn(t, e, i) {
                return i < 0 && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
            }

            function Mn(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            function Tn(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }
            var Cn = function(t, e, i) {
                return Object.defineProperty(this, "isColor", {
                    value: !0
                }), void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
            };
            Cn.prototype.set = function(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            }, Cn.prototype.setScalar = function(t) {
                return this.r = t, this.g = t, this.b = t, this
            }, Cn.prototype.setHex = function(t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            }, Cn.prototype.setRGB = function(t, e, i) {
                return this.r = t, this.g = e, this.b = i, this
            }, Cn.prototype.setHSL = function(t, e, i) {
                var n, r;
                return t = je.euclideanModulo(t, 1), e = je.clamp(e, 0, 1), i = je.clamp(i, 0, 1), 0 === e ? this.r = this.g = this.b = i : (r = 2 * i - (n = i <= .5 ? i * (1 + e) : i + e - i * e), this.r = Sn(r, n, t + 1 / 3), this.g = Sn(r, n, t), this.b = Sn(r, n, t - 1 / 3)), this
            }, Cn.prototype.setStyle = function(t) {
                function e(t) {
                    void 0 !== t && parseFloat(t)
                }
                var i;
                if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var n, r = i[1],
                        a = i[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
                            if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                var s = parseFloat(n[1]) / 360,
                                    o = parseInt(n[2], 10) / 100,
                                    l = parseInt(n[3], 10) / 100;
                                return e(n[5]), this.setHSL(s, o, l)
                            }
                    }
                } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                    var h = i[1],
                        u = h.length;
                    if (3 === u) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255, this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
                    if (6 === u) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255, this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
                }
                return t && 0 < t.length ? this.setColorName(t) : this
            }, Cn.prototype.setColorName = function(t) {
                var e = xn[t];
                return void 0 !== e && this.setHex(e), this
            }, Cn.prototype.clone = function() {
                return new this.constructor(this.r, this.g, this.b)
            }, Cn.prototype.copy = function(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }, Cn.prototype.copyGammaToLinear = function(t, e) {
                return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            }, Cn.prototype.copyLinearToGamma = function(t, e) {
                void 0 === e && (e = 2);
                var i = 0 < e ? 1 / e : 1;
                return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
            }, Cn.prototype.convertGammaToLinear = function(t) {
                return this.copyGammaToLinear(this, t), this
            }, Cn.prototype.convertLinearToGamma = function(t) {
                return this.copyLinearToGamma(this, t), this
            }, Cn.prototype.copySRGBToLinear = function(t) {
                return this.r = Mn(t.r), this.g = Mn(t.g), this.b = Mn(t.b), this
            }, Cn.prototype.copyLinearToSRGB = function(t) {
                return this.r = Tn(t.r), this.g = Tn(t.g), this.b = Tn(t.b), this
            }, Cn.prototype.convertSRGBToLinear = function() {
                return this.copySRGBToLinear(this), this
            }, Cn.prototype.convertLinearToSRGB = function() {
                return this.copyLinearToSRGB(this), this
            }, Cn.prototype.getHex = function() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }, Cn.prototype.getHexString = function() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }, Cn.prototype.getHSL = function(t) {
                void 0 === t && (t = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                var e, i = this.r,
                    n = this.g,
                    r = this.b,
                    a = Math.max(i, n, r),
                    s = Math.min(i, n, r),
                    o = (s + a) / 2;
                if (s === a) h = e = 0;
                else {
                    var l = a - s,
                        h = o <= .5 ? l / (a + s) : l / (2 - a - s);
                    switch (a) {
                        case i:
                            e = (n - r) / l + (n < r ? 6 : 0);
                            break;
                        case n:
                            e = (r - i) / l + 2;
                            break;
                        case r:
                            e = (i - n) / l + 4
                    }
                    e /= 6
                }
                return t.h = e, t.s = h, t.l = o, t
            }, Cn.prototype.getStyle = function() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }, Cn.prototype.offsetHSL = function(t, e, i) {
                return this.getHSL(_n), _n.h += t, _n.s += e, _n.l += i, this.setHSL(_n.h, _n.s, _n.l), this
            }, Cn.prototype.add = function(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }, Cn.prototype.addColors = function(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }, Cn.prototype.addScalar = function(t) {
                return this.r += t, this.g += t, this.b += t, this
            }, Cn.prototype.sub = function(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }, Cn.prototype.multiply = function(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }, Cn.prototype.multiplyScalar = function(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            }, Cn.prototype.lerp = function(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }, Cn.prototype.lerpHSL = function(t, e) {
                this.getHSL(_n), t.getHSL(wn);
                var i = je.lerp(_n.h, wn.h, e),
                    n = je.lerp(_n.s, wn.s, e),
                    r = je.lerp(_n.l, wn.l, e);
                return this.setHSL(i, n, r), this
            }, Cn.prototype.equals = function(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }, Cn.prototype.fromArray = function(t, e) {
                return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }, Cn.prototype.toArray = function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }, Cn.prototype.fromBufferAttribute = function(t, e) {
                return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
            }, Cn.prototype.toJSON = function() {
                return this.getHex()
            }, Cn.NAMES = xn, Cn.prototype.r = 1, Cn.prototype.g = 1, Cn.prototype.b = 1;
            var An = function(t, e, i, n, r, a) {
                this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new ni, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new Cn, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
            };
            An.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, An.prototype.copy = function(t) {
                this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (var n = 0, r = t.vertexColors.length; n < r; n++) this.vertexColors[n] = t.vertexColors[n].clone();
                return this
            };
            var En = 0;

            function Dn() {
                Object.defineProperty(this, "id", {
                    value: En++
                }), this.uuid = je.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = J, this.side = k, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = ht, this.blendDst = ut, this.blendEquation = tt, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = bt, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Ie, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Fe, this.stencilZFail = Fe, this.stencilZPass = Fe, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
            }

            function Pn(t) {
                Dn.call(this), this.type = "MeshBasicMaterial", this.color = new Cn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = R, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
            }
            Dn.prototype = Object.assign(Object.create(ze.prototype), {
                constructor: Dn,
                isMaterial: !0,
                onBeforeCompile: function() {},
                customProgramCacheKey: function() {
                    return this.onBeforeCompile.toString()
                },
                setValues: function(t) {
                    if (void 0 !== t)
                        for (var e in t) {
                            var i, n = t[e];
                            void 0 !== n && ("shading" !== e ? void 0 !== (i = this[e]) && (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n) : this.flatShading = 1 === n)
                        }
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    var i, n, r = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function a(t) {
                        var e = [];
                        for (var i in t) {
                            var n = t[i];
                            delete n.metadata, e.push(n)
                        }
                        return e
                    }
                    return r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), void 0 !== this.roughness && (r.roughness = this.roughness), void 0 !== this.metalness && (r.metalness = this.metalness), this.sheen && this.sheen.isColor && (r.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), void 0 !== this.shininess && (r.shininess = this.shininess), void 0 !== this.clearcoat && (r.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (r.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(t).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(t).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(t).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(t).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(t).uuid, r.reflectivity = this.reflectivity, r.refractionRatio = this.refractionRatio, void 0 !== this.combine && (r.combine = this.combine), void 0 !== this.envMapIntensity && (r.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (r.size = this.size), void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== J && (r.blending = this.blending), !0 === this.flatShading && (r.flatShading = this.flatShading), this.side !== k && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), !0 === this.transparent && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (r.rotation = this.rotation), !0 === this.polygonOffset && (r.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (r.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (r.linewidth = this.linewidth), void 0 !== this.dashSize && (r.dashSize = this.dashSize), void 0 !== this.gapSize && (r.gapSize = this.gapSize), void 0 !== this.scale && (r.scale = this.scale), !0 === this.dithering && (r.dithering = !0), 0 < this.alphaTest && (r.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (r.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (r.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (r.morphTargets = !0), !0 === this.morphNormals && (r.morphNormals = !0), !0 === this.skinning && (r.skinning = !0), !1 === this.visible && (r.visible = !1), !1 === this.toneMapped && (r.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), e && (i = a(t.textures), n = a(t.images), 0 < i.length && (r.textures = i), 0 < n.length && (r.images = n)), r
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                    var e = t.clippingPlanes,
                        i = null;
                    if (null !== e)
                        for (var n = e.length, i = new Array(n), r = 0; r !== n; ++r) i[r] = e[r].clone();
                    return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(Dn.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), ((Pn.prototype = Object.create(Dn.prototype)).constructor = Pn).prototype.isMeshBasicMaterial = !0, Pn.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
            };
            var Ln = new ni,
                kn = new He;

            function On(t, e, i) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.usage = Ne, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function Fn(t, e, i) {
                On.call(this, new Int8Array(t), e, i)
            }

            function In(t, e, i) {
                On.call(this, new Uint8Array(t), e, i)
            }

            function Nn(t, e, i) {
                On.call(this, new Uint8ClampedArray(t), e, i)
            }

            function Bn(t, e, i) {
                On.call(this, new Int16Array(t), e, i)
            }

            function Rn(t, e, i) {
                On.call(this, new Uint16Array(t), e, i)
            }

            function zn(t, e, i) {
                On.call(this, new Int32Array(t), e, i)
            }

            function Gn(t, e, i) {
                On.call(this, new Uint32Array(t), e, i)
            }

            function Vn(t, e, i) {
                On.call(this, new Float32Array(t), e, i)
            }

            function Un(t, e, i) {
                On.call(this, new Float64Array(t), e, i)
            }
            Object.defineProperty(On.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(On.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setUsage: function(t) {
                    return this.usage = t, this
                },
                copy: function(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
                },
                copyAt: function(t, e, i) {
                    t *= this.itemSize, i *= e.itemSize;
                    for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var a = t[n];
                        void 0 === a && (a = new Cn), e[i++] = a.r, e[i++] = a.g, e[i++] = a.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var a = t[n];
                        void 0 === a && (a = new He), e[i++] = a.x, e[i++] = a.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var a = t[n];
                        void 0 === a && (a = new ni), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var a = t[n];
                        void 0 === a && (a = new $e), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z, e[i++] = a.w
                    }
                    return this
                },
                applyMatrix3: function(t) {
                    if (2 === this.itemSize)
                        for (var e = 0, i = this.count; e < i; e++) kn.fromBufferAttribute(this, e), kn.applyMatrix3(t), this.setXY(e, kn.x, kn.y);
                    else if (3 === this.itemSize)
                        for (var n = 0, r = this.count; n < r; n++) Ln.fromBufferAttribute(this, n), Ln.applyMatrix3(t), this.setXYZ(n, Ln.x, Ln.y, Ln.z);
                    return this
                },
                applyMatrix4: function(t) {
                    for (var e = 0, i = this.count; e < i; e++) Ln.x = this.getX(e), Ln.y = this.getY(e), Ln.z = this.getZ(e), Ln.applyMatrix4(t), this.setXYZ(e, Ln.x, Ln.y, Ln.z);
                    return this
                },
                applyNormalMatrix: function(t) {
                    for (var e = 0, i = this.count; e < i; e++) Ln.x = this.getX(e), Ln.y = this.getY(e), Ln.z = this.getZ(e), Ln.applyNormalMatrix(t), this.setXYZ(e, Ln.x, Ln.y, Ln.z);
                    return this
                },
                transformDirection: function(t) {
                    for (var e = 0, i = this.count; e < i; e++) Ln.x = this.getX(e), Ln.y = this.getY(e), Ln.z = this.getZ(e), Ln.transformDirection(t), this.setXYZ(e, Ln.x, Ln.y, Ln.z);
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
                },
                setXYZ: function(t, e, i, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
                },
                setXYZW: function(t, e, i, n, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                },
                toJSON: function() {
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    }
                }
            }), (Fn.prototype = Object.create(On.prototype)).constructor = Fn, (In.prototype = Object.create(On.prototype)).constructor = In, (Nn.prototype = Object.create(On.prototype)).constructor = Nn, (Bn.prototype = Object.create(On.prototype)).constructor = Bn, (Rn.prototype = Object.create(On.prototype)).constructor = Rn, (zn.prototype = Object.create(On.prototype)).constructor = zn, (Gn.prototype = Object.create(On.prototype)).constructor = Gn, (Vn.prototype = Object.create(On.prototype)).constructor = Vn, (Un.prototype = Object.create(On.prototype)).constructor = Un;

            function jn() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function Hn(t) {
                if (0 === t.length) return -1 / 0;
                for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
                return e
            }
            jn.prototype.computeGroups = function(t) {
                for (var e, i = [], n = void 0, r = t.faces, a = 0; a < r.length; a++) {
                    var s = r[a];
                    s.materialIndex !== n && (n = s.materialIndex, void 0 !== e && (e.count = 3 * a - e.start, i.push(e)), e = {
                        start: 3 * a,
                        materialIndex: n
                    })
                }
                void 0 !== e && (e.count = 3 * a - e.start, i.push(e)), this.groups = i
            }, jn.prototype.fromGeometry = function(t) {
                var e, i = t.faces,
                    n = t.vertices,
                    r = t.faceVertexUvs,
                    a = r[0] && 0 < r[0].length,
                    s = r[1] && 0 < r[1].length,
                    o = t.morphTargets,
                    l = o.length;
                if (0 < l) {
                    e = [];
                    for (var h = 0; h < l; h++) e[h] = {
                        name: o[h].name,
                        data: []
                    };
                    this.morphTargets.position = e
                }
                var u, c = t.morphNormals,
                    p = c.length;
                if (0 < p) {
                    u = [];
                    for (var d = 0; d < p; d++) u[d] = {
                        name: c[d].name,
                        data: []
                    };
                    this.morphTargets.normal = u
                }
                var f = t.skinIndices,
                    m = t.skinWeights,
                    g = f.length === n.length,
                    v = m.length === n.length;
                0 < n.length && i.length;
                for (var y = 0; y < i.length; y++) {
                    var b = i[y];
                    this.vertices.push(n[b.a], n[b.b], n[b.c]);
                    var x, _ = b.vertexNormals;
                    3 === _.length ? this.normals.push(_[0], _[1], _[2]) : (x = b.normal, this.normals.push(x, x, x));
                    var w, S, M, T = b.vertexColors;
                    3 === T.length ? this.colors.push(T[0], T[1], T[2]) : (w = b.color, this.colors.push(w, w, w)), !0 === a && (void 0 !== (S = r[0][y]) ? this.uvs.push(S[0], S[1], S[2]) : this.uvs.push(new He, new He, new He)), !0 === s && (void 0 !== (M = r[1][y]) ? this.uvs2.push(M[0], M[1], M[2]) : this.uvs2.push(new He, new He, new He));
                    for (var C = 0; C < l; C++) {
                        var A = o[C].vertices;
                        e[C].data.push(A[b.a], A[b.b], A[b.c])
                    }
                    for (var E = 0; E < p; E++) {
                        var D = c[E].vertexNormals[y];
                        u[E].data.push(D.a, D.b, D.c)
                    }
                    g && this.skinIndices.push(f[b.a], f[b.b], f[b.c]), v && this.skinWeights.push(m[b.a], m[b.b], m[b.c])
                }
                return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            };
            var Wn = 1,
                qn = new Li,
                Xn = new rn,
                Yn = new ni,
                Jn = new ri,
                Zn = new ri,
                $n = new ni;

            function Kn() {
                Object.defineProperty(this, "id", {
                    value: Wn += 2
                }), this.uuid = je.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            Kn.prototype = Object.assign(Object.create(ze.prototype), {
                constructor: Kn,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    Array.isArray(t) ? this.index = new(65535 < Hn(t) ? Gn : Rn)(t, 1) : this.index = t
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                setAttribute: function(t, e) {
                    return this.attributes[t] = e, this
                },
                deleteAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                addGroup: function(t, e, i) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== i ? i : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix4: function(t) {
                    var e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                    var i, n = this.attributes.normal;
                    void 0 !== n && (i = (new Xe).getNormalMatrix(t), n.applyNormalMatrix(i), n.needsUpdate = !0);
                    var r = this.attributes.tangent;
                    return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function(t) {
                    return qn.makeRotationX(t), this.applyMatrix4(qn), this
                },
                rotateY: function(t) {
                    return qn.makeRotationY(t), this.applyMatrix4(qn), this
                },
                rotateZ: function(t) {
                    return qn.makeRotationZ(t), this.applyMatrix4(qn), this
                },
                translate: function(t, e, i) {
                    return qn.makeTranslation(t, e, i), this.applyMatrix4(qn), this
                },
                scale: function(t, e, i) {
                    return qn.makeScale(t, e, i), this.applyMatrix4(qn), this
                },
                lookAt: function(t) {
                    return Xn.lookAt(t), Xn.updateMatrix(), this.applyMatrix4(Xn.matrix), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(Yn).negate(), this.translate(Yn.x, Yn.y, Yn.z), this
                },
                setFromObject: function(t) {
                    var e, i, n, r = t.geometry;
                    return t.isPoints || t.isLine ? (e = new Vn(3 * r.vertices.length, 3), i = new Vn(3 * r.colors.length, 3), this.setAttribute("position", e.copyVector3sArray(r.vertices)), this.setAttribute("color", i.copyColorsArray(r.colors)), r.lineDistances && r.lineDistances.length === r.vertices.length && (n = new Vn(r.lineDistances.length, 1), this.setAttribute("lineDistance", n.copyArray(r.lineDistances))), null !== r.boundingSphere && (this.boundingSphere = r.boundingSphere.clone()), null !== r.boundingBox && (this.boundingBox = r.boundingBox.clone())) : t.isMesh && r && r.isGeometry && this.fromGeometry(r), this
                },
                setFromPoints: function(t) {
                    for (var e = [], i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        e.push(r.x, r.y, r.z || 0)
                    }
                    return this.setAttribute("position", new Vn(e, 3)), this
                },
                updateFromObject: function(t) {
                    var e, i, n, r, a, s = t.geometry;
                    if (t.isMesh) {
                        var o = s.__directGeometry;
                        if (!0 === s.elementsNeedUpdate && (o = void 0, s.elementsNeedUpdate = !1), void 0 === o) return this.fromGeometry(s);
                        o.verticesNeedUpdate = s.verticesNeedUpdate, o.normalsNeedUpdate = s.normalsNeedUpdate, o.colorsNeedUpdate = s.colorsNeedUpdate, o.uvsNeedUpdate = s.uvsNeedUpdate, o.groupsNeedUpdate = s.groupsNeedUpdate, s.verticesNeedUpdate = !1, s.normalsNeedUpdate = !1, s.colorsNeedUpdate = !1, s.uvsNeedUpdate = !1, s.groupsNeedUpdate = !1, s = o
                    }
                    return !0 === s.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(s.vertices), e.needsUpdate = !0), s.verticesNeedUpdate = !1), !0 === s.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(s.normals), i.needsUpdate = !0), s.normalsNeedUpdate = !1), !0 === s.colorsNeedUpdate && (void 0 !== (n = this.attributes.color) && (n.copyColorsArray(s.colors), n.needsUpdate = !0), s.colorsNeedUpdate = !1), s.uvsNeedUpdate && (void 0 !== (r = this.attributes.uv) && (r.copyVector2sArray(s.uvs), r.needsUpdate = !0), s.uvsNeedUpdate = !1), s.lineDistancesNeedUpdate && (void 0 !== (a = this.attributes.lineDistance) && (a.copyArray(s.lineDistances), a.needsUpdate = !0), s.lineDistancesNeedUpdate = !1), s.groupsNeedUpdate && (s.computeGroups(t.geometry), this.groups = s.groups, s.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new jn).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    var e, i, n, r, a, s, o = new Float32Array(3 * t.vertices.length);
                    for (var l in this.setAttribute("position", new On(o, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.setAttribute("normal", new On(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (i = new Float32Array(3 * t.colors.length), this.setAttribute("color", new On(i, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (n = new Float32Array(2 * t.uvs.length), this.setAttribute("uv", new On(n, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (r = new Float32Array(2 * t.uvs2.length), this.setAttribute("uv2", new On(r, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups, t.morphTargets) {
                        for (var h = [], u = t.morphTargets[l], c = 0, p = u.length; c < p; c++) {
                            var d = u[c],
                                f = new Vn(3 * d.data.length, 3);
                            f.name = d.name, h.push(f.copyVector3sArray(d.data))
                        }
                        this.morphAttributes[l] = h
                    }
                    return 0 < t.skinIndices.length && (a = new Vn(4 * t.skinIndices.length, 4), this.setAttribute("skinIndex", a.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (s = new Vn(4 * t.skinWeights.length, 4), this.setAttribute("skinWeight", s.copyVector4sArray(t.skinWeights))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new ri);
                    var t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) this.boundingBox.set(new ni(-1 / 0, -1 / 0, -1 / 0), new ni(1 / 0, 1 / 0, 1 / 0));
                    else {
                        if (void 0 !== t) {
                            if (this.boundingBox.setFromBufferAttribute(t), e)
                                for (var i = 0, n = e.length; i < n; i++) {
                                    var r = e[i];
                                    Jn.setFromBufferAttribute(r), this.morphTargetsRelative ? ($n.addVectors(this.boundingBox.min, Jn.min), this.boundingBox.expandByPoint($n), $n.addVectors(this.boundingBox.max, Jn.max), this.boundingBox.expandByPoint($n)) : (this.boundingBox.expandByPoint(Jn.min), this.boundingBox.expandByPoint(Jn.max))
                                }
                        } else this.boundingBox.makeEmpty();
                        isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
                    }
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new li);
                    var t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) this.boundingSphere.set(new ni, 1 / 0);
                    else if (t) {
                        var i = this.boundingSphere.center;
                        if (Jn.setFromBufferAttribute(t), e)
                            for (var n = 0, r = e.length; n < r; n++) {
                                var a = e[n];
                                Zn.setFromBufferAttribute(a), this.morphTargetsRelative ? ($n.addVectors(Jn.min, Zn.min), Jn.expandByPoint($n), $n.addVectors(Jn.max, Zn.max), Jn.expandByPoint($n)) : (Jn.expandByPoint(Zn.min), Jn.expandByPoint(Zn.max))
                            }
                        Jn.getCenter(i);
                        for (var s = 0, o = 0, l = t.count; o < l; o++) $n.fromBufferAttribute(t, o), s = Math.max(s, i.distanceToSquared($n));
                        if (e)
                            for (var h = 0, u = e.length; h < u; h++)
                                for (var c = e[h], p = this.morphTargetsRelative, d = 0, f = c.count; d < f; d++) $n.fromBufferAttribute(c, d), p && (Yn.fromBufferAttribute(t, d), $n.add(Yn)), s = Math.max(s, i.distanceToSquared($n));
                        this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius)
                    }
                },
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var t = this.index,
                        e = this.getAttribute("position");
                    if (void 0 !== e) {
                        var i = this.getAttribute("normal");
                        if (void 0 === i) i = new On(new Float32Array(3 * e.count), 3), this.setAttribute("normal", i);
                        else
                            for (var n = 0, r = i.count; n < r; n++) i.setXYZ(n, 0, 0, 0);
                        var a = new ni,
                            s = new ni,
                            o = new ni,
                            l = new ni,
                            h = new ni,
                            u = new ni,
                            c = new ni,
                            p = new ni;
                        if (t)
                            for (var d = 0, f = t.count; d < f; d += 3) {
                                var m = t.getX(d + 0),
                                    g = t.getX(d + 1),
                                    v = t.getX(d + 2);
                                a.fromBufferAttribute(e, m), s.fromBufferAttribute(e, g), o.fromBufferAttribute(e, v), c.subVectors(o, s), p.subVectors(a, s), c.cross(p), l.fromBufferAttribute(i, m), h.fromBufferAttribute(i, g), u.fromBufferAttribute(i, v), l.add(c), h.add(c), u.add(c), i.setXYZ(m, l.x, l.y, l.z), i.setXYZ(g, h.x, h.y, h.z), i.setXYZ(v, u.x, u.y, u.z)
                            } else
                                for (var y = 0, b = e.count; y < b; y += 3) a.fromBufferAttribute(e, y + 0), s.fromBufferAttribute(e, y + 1), o.fromBufferAttribute(e, y + 2), c.subVectors(o, s), p.subVectors(a, s), c.cross(p), i.setXYZ(y + 0, c.x, c.y, c.z), i.setXYZ(y + 1, c.x, c.y, c.z), i.setXYZ(y + 2, c.x, c.y, c.z);
                        this.normalizeNormals(), i.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (t && t.isBufferGeometry) {
                        void 0 === e && (e = 0);
                        var i = this.attributes;
                        for (var n in i)
                            if (void 0 !== t.attributes[n])
                                for (var r = i[n].array, a = t.attributes[n], s = a.array, o = a.itemSize * e, l = Math.min(s.length, r.length - o), h = 0, u = o; h < l; h++, u++) r[u] = s[h];
                        return this
                    }
                },
                normalizeNormals: function() {
                    for (var t = this.attributes.normal, e = 0, i = t.count; e < i; e++) $n.fromBufferAttribute(t, e), $n.normalize(), t.setXYZ(e, $n.x, $n.y, $n.z)
                },
                toNonIndexed: function() {
                    function t(t, e) {
                        for (var i = t.array, n = t.itemSize, r = t.normalized, a = new i.constructor(e.length * n), s = 0, o = 0, l = 0, h = e.length; l < h; l++) {
                            s = e[l] * n;
                            for (var u = 0; u < n; u++) a[o++] = i[s++]
                        }
                        return new On(a, n, r)
                    }
                    if (null === this.index) return this;
                    var e = new Kn,
                        i = this.index.array,
                        n = this.attributes;
                    for (var r in n) {
                        var a = t(n[r], i);
                        e.setAttribute(r, a)
                    }
                    var s = this.morphAttributes;
                    for (var o in s) {
                        for (var l = [], h = s[o], u = 0, c = h.length; u < c; u++) {
                            var p = t(h[u], i);
                            l.push(p)
                        }
                        e.morphAttributes[o] = l
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    for (var d = this.groups, f = 0, m = d.length; f < m; f++) {
                        var g = d[f];
                        e.addGroup(g.start, g.count, g.materialIndex)
                    }
                    return e
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    var n = this.index;
                    null !== n && (t.data.index = {
                        type: n.array.constructor.name,
                        array: Array.prototype.slice.call(n.array)
                    });
                    var r = this.attributes;
                    for (var a in r) {
                        var s = r[a],
                            o = s.toJSON(t.data);
                        "" !== s.name && (o.name = s.name), t.data.attributes[a] = o
                    }
                    var l = {},
                        h = !1;
                    for (var u in this.morphAttributes) {
                        for (var c = this.morphAttributes[u], p = [], d = 0, f = c.length; d < f; d++) {
                            var m = c[d],
                                g = m.toJSON(t.data);
                            "" !== m.name && (g.name = m.name), p.push(g)
                        }
                        0 < p.length && (l[u] = p, h = !0)
                    }
                    h && (t.data.morphAttributes = l, t.data.morphTargetsRelative = this.morphTargetsRelative);
                    var v = this.groups;
                    0 < v.length && (t.data.groups = JSON.parse(JSON.stringify(v)));
                    var y = this.boundingSphere;
                    return null !== y && (t.data.boundingSphere = {
                        center: y.center.toArray(),
                        radius: y.radius
                    }), t
                },
                clone: function() {
                    return (new Kn).copy(this)
                },
                copy: function(t) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    var e = {};
                    this.name = t.name;
                    var i = t.index;
                    null !== i && this.setIndex(i.clone(e));
                    var n = t.attributes;
                    for (var r in n) {
                        var a = n[r];
                        this.setAttribute(r, a.clone(e))
                    }
                    var s = t.morphAttributes;
                    for (var o in s) {
                        for (var l = [], h = s[o], u = 0, c = h.length; u < c; u++) l.push(h[u].clone(e));
                        this.morphAttributes[o] = l
                    }
                    this.morphTargetsRelative = t.morphTargetsRelative;
                    for (var p = t.groups, d = 0, f = p.length; d < f; d++) {
                        var m = p[d];
                        this.addGroup(m.start, m.count, m.materialIndex)
                    }
                    var g = t.boundingBox;
                    null !== g && (this.boundingBox = g.clone());
                    var v = t.boundingSphere;
                    return null !== v && (this.boundingSphere = v.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            var Qn = new Li,
                tr = new Si,
                er = new li,
                ir = new ni,
                nr = new ni,
                rr = new ni,
                ar = new ni,
                sr = new ni,
                or = new ni,
                lr = new ni,
                hr = new ni,
                ur = new ni,
                cr = new He,
                pr = new He,
                dr = new He,
                fr = new ni,
                mr = new ni;

            function gr(t, e) {
                rn.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Kn, this.material = void 0 !== e ? e : new Pn, this.updateMorphTargets()
            }

            function vr(t, e, i, n, r, a, s, o) {
                var l = e.side === q ? n.intersectTriangle(s, a, r, !0, o) : n.intersectTriangle(r, a, s, e.side !== X, o);
                if (null === l) return null;
                mr.copy(o), mr.applyMatrix4(t.matrixWorld);
                var h = i.ray.origin.distanceTo(mr);
                return h < i.near || h > i.far ? null : {
                    distance: h,
                    point: mr.clone(),
                    object: t
                }
            }

            function yr(t, e, i, n, r, a, s, o, l, h, u, c) {
                ir.fromBufferAttribute(r, h), nr.fromBufferAttribute(r, u), rr.fromBufferAttribute(r, c);
                var p = t.morphTargetInfluences;
                if (e.morphTargets && a && p) {
                    lr.set(0, 0, 0), hr.set(0, 0, 0), ur.set(0, 0, 0);
                    for (var d = 0, f = a.length; d < f; d++) {
                        var m = p[d],
                            g = a[d];
                        0 !== m && (ar.fromBufferAttribute(g, h), sr.fromBufferAttribute(g, u), or.fromBufferAttribute(g, c), s ? (lr.addScaledVector(ar, m), hr.addScaledVector(sr, m), ur.addScaledVector(or, m)) : (lr.addScaledVector(ar.sub(ir), m), hr.addScaledVector(sr.sub(nr), m), ur.addScaledVector(or.sub(rr), m)))
                    }
                    ir.add(lr), nr.add(hr), rr.add(ur)
                }
                t.isSkinnedMesh && (t.boneTransform(h, ir), t.boneTransform(u, nr), t.boneTransform(c, rr));
                var v, y = vr(t, e, i, n, ir, nr, rr, fr);
                return y && (o && (cr.fromBufferAttribute(o, h), pr.fromBufferAttribute(o, u), dr.fromBufferAttribute(o, c), y.uv = bn.getUV(fr, ir, nr, rr, cr, pr, dr, new He)), l && (cr.fromBufferAttribute(l, h), pr.fromBufferAttribute(l, u), dr.fromBufferAttribute(l, c), y.uv2 = bn.getUV(fr, ir, nr, rr, cr, pr, dr, new He)), v = new An(h, u, c), bn.getNormal(ir, nr, rr, v.normal), y.face = v), y
            }
            gr.prototype = Object.assign(Object.create(rn.prototype), {
                constructor: gr,
                isMesh: !0,
                copy: function(t) {
                    return rn.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                },
                updateMorphTargets: function() {
                    var t = this.geometry;
                    if (t.isBufferGeometry) {
                        var e = t.morphAttributes,
                            i = Object.keys(e);
                        if (0 < i.length) {
                            var n = e[i[0]];
                            if (void 0 !== n) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (var r = 0, a = n.length; r < a; r++) {
                                    var s = n[r].name || String(r);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = r
                                }
                            }
                        }
                    } else {
                        var o = t.morphTargets;
                        void 0 !== o && o.length
                    }
                },
                raycast: function(t, e) {
                    var i = this.geometry,
                        n = this.material,
                        r = this.matrixWorld;
                    if (void 0 !== n && (null === i.boundingSphere && i.computeBoundingSphere(), er.copy(i.boundingSphere), er.applyMatrix4(r), !1 !== t.ray.intersectsSphere(er) && (Qn.getInverse(r), tr.copy(t.ray).applyMatrix4(Qn), null === i.boundingBox || !1 !== tr.intersectsBox(i.boundingBox))))
                        if (i.isBufferGeometry) {
                            var a = i.index,
                                s = i.attributes.position,
                                o = i.morphAttributes.position,
                                l = i.morphTargetsRelative,
                                h = i.attributes.uv,
                                u = i.attributes.uv2,
                                c = i.groups,
                                p = i.drawRange;
                            if (null !== a)
                                if (Array.isArray(n))
                                    for (var d = 0, f = c.length; d < f; d++)
                                        for (var m = c[d], g = n[m.materialIndex], v = Math.max(m.start, p.start), y = Math.min(m.start + m.count, p.start + p.count); v < y; v += 3) {
                                            var b, x = a.getX(v),
                                                _ = a.getX(v + 1),
                                                w = a.getX(v + 2);
                                            (b = yr(this, g, t, tr, s, o, l, h, u, x, _, w)) && (b.faceIndex = Math.floor(v / 3), b.face.materialIndex = m.materialIndex, e.push(b))
                                        } else
                                            for (var S = Math.max(0, p.start), M = Math.min(a.count, p.start + p.count); S < M; S += 3) {
                                                var T = a.getX(S),
                                                    C = a.getX(S + 1),
                                                    A = a.getX(S + 2);
                                                (b = yr(this, n, t, tr, s, o, l, h, u, T, C, A)) && (b.faceIndex = Math.floor(S / 3), e.push(b))
                                            } else if (void 0 !== s)
                                                if (Array.isArray(n))
                                                    for (var E = 0, D = c.length; E < D; E++)
                                                        for (var P = c[E], L = n[P.materialIndex], k = Math.max(P.start, p.start), O = Math.min(P.start + P.count, p.start + p.count); k < O; k += 3) {
                                                            (b = yr(this, L, t, tr, s, o, l, h, u, k, k + 1, k + 2)) && (b.faceIndex = Math.floor(k / 3), b.face.materialIndex = P.materialIndex, e.push(b))
                                                        } else
                                                            for (var F = Math.max(0, p.start), I = Math.min(s.count, p.start + p.count); F < I; F += 3) {
                                                                (b = yr(this, n, t, tr, s, o, l, h, u, F, F + 1, F + 2)) && (b.faceIndex = Math.floor(F / 3), e.push(b))
                                                            }
                        } else if (i.isGeometry) {
                        var N, B = Array.isArray(n),
                            R = i.vertices,
                            z = i.faces,
                            G = i.faceVertexUvs[0];
                        0 < G.length && (N = G);
                        for (var V = 0, U = z.length; V < U; V++) {
                            var j, H, W, q, X = z[V],
                                Y = B ? n[X.materialIndex] : n;
                            void 0 !== Y && (j = R[X.a], H = R[X.b], W = R[X.c], (b = vr(this, Y, t, tr, j, H, W, fr)) && (N && N[V] && (q = N[V], cr.copy(q[0]), pr.copy(q[1]), dr.copy(q[2]), b.uv = bn.getUV(fr, j, H, W, cr, pr, dr, new He)), b.face = X, b.faceIndex = V, e.push(b)))
                        }
                    }
                }
            });
            var br = 0,
                xr = new Li,
                _r = new rn,
                wr = new ni;

            function Sr() {
                Object.defineProperty(this, "id", {
                    value: br += 2
                }), this.uuid = je.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function Mr(t, e, i, n, r, a) {
                Sr.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: i,
                    widthSegments: n,
                    heightSegments: r,
                    depthSegments: a
                }, this.fromBufferGeometry(new Tr(t, e, i, n, r, a)), this.mergeVertices()
            }

            function Tr(t, e, i, n, r, a) {
                void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === a && (a = 1), Kn.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: i,
                    widthSegments: n,
                    heightSegments: r,
                    depthSegments: a
                };
                var L = this;
                n = Math.floor(n), r = Math.floor(r), a = Math.floor(a);
                var k = [],
                    O = [],
                    F = [],
                    I = [],
                    N = 0,
                    B = 0;

                function s(t, e, i, n, r, a, s, o, l, h, u) {
                    for (var c = a / l, p = s / h, d = a / 2, f = s / 2, m = o / 2, g = l + 1, v = h + 1, y = 0, b = 0, x = new ni, _ = 0; _ < v; _++)
                        for (var w = _ * p - f, S = 0; S < g; S++) {
                            var M = S * c - d;
                            x[t] = M * n, x[e] = w * r, x[i] = m, O.push(x.x, x.y, x.z), x[t] = 0, x[e] = 0, x[i] = 0 < o ? 1 : -1, F.push(x.x, x.y, x.z), I.push(S / l), I.push(1 - _ / h), y += 1
                        }
                    for (var T = 0; T < h; T++)
                        for (var C = 0; C < l; C++) {
                            var A = N + C + g * T,
                                E = N + C + g * (T + 1),
                                D = N + (C + 1) + g * (T + 1),
                                P = N + (C + 1) + g * T;
                            k.push(A, E, P), k.push(E, D, P), b += 6
                        }
                    L.addGroup(B, b, u), B += b, N += y
                }
                s("z", "y", "x", -1, -1, i, e, t, a, r, 0), s("z", "y", "x", 1, -1, i, e, -t, a, r, 1), s("x", "z", "y", 1, 1, t, i, e, n, a, 2), s("x", "z", "y", 1, -1, t, i, -e, n, a, 3), s("x", "y", "z", 1, -1, t, e, i, n, r, 4), s("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(k), this.setAttribute("position", new Vn(O, 3)), this.setAttribute("normal", new Vn(F, 3)), this.setAttribute("uv", new Vn(I, 2))
            }

            function Cr(t) {
                var e = {};
                for (var i in t)
                    for (var n in e[i] = {}, t[i]) {
                        var r = t[i][n];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                    }
                return e
            }

            function Ar(t) {
                for (var e = {}, i = 0; i < t.length; i++) {
                    var n = Cr(t[i]);
                    for (var r in n) e[r] = n[r]
                }
                return e
            }
            Sr.prototype = Object.assign(Object.create(ze.prototype), {
                constructor: Sr,
                isGeometry: !0,
                applyMatrix4: function(t) {
                    for (var e = (new Xe).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) {
                        this.vertices[i].applyMatrix4(t)
                    }
                    for (var r = 0, a = this.faces.length; r < a; r++) {
                        var s = this.faces[r];
                        s.normal.applyMatrix3(e).normalize();
                        for (var o = 0, l = s.vertexNormals.length; o < l; o++) s.vertexNormals[o].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function(t) {
                    return xr.makeRotationX(t), this.applyMatrix4(xr), this
                },
                rotateY: function(t) {
                    return xr.makeRotationY(t), this.applyMatrix4(xr), this
                },
                rotateZ: function(t) {
                    return xr.makeRotationZ(t), this.applyMatrix4(xr), this
                },
                translate: function(t, e, i) {
                    return xr.makeTranslation(t, e, i), this.applyMatrix4(xr), this
                },
                scale: function(t, e, i) {
                    return xr.makeScale(t, e, i), this.applyMatrix4(xr), this
                },
                lookAt: function(t) {
                    return _r.lookAt(t), _r.updateMatrix(), this.applyMatrix4(_r.matrix), this
                },
                fromBufferGeometry: function(t) {
                    var o = this,
                        e = null !== t.index ? t.index : void 0,
                        i = t.attributes;
                    if (void 0 === i.position) return this;
                    var n = i.position,
                        l = i.normal,
                        h = i.color,
                        u = i.uv,
                        c = i.uv2;
                    void 0 !== c && (this.faceVertexUvs[1] = []);
                    for (var r = 0; r < n.count; r++) o.vertices.push((new ni).fromBufferAttribute(n, r)), void 0 !== h && o.colors.push((new Cn).fromBufferAttribute(h, r));

                    function a(t, e, i, n) {
                        var r = void 0 === h ? [] : [o.colors[t].clone(), o.colors[e].clone(), o.colors[i].clone()],
                            a = void 0 === l ? [] : [(new ni).fromBufferAttribute(l, t), (new ni).fromBufferAttribute(l, e), (new ni).fromBufferAttribute(l, i)],
                            s = new An(t, e, i, a, r, n);
                        o.faces.push(s), void 0 !== u && o.faceVertexUvs[0].push([(new He).fromBufferAttribute(u, t), (new He).fromBufferAttribute(u, e), (new He).fromBufferAttribute(u, i)]), void 0 !== c && o.faceVertexUvs[1].push([(new He).fromBufferAttribute(c, t), (new He).fromBufferAttribute(c, e), (new He).fromBufferAttribute(c, i)])
                    }
                    var s = t.groups;
                    if (0 < s.length)
                        for (var p = 0; p < s.length; p++)
                            for (var d = s[p], f = d.start, m = f, g = f + d.count; m < g; m += 3) void 0 !== e ? a(e.getX(m), e.getX(m + 1), e.getX(m + 2), d.materialIndex) : a(m, m + 1, m + 2, d.materialIndex);
                    else if (void 0 !== e)
                        for (var v = 0; v < e.count; v += 3) a(e.getX(v), e.getX(v + 1), e.getX(v + 2));
                    else
                        for (var y = 0; y < n.count; y += 3) a(y, y + 1, y + 2);
                    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(wr).negate(), this.translate(wr.x, wr.y, wr.z), this
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    var t = this.boundingSphere.center,
                        e = this.boundingSphere.radius,
                        i = 0 === e ? 1 : 1 / e,
                        n = new Li;
                    return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix4(n), this
                },
                computeFaceNormals: function() {
                    for (var t = new ni, e = new ni, i = 0, n = this.faces.length; i < n; i++) {
                        var r = this.faces[i],
                            a = this.vertices[r.a],
                            s = this.vertices[r.b],
                            o = this.vertices[r.c];
                        t.subVectors(o, s), e.subVectors(a, s), t.cross(e), t.normalize(), r.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    void 0 === t && (t = !0);
                    for (var e = new Array(this.vertices.length), i = 0, n = this.vertices.length; i < n; i++) e[i] = new ni;
                    if (t)
                        for (var r = new ni, a = new ni, s = 0, o = this.faces.length; s < o; s++) {
                            var l = this.faces[s],
                                h = this.vertices[l.a],
                                u = this.vertices[l.b],
                                c = this.vertices[l.c];
                            r.subVectors(c, u), a.subVectors(h, u), r.cross(a), e[l.a].add(r), e[l.b].add(r), e[l.c].add(r)
                        } else {
                            this.computeFaceNormals();
                            for (var p = 0, d = this.faces.length; p < d; p++) {
                                var f = this.faces[p];
                                e[f.a].add(f.normal), e[f.b].add(f.normal), e[f.c].add(f.normal)
                            }
                        }
                    for (var m = 0, g = this.vertices.length; m < g; m++) e[m].normalize();
                    for (var v = 0, y = this.faces.length; v < y; v++) {
                        var b = this.faces[v],
                            x = b.vertexNormals;
                        3 === x.length ? (x[0].copy(e[b.a]), x[1].copy(e[b.b]), x[2].copy(e[b.c])) : (x[0] = e[b.a].clone(), x[1] = e[b.b].clone(), x[2] = e[b.c].clone())
                    }
                    0 < this.faces.length && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    this.computeFaceNormals();
                    for (var t = 0, e = this.faces.length; t < e; t++) {
                        var i = this.faces[t],
                            n = i.vertexNormals;
                        3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
                    }
                    0 < this.faces.length && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    for (var t = 0, e = this.faces.length; t < e; t++) {
                        var i = this.faces[t];
                        i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []);
                        for (var n = 0, r = i.vertexNormals.length; n < r; n++) i.__originalVertexNormals[n] ? i.__originalVertexNormals[n].copy(i.vertexNormals[n]) : i.__originalVertexNormals[n] = i.vertexNormals[n].clone()
                    }
                    var a = new Sr;
                    a.faces = this.faces;
                    for (var s = 0, o = this.morphTargets.length; s < o; s++) {
                        if (!this.morphNormals[s]) {
                            this.morphNormals[s] = {}, this.morphNormals[s].faceNormals = [], this.morphNormals[s].vertexNormals = [];
                            for (var l = this.morphNormals[s].faceNormals, h = this.morphNormals[s].vertexNormals, u = 0, c = this.faces.length; u < c; u++) {
                                var p = new ni,
                                    d = {
                                        a: new ni,
                                        b: new ni,
                                        c: new ni
                                    };
                                l.push(p), h.push(d)
                            }
                        }
                        var f = this.morphNormals[s];
                        a.vertices = this.morphTargets[s].vertices, a.computeFaceNormals(), a.computeVertexNormals();
                        for (var m = 0, g = this.faces.length; m < g; m++) {
                            var v = this.faces[m],
                                y = f.faceNormals[m],
                                b = f.vertexNormals[m];
                            y.copy(v.normal), b.a.copy(v.vertexNormals[0]), b.b.copy(v.vertexNormals[1]), b.c.copy(v.vertexNormals[2])
                        }
                    }
                    for (var x = 0, _ = this.faces.length; x < _; x++) {
                        var w = this.faces[x];
                        w.normal = w.__originalFaceNormal, w.vertexNormals = w.__originalVertexNormals
                    }
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new ri), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new li), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, i) {
                    if (t && t.isGeometry) {
                        var n, r = this.vertices.length,
                            a = this.vertices,
                            s = t.vertices,
                            o = this.faces,
                            l = t.faces,
                            h = this.colors,
                            u = t.colors;
                        void 0 === i && (i = 0), void 0 !== e && (n = (new Xe).getNormalMatrix(e));
                        for (var c = 0, p = s.length; c < p; c++) {
                            var d = s[c].clone();
                            void 0 !== e && d.applyMatrix4(e), a.push(d)
                        }
                        for (var f = 0, m = u.length; f < m; f++) h.push(u[f].clone());
                        for (var g = 0, v = l.length; g < v; g++) {
                            var y = l[g],
                                b = void 0,
                                x = void 0,
                                _ = y.vertexNormals,
                                w = y.vertexColors,
                                S = new An(y.a + r, y.b + r, y.c + r);
                            S.normal.copy(y.normal), void 0 !== n && S.normal.applyMatrix3(n).normalize();
                            for (var M = 0, T = _.length; M < T; M++) b = _[M].clone(), void 0 !== n && b.applyMatrix3(n).normalize(), S.vertexNormals.push(b);
                            S.color.copy(y.color);
                            for (var C = 0, A = w.length; C < A; C++) x = w[C], S.vertexColors.push(x.clone());
                            S.materialIndex = y.materialIndex + i, o.push(S)
                        }
                        for (var E = 0, D = t.faceVertexUvs.length; E < D; E++) {
                            var P = t.faceVertexUvs[E];
                            void 0 === this.faceVertexUvs[E] && (this.faceVertexUvs[E] = []);
                            for (var L = 0, k = P.length; L < k; L++) {
                                for (var O = P[L], F = [], I = 0, N = O.length; I < N; I++) F.push(O[I].clone());
                                this.faceVertexUvs[E].push(F)
                            }
                        }
                    }
                },
                mergeMesh: function(t) {
                    t && t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix))
                },
                mergeVertices: function() {
                    for (var t = {}, e = [], i = [], n = Math.pow(10, 4), r = 0, a = this.vertices.length; r < a; r++) {
                        var s = this.vertices[r],
                            o = Math.round(s.x * n) + "_" + Math.round(s.y * n) + "_" + Math.round(s.z * n);
                        void 0 === t[o] ? (t[o] = r, e.push(this.vertices[r]), i[r] = e.length - 1) : i[r] = i[t[o]]
                    }
                    for (var l = [], h = 0, u = this.faces.length; h < u; h++) {
                        var c = this.faces[h];
                        c.a = i[c.a], c.b = i[c.b], c.c = i[c.c];
                        for (var p = [c.a, c.b, c.c], d = 0; d < 3; d++)
                            if (p[d] === p[(d + 1) % 3]) {
                                l.push(h);
                                break
                            }
                    }
                    for (var f = l.length - 1; 0 <= f; f--) {
                        var m = l[f];
                        this.faces.splice(m, 1);
                        for (var g = 0, v = this.faceVertexUvs.length; g < v; g++) this.faceVertexUvs[g].splice(m, 1)
                    }
                    var y = this.vertices.length - e.length;
                    return this.vertices = e, y
                },
                setFromPoints: function(t) {
                    this.vertices = [];
                    for (var e = 0, i = t.length; e < i; e++) {
                        var n = t[e];
                        this.vertices.push(new ni(n.x, n.y, n.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
                    t.sort(function(t, e) {
                        return t.materialIndex - e.materialIndex
                    });
                    var n, r, a = this.faceVertexUvs[0],
                        s = this.faceVertexUvs[1];
                    a && a.length === e && (n = []), s && s.length === e && (r = []);
                    for (var o = 0; o < e; o++) {
                        var l = t[o]._id;
                        n && n.push(a[l]), r && r.push(s[l])
                    }
                    n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                        return t
                    }
                    for (var n = [], r = 0; r < this.vertices.length; r++) {
                        var a = this.vertices[r];
                        n.push(a.x, a.y, a.z)
                    }
                    for (var s = [], o = [], l = {}, h = [], u = {}, c = [], p = {}, d = 0; d < this.faces.length; d++) {
                        var f, m, g, v = this.faces[d],
                            y = void 0 !== this.faceVertexUvs[0][d],
                            b = 0 < v.normal.length(),
                            x = 0 < v.vertexNormals.length,
                            _ = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b,
                            w = 0 < v.vertexColors.length,
                            S = M(S = 0, 0, 0);
                        S = M(S, 1, !0), S = M(S, 2, !1), S = M(S, 3, y), S = M(S, 4, b), S = M(S, 5, x), S = M(S, 6, _), S = M(S, 7, w), s.push(S), s.push(v.a, v.b, v.c), s.push(v.materialIndex), y && (f = this.faceVertexUvs[0][d], s.push(A(f[0]), A(f[1]), A(f[2]))), b && s.push(T(v.normal)), x && (m = v.vertexNormals, s.push(T(m[0]), T(m[1]), T(m[2]))), _ && s.push(C(v.color)), w && (g = v.vertexColors, s.push(C(g[0]), C(g[1]), C(g[2])))
                    }

                    function M(t, e, i) {
                        return i ? t | 1 << e : t & ~(1 << e)
                    }

                    function T(t) {
                        var e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== l[e] || (l[e] = o.length / 3, o.push(t.x, t.y, t.z)), l[e]
                    }

                    function C(t) {
                        var e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== u[e] || (u[e] = h.length, h.push(t.getHex())), u[e]
                    }

                    function A(t) {
                        var e = t.x.toString() + t.y.toString();
                        return void 0 !== p[e] || (p[e] = c.length / 2, c.push(t.x, t.y)), p[e]
                    }
                    return t.data = {}, t.data.vertices = n, t.data.normals = o, 0 < h.length && (t.data.colors = h), 0 < c.length && (t.data.uvs = [c]), t.data.faces = s, t
                },
                clone: function() {
                    return (new Sr).copy(this)
                },
                copy: function(t) {
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    for (var e = t.vertices, i = 0, n = e.length; i < n; i++) this.vertices.push(e[i].clone());
                    for (var r = t.colors, a = 0, s = r.length; a < s; a++) this.colors.push(r[a].clone());
                    for (var o = t.faces, l = 0, h = o.length; l < h; l++) this.faces.push(o[l].clone());
                    for (var u = 0, c = t.faceVertexUvs.length; u < c; u++) {
                        var p = t.faceVertexUvs[u];
                        void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
                        for (var d = 0, f = p.length; d < f; d++) {
                            for (var m = p[d], g = [], v = 0, y = m.length; v < y; v++) {
                                var b = m[v];
                                g.push(b.clone())
                            }
                            this.faceVertexUvs[u].push(g)
                        }
                    }
                    for (var x = t.morphTargets, _ = 0, w = x.length; _ < w; _++) {
                        var S = {};
                        if (S.name = x[_].name, void 0 !== x[_].vertices) {
                            S.vertices = [];
                            for (var M = 0, T = x[_].vertices.length; M < T; M++) S.vertices.push(x[_].vertices[M].clone())
                        }
                        if (void 0 !== x[_].normals) {
                            S.normals = [];
                            for (var C = 0, A = x[_].normals.length; C < A; C++) S.normals.push(x[_].normals[C].clone())
                        }
                        this.morphTargets.push(S)
                    }
                    for (var E = t.morphNormals, D = 0, P = E.length; D < P; D++) {
                        var L = {};
                        if (void 0 !== E[D].vertexNormals) {
                            L.vertexNormals = [];
                            for (var k = 0, O = E[D].vertexNormals.length; k < O; k++) {
                                var F = E[D].vertexNormals[k],
                                    I = {};
                                I.a = F.a.clone(), I.b = F.b.clone(), I.c = F.c.clone(), L.vertexNormals.push(I)
                            }
                        }
                        if (void 0 !== E[D].faceNormals) {
                            L.faceNormals = [];
                            for (var N = 0, B = E[D].faceNormals.length; N < B; N++) L.faceNormals.push(E[D].faceNormals[N].clone())
                        }
                        this.morphNormals.push(L)
                    }
                    for (var R = t.skinWeights, z = 0, G = R.length; z < G; z++) this.skinWeights.push(R[z].clone());
                    for (var V = t.skinIndices, U = 0, j = V.length; U < j; U++) this.skinIndices.push(V[U].clone());
                    for (var H = t.lineDistances, W = 0, q = H.length; W < q; W++) this.lineDistances.push(H[W]);
                    var X = t.boundingBox;
                    null !== X && (this.boundingBox = X.clone());
                    var Y = t.boundingSphere;
                    return null !== Y && (this.boundingSphere = Y.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), (Mr.prototype = Object.create(Sr.prototype)).constructor = Mr, (Tr.prototype = Object.create(Kn.prototype)).constructor = Tr;
            var Er = {
                    clone: Cr,
                    merge: Ar
                },
                Dr = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                Pr = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

            function Lr(t) {
                Dn.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = Dr, this.fragmentShader = Pr, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (t.attributes, this.setValues(t))
            }

            function kr() {
                rn.call(this), this.type = "Camera", this.matrixWorldInverse = new Li, this.projectionMatrix = new Li, this.projectionMatrixInverse = new Li
            }

            function Or(t, e, i, n) {
                kr.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }((Lr.prototype = Object.create(Dn.prototype)).constructor = Lr).prototype.isShaderMaterial = !0, Lr.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Cr(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
            }, Lr.prototype.toJSON = function(t) {
                var e = Dn.prototype.toJSON.call(this, t);
                for (var i in e.glslVersion = this.glslVersion, e.uniforms = {}, this.uniforms) {
                    var n = this.uniforms[i].value;
                    n && n.isTexture ? e.uniforms[i] = {
                        type: "t",
                        value: n.toJSON(t).uuid
                    } : n && n.isColor ? e.uniforms[i] = {
                        type: "c",
                        value: n.getHex()
                    } : n && n.isVector2 ? e.uniforms[i] = {
                        type: "v2",
                        value: n.toArray()
                    } : n && n.isVector3 ? e.uniforms[i] = {
                        type: "v3",
                        value: n.toArray()
                    } : n && n.isVector4 ? e.uniforms[i] = {
                        type: "v4",
                        value: n.toArray()
                    } : n && n.isMatrix3 ? e.uniforms[i] = {
                        type: "m3",
                        value: n.toArray()
                    } : n && n.isMatrix4 ? e.uniforms[i] = {
                        type: "m4",
                        value: n.toArray()
                    } : e.uniforms[i] = {
                        value: n
                    }
                }
                0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                var r = {};
                for (var a in this.extensions) !0 === this.extensions[a] && (r[a] = !0);
                return 0 < Object.keys(r).length && (e.extensions = r), e
            }, kr.prototype = Object.assign(Object.create(rn.prototype), {
                constructor: kr,
                isCamera: !0,
                copy: function(t, e) {
                    return rn.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (t = new ni), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    rn.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                updateWorldMatrix: function(t, e) {
                    rn.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), Or.prototype = Object.assign(Object.create(kr.prototype), {
                constructor: Or,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return kr.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    var e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * je.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var t = Math.tan(.5 * je.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * je.RAD2DEG * Math.atan(Math.tan(.5 * je.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, i, n, r, a) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t, e, i = this.near,
                        n = i * Math.tan(.5 * je.DEG2RAD * this.fov) / this.zoom,
                        r = 2 * n,
                        a = this.aspect * r,
                        s = -.5 * a,
                        o = this.view;
                    null !== this.view && this.view.enabled && (t = o.fullWidth, e = o.fullHeight, s += o.offsetX * a / t, n -= o.offsetY * r / e, a *= o.width / t, r *= o.height / e);
                    var l = this.filmOffset;
                    0 !== l && (s += i * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + a, n, n - r, i, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = rn.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            });

            function Fr(t, e, s) {
                var a, o, l, h, u, c;
                rn.call(this), this.type = "CubeCamera", !0 === s.isWebGLCubeRenderTarget && (this.renderTarget = s, (a = new Or(90, 1, t, e)).layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new ni(1, 0, 0)), this.add(a), (o = new Or(90, 1, t, e)).layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new ni(-1, 0, 0)), this.add(o), (l = new Or(90, 1, t, e)).layers = this.layers, l.up.set(0, 0, 1), l.lookAt(new ni(0, 1, 0)), this.add(l), (h = new Or(90, 1, t, e)).layers = this.layers, h.up.set(0, 0, -1), h.lookAt(new ni(0, -1, 0)), this.add(h), (u = new Or(90, 1, t, e)).layers = this.layers, u.up.set(0, -1, 0), u.lookAt(new ni(0, 0, 1)), this.add(u), (c = new Or(90, 1, t, e)).layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new ni(0, 0, -1)), this.add(c), this.update = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    var i = t.xr.enabled,
                        n = t.getRenderTarget();
                    t.xr.enabled = !1;
                    var r = s.texture.generateMipmaps;
                    s.texture.generateMipmaps = !1, t.setRenderTarget(s, 0), t.render(e, a), t.setRenderTarget(s, 1), t.render(e, o), t.setRenderTarget(s, 2), t.render(e, l), t.setRenderTarget(s, 3), t.render(e, h), t.setRenderTarget(s, 4), t.render(e, u), s.texture.generateMipmaps = r, t.setRenderTarget(s, 5), t.render(e, c), t.setRenderTarget(n), t.xr.enabled = i
                }, this.clear = function(t, e, i, n) {
                    for (var r = t.getRenderTarget(), a = 0; a < 6; a++) t.setRenderTarget(s, a), t.clear(e, i, n);
                    t.setRenderTarget(r)
                })
            }

            function Ir(t, e, i) {
                Number.isInteger(e) && (e = i), Qe.call(this, t, t, e), this.texture.isWebGLCubeRenderTargetTexture = !0
            }

            function Nr(t, e, i, n, r, a, s, o, l, h, u, c) {
                Ze.call(this, null, a, s, o, l, h, n, r, u, c), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: i || 1
                }, this.magFilter = void 0 !== l ? l : It, this.minFilter = void 0 !== h ? h : It, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }(Fr.prototype = Object.create(rn.prototype)).constructor = Fr, ((Ir.prototype = Object.create(Qe.prototype)).constructor = Ir).prototype.isWebGLCubeRenderTarget = !0, Ir.prototype.fromEquirectangularTexture = function(t, e) {
                this.texture.type = e.type, this.texture.format = Yt, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                var i = {
                        tEquirect: {
                            value: null
                        }
                    },
                    n = "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
                    r = "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t",
                    a = new Tr(5, 5, 5),
                    s = new Lr({
                        name: "CubemapFromEquirect",
                        uniforms: Cr(i),
                        vertexShader: n,
                        fragmentShader: r,
                        side: q,
                        blending: Y
                    });
                s.uniforms.tEquirect.value = e;
                var o = new gr(a, s),
                    l = e.minFilter;
                return e.minFilter === Gt && (e.minFilter = Rt), new Fr(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
            }, ((Nr.prototype = Object.create(Ze.prototype)).constructor = Nr).prototype.isDataTexture = !0;
            var Br = new li,
                Rr = new ni,
                zr = function(t, e, i, n, r, a) {
                    this.planes = [void 0 !== t ? t : new ln, void 0 !== e ? e : new ln, void 0 !== i ? i : new ln, void 0 !== n ? n : new ln, void 0 !== r ? r : new ln, void 0 !== a ? a : new ln]
                };

            function Gr() {
                var i = null,
                    t = !1,
                    n = null,
                    r = null;

                function a(t, e) {
                    n(t, e), r = i.requestAnimationFrame(a)
                }
                return {
                    start: function() {
                        !0 !== t && null !== n && (r = i.requestAnimationFrame(a), t = !0)
                    },
                    stop: function() {
                        i.cancelAnimationFrame(r), t = !1
                    },
                    setAnimationLoop: function(t) {
                        n = t
                    },
                    setContext: function(t) {
                        i = t
                    }
                }
            }

            function Vr(h, t) {
                var u = t.isWebGL2,
                    c = new WeakMap;
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), c.get(t)
                    },
                    remove: function(t) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        var e = c.get(t);
                        e && (h.deleteBuffer(e.buffer), c.delete(t))
                    },
                    update: function(t, e) {
                        var i, n, r, a, s, o, l;
                        t.isGLBufferAttribute ? (!(i = c.get(t)) || i.version < t.version) && c.set(t, {
                            buffer: t.buffer,
                            type: t.type,
                            bytesPerElement: t.elementSize,
                            version: t.version
                        }) : (t.isInterleavedBufferAttribute && (t = t.data), void 0 === (n = c.get(t)) ? c.set(t, function(t, e) {
                            var i = t.array,
                                n = t.usage,
                                r = h.createBuffer();
                            h.bindBuffer(e, r), h.bufferData(e, i, n), t.onUploadCallback();
                            var a = 5126;
                            return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array || (i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121)), {
                                buffer: r,
                                type: a,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: t.version
                            }
                        }(t, e)) : n.version < t.version && (r = n.buffer, s = e, o = (a = t).array, l = a.updateRange, h.bindBuffer(s, r), -1 === l.count ? h.bufferSubData(s, 0, o) : (u ? h.bufferSubData(s, l.offset * o.BYTES_PER_ELEMENT, o, l.offset, l.count) : h.bufferSubData(s, l.offset * o.BYTES_PER_ELEMENT, o.subarray(l.offset, l.offset + l.count)), l.count = -1), n.version = t.version))
                    }
                }
            }

            function Ur(t, e, i, n) {
                Sr.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: i,
                    heightSegments: n
                }, this.fromBufferGeometry(new jr(t, e, i, n)), this.mergeVertices()
            }

            function jr(t, e, i, n) {
                Kn.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: i,
                    heightSegments: n
                };
                for (var r = (t = t || 1) / 2, a = (e = e || 1) / 2, s = Math.floor(i) || 1, o = Math.floor(n) || 1, l = s + 1, h = o + 1, u = t / s, c = e / o, p = [], d = [], f = [], m = [], g = 0; g < h; g++)
                    for (var v = g * c - a, y = 0; y < l; y++) {
                        var b = y * u - r;
                        d.push(b, -v, 0), f.push(0, 0, 1), m.push(y / s), m.push(1 - g / o)
                    }
                for (var x = 0; x < o; x++)
                    for (var _ = 0; _ < s; _++) {
                        var w = _ + l * x,
                            S = _ + l * (x + 1),
                            M = _ + 1 + l * (x + 1),
                            T = _ + 1 + l * x;
                        p.push(w, S, T), p.push(S, M, T)
                    }
                this.setIndex(p), this.setAttribute("position", new Vn(d, 3)), this.setAttribute("normal", new Vn(f, 3)), this.setAttribute("uv", new Vn(m, 2))
            }
            zr.prototype.set = function(t, e, i, n, r, a) {
                var s = this.planes;
                return s[0].copy(t), s[1].copy(e), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(a), this
            }, zr.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, zr.prototype.copy = function(t) {
                for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                return this
            }, zr.prototype.setFromProjectionMatrix = function(t) {
                var e = this.planes,
                    i = t.elements,
                    n = i[0],
                    r = i[1],
                    a = i[2],
                    s = i[3],
                    o = i[4],
                    l = i[5],
                    h = i[6],
                    u = i[7],
                    c = i[8],
                    p = i[9],
                    d = i[10],
                    f = i[11],
                    m = i[12],
                    g = i[13],
                    v = i[14],
                    y = i[15];
                return e[0].setComponents(s - n, u - o, f - c, y - m).normalize(), e[1].setComponents(s + n, u + o, f + c, y + m).normalize(), e[2].setComponents(s + r, u + l, f + p, y + g).normalize(), e[3].setComponents(s - r, u - l, f - p, y - g).normalize(), e[4].setComponents(s - a, u - h, f - d, y - v).normalize(), e[5].setComponents(s + a, u + h, f + d, y + v).normalize(), this
            }, zr.prototype.intersectsObject = function(t) {
                var e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(), Br.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Br)
            }, zr.prototype.intersectsSprite = function(t) {
                return Br.center.set(0, 0, 0), Br.radius = .7071067811865476, Br.applyMatrix4(t.matrixWorld), this.intersectsSphere(Br)
            }, zr.prototype.intersectsSphere = function(t) {
                for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
                    if (e[r].distanceToPoint(i) < n) return !1
                }
                return !0
            }, zr.prototype.intersectsBox = function(t) {
                for (var e = this.planes, i = 0; i < 6; i++) {
                    var n = e[i];
                    if (Rr.x = 0 < n.normal.x ? t.max.x : t.min.x, Rr.y = 0 < n.normal.y ? t.max.y : t.min.y, Rr.z = 0 < n.normal.z ? t.max.z : t.min.z, n.distanceToPoint(Rr) < 0) return !1
                }
                return !0
            }, zr.prototype.containsPoint = function(t) {
                for (var e = this.planes, i = 0; i < 6; i++)
                    if (e[i].distanceToPoint(t) < 0) return !1;
                return !0
            }, (Ur.prototype = Object.create(Sr.prototype)).constructor = Ur, (jr.prototype = Object.create(Kn.prototype)).constructor = jr;
            var Hr = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                    normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
                    transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                },
                Wr = {
                    common: {
                        diffuse: {
                            value: new Cn(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Xe
                        },
                        uv2Transform: {
                            value: new Xe
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new He(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new Cn(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new Cn(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new Xe
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new Cn(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new He(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new Xe
                        }
                    }
                },
                qr = {
                    basic: {
                        uniforms: Ar([Wr.common, Wr.specularmap, Wr.envmap, Wr.aomap, Wr.lightmap, Wr.fog]),
                        vertexShader: Hr.meshbasic_vert,
                        fragmentShader: Hr.meshbasic_frag
                    },
                    lambert: {
                        uniforms: Ar([Wr.common, Wr.specularmap, Wr.envmap, Wr.aomap, Wr.lightmap, Wr.emissivemap, Wr.fog, Wr.lights, {
                            emissive: {
                                value: new Cn(0)
                            }
                        }]),
                        vertexShader: Hr.meshlambert_vert,
                        fragmentShader: Hr.meshlambert_frag
                    },
                    phong: {
                        uniforms: Ar([Wr.common, Wr.specularmap, Wr.envmap, Wr.aomap, Wr.lightmap, Wr.emissivemap, Wr.bumpmap, Wr.normalmap, Wr.displacementmap, Wr.fog, Wr.lights, {
                            emissive: {
                                value: new Cn(0)
                            },
                            specular: {
                                value: new Cn(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Hr.meshphong_vert,
                        fragmentShader: Hr.meshphong_frag
                    },
                    standard: {
                        uniforms: Ar([Wr.common, Wr.envmap, Wr.aomap, Wr.lightmap, Wr.emissivemap, Wr.bumpmap, Wr.normalmap, Wr.displacementmap, Wr.roughnessmap, Wr.metalnessmap, Wr.fog, Wr.lights, {
                            emissive: {
                                value: new Cn(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Hr.meshphysical_vert,
                        fragmentShader: Hr.meshphysical_frag
                    },
                    toon: {
                        uniforms: Ar([Wr.common, Wr.aomap, Wr.lightmap, Wr.emissivemap, Wr.bumpmap, Wr.normalmap, Wr.displacementmap, Wr.gradientmap, Wr.fog, Wr.lights, {
                            emissive: {
                                value: new Cn(0)
                            }
                        }]),
                        vertexShader: Hr.meshtoon_vert,
                        fragmentShader: Hr.meshtoon_frag
                    },
                    matcap: {
                        uniforms: Ar([Wr.common, Wr.bumpmap, Wr.normalmap, Wr.displacementmap, Wr.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: Hr.meshmatcap_vert,
                        fragmentShader: Hr.meshmatcap_frag
                    },
                    points: {
                        uniforms: Ar([Wr.points, Wr.fog]),
                        vertexShader: Hr.points_vert,
                        fragmentShader: Hr.points_frag
                    },
                    dashed: {
                        uniforms: Ar([Wr.common, Wr.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Hr.linedashed_vert,
                        fragmentShader: Hr.linedashed_frag
                    },
                    depth: {
                        uniforms: Ar([Wr.common, Wr.displacementmap]),
                        vertexShader: Hr.depth_vert,
                        fragmentShader: Hr.depth_frag
                    },
                    normal: {
                        uniforms: Ar([Wr.common, Wr.bumpmap, Wr.normalmap, Wr.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Hr.normal_vert,
                        fragmentShader: Hr.normal_frag
                    },
                    sprite: {
                        uniforms: Ar([Wr.sprite, Wr.fog]),
                        vertexShader: Hr.sprite_vert,
                        fragmentShader: Hr.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new Xe
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: Hr.background_vert,
                        fragmentShader: Hr.background_frag
                    },
                    cube: {
                        uniforms: Ar([Wr.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Hr.cube_vert,
                        fragmentShader: Hr.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: Hr.equirect_vert,
                        fragmentShader: Hr.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: Ar([Wr.common, Wr.displacementmap, {
                            referencePosition: {
                                value: new ni
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: Hr.distanceRGBA_vert,
                        fragmentShader: Hr.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: Ar([Wr.lights, Wr.fog, {
                            color: {
                                value: new Cn(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Hr.shadow_vert,
                        fragmentShader: Hr.shadow_frag
                    }
                };

            function Xr(o, l, i, h, n) {
                var u, c, p = new Cn(0),
                    d = 0,
                    f = null,
                    m = 0,
                    g = null;

                function v(t, e) {
                    i.buffers.color.setClear(t.r, t.g, t.b, e, n)
                }
                return {
                    getClearColor: function() {
                        return p
                    },
                    setClearColor: function(t, e) {
                        p.set(t), v(p, d = void 0 !== e ? e : 1)
                    },
                    getClearAlpha: function() {
                        return d
                    },
                    setClearAlpha: function(t) {
                        v(p, d = t)
                    },
                    render: function(t, e, i, n) {
                        var r = !0 === e.isScene ? e.background : null;
                        r && r.isTexture && (r = l.get(r));
                        var a = o.xr,
                            s = a.getSession && a.getSession();
                        s && "additive" === s.environmentBlendMode && (r = null), null === r ? v(p, d) : r && r.isColor && (v(r, 1), n = !0), (o.autoClear || n) && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil), r && (r.isCubeTexture || r.isWebGLCubeRenderTarget || r.isWebGLCubeRenderTargetTexture || r.mapping === Pt) ? (void 0 === c && ((c = new gr(new Tr(1, 1, 1), new Lr({
                            name: "BackgroundCubeMaterial",
                            uniforms: Cr(qr.cube.uniforms),
                            vertexShader: qr.cube.vertexShader,
                            fragmentShader: qr.cube.fragmentShader,
                            side: q,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(t, e, i) {
                            this.matrixWorld.copyPosition(i.matrixWorld)
                        }, Object.defineProperty(c.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), h.update(c)), r.isWebGLCubeRenderTarget && (r = r.texture), c.material.uniforms.envMap.value = r, c.material.uniforms.flipEnvMap.value = r.isCubeTexture ? -1 : 1, f === r && m === r.version && g === o.toneMapping || (c.material.needsUpdate = !0, m = (f = r).version, g = o.toneMapping), t.unshift(c, c.geometry, c.material, 0, 0, null)) : r && r.isTexture && (void 0 === u && ((u = new gr(new jr(2, 2), new Lr({
                            name: "BackgroundMaterial",
                            uniforms: Cr(qr.background.uniforms),
                            vertexShader: qr.background.vertexShader,
                            fragmentShader: qr.background.fragmentShader,
                            side: k,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), h.update(u)), !0 === (u.material.uniforms.t2D.value = r).matrixAutoUpdate && r.updateMatrix(), u.material.uniforms.uvTransform.value.copy(r.matrix), f === r && m === r.version && g === o.toneMapping || (u.material.needsUpdate = !0, m = (f = r).version, g = o.toneMapping), t.unshift(u, u.geometry, u.material, 0, 0, null))
                    }
                }
            }

            function Yr(C, A, E, D) {
                var a = C.getParameter(34921),
                    l = D.isWebGL2 ? null : A.get("OES_vertex_array_object"),
                    h = D.isWebGL2 || null !== l,
                    u = {},
                    t = d(null),
                    c = t;

                function p(t) {
                    return D.isWebGL2 ? C.bindVertexArray(t) : l.bindVertexArrayOES(t)
                }

                function s(t) {
                    return D.isWebGL2 ? C.deleteVertexArray(t) : l.deleteVertexArrayOES(t)
                }

                function d(t) {
                    for (var e = [], i = [], n = [], r = 0; r < a; r++) e[r] = 0, i[r] = 0, n[r] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: e,
                        enabledAttributes: i,
                        attributeDivisors: n,
                        object: t,
                        attributes: {},
                        index: null
                    }
                }

                function P() {
                    for (var t = c.newAttributes, e = 0, i = t.length; e < i; e++) t[e] = 0
                }

                function L(t) {
                    k(t, 0)
                }

                function k(t, e) {
                    var i = c.newAttributes,
                        n = c.enabledAttributes,
                        r = c.attributeDivisors;
                    i[t] = 1, 0 === n[t] && (C.enableVertexAttribArray(t), n[t] = 1), r[t] !== e && ((D.isWebGL2 ? C : A.get("ANGLE_instanced_arrays"))[D.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](t, e), r[t] = e)
                }

                function O() {
                    for (var t = c.newAttributes, e = c.enabledAttributes, i = 0, n = e.length; i < n; i++) e[i] !== t[i] && (C.disableVertexAttribArray(i), e[i] = 0)
                }

                function F(t, e, i, n, r, a) {
                    !0 !== D.isWebGL2 || 5124 !== i && 5125 !== i ? C.vertexAttribPointer(t, e, i, n, r, a) : C.vertexAttribIPointer(t, e, i, r, a)
                }

                function o() {
                    e(), c !== t && p((c = t).object)
                }

                function e() {
                    t.geometry = null, t.program = null, t.wireframe = !1
                }
                return {
                    setup: function(t, e, i, n, r) {
                        var a, s, o = !1;
                        h ? (a = function(t, e, i) {
                            var n = !0 === i.wireframe,
                                r = u[t.id];
                            void 0 === r && (r = {}, u[t.id] = r);
                            var a = r[e.id];
                            void 0 === a && (a = {}, r[e.id] = a);
                            var s = a[n];
                            void 0 === s && (s = d(function() {
                                if (D.isWebGL2) return C.createVertexArray();
                                return l.createVertexArrayOES()
                            }()), a[n] = s);
                            return s
                        }(n, i, e), c !== a && p((c = a).object), (o = function(t, e) {
                            var i = c.attributes,
                                n = t.attributes;
                            if (Object.keys(i).length !== Object.keys(n).length) return !0;
                            for (var r in n) {
                                var a = i[r],
                                    s = n[r];
                                if (void 0 === a) return !0;
                                if (a.attribute !== s) return !0;
                                if (a.data !== s.data) return !0
                            }
                            return c.index !== e
                        }(n, r)) && function(t, e) {
                            var i = {},
                                n = t.attributes;
                            for (var r in n) {
                                var a = n[r],
                                    s = {};
                                (s.attribute = a).data && (s.data = a.data), i[r] = s
                            }
                            c.attributes = i, c.index = e
                        }(n, r)) : (s = !0 === e.wireframe, c.geometry === n.id && c.program === i.id && c.wireframe === s || (c.geometry = n.id, c.program = i.id, c.wireframe = s, o = !0)), !0 === t.isInstancedMesh && (o = !0), null !== r && E.update(r, 34963), o && (function(t, e, i, n) {
                            if (!1 === D.isWebGL2 && (t.isInstancedMesh || n.isInstancedBufferGeometry) && null === A.get("ANGLE_instanced_arrays")) return;
                            P();
                            var r = n.attributes,
                                a = i.getAttributes(),
                                s = e.defaultAttributeValues;
                            for (var o in a) {
                                var l = a[o];
                                if (0 <= l) {
                                    var h = r[o];
                                    if (void 0 !== h) {
                                        var u = h.normalized,
                                            c = h.itemSize,
                                            p = E.get(h);
                                        if (void 0 === p) continue;
                                        var d, f, m, g = p.buffer,
                                            v = p.type,
                                            y = p.bytesPerElement;
                                        h.isInterleavedBufferAttribute ? (d = h.data, f = d.stride, m = h.offset, d && d.isInstancedInterleavedBuffer ? (k(l, d.meshPerAttribute), void 0 === n._maxInstanceCount && (n._maxInstanceCount = d.meshPerAttribute * d.count)) : L(l), C.bindBuffer(34962, g), F(l, c, v, u, f * y, m * y)) : (h.isInstancedBufferAttribute ? (k(l, h.meshPerAttribute), void 0 === n._maxInstanceCount && (n._maxInstanceCount = h.meshPerAttribute * h.count)) : L(l), C.bindBuffer(34962, g), F(l, c, v, u, 0, 0))
                                    } else if ("instanceMatrix" === o) {
                                        var b = E.get(t.instanceMatrix);
                                        if (void 0 === b) continue;
                                        var x = b.buffer,
                                            _ = b.type;
                                        k(l + 0, 1), k(l + 1, 1), k(l + 2, 1), k(l + 3, 1), C.bindBuffer(34962, x), C.vertexAttribPointer(l + 0, 4, _, !1, 64, 0), C.vertexAttribPointer(l + 1, 4, _, !1, 64, 16), C.vertexAttribPointer(l + 2, 4, _, !1, 64, 32), C.vertexAttribPointer(l + 3, 4, _, !1, 64, 48)
                                    } else if ("instanceColor" === o) {
                                        var w = E.get(t.instanceColor);
                                        if (void 0 === w) continue;
                                        var S = w.buffer,
                                            M = w.type;
                                        k(l, 1), C.bindBuffer(34962, S), C.vertexAttribPointer(l, 3, M, !1, 12, 0)
                                    } else if (void 0 !== s) {
                                        var T = s[o];
                                        if (void 0 !== T) switch (T.length) {
                                            case 2:
                                                C.vertexAttrib2fv(l, T);
                                                break;
                                            case 3:
                                                C.vertexAttrib3fv(l, T);
                                                break;
                                            case 4:
                                                C.vertexAttrib4fv(l, T);
                                                break;
                                            default:
                                                C.vertexAttrib1fv(l, T)
                                        }
                                    }
                                }
                            }
                            O()
                        }(t, e, i, n), null !== r && C.bindBuffer(34963, E.get(r).buffer))
                    },
                    reset: o,
                    resetDefaultState: e,
                    dispose: function() {
                        for (var t in o(), u) {
                            var e = u[t];
                            for (var i in e) {
                                var n = e[i];
                                for (var r in n) s(n[r].object), delete n[r];
                                delete e[i]
                            }
                            delete u[t]
                        }
                    },
                    releaseStatesOfGeometry: function(t) {
                        if (void 0 !== u[t.id]) {
                            var e = u[t.id];
                            for (var i in e) {
                                var n = e[i];
                                for (var r in n) s(n[r].object), delete n[r];
                                delete e[i]
                            }
                            delete u[t.id]
                        }
                    },
                    releaseStatesOfProgram: function(t) {
                        for (var e in u) {
                            var i = u[e];
                            if (void 0 !== i[t.id]) {
                                var n = i[t.id];
                                for (var r in n) s(n[r].object), delete n[r];
                                delete i[t.id]
                            }
                        }
                    },
                    initAttributes: P,
                    enableAttribute: L,
                    disableUnusedAttributes: O
                }
            }

            function Jr(a, s, o, t) {
                var l, h = t.isWebGL2;
                this.setMode = function(t) {
                    l = t
                }, this.render = function(t, e) {
                    a.drawArrays(l, t, e), o.update(e, l, 1)
                }, this.renderInstances = function(t, e, i) {
                    if (0 !== i) {
                        var n, r;
                        if (h) n = a, r = "drawArraysInstanced";
                        else if (r = "drawArraysInstancedANGLE", null === (n = s.get("ANGLE_instanced_arrays"))) return;
                        n[r](l, t, e, i), o.update(e, l, i)
                    }
                }
            }

            function Zr(e, i, t) {
                var n;

                function r(t) {
                    if ("highp" === t) {
                        if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
                }
                var a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext,
                    s = void 0 !== t.precision ? t.precision : "highp",
                    o = r(s);
                o !== s && (s = o);
                var l = !0 === t.logarithmicDepthBuffer,
                    h = e.getParameter(34930),
                    u = e.getParameter(35660),
                    c = e.getParameter(3379),
                    p = e.getParameter(34076),
                    d = e.getParameter(34921),
                    f = e.getParameter(36347),
                    m = e.getParameter(36348),
                    g = e.getParameter(36349),
                    v = 0 < u,
                    y = a || !!i.get("OES_texture_float");
                return {
                    isWebGL2: a,
                    getMaxAnisotropy: function() {
                        if (void 0 !== n) return n;
                        var t = i.get("EXT_texture_filter_anisotropic");
                        return n = null !== t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: r,
                    precision: s,
                    logarithmicDepthBuffer: l,
                    maxTextures: h,
                    maxVertexTextures: u,
                    maxTextureSize: c,
                    maxCubemapSize: p,
                    maxAttributes: d,
                    maxVertexUniforms: f,
                    maxVaryings: m,
                    maxFragmentUniforms: g,
                    vertexTextures: v,
                    floatFragmentTextures: y,
                    floatVertexTextures: v && y,
                    maxSamples: a ? e.getParameter(36183) : 0
                }
            }

            function $r(c) {
                var u = this,
                    p = null,
                    d = 0,
                    f = !1,
                    m = !1,
                    g = new ln,
                    v = new Xe,
                    y = {
                        value: null,
                        needsUpdate: !1
                    };

                function b() {
                    y.value !== p && (y.value = p, y.needsUpdate = 0 < d), u.numPlanes = d, u.numIntersection = 0
                }

                function x(t, e, i, n) {
                    var r = null !== t ? t.length : 0,
                        a = null;
                    if (0 !== r) {
                        if (a = y.value, !0 !== n || null === a) {
                            var s = i + 4 * r,
                                o = e.matrixWorldInverse;
                            v.getNormalMatrix(o), (null === a || a.length < s) && (a = new Float32Array(s));
                            for (var l = 0, h = i; l !== r; ++l, h += 4) g.copy(t[l]).applyMatrix4(o, v), g.normal.toArray(a, h), a[h + 3] = g.constant
                        }
                        y.value = a, y.needsUpdate = !0
                    }
                    return u.numPlanes = r, u.numIntersection = 0, a
                }
                this.uniform = y, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, i) {
                    var n = 0 !== t.length || e || 0 !== d || f;
                    return f = e, p = x(t, i, 0), d = t.length, n
                }, this.beginShadows = function() {
                    m = !0, x(null)
                }, this.endShadows = function() {
                    m = !1, b()
                }, this.setState = function(t, e, i) {
                    var n = t.clippingPlanes,
                        r = t.clipIntersection,
                        a = t.clipShadows,
                        s = c.get(t);
                    if (!f || null === n || 0 === n.length || m && !a) m ? x(null) : b();
                    else {
                        var o = m ? 0 : d,
                            l = 4 * o,
                            h = s.clippingState || null;
                        y.value = h, h = x(n, e, l, i);
                        for (var u = 0; u !== l; ++u) h[u] = p[u];
                        s.clippingState = h, this.numIntersection = r ? this.numPlanes : 0, this.numPlanes += o
                    }
                }
            }

            function Kr(o) {
                var l = new WeakMap;

                function h(t, e) {
                    return e === u ? t.mapping = Et : e === c && (t.mapping = Dt), t
                }
                return {
                    get: function(t) {
                        if (t && t.isTexture) {
                            var e = t.mapping;
                            if (e === u || e === c) {
                                if (l.has(t)) return h(l.get(t).texture, t.mapping);
                                var i = t.image;
                                if (i && 0 < i.height) {
                                    var n = o.getRenderList(),
                                        r = o.getRenderTarget(),
                                        a = o.getRenderState(),
                                        s = new Ir(i.height / 2);
                                    return s.fromEquirectangularTexture(o, t), l.set(t, s), o.setRenderTarget(r), o.setRenderList(n), o.setRenderState(a), h(s.texture, t.mapping)
                                }
                                return null
                            }
                        }
                        return t
                    },
                    dispose: function() {
                        l = new WeakMap
                    }
                }
            }

            function Qr(i) {
                var n = {};
                return {
                    has: function(t) {
                        if (void 0 !== n[t]) return null !== n[t];
                        var e;
                        switch (t) {
                            case "WEBGL_depth_texture":
                                e = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                e = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                e = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                e = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                e = i.getExtension(t)
                        }
                        return null !== (n[t] = e)
                    },
                    get: function(t) {
                        return this.has(t), n[t]
                    }
                }
            }

            function ta(t, b, a, s) {
                var o = new WeakMap,
                    x = new WeakMap;

                function l(t) {
                    var e = t.target,
                        i = o.get(e);
                    for (var n in null !== i.index && b.remove(i.index), i.attributes) b.remove(i.attributes[n]);
                    e.removeEventListener("dispose", l), o.delete(e);
                    var r = x.get(i);
                    r && (b.remove(r), x.delete(i)), s.releaseStatesOfGeometry(e), !0 === e.isInstancedBufferGeometry && delete e._maxInstanceCount, a.memory.geometries--
                }

                function n(t) {
                    var e = [],
                        i = t.index,
                        n = t.attributes.position,
                        r = 0;
                    if (null !== i)
                        for (var a = i.array, r = i.version, s = 0, o = a.length; s < o; s += 3) {
                            var l = a[s + 0],
                                h = a[s + 1],
                                u = a[s + 2];
                            e.push(l, h, h, u, u, l)
                        } else {
                            var c = n.array;
                            r = n.version;
                            for (var p = 0, d = c.length / 3 - 1; p < d; p += 3) {
                                var f = p + 0,
                                    m = p + 1,
                                    g = p + 2;
                                e.push(f, m, m, g, g, f)
                            }
                        }
                    var v = new(65535 < Hn(e) ? Gn : Rn)(e, 1);
                    v.version = r;
                    var y = x.get(t);
                    y && b.remove(y), x.set(t, v)
                }
                return {
                    get: function(t, e) {
                        var i = o.get(e);
                        return i || (e.addEventListener("dispose", l), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Kn).setFromObject(t)), i = e._bufferGeometry), o.set(e, i), a.memory.geometries++, i)
                    },
                    update: function(t) {
                        var e = t.attributes;
                        for (var i in e) b.update(e[i], 34962);
                        var n = t.morphAttributes;
                        for (var r in n)
                            for (var a = n[r], s = 0, o = a.length; s < o; s++) b.update(a[s], 34962)
                    },
                    getWireframeAttribute: function(t) {
                        var e, i = x.get(t);
                        return (!i || null !== (e = t.index) && i.version < e.version) && n(t), x.get(t)
                    }
                }
            }

            function ea(a, s, o, t) {
                var l, h, u, c = t.isWebGL2;
                this.setMode = function(t) {
                    l = t
                }, this.setIndex = function(t) {
                    h = t.type, u = t.bytesPerElement
                }, this.render = function(t, e) {
                    a.drawElements(l, e, h, t * u), o.update(e, l, 1)
                }, this.renderInstances = function(t, e, i) {
                    if (0 !== i) {
                        var n, r;
                        if (c) n = a, r = "drawElementsInstanced";
                        else if (r = "drawElementsInstancedANGLE", null === (n = s.get("ANGLE_instanced_arrays"))) return;
                        n[r](l, e, h, t * u, i), o.update(e, l, i)
                    }
                }
            }

            function ia(t) {
                var n = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: n,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0
                    },
                    update: function(t, e, i) {
                        switch (n.calls++, e) {
                            case 4:
                                n.triangles += i * (t / 3);
                                break;
                            case 1:
                                n.lines += i * (t / 2);
                                break;
                            case 3:
                                n.lines += i * (t - 1);
                                break;
                            case 2:
                                n.lines += i * t;
                                break;
                            case 0:
                                n.points += i * t
                        }
                    }
                }
            }

            function na(t, e) {
                return t[0] - e[0]
            }

            function ra(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function aa(b) {
                for (var x = {}, _ = new Float32Array(8), w = [], t = 0; t < 8; t++) w[t] = [t, 0];
                return {
                    update: function(t, e, i, n) {
                        var r = t.morphTargetInfluences,
                            a = void 0 === r ? 0 : r.length,
                            s = x[e.id];
                        if (void 0 === s) {
                            s = [];
                            for (var o = 0; o < a; o++) s[o] = [o, 0];
                            x[e.id] = s
                        }
                        for (var l = 0; l < a; l++) {
                            var h = s[l];
                            h[0] = l, h[1] = r[l]
                        }
                        s.sort(ra);
                        for (var u = 0; u < 8; u++) u < a && s[u][1] ? (w[u][0] = s[u][0], w[u][1] = s[u][1]) : (w[u][0] = Number.MAX_SAFE_INTEGER, w[u][1] = 0);
                        w.sort(na);
                        for (var c = i.morphTargets && e.morphAttributes.position, p = i.morphNormals && e.morphAttributes.normal, d = 0, f = 0; f < 8; f++) {
                            var m = w[f],
                                g = m[0],
                                v = m[1];
                            g !== Number.MAX_SAFE_INTEGER && v ? (c && e.getAttribute("morphTarget" + f) !== c[g] && e.setAttribute("morphTarget" + f, c[g]), p && e.getAttribute("morphNormal" + f) !== p[g] && e.setAttribute("morphNormal" + f, p[g]), d += _[f] = v) : (c && void 0 !== e.getAttribute("morphTarget" + f) && e.deleteAttribute("morphTarget" + f), p && void 0 !== e.getAttribute("morphNormal" + f) && e.deleteAttribute("morphNormal" + f), _[f] = 0)
                        }
                        var y = e.morphTargetsRelative ? 1 : 1 - d;
                        n.getUniforms().setValue(b, "morphTargetBaseInfluence", y), n.getUniforms().setValue(b, "morphTargetInfluences", _)
                    }
                }
            }

            function sa(t, r, a, s) {
                var o = new WeakMap;
                return {
                    update: function(t) {
                        var e = s.render.frame,
                            i = t.geometry,
                            n = r.get(t, i);
                        return o.get(n) !== e && (i.isGeometry && n.updateFromObject(t), r.update(n), o.set(n, e)), t.isInstancedMesh && (a.update(t.instanceMatrix, 34962), null !== t.instanceColor && a.update(t.instanceColor, 34962)), n
                    },
                    dispose: function() {
                        o = new WeakMap
                    }
                }
            }

            function oa(t, e, i, n, r, a, s, o, l, h) {
                Ze.call(this, t = void 0 !== t ? t : [], e = void 0 !== e ? e : Et, i, n, r, a, s = void 0 !== s ? s : Xt, o, l, h), this.flipY = !1
            }

            function la(t, e, i, n) {
                Ze.call(this, null), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: i || 1,
                    depth: n || 1
                }, this.magFilter = It, this.minFilter = It, this.wrapR = Ot, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }

            function ha(t, e, i, n) {
                Ze.call(this, null), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: i || 1,
                    depth: n || 1
                }, this.magFilter = It, this.minFilter = It, this.wrapR = Ot, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }
            qr.physical = {
                uniforms: Ar([qr.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new He(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    sheen: {
                        value: new Cn(0)
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    }
                }]),
                vertexShader: Hr.meshphysical_vert,
                fragmentShader: Hr.meshphysical_frag
            }, ((oa.prototype = Object.create(Ze.prototype)).constructor = oa).prototype.isCubeTexture = !0, Object.defineProperty(oa.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            }), ((la.prototype = Object.create(Ze.prototype)).constructor = la).prototype.isDataTexture2DArray = !0, ((ha.prototype = Object.create(Ze.prototype)).constructor = ha).prototype.isDataTexture3D = !0;
            var ua = new Ze,
                ca = new la,
                pa = new ha,
                da = new oa,
                fa = [],
                ma = [],
                ga = new Float32Array(16),
                va = new Float32Array(9),
                ya = new Float32Array(4);

            function ba(t, e, i) {
                var n = t[0];
                if (n <= 0 || 0 < n) return t;
                var r = e * i,
                    a = fa[r];
                if (void 0 === a && (a = new Float32Array(r), fa[r] = a), 0 !== e) {
                    n.toArray(a, 0);
                    for (var s = 1, o = 0; s !== e; ++s) o += i, t[s].toArray(a, o)
                }
                return a
            }

            function xa(t, e) {
                if (t.length === e.length) {
                    for (var i = 0, n = t.length; i < n; i++)
                        if (t[i] !== e[i]) return;
                    return 1
                }
            }

            function _a(t, e) {
                for (var i = 0, n = e.length; i < n; i++) t[i] = e[i]
            }

            function wa(t, e) {
                var i = ma[e];
                void 0 === i && (i = new Int32Array(e), ma[e] = i);
                for (var n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
                return i
            }

            function Sa(t, e) {
                var i = this.cache;
                i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
            }

            function Ma(t, e) {
                var i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
                else {
                    if (xa(i, e)) return;
                    t.uniform2fv(this.addr, e), _a(i, e)
                }
            }

            function Ta(t, e) {
                var i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
                else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
                else {
                    if (xa(i, e)) return;
                    t.uniform3fv(this.addr, e), _a(i, e)
                }
            }

            function Ca(t, e) {
                var i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
                else {
                    if (xa(i, e)) return;
                    t.uniform4fv(this.addr, e), _a(i, e)
                }
            }

            function Aa(t, e) {
                var i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (xa(i, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), _a(i, e)
                } else {
                    if (xa(i, n)) return;
                    ya.set(n), t.uniformMatrix2fv(this.addr, !1, ya), _a(i, n)
                }
            }

            function Ea(t, e) {
                var i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (xa(i, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), _a(i, e)
                } else {
                    if (xa(i, n)) return;
                    va.set(n), t.uniformMatrix3fv(this.addr, !1, va), _a(i, n)
                }
            }

            function Da(t, e) {
                var i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (xa(i, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), _a(i, e)
                } else {
                    if (xa(i, n)) return;
                    ga.set(n), t.uniformMatrix4fv(this.addr, !1, ga), _a(i, n)
                }
            }

            function Pa(t, e, i) {
                var n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(e || ua, r)
            }

            function La(t, e, i) {
                var n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(e || ca, r)
            }

            function ka(t, e, i) {
                var n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || pa, r)
            }

            function Oa(t, e, i) {
                var n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(e || da, r)
            }

            function Fa(t, e) {
                var i = this.cache;
                i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
            }

            function Ia(t, e) {
                var i = this.cache;
                xa(i, e) || (t.uniform2iv(this.addr, e), _a(i, e))
            }

            function Na(t, e) {
                var i = this.cache;
                xa(i, e) || (t.uniform3iv(this.addr, e), _a(i, e))
            }

            function Ba(t, e) {
                var i = this.cache;
                xa(i, e) || (t.uniform4iv(this.addr, e), _a(i, e))
            }

            function Ra(t, e) {
                var i = this.cache;
                i[0] !== e && (t.uniform1ui(this.addr, e), i[0] = e)
            }

            function za(t, e) {
                t.uniform1fv(this.addr, e)
            }

            function Ga(t, e) {
                t.uniform1iv(this.addr, e)
            }

            function Va(t, e) {
                t.uniform2iv(this.addr, e)
            }

            function Ua(t, e) {
                t.uniform3iv(this.addr, e)
            }

            function ja(t, e) {
                t.uniform4iv(this.addr, e)
            }

            function Ha(t, e) {
                var i = ba(e, this.size, 2);
                t.uniform2fv(this.addr, i)
            }

            function Wa(t, e) {
                var i = ba(e, this.size, 3);
                t.uniform3fv(this.addr, i)
            }

            function qa(t, e) {
                var i = ba(e, this.size, 4);
                t.uniform4fv(this.addr, i)
            }

            function Xa(t, e) {
                var i = ba(e, this.size, 4);
                t.uniformMatrix2fv(this.addr, !1, i)
            }

            function Ya(t, e) {
                var i = ba(e, this.size, 9);
                t.uniformMatrix3fv(this.addr, !1, i)
            }

            function Ja(t, e) {
                var i = ba(e, this.size, 16);
                t.uniformMatrix4fv(this.addr, !1, i)
            }

            function Za(t, e, i) {
                var n = e.length,
                    r = wa(i, n);
                t.uniform1iv(this.addr, r);
                for (var a = 0; a !== n; ++a) i.safeSetTexture2D(e[a] || ua, r[a])
            }

            function $a(t, e, i) {
                var n = e.length,
                    r = wa(i, n);
                t.uniform1iv(this.addr, r);
                for (var a = 0; a !== n; ++a) i.safeSetTextureCube(e[a] || da, r[a])
            }

            function Ka(t, e, i) {
                this.id = t, this.addr = i, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Sa;
                        case 35664:
                            return Ma;
                        case 35665:
                            return Ta;
                        case 35666:
                            return Ca;
                        case 35674:
                            return Aa;
                        case 35675:
                            return Ea;
                        case 35676:
                            return Da;
                        case 5124:
                        case 35670:
                            return Fa;
                        case 35667:
                        case 35671:
                            return Ia;
                        case 35668:
                        case 35672:
                            return Na;
                        case 35669:
                        case 35673:
                            return Ba;
                        case 5125:
                            return Ra;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Pa;
                        case 35679:
                        case 36299:
                        case 36307:
                            return ka;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Oa;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return La
                    }
                }(e.type)
            }

            function Qa(t, e, i) {
                this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return za;
                        case 35664:
                            return Ha;
                        case 35665:
                            return Wa;
                        case 35666:
                            return qa;
                        case 35674:
                            return Xa;
                        case 35675:
                            return Ya;
                        case 35676:
                            return Ja;
                        case 5124:
                        case 35670:
                            return Ga;
                        case 35667:
                        case 35671:
                            return Va;
                        case 35668:
                        case 35672:
                            return Ua;
                        case 35669:
                        case 35673:
                            return ja;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Za;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return $a
                    }
                }(e.type)
            }

            function ts(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            Qa.prototype.updateCache = function(t) {
                var e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), _a(e, t)
            }, ts.prototype.setValue = function(t, e, i) {
                for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
                    var s = n[r];
                    s.setValue(t, e[s.id], i)
                }
            };
            var es = /([\w\d_]+)(\])?(\[|\.)?/g;

            function is(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function ns(t, e) {
                this.seq = [], this.map = {};
                for (var i = t.getProgramParameter(e, 35718), n = 0; n < i; ++n) {
                    var r = t.getActiveUniform(e, n);
                    ! function(t, e, i) {
                        var n = t.name,
                            r = n.length;
                        for (es.lastIndex = 0;;) {
                            var a = es.exec(n),
                                s = es.lastIndex,
                                o = a[1],
                                l = "]" === a[2],
                                h = a[3];
                            if (l && (o |= 0), void 0 === h || "[" === h && s + 2 === r) {
                                is(i, new(void 0 === h ? Ka : Qa)(o, t, e));
                                break
                            }
                            var u = i.map[o];
                            void 0 === u && is(i, u = new ts(o)), i = u
                        }
                    }(r, t.getUniformLocation(e, r.name), this)
                }
            }

            function rs(t, e, i) {
                var n = t.createShader(e);
                return t.shaderSource(n, i), t.compileShader(n), n
            }
            ns.prototype.setValue = function(t, e, i, n) {
                var r = this.map[e];
                void 0 !== r && r.setValue(t, i, n)
            }, ns.prototype.setOptional = function(t, e, i) {
                var n = e[i];
                void 0 !== n && this.setValue(t, i, n)
            }, ns.upload = function(t, e, i, n) {
                for (var r = 0, a = e.length; r !== a; ++r) {
                    var s = e[r],
                        o = i[s.id];
                    !1 !== o.needsUpdate && s.setValue(t, o.value, n)
                }
            }, ns.seqWithValue = function(t, e) {
                for (var i = [], n = 0, r = t.length; n !== r; ++n) {
                    var a = t[n];
                    a.id in e && i.push(a)
                }
                return i
            };
            var as = 0;

            function ss(t) {
                switch (t) {
                    case Te:
                        return ["Linear", "( value )"];
                    case Ce:
                        return ["sRGB", "( value )"];
                    case Ee:
                        return ["RGBE", "( value )"];
                    case i:
                        return ["RGBM", "( value, 7.0 )"];
                    case n:
                        return ["RGBM", "( value, 16.0 )"];
                    case De:
                        return ["RGBD", "( value, 256.0 )"];
                    case Ae:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case e:
                        return ["LogLuv", "( value )"];
                    default:
                        return ["Linear", "( value )"]
                }
            }

            function os(t, e, i) {
                var n = t.getShaderParameter(e, 35713),
                    r = t.getShaderInfoLog(e).trim();
                return n && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + i + "\n" + r + function(t) {
                    for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
                    return e.join("\n")
                }(t.getShaderSource(e))
            }

            function ls(t, e) {
                var i = ss(e);
                return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
            }

            function hs(t) {
                return "" !== t
            }

            function us(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
            }

            function cs(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }
            var ps = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function ds(t) {
                return t.replace(ps, fs)
            }

            function fs(t, e) {
                var i = Hr[e];
                if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
                return ds(i)
            }
            var ms = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                gs = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function vs(t) {
                return t.replace(gs, bs).replace(ms, ys)
            }

            function ys(t, e, i, n) {
                return bs(0, e, i, n)
            }

            function bs(t, e, i, n) {
                for (var r = "", a = parseInt(e); a < parseInt(i); a++) r += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
                return r
            }

            function xs(t) {
                var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
            }

            function _s(t, e, i, n) {
                var r, a, s, o, l, h, u, c, p = t.getContext(),
                    d = i.defines,
                    f = i.vertexShader,
                    m = i.fragmentShader,
                    g = (a = "SHADOWMAP_TYPE_BASIC", (r = i).shadowMapType === I ? a = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === N ? a = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === B && (a = "SHADOWMAP_TYPE_VSM"), a),
                    v = function(t) {
                        var e = "ENVMAP_TYPE_CUBE";
                        if (t.envMap) switch (t.envMapMode) {
                            case Et:
                            case Dt:
                                e = "ENVMAP_TYPE_CUBE";
                                break;
                            case Pt:
                            case Lt:
                                e = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return e
                    }(i),
                    y = function(t) {
                        var e = "ENVMAP_MODE_REFLECTION";
                        if (t.envMap) switch (t.envMapMode) {
                            case Dt:
                            case Lt:
                                e = "ENVMAP_MODE_REFRACTION"
                        }
                        return e
                    }(i),
                    b = function(t) {
                        var e = "ENVMAP_BLENDING_NONE";
                        if (t.envMap) switch (t.combine) {
                            case R:
                                e = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case z:
                                e = "ENVMAP_BLENDING_MIX";
                                break;
                            case G:
                                e = "ENVMAP_BLENDING_ADD"
                        }
                        return e
                    }(i),
                    x = 0 < t.gammaFactor ? t.gammaFactor : 1,
                    _ = i.isWebGL2 ? "" : [(s = i).extensionDerivatives || s.envMapCubeUV || s.bumpMap || s.tangentSpaceNormalMap || s.clearcoatNormalMap || s.flatShading || "physical" === s.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (s.extensionFragDepth || s.logarithmicDepthBuffer) && s.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", s.extensionDrawBuffers && s.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (s.extensionShaderTextureLOD || s.envMap) && s.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(hs).join("\n"),
                    w = function(t) {
                        var e = [];
                        for (var i in t) {
                            var n = t[i];
                            !1 !== n && e.push("#define " + i + " " + n)
                        }
                        return e.join("\n")
                    }(d),
                    S = p.createProgram(),
                    M = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
                i.isRawShaderMaterial ? (0 < (o = [w].filter(hs).join("\n")).length && (o += "\n"), 0 < (l = [_, w].filter(hs).join("\n")).length && (l += "\n")) : (o = [xs(i), "#define SHADER_NAME " + i.shaderName, w, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + x, "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + y : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + g : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(hs).join("\n"), l = [_, xs(i), "#define SHADER_NAME " + i.shaderName, w, i.alphaTest ? "#define ALPHATEST " + i.alphaTest + (i.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + x, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + v : "", i.envMap ? "#define " + y : "", i.envMap ? "#define " + b : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.sheen ? "#define USE_SHEEN" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + g : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== Tt ? "#define TONE_MAPPING" : "", i.toneMapping !== Tt ? Hr.tonemapping_pars_fragment : "", i.toneMapping !== Tt ? function(t, e) {
                    var i;
                    switch (e) {
                        case V:
                            i = "Linear";
                            break;
                        case U:
                            i = "Reinhard";
                            break;
                        case Mt:
                            i = "OptimizedCineon";
                            break;
                        case Ct:
                            i = "ACESFilmic";
                            break;
                        case At:
                            i = "Custom";
                            break;
                        default:
                            i = "Linear"
                    }
                    return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
                }("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", Hr.encodings_pars_fragment, i.map ? ls("mapTexelToLinear", i.mapEncoding) : "", i.matcap ? ls("matcapTexelToLinear", i.matcapEncoding) : "", i.envMap ? ls("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMap ? ls("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.lightMap ? ls("lightMapTexelToLinear", i.lightMapEncoding) : "", (h = "linearToOutputTexel", u = i.outputEncoding, c = ss(u), "vec4 " + h + "( vec4 value ) { return LinearTo" + c[0] + c[1] + "; }"), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(hs).join("\n")), f = cs(f = us(f = ds(f), i), i), m = cs(m = us(m = ds(m), i), i), f = vs(f), m = vs(m), i.isWebGL2 && !0 !== i.isRawShaderMaterial && (M = "#version 300 es\n", o = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + o, l = ["#define varying in", i.glslVersion === Re ? "" : "out highp vec4 pc_fragColor;", i.glslVersion === Re ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + l);
                var T, C, A, E, D, P, L, k = M + l + m,
                    O = rs(p, 35633, M + o + f),
                    F = rs(p, 35632, k);
                return p.attachShader(S, O), p.attachShader(S, F), void 0 !== i.index0AttributeName ? p.bindAttribLocation(S, 0, i.index0AttributeName) : !0 === i.morphTargets && p.bindAttribLocation(S, 0, "position"), p.linkProgram(S), t.debug.checkShaderErrors && (T = p.getProgramInfoLog(S).trim(), C = p.getShaderInfoLog(O).trim(), A = p.getShaderInfoLog(F).trim(), !(D = E = !0) === p.getProgramParameter(S, 35714) ? (E = !1, os(p, O, "vertex"), os(p, F, "fragment")) : "" !== T || "" !== C && "" !== A || (D = !1), D && (this.diagnostics = {
                    runnable: E,
                    programLog: T,
                    vertexShader: {
                        log: C,
                        prefix: o
                    },
                    fragmentShader: {
                        log: A,
                        prefix: l
                    }
                })), p.deleteShader(O), p.deleteShader(F), this.getUniforms = function() {
                    return void 0 === P && (P = new ns(p, S)), P
                }, this.getAttributes = function() {
                    return void 0 === L && (L = function(t, e) {
                        for (var i = {}, n = t.getProgramParameter(e, 35721), r = 0; r < n; r++) {
                            var a = t.getActiveAttrib(e, r).name;
                            i[a] = t.getAttribLocation(e, a)
                        }
                        return i
                    }(p, S)), L
                }, this.destroy = function() {
                    n.releaseStatesOfProgram(this), p.deleteProgram(S), this.program = void 0
                }, this.name = i.shaderName, this.id = as++, this.cacheKey = e, this.usedTimes = 1, this.program = S, this.vertexShader = O, this.fragmentShader = F, this
            }

            function ws(f, m, g, v, s, y) {
                var o = [],
                    b = v.isWebGL2,
                    x = v.logarithmicDepthBuffer,
                    _ = v.floatVertexTextures,
                    w = v.maxVertexUniforms,
                    S = v.vertexTextures,
                    M = v.precision,
                    T = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    r = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

                function C(t) {
                    var e;
                    return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (e = t.texture.encoding) : e = Te, e
                }
                return {
                    getParameters: function(t, e, i, n, r) {
                        var a, s, o, l = n.fog,
                            h = t.isMeshStandardMaterial ? n.environment : null,
                            u = m.get(t.envMap || h),
                            c = T[t.type],
                            p = r.isSkinnedMesh ? function(t) {
                                var e = t.skeleton.bones;
                                if (_) return 1024;
                                var i = Math.floor((w - 20) / 4),
                                    n = Math.min(i, e.length);
                                return n < e.length ? 0 : n
                            }(r) : 0;
                        null !== t.precision && (M = v.getMaxPrecision(t.precision), t.precision), o = c ? (s = (a = qr[c]).vertexShader, a.fragmentShader) : (s = t.vertexShader, t.fragmentShader);
                        var d = f.getRenderTarget();
                        return {
                            isWebGL2: b,
                            shaderID: c,
                            shaderName: t.type,
                            vertexShader: s,
                            fragmentShader: o,
                            defines: t.defines,
                            isRawShaderMaterial: !0 === t.isRawShaderMaterial,
                            glslVersion: t.glslVersion,
                            precision: M,
                            instancing: !0 === r.isInstancedMesh,
                            instancingColor: !0 === r.isInstancedMesh && null !== r.instanceColor,
                            supportsVertexTextures: S,
                            outputEncoding: null !== d ? C(d.texture) : f.outputEncoding,
                            map: !!t.map,
                            mapEncoding: C(t.map),
                            matcap: !!t.matcap,
                            matcapEncoding: C(t.matcap),
                            envMap: !!u,
                            envMapMode: u && u.mapping,
                            envMapEncoding: C(u),
                            envMapCubeUV: !!u && (u.mapping === Pt || u.mapping === Lt),
                            lightMap: !!t.lightMap,
                            lightMapEncoding: C(t.lightMap),
                            aoMap: !!t.aoMap,
                            emissiveMap: !!t.emissiveMap,
                            emissiveMapEncoding: C(t.emissiveMap),
                            bumpMap: !!t.bumpMap,
                            normalMap: !!t.normalMap,
                            objectSpaceNormalMap: t.normalMapType === Oe,
                            tangentSpaceNormalMap: t.normalMapType === ke,
                            clearcoatMap: !!t.clearcoatMap,
                            clearcoatRoughnessMap: !!t.clearcoatRoughnessMap,
                            clearcoatNormalMap: !!t.clearcoatNormalMap,
                            displacementMap: !!t.displacementMap,
                            roughnessMap: !!t.roughnessMap,
                            metalnessMap: !!t.metalnessMap,
                            specularMap: !!t.specularMap,
                            alphaMap: !!t.alphaMap,
                            gradientMap: !!t.gradientMap,
                            sheen: !!t.sheen,
                            transmissionMap: !!t.transmissionMap,
                            combine: t.combine,
                            vertexTangents: t.normalMap && t.vertexTangents,
                            vertexColors: t.vertexColors,
                            vertexUvs: !!(t.map || t.bumpMap || t.normalMap || t.specularMap || t.alphaMap || t.emissiveMap || t.roughnessMap || t.metalnessMap || t.clearcoatMap || t.clearcoatRoughnessMap || t.clearcoatNormalMap || t.displacementMap || t.transmissionMap),
                            uvsVertexOnly: !(t.map || t.bumpMap || t.normalMap || t.specularMap || t.alphaMap || t.emissiveMap || t.roughnessMap || t.metalnessMap || t.clearcoatNormalMap || t.transmissionMap || !t.displacementMap),
                            fog: !!l,
                            useFog: t.fog,
                            fogExp2: l && l.isFogExp2,
                            flatShading: t.flatShading,
                            sizeAttenuation: t.sizeAttenuation,
                            logarithmicDepthBuffer: x,
                            skinning: t.skinning && 0 < p,
                            maxBones: p,
                            useVertexTexture: _,
                            morphTargets: t.morphTargets,
                            morphNormals: t.morphNormals,
                            maxMorphTargets: f.maxMorphTargets,
                            maxMorphNormals: f.maxMorphNormals,
                            numDirLights: e.directional.length,
                            numPointLights: e.point.length,
                            numSpotLights: e.spot.length,
                            numRectAreaLights: e.rectArea.length,
                            numHemiLights: e.hemi.length,
                            numDirLightShadows: e.directionalShadowMap.length,
                            numPointLightShadows: e.pointShadowMap.length,
                            numSpotLightShadows: e.spotShadowMap.length,
                            numClippingPlanes: y.numPlanes,
                            numClipIntersection: y.numIntersection,
                            dithering: t.dithering,
                            shadowMapEnabled: f.shadowMap.enabled && 0 < i.length,
                            shadowMapType: f.shadowMap.type,
                            toneMapping: t.toneMapped ? f.toneMapping : Tt,
                            physicallyCorrectLights: f.physicallyCorrectLights,
                            premultipliedAlpha: t.premultipliedAlpha,
                            alphaTest: t.alphaTest,
                            doubleSided: t.side === X,
                            flipSided: t.side === q,
                            depthPacking: void 0 !== t.depthPacking && t.depthPacking,
                            index0AttributeName: t.index0AttributeName,
                            extensionDerivatives: t.extensions && t.extensions.derivatives,
                            extensionFragDepth: t.extensions && t.extensions.fragDepth,
                            extensionDrawBuffers: t.extensions && t.extensions.drawBuffers,
                            extensionShaderTextureLOD: t.extensions && t.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: b || g.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: b || g.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: b || g.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: t.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function(t) {
                        var e = [];
                        if (t.shaderID ? e.push(t.shaderID) : (e.push(t.fragmentShader), e.push(t.vertexShader)), void 0 !== t.defines)
                            for (var i in t.defines) e.push(i), e.push(t.defines[i]);
                        if (!1 === t.isRawShaderMaterial) {
                            for (var n = 0; n < r.length; n++) e.push(t[r[n]]);
                            e.push(f.outputEncoding), e.push(f.gammaFactor)
                        }
                        return e.push(t.customProgramCacheKey), e.join()
                    },
                    getUniforms: function(t) {
                        var e, i = T[t.type];
                        return i ? (e = qr[i], Er.clone(e.uniforms)) : t.uniforms
                    },
                    acquireProgram: function(t, e) {
                        for (var i, n = 0, r = o.length; n < r; n++) {
                            var a = o[n];
                            if (a.cacheKey === e) {
                                ++(i = a).usedTimes;
                                break
                            }
                        }
                        return void 0 === i && (i = new _s(f, e, t, s), o.push(i)), i
                    },
                    releaseProgram: function(t) {
                        var e;
                        0 == --t.usedTimes && (e = o.indexOf(t), o[e] = o[o.length - 1], o.pop(), t.destroy())
                    },
                    programs: o
                }
            }

            function Ss() {
                var n = new WeakMap;
                return {
                    get: function(t) {
                        var e = n.get(t);
                        return void 0 === e && (e = {}, n.set(t, e)), e
                    },
                    remove: function(t) {
                        n.delete(t)
                    },
                    update: function(t, e, i) {
                        n.get(t)[e] = i
                    },
                    dispose: function() {
                        n = new WeakMap
                    }
                }
            }

            function Ms(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function Ts(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function Cs(l) {
                var h = [],
                    u = 0,
                    o = [],
                    c = [],
                    p = {
                        id: -1
                    };

                function d(t, e, i, n, r, a) {
                    var s = h[u],
                        o = l.get(i);
                    return void 0 === s ? (s = {
                        id: t.id,
                        object: t,
                        geometry: e,
                        material: i,
                        program: o.program || p,
                        groupOrder: n,
                        renderOrder: t.renderOrder,
                        z: r,
                        group: a
                    }, h[u] = s) : (s.id = t.id, s.object = t, s.geometry = e, s.material = i, s.program = o.program || p, s.groupOrder = n, s.renderOrder = t.renderOrder, s.z = r, s.group = a), u++, s
                }
                return {
                    opaque: o,
                    transparent: c,
                    init: function() {
                        u = 0, o.length = 0, c.length = 0
                    },
                    push: function(t, e, i, n, r, a) {
                        var s = d(t, e, i, n, r, a);
                        (!0 === i.transparent ? c : o).push(s)
                    },
                    unshift: function(t, e, i, n, r, a) {
                        var s = d(t, e, i, n, r, a);
                        (!0 === i.transparent ? c : o).unshift(s)
                    },
                    finish: function() {
                        for (var t = u, e = h.length; t < e; t++) {
                            var i = h[t];
                            if (null === i.id) break;
                            i.id = null, i.object = null, i.geometry = null, i.material = null, i.program = null, i.group = null
                        }
                    },
                    sort: function(t, e) {
                        1 < o.length && o.sort(t || Ms), 1 < c.length && c.sort(e || Ts)
                    }
                }
            }

            function As(r) {
                var a = new WeakMap;
                return {
                    get: function(t, e) {
                        var i, n = a.get(t);
                        return void 0 === n ? (i = new Cs(r), a.set(t, new WeakMap), a.get(t).set(e, i)) : void 0 === (i = n.get(e)) && (i = new Cs(r), n.set(e, i)), i
                    },
                    dispose: function() {
                        a = new WeakMap
                    }
                }
            }

            function Es() {
                var i = {};
                return {
                    get: function(t) {
                        if (void 0 !== i[t.id]) return i[t.id];
                        var e;
                        switch (t.type) {
                            case "DirectionalLight":
                                e = {
                                    direction: new ni,
                                    color: new Cn
                                };
                                break;
                            case "SpotLight":
                                e = {
                                    position: new ni,
                                    direction: new ni,
                                    color: new Cn,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                e = {
                                    position: new ni,
                                    color: new Cn,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                e = {
                                    direction: new ni,
                                    skyColor: new Cn,
                                    groundColor: new Cn
                                };
                                break;
                            case "RectAreaLight":
                                e = {
                                    color: new Cn,
                                    position: new ni,
                                    halfWidth: new ni,
                                    halfHeight: new ni
                                }
                        }
                        return i[t.id] = e
                    }
                }
            }
            var Ds = 0;

            function Ps(t, e) {
                return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
            }

            function Ls() {
                for (var i, N = new Es, B = (i = {}, {
                        get: function(t) {
                            if (void 0 !== i[t.id]) return i[t.id];
                            var e;
                            switch (t.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    e = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new He
                                    };
                                    break;
                                case "PointLight":
                                    e = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new He,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return i[t.id] = e
                        }
                    }), R = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    }, t = 0; t < 9; t++) R.probe.push(new ni);
                var z = new ni,
                    G = new Li,
                    V = new Li;
                return {
                    setup: function(t, e, i) {
                        for (var n = 0, r = 0, a = 0, s = 0; s < 9; s++) R.probe[s].set(0, 0, 0);
                        var o = 0,
                            l = 0,
                            h = 0,
                            u = 0,
                            c = 0,
                            p = 0,
                            d = 0,
                            f = 0,
                            m = i.matrixWorldInverse;
                        t.sort(Ps);
                        for (var g = 0, v = t.length; g < v; g++) {
                            var y, b, x, _, w, S, M, T, C, A, E, D = t[g],
                                P = D.color,
                                L = D.intensity,
                                k = D.distance,
                                O = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
                            if (D.isAmbientLight) n += P.r * L, r += P.g * L, a += P.b * L;
                            else if (D.isLightProbe)
                                for (var F = 0; F < 9; F++) R.probe[F].addScaledVector(D.sh.coefficients[F], L);
                            else {
                                D.isDirectionalLight ? ((y = N.get(D)).color.copy(D.color).multiplyScalar(D.intensity), y.direction.setFromMatrixPosition(D.matrixWorld), z.setFromMatrixPosition(D.target.matrixWorld), y.direction.sub(z), y.direction.transformDirection(m), D.castShadow && (b = D.shadow, (x = B.get(D)).shadowBias = b.bias, x.shadowNormalBias = b.normalBias, x.shadowRadius = b.radius, x.shadowMapSize = b.mapSize, R.directionalShadow[o] = x, R.directionalShadowMap[o] = O, R.directionalShadowMatrix[o] = D.shadow.matrix, p++), R.directional[o] = y, o++) : D.isSpotLight ? ((_ = N.get(D)).position.setFromMatrixPosition(D.matrixWorld), _.position.applyMatrix4(m), _.color.copy(P).multiplyScalar(L), _.distance = k, _.direction.setFromMatrixPosition(D.matrixWorld), z.setFromMatrixPosition(D.target.matrixWorld), _.direction.sub(z), _.direction.transformDirection(m), _.coneCos = Math.cos(D.angle), _.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), _.decay = D.decay, D.castShadow && (w = D.shadow, (S = B.get(D)).shadowBias = w.bias, S.shadowNormalBias = w.normalBias, S.shadowRadius = w.radius, S.shadowMapSize = w.mapSize, R.spotShadow[h] = S, R.spotShadowMap[h] = O, R.spotShadowMatrix[h] = D.shadow.matrix, f++), R.spot[h] = _, h++) : D.isRectAreaLight ? ((M = N.get(D)).color.copy(P).multiplyScalar(L), M.position.setFromMatrixPosition(D.matrixWorld), M.position.applyMatrix4(m), V.identity(), G.copy(D.matrixWorld), G.premultiply(m), V.extractRotation(G), M.halfWidth.set(.5 * D.width, 0, 0), M.halfHeight.set(0, .5 * D.height, 0), M.halfWidth.applyMatrix4(V), M.halfHeight.applyMatrix4(V), R.rectArea[u] = M, u++) : D.isPointLight ? ((T = N.get(D)).position.setFromMatrixPosition(D.matrixWorld), T.position.applyMatrix4(m), T.color.copy(D.color).multiplyScalar(D.intensity), T.distance = D.distance, T.decay = D.decay, D.castShadow && (C = D.shadow, (A = B.get(D)).shadowBias = C.bias, A.shadowNormalBias = C.normalBias, A.shadowRadius = C.radius, A.shadowMapSize = C.mapSize, A.shadowCameraNear = C.camera.near, A.shadowCameraFar = C.camera.far, R.pointShadow[l] = A, R.pointShadowMap[l] = O, R.pointShadowMatrix[l] = D.shadow.matrix, d++), R.point[l] = T, l++) : D.isHemisphereLight && ((E = N.get(D)).direction.setFromMatrixPosition(D.matrixWorld), E.direction.transformDirection(m), E.direction.normalize(), E.skyColor.copy(D.color).multiplyScalar(L), E.groundColor.copy(D.groundColor).multiplyScalar(L), R.hemi[c] = E, c++)
                            }
                        }
                        0 < u && (R.rectAreaLTC1 = Wr.LTC_1, R.rectAreaLTC2 = Wr.LTC_2), R.ambient[0] = n, R.ambient[1] = r, R.ambient[2] = a;
                        var I = R.hash;
                        I.directionalLength === o && I.pointLength === l && I.spotLength === h && I.rectAreaLength === u && I.hemiLength === c && I.numDirectionalShadows === p && I.numPointShadows === d && I.numSpotShadows === f || (R.directional.length = o, R.spot.length = h, R.rectArea.length = u, R.point.length = l, R.hemi.length = c, R.directionalShadow.length = p, R.directionalShadowMap.length = p, R.pointShadow.length = d, R.pointShadowMap.length = d, R.spotShadow.length = f, R.spotShadowMap.length = f, R.directionalShadowMatrix.length = p, R.pointShadowMatrix.length = d, R.spotShadowMatrix.length = f, I.directionalLength = o, I.pointLength = l, I.spotLength = h, I.rectAreaLength = u, I.hemiLength = c, I.numDirectionalShadows = p, I.numPointShadows = d, I.numSpotShadows = f, R.version = Ds++)
                    },
                    state: R
                }
            }

            function ks() {
                var e = new Ls,
                    i = [],
                    n = [];
                return {
                    init: function() {
                        i.length = 0, n.length = 0
                    },
                    state: {
                        lightsArray: i,
                        shadowsArray: n,
                        lights: e
                    },
                    setupLights: function(t) {
                        e.setup(i, n, t)
                    },
                    pushLight: function(t) {
                        i.push(t)
                    },
                    pushShadow: function(t) {
                        n.push(t)
                    }
                }
            }

            function Os() {
                var n = new WeakMap;
                return {
                    get: function(t, e) {
                        var i;
                        return !1 === n.has(t) ? (i = new ks, n.set(t, new WeakMap), n.get(t).set(e, i)) : !1 === n.get(t).has(e) ? (i = new ks, n.get(t).set(e, i)) : i = n.get(t).get(e), i
                    },
                    dispose: function() {
                        n = new WeakMap
                    }
                }
            }

            function Fs(t) {
                Dn.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Pe, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
            }

            function Is(t) {
                Dn.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new ni, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
            }((Fs.prototype = Object.create(Dn.prototype)).constructor = Fs).prototype.isMeshDepthMaterial = !0, Fs.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }, ((Is.prototype = Object.create(Dn.prototype)).constructor = Is).prototype.isMeshDistanceMaterial = !0, Is.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            };
            var Ns = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
                Bs = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

            function Rs(x, _, w) {
                var S = new zr,
                    M = new He,
                    T = new He,
                    C = new $e,
                    a = [],
                    s = [],
                    g = {},
                    v = {
                        0: q,
                        1: k,
                        2: X
                    },
                    A = new Lr({
                        defines: {
                            SAMPLE_RATE: .25,
                            HALF_SAMPLE_RATE: 1 / 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new He
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: Bs,
                        fragmentShader: Ns
                    }),
                    E = A.clone();
                E.defines.HORIZONAL_PASS = 1;
                var t = new Kn;
                t.setAttribute("position", new On(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                var D = new gr(t, A),
                    P = this;

                function y(t, e, i) {
                    var n = t << 0 | e << 1 | i << 2,
                        r = a[n];
                    return void 0 === r && (r = new Fs({
                        depthPacking: Le,
                        morphTargets: t,
                        skinning: e
                    }), a[n] = r), r
                }

                function b(t, e, i) {
                    var n = t << 0 | e << 1 | i << 2,
                        r = s[n];
                    return void 0 === r && (r = new Is({
                        morphTargets: t,
                        skinning: e
                    }), s[n] = r), r
                }

                function L(t, e, i, n, r, a, s) {
                    var o, l, h, u, c, p, d = null,
                        f = y,
                        m = t.customDepthMaterial;
                    return !0 === n.isPointLight && (f = b, m = t.customDistanceMaterial), d = void 0 === m ? (!(o = !1) === i.morphTargets && (o = e.morphAttributes && e.morphAttributes.position && 0 < e.morphAttributes.position.length), !(l = !1) === t.isSkinnedMesh && !0 === i.skinning && (l = !0), f(o, l, !0 === t.isInstancedMesh)) : m, x.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (h = d.uuid, u = i.uuid, void 0 === (c = g[h]) && (c = {}, g[h] = c), void 0 === (p = c[u]) && (p = d.clone(), c[u] = p), d = p), d.visible = i.visible, d.wireframe = i.wireframe, d.side = s === B ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : v[i.side], d.clipShadows = i.clipShadows, d.clippingPlanes = i.clippingPlanes, d.clipIntersection = i.clipIntersection, d.wireframeLinewidth = i.wireframeLinewidth, d.linewidth = i.linewidth, !0 === n.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(n.matrixWorld), d.nearDistance = r, d.farDistance = a), d
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = I, this.render = function(t, e, i) {
                    if (!1 !== P.enabled && (!1 !== P.autoUpdate || !1 !== P.needsUpdate) && 0 !== t.length) {
                        var n = x.getRenderTarget(),
                            r = x.getActiveCubeFace(),
                            a = x.getActiveMipmapLevel(),
                            s = x.state;
                        s.setBlending(Y), s.buffers.color.setClear(1, 1, 1, 1), s.buffers.depth.setTest(!0), s.setScissorTest(!1);
                        for (var o, l, h, u = 0, c = t.length; u < c; u++) {
                            var p = t[u],
                                d = p.shadow;
                            if ((!1 !== d.autoUpdate || !1 !== d.needsUpdate) && void 0 !== d) {
                                M.copy(d.mapSize);
                                var f, m, g = d.getFrameExtents();
                                M.multiply(g), T.copy(d.mapSize), (M.x > w || M.y > w) && (M.x > w && (T.x = Math.floor(w / g.x), M.x = T.x * g.x, d.mapSize.x = T.x), M.y > w && (T.y = Math.floor(w / g.y), M.y = T.y * g.y, d.mapSize.y = T.y)), null !== d.map || d.isPointLightShadow || this.type !== B || (f = {
                                    minFilter: Rt,
                                    magFilter: Rt,
                                    format: Yt
                                }, d.map = new Qe(M.x, M.y, f), d.map.texture.name = p.name + ".shadowMap", d.mapPass = new Qe(M.x, M.y, f), d.camera.updateProjectionMatrix()), null === d.map && (m = {
                                    minFilter: It,
                                    magFilter: It,
                                    format: Yt
                                }, d.map = new Qe(M.x, M.y, m), d.map.texture.name = p.name + ".shadowMap", d.camera.updateProjectionMatrix()), x.setRenderTarget(d.map), x.clear();
                                for (var v = d.getViewportCount(), y = 0; y < v; y++) {
                                    var b = d.getViewport(y);
                                    C.set(T.x * b.x, T.y * b.y, T.x * b.z, T.y * b.w), s.viewport(C), d.updateMatrices(p, y), S = d.getFrustum(),
                                        function t(e, i, n, r, a) {
                                            if (!1 === e.visible) return;
                                            var s = e.layers.test(i.layers);
                                            if (s && (e.isMesh || e.isLine || e.isPoints) && (e.castShadow || e.receiveShadow && a === B) && (!e.frustumCulled || S.intersectsObject(e))) {
                                                e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld);
                                                var o, l = _.update(e),
                                                    h = e.material;
                                                if (Array.isArray(h))
                                                    for (var u = l.groups, c = 0, p = u.length; c < p; c++) {
                                                        var d, f = u[c],
                                                            m = h[f.materialIndex];
                                                        m && m.visible && (d = L(e, l, m, r, n.near, n.far, a), x.renderBufferDirect(n, null, l, d, e, f))
                                                    } else h.visible && (o = L(e, l, h, r, n.near, n.far, a), x.renderBufferDirect(n, null, l, o, e, null))
                                            }
                                            var g = e.children;
                                            for (var v = 0, y = g.length; v < y; v++) t(g[v], i, n, r, a)
                                        }(e, i, d.camera, p, this.type)
                                }
                                d.isPointLightShadow || this.type !== B || (o = d, l = i, h = _.update(D), A.uniforms.shadow_pass.value = o.map.texture, A.uniforms.resolution.value = o.mapSize, A.uniforms.radius.value = o.radius, x.setRenderTarget(o.mapPass), x.clear(), x.renderBufferDirect(l, null, h, A, D, null), E.uniforms.shadow_pass.value = o.mapPass.texture, E.uniforms.resolution.value = o.mapSize, E.uniforms.radius.value = o.radius, x.setRenderTarget(o.map), x.clear(), x.renderBufferDirect(l, null, h, E, D, null)), d.needsUpdate = !1
                            }
                        }
                        P.needsUpdate = !1, x.setRenderTarget(n, r, a)
                    }
                }
            }

            function zs(u, t, e) {
                var i = e.isWebGL2;
                var r = new function() {
                        var e = !1,
                            a = new $e,
                            i = null,
                            s = new $e(0, 0, 0, 0);
                        return {
                            setMask: function(t) {
                                i === t || e || (u.colorMask(t, t, t, t), i = t)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(t, e, i, n, r) {
                                !0 === r && (t *= n, e *= n, i *= n), a.set(t, e, i, n), !1 === s.equals(a) && (u.clearColor(t, e, i, n), s.copy(a))
                            },
                            reset: function() {
                                e = !1, i = null, s.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    a = new function() {
                        var e = !1,
                            i = null,
                            n = null,
                            r = null;
                        return {
                            setTest: function(t) {
                                (t ? O : F)(2929)
                            },
                            setMask: function(t) {
                                i === t || e || (u.depthMask(t), i = t)
                            },
                            setFunc: function(t) {
                                if (n !== t) {
                                    if (t) switch (t) {
                                        case gt:
                                            u.depthFunc(512);
                                            break;
                                        case vt:
                                            u.depthFunc(519);
                                            break;
                                        case yt:
                                            u.depthFunc(513);
                                            break;
                                        case bt:
                                            u.depthFunc(515);
                                            break;
                                        case xt:
                                            u.depthFunc(514);
                                            break;
                                        case _t:
                                            u.depthFunc(518);
                                            break;
                                        case wt:
                                            u.depthFunc(516);
                                            break;
                                        case St:
                                            u.depthFunc(517);
                                            break;
                                        default:
                                            u.depthFunc(515)
                                    } else u.depthFunc(515);
                                    n = t
                                }
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(t) {
                                r !== t && (u.clearDepth(t), r = t)
                            },
                            reset: function() {
                                e = !1, r = n = i = null
                            }
                        }
                    },
                    s = new function() {
                        var e = !1,
                            i = null,
                            n = null,
                            r = null,
                            a = null,
                            s = null,
                            o = null,
                            l = null,
                            h = null;
                        return {
                            setTest: function(t) {
                                e || (t ? O : F)(2960)
                            },
                            setMask: function(t) {
                                i === t || e || (u.stencilMask(t), i = t)
                            },
                            setFunc: function(t, e, i) {
                                n === t && r === e && a === i || (u.stencilFunc(t, e, i), n = t, r = e, a = i)
                            },
                            setOp: function(t, e, i) {
                                s === t && o === e && l === i || (u.stencilOp(t, e, i), s = t, o = e, l = i)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(t) {
                                h !== t && (u.clearStencil(t), h = t)
                            },
                            reset: function() {
                                e = !1, h = l = o = s = a = r = n = i = null
                            }
                        }
                    },
                    n = {},
                    o = null,
                    l = null,
                    h = null,
                    c = null,
                    p = null,
                    d = null,
                    f = null,
                    m = null,
                    g = null,
                    v = !1,
                    y = null,
                    b = null,
                    x = null,
                    _ = null,
                    w = null,
                    S = u.getParameter(35661),
                    M = !1,
                    T = 0,
                    C = u.getParameter(7938); - 1 !== C.indexOf("WebGL") ? (T = parseFloat(/^WebGL\ ([0-9])/.exec(C)[1]), M = 1 <= T) : -1 !== C.indexOf("OpenGL ES") && (T = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(C)[1]), M = 2 <= T);
                var A = null,
                    E = {},
                    D = new $e,
                    P = new $e;

                function L(t, e, i) {
                    var n = new Uint8Array(4),
                        r = u.createTexture();
                    u.bindTexture(t, r), u.texParameteri(t, 10241, 9728), u.texParameteri(t, 10240, 9728);
                    for (var a = 0; a < i; a++) u.texImage2D(e + a, 0, 6408, 1, 1, 0, 6408, 5121, n);
                    return r
                }
                var k = {};

                function O(t) {
                    !0 !== n[t] && (u.enable(t), n[t] = !0)
                }

                function F(t) {
                    !1 !== n[t] && (u.disable(t), n[t] = !1)
                }
                k[3553] = L(3553, 3553, 1), k[34067] = L(34067, 34069, 6), r.setClear(0, 0, 0, 1), a.setClear(1), s.setClear(0), O(2929), a.setFunc(bt), z(!1), G(H), O(2884), R(Y);
                var I, N = {};
                N[tt] = 32774, N[et] = 32778, N[it] = 32779, i ? (N[nt] = 32775, N[rt] = 32776) : null !== (I = t.get("EXT_blend_minmax")) && (N[nt] = I.MIN_EXT, N[rt] = I.MAX_EXT);
                var B = {};

                function R(t, e, i, n, r, a, s, o) {
                    if (t !== Y) {
                        if (l || (O(3042), l = !0), t === Q) r = r || e, a = a || i, s = s || n, e === c && r === f || (u.blendEquationSeparate(N[e], N[r]), c = e, f = r), i === p && n === d && a === m && s === g || (u.blendFuncSeparate(B[i], B[n], B[a], B[s]), p = i, d = n, m = a, g = s), h = t, v = null;
                        else if (t !== h || o !== v) {
                            if (c === tt && f === tt || (u.blendEquation(32774), f = c = tt), o) switch (t) {
                                case J:
                                    u.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case Z:
                                    u.blendFunc(1, 1);
                                    break;
                                case $:
                                    u.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case K:
                                    u.blendFuncSeparate(0, 768, 0, 770)
                            } else switch (t) {
                                case J:
                                    u.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case Z:
                                    u.blendFunc(770, 1);
                                    break;
                                case $:
                                    u.blendFunc(0, 769);
                                    break;
                                case K:
                                    u.blendFunc(0, 768)
                            }
                            g = m = d = p = null, h = t, v = o
                        }
                    } else l && (F(3042), l = !1)
                }

                function z(t) {
                    y !== t && (t ? u.frontFace(2304) : u.frontFace(2305), y = t)
                }

                function G(t) {
                    t !== j ? (O(2884), t !== b && (t === H ? u.cullFace(1029) : t === W ? u.cullFace(1028) : u.cullFace(1032))) : F(2884), b = t
                }

                function V(t, e, i) {
                    t ? (O(32823), _ === e && w === i || (u.polygonOffset(e, i), _ = e, w = i)) : F(32823)
                }

                function U(t) {
                    void 0 === t && (t = 33984 + S - 1), A !== t && (u.activeTexture(t), A = t)
                }
                return B[at] = 0, B[st] = 1, B[ot] = 768, B[ht] = 770, B[mt] = 776, B[dt] = 774, B[ct] = 772, B[lt] = 769, B[ut] = 771, B[ft] = 775, B[pt] = 773, {
                    buffers: {
                        color: r,
                        depth: a,
                        stencil: s
                    },
                    enable: O,
                    disable: F,
                    useProgram: function(t) {
                        return o !== t && (u.useProgram(t), o = t, !0)
                    },
                    setBlending: R,
                    setMaterial: function(t, e) {
                        (t.side === X ? F : O)(2884);
                        var i = t.side === q;
                        e && (i = !i), z(i), t.blending === J && !1 === t.transparent ? R(Y) : R(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), a.setFunc(t.depthFunc), a.setTest(t.depthTest), a.setMask(t.depthWrite), r.setMask(t.colorWrite);
                        var n = t.stencilWrite;
                        s.setTest(n), n && (s.setMask(t.stencilWriteMask), s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), V(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                    },
                    setFlipSided: z,
                    setCullFace: G,
                    setLineWidth: function(t) {
                        t !== x && (M && u.lineWidth(t), x = t)
                    },
                    setPolygonOffset: V,
                    setScissorTest: function(t) {
                        (t ? O : F)(3089)
                    },
                    activeTexture: U,
                    bindTexture: function(t, e) {
                        null === A && U();
                        var i = E[A];
                        void 0 === i && (i = {
                            type: void 0,
                            texture: void 0
                        }, E[A] = i), i.type === t && i.texture === e || (u.bindTexture(t, e || k[t]), i.type = t, i.texture = e)
                    },
                    unbindTexture: function() {
                        var t = E[A];
                        void 0 !== t && void 0 !== t.type && (u.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            u.compressedTexImage2D.apply(u, arguments)
                        } catch (t) {}
                    },
                    texImage2D: function() {
                        try {
                            u.texImage2D.apply(u, arguments)
                        } catch (t) {}
                    },
                    texImage3D: function() {
                        try {
                            u.texImage3D.apply(u, arguments)
                        } catch (t) {}
                    },
                    scissor: function(t) {
                        !1 === D.equals(t) && (u.scissor(t.x, t.y, t.z, t.w), D.copy(t))
                    },
                    viewport: function(t) {
                        !1 === P.equals(t) && (u.viewport(t.x, t.y, t.z, t.w), P.copy(t))
                    },
                    reset: function() {
                        n = {}, E = {}, b = y = h = o = A = null, r.reset(), a.reset(), s.reset()
                    }
                }
            }

            function Gs(_, r, w, S, a, M, p) {
                var h, T = a.isWebGL2,
                    C = (a.maxTextures, a.maxCubemapSize),
                    b = a.maxTextureSize,
                    e = a.maxSamples,
                    s = new WeakMap,
                    i = !1;
                try {
                    i = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (t) {}

                function u(t, e) {
                    return i ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }

                function A(t, e, i, n) {
                    var r = 1;
                    if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                            var a = e ? je.floorPowerOfTwo : Math.floor,
                                s = a(r * t.width),
                                o = a(r * t.height);
                            void 0 === h && (h = u(s, o));
                            var l = i ? u(s, o) : h;
                            return l.width = s, l.height = o, l.getContext("2d").drawImage(t, 0, 0, s, o), l
                        }
                        return t
                    }
                    return t
                }

                function E(t) {
                    return je.isPowerOfTwo(t.width) && je.isPowerOfTwo(t.height)
                }

                function D(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== It && t.minFilter !== Rt
                }

                function P(t, e, i, n) {
                    _.generateMipmap(t), S.get(e).__maxMipLevel = Math.log(Math.max(i, n)) * Math.LOG2E
                }

                function L(t, e, i) {
                    if (!1 === T) return e;
                    if (null !== t && void 0 !== _[t]) return _[t];
                    var n = e;
                    return 6403 === e && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === e && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === e && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 !== n && 33326 !== n && 34842 !== n && 34836 !== n || r.get("EXT_color_buffer_float"), n
                }

                function o(t) {
                    return t === It || t === Nt || t === Bt ? 9728 : 9729
                }

                function n(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", n),
                        function(t) {
                            var e = S.get(t);
                            if (void 0 === e.__webglInit) return;
                            _.deleteTexture(e.__webglTexture), S.remove(t)
                        }(e), e.isVideoTexture && s.delete(e), p.memory.textures--
                }

                function d(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", d),
                        function(t) {
                            var e = S.get(t),
                                i = S.get(t.texture);
                            if (!t) return;
                            void 0 !== i.__webglTexture && _.deleteTexture(i.__webglTexture);
                            t.depthTexture && t.depthTexture.dispose();
                            if (t.isWebGLCubeRenderTarget)
                                for (var n = 0; n < 6; n++) _.deleteFramebuffer(e.__webglFramebuffer[n]), e.__webglDepthbuffer && _.deleteRenderbuffer(e.__webglDepthbuffer[n]);
                            else _.deleteFramebuffer(e.__webglFramebuffer), e.__webglDepthbuffer && _.deleteRenderbuffer(e.__webglDepthbuffer), e.__webglMultisampledFramebuffer && _.deleteFramebuffer(e.__webglMultisampledFramebuffer), e.__webglColorRenderbuffer && _.deleteRenderbuffer(e.__webglColorRenderbuffer), e.__webglDepthRenderbuffer && _.deleteRenderbuffer(e.__webglDepthRenderbuffer);
                            S.remove(t.texture), S.remove(t)
                        }(e), p.memory.textures--
                }
                var l = 0;

                function c(t, e) {
                    var i, n, r = S.get(t);
                    if (t.isVideoTexture && (i = t, n = p.render.frame, s.get(i) !== n && (s.set(i, n), i.update())), 0 < t.version && r.__version !== t.version) {
                        var a = t.image;
                        if (void 0 !== a && !1 !== a.complete) return void y(r, t, e)
                    }
                    w.activeTexture(33984 + e), w.bindTexture(3553, r.__webglTexture)
                }

                function f(t, e) {
                    if (6 === t.image.length) {
                        var i = S.get(t);
                        if (0 < t.version && i.__version !== t.version) {
                            O(i, t), w.activeTexture(33984 + e), w.bindTexture(34067, i.__webglTexture), _.pixelStorei(37440, t.flipY);
                            for (var n = t && (t.isCompressedTexture || t.image[0].isCompressedTexture), r = t.image[0] && t.image[0].isDataTexture, a = [], s = 0; s < 6; s++) a[s] = n || r ? r ? t.image[s].image : t.image[s] : A(t.image[s], !1, !0, C);
                            var o, l = a[0],
                                h = E(l) || T,
                                u = M.convert(t.format),
                                c = M.convert(t.type),
                                p = L(t.internalFormat, u, c);
                            if (k(34067, t, h), n) {
                                for (var d = 0; d < 6; d++) {
                                    o = a[d].mipmaps;
                                    for (var f = 0; f < o.length; f++) {
                                        var m = o[f];
                                        t.format !== Yt && t.format !== Xt ? null !== u && w.compressedTexImage2D(34069 + d, f, p, m.width, m.height, 0, m.data) : w.texImage2D(34069 + d, f, p, m.width, m.height, 0, u, c, m.data)
                                    }
                                }
                                i.__maxMipLevel = o.length - 1
                            } else {
                                o = t.mipmaps;
                                for (var g = 0; g < 6; g++)
                                    if (r) {
                                        w.texImage2D(34069 + g, 0, p, a[g].width, a[g].height, 0, u, c, a[g].data);
                                        for (var v = 0; v < o.length; v++) {
                                            var y = o[v].image[g].image;
                                            w.texImage2D(34069 + g, v + 1, p, y.width, y.height, 0, u, c, y.data)
                                        }
                                    } else {
                                        w.texImage2D(34069 + g, 0, p, u, c, a[g]);
                                        for (var b = 0; b < o.length; b++) {
                                            var x = o[b];
                                            w.texImage2D(34069 + g, b + 1, p, u, c, x.image[g])
                                        }
                                    }
                                i.__maxMipLevel = o.length
                            }
                            D(t, h) && P(34067, t, l.width, l.height), i.__version = t.version, t.onUpdate && t.onUpdate(t)
                        } else w.activeTexture(33984 + e), w.bindTexture(34067, i.__webglTexture)
                    }
                }

                function m(t, e) {
                    w.activeTexture(33984 + e), w.bindTexture(34067, S.get(t).__webglTexture)
                }
                var g = {};
                g[kt] = 10497, g[Ot] = 33071, g[Ft] = 33648;
                var v = {};

                function k(t, e, i) {
                    i ? (_.texParameteri(t, 10242, g[e.wrapS]), _.texParameteri(t, 10243, g[e.wrapT]), 32879 !== t && 35866 !== t || _.texParameteri(t, 32882, g[e.wrapR]), _.texParameteri(t, 10240, v[e.magFilter]), _.texParameteri(t, 10241, v[e.minFilter])) : (_.texParameteri(t, 10242, 33071), _.texParameteri(t, 10243, 33071), 32879 !== t && 35866 !== t || _.texParameteri(t, 32882, 33071), e.wrapS !== Ot || e.wrapT, _.texParameteri(t, 10240, o(e.magFilter)), _.texParameteri(t, 10241, o(e.minFilter)), e.minFilter !== It && e.minFilter);
                    var n = r.get("EXT_texture_filter_anisotropic");
                    if (n) {
                        if (e.type === Ht && null === r.get("OES_texture_float_linear")) return;
                        if (e.type === Wt && null === (T || r.get("OES_texture_half_float_linear"))) return;
                        (1 < e.anisotropy || S.get(e).__currentAnisotropy) && (_.texParameterf(t, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, a.getMaxAnisotropy())), S.get(e).__currentAnisotropy = e.anisotropy)
                    }
                }

                function O(t, e) {
                    void 0 === t.__webglInit && (t.__webglInit = !0, e.addEventListener("dispose", n), t.__webglTexture = _.createTexture(), p.memory.textures++)
                }

                function y(t, e, i) {
                    var n = 3553;
                    e.isDataTexture2DArray && (n = 35866), e.isDataTexture3D && (n = 32879), O(t, e), w.activeTexture(33984 + i), w.bindTexture(n, t.__webglTexture), _.pixelStorei(37440, e.flipY), _.pixelStorei(37441, e.premultiplyAlpha), _.pixelStorei(3317, e.unpackAlignment);
                    var r, a, s = (r = e, !T && (r.wrapS !== Ot || r.wrapT !== Ot || r.minFilter !== It && r.minFilter !== Rt) && !1 === E(e.image)),
                        o = A(e.image, s, !1, b),
                        l = E(o) || T,
                        h = M.convert(e.format),
                        u = M.convert(e.type),
                        c = L(e.internalFormat, h, u);
                    k(n, e, l);
                    var p = e.mipmaps;
                    if (e.isDepthTexture) c = 6402, T ? c = e.type === Ht ? 36012 : e.type === jt ? 33190 : e.type === qt ? 35056 : 33189 : e.type, e.format === Jt && 6402 === c && e.type !== Ut && e.type !== jt && (e.type = Ut, u = M.convert(e.type)), e.format === Zt && 6402 === c && (c = 34041, e.type !== qt && (e.type = qt, u = M.convert(e.type))), w.texImage2D(3553, 0, c, o.width, o.height, 0, h, u, null);
                    else if (e.isDataTexture)
                        if (0 < p.length && l) {
                            for (var d = 0, f = p.length; d < f; d++) a = p[d], w.texImage2D(3553, d, c, a.width, a.height, 0, h, u, a.data);
                            e.generateMipmaps = !1, t.__maxMipLevel = p.length - 1
                        } else w.texImage2D(3553, 0, c, o.width, o.height, 0, h, u, o.data), t.__maxMipLevel = 0;
                    else if (e.isCompressedTexture) {
                        for (var m = 0, g = p.length; m < g; m++) a = p[m], e.format !== Yt && e.format !== Xt ? null !== h && w.compressedTexImage2D(3553, m, c, a.width, a.height, 0, a.data) : w.texImage2D(3553, m, c, a.width, a.height, 0, h, u, a.data);
                        t.__maxMipLevel = p.length - 1
                    } else if (e.isDataTexture2DArray) w.texImage3D(35866, 0, c, o.width, o.height, o.depth, 0, h, u, o.data), t.__maxMipLevel = 0;
                    else if (e.isDataTexture3D) w.texImage3D(32879, 0, c, o.width, o.height, o.depth, 0, h, u, o.data), t.__maxMipLevel = 0;
                    else if (0 < p.length && l) {
                        for (var v = 0, y = p.length; v < y; v++) a = p[v], w.texImage2D(3553, v, c, h, u, a);
                        e.generateMipmaps = !1, t.__maxMipLevel = p.length - 1
                    } else w.texImage2D(3553, 0, c, h, u, o), t.__maxMipLevel = 0;
                    D(e, l) && P(n, e, o.width, o.height), t.__version = e.version, e.onUpdate && e.onUpdate(e)
                }

                function x(t, e, i, n) {
                    var r = M.convert(e.texture.format),
                        a = M.convert(e.texture.type),
                        s = L(e.texture.internalFormat, r, a);
                    w.texImage2D(n, 0, s, e.width, e.height, 0, r, a, null), _.bindFramebuffer(36160, t), _.framebufferTexture2D(36160, i, n, S.get(e.texture).__webglTexture, 0), _.bindFramebuffer(36160, null)
                }

                function F(t, e, i) {
                    var n, r, a, s, o, l, h, u;
                    _.bindRenderbuffer(36161, t), e.depthBuffer && !e.stencilBuffer ? (n = 33189, i ? ((r = e.depthTexture) && r.isDepthTexture && (r.type === Ht ? n = 36012 : r.type === jt && (n = 33190)), a = N(e), _.renderbufferStorageMultisample(36161, a, n, e.width, e.height)) : _.renderbufferStorage(36161, n, e.width, e.height), _.framebufferRenderbuffer(36160, 36096, 36161, t)) : e.depthBuffer && e.stencilBuffer ? (i ? (s = N(e), _.renderbufferStorageMultisample(36161, s, 35056, e.width, e.height)) : _.renderbufferStorage(36161, 34041, e.width, e.height), _.framebufferRenderbuffer(36160, 33306, 36161, t)) : (o = M.convert(e.texture.format), l = M.convert(e.texture.type), h = L(e.texture.internalFormat, o, l), i ? (u = N(e), _.renderbufferStorageMultisample(36161, u, h, e.width, e.height)) : _.renderbufferStorage(36161, h, e.width, e.height)), _.bindRenderbuffer(36161, null)
                }

                function I(t) {
                    var e = S.get(t),
                        i = !0 === t.isWebGLCubeRenderTarget;
                    if (t.depthTexture) {
                        if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(t, e) {
                            if (e && e.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (_.bindFramebuffer(36160, t), !e.depthTexture || !e.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            S.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), c(e.depthTexture, 0);
                            var i = S.get(e.depthTexture).__webglTexture;
                            if (e.depthTexture.format === Jt) _.framebufferTexture2D(36160, 36096, 3553, i, 0);
                            else {
                                if (e.depthTexture.format !== Zt) throw new Error("Unknown depthTexture format");
                                _.framebufferTexture2D(36160, 33306, 3553, i, 0)
                            }
                        }(e.__webglFramebuffer, t)
                    } else if (i) {
                        e.__webglDepthbuffer = [];
                        for (var n = 0; n < 6; n++) _.bindFramebuffer(36160, e.__webglFramebuffer[n]), e.__webglDepthbuffer[n] = _.createRenderbuffer(), F(e.__webglDepthbuffer[n], t, !1)
                    } else _.bindFramebuffer(36160, e.__webglFramebuffer), e.__webglDepthbuffer = _.createRenderbuffer(), F(e.__webglDepthbuffer, t, !1);
                    _.bindFramebuffer(36160, null)
                }

                function N(t) {
                    return T && t.isWebGLMultisampleRenderTarget ? Math.min(e, t.samples) : 0
                }
                v[It] = 9728, v[Nt] = 9984, v[Bt] = 9986, v[Rt] = 9729, v[zt] = 9985;
                var B = !(v[Gt] = 9987),
                    R = !1;
                this.allocateTextureUnit = function() {
                    var t = l;
                    return l += 1, t
                }, this.resetTextureUnits = function() {
                    l = 0
                }, this.setTexture2D = c, this.setTexture2DArray = function(t, e) {
                    var i = S.get(t);
                    0 < t.version && i.__version !== t.version ? y(i, t, e) : (w.activeTexture(33984 + e), w.bindTexture(35866, i.__webglTexture))
                }, this.setTexture3D = function(t, e) {
                    var i = S.get(t);
                    0 < t.version && i.__version !== t.version ? y(i, t, e) : (w.activeTexture(33984 + e), w.bindTexture(32879, i.__webglTexture))
                }, this.setTextureCube = f, this.setTextureCubeDynamic = m, this.setupRenderTarget = function(t) {
                    var e = S.get(t),
                        i = S.get(t.texture);
                    t.addEventListener("dispose", d), i.__webglTexture = _.createTexture(), p.memory.textures++;
                    var n, r, a, s, o = !0 === t.isWebGLCubeRenderTarget,
                        l = !0 === t.isWebGLMultisampleRenderTarget,
                        h = E(t) || T;
                    if (!T || t.texture.format !== Xt || t.texture.type !== Ht && t.texture.type !== Wt || (t.texture.format = Yt), o) {
                        e.__webglFramebuffer = [];
                        for (var u = 0; u < 6; u++) e.__webglFramebuffer[u] = _.createFramebuffer()
                    } else {
                        e.__webglFramebuffer = _.createFramebuffer(), l && T && (e.__webglMultisampledFramebuffer = _.createFramebuffer(), e.__webglColorRenderbuffer = _.createRenderbuffer(), _.bindRenderbuffer(36161, e.__webglColorRenderbuffer), n = M.convert(t.texture.format), r = M.convert(t.texture.type), a = L(t.texture.internalFormat, n, r), s = N(t), _.renderbufferStorageMultisample(36161, s, a, t.width, t.height), _.bindFramebuffer(36160, e.__webglMultisampledFramebuffer), _.framebufferRenderbuffer(36160, 36064, 36161, e.__webglColorRenderbuffer), _.bindRenderbuffer(36161, null), t.depthBuffer && (e.__webglDepthRenderbuffer = _.createRenderbuffer(), F(e.__webglDepthRenderbuffer, t, !0)), _.bindFramebuffer(36160, null))
                    }
                    if (o) {
                        w.bindTexture(34067, i.__webglTexture), k(34067, t.texture, h);
                        for (var c = 0; c < 6; c++) x(e.__webglFramebuffer[c], t, 36064, 34069 + c);
                        D(t.texture, h) && P(34067, t.texture, t.width, t.height), w.bindTexture(34067, null)
                    } else w.bindTexture(3553, i.__webglTexture), k(3553, t.texture, h), x(e.__webglFramebuffer, t, 36064, 3553), D(t.texture, h) && P(3553, t.texture, t.width, t.height), w.bindTexture(3553, null);
                    t.depthBuffer && I(t)
                }, this.updateRenderTargetMipmap = function(t) {
                    var e, i, n = t.texture;
                    D(n, E(t) || T) && (e = t.isWebGLCubeRenderTarget ? 34067 : 3553, i = S.get(n).__webglTexture, w.bindTexture(e, i), P(e, n, t.width, t.height), w.bindTexture(e, null))
                }, this.updateMultisampleRenderTarget = function(t) {
                    var e, i, n, r;
                    t.isWebGLMultisampleRenderTarget && T && (e = S.get(t), _.bindFramebuffer(36008, e.__webglMultisampledFramebuffer), _.bindFramebuffer(36009, e.__webglFramebuffer), i = t.width, n = t.height, r = 16384, t.depthBuffer && (r |= 256), t.stencilBuffer && (r |= 1024), _.blitFramebuffer(0, 0, i, n, 0, 0, i, n, r, 9728), _.bindFramebuffer(36160, e.__webglMultisampledFramebuffer))
                }, this.safeSetTexture2D = function(t, e) {
                    t && t.isWebGLRenderTarget && (!1 === B && (B = !0), t = t.texture), c(t, e)
                }, this.safeSetTextureCube = function(t, e) {
                    t && t.isWebGLCubeRenderTarget && (!1 === R && (R = !0), t = t.texture), (t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? f : m)(t, e)
                }
            }

            function Vs(t, i, e) {
                var n = e.isWebGL2;
                return {
                    convert: function(t) {
                        var e;
                        if (t === Vt) return 5121;
                        if (t === o) return 32819;
                        if (t === l) return 32820;
                        if (t === h) return 33635;
                        if (t === r) return 5120;
                        if (t === a) return 5122;
                        if (t === Ut) return 5123;
                        if (t === s) return 5124;
                        if (t === jt) return 5125;
                        if (t === Ht) return 5126;
                        if (t === Wt) return n ? 5131 : null !== (e = i.get("OES_texture_half_float")) ? e.HALF_FLOAT_OES : null;
                        if (t === p) return 6406;
                        if (t === Xt) return 6407;
                        if (t === Yt) return 6408;
                        if (t === d) return 6409;
                        if (t === f) return 6410;
                        if (t === Jt) return 6402;
                        if (t === Zt) return 34041;
                        if (t === g) return 6403;
                        if (t === v) return 36244;
                        if (t === y) return 33319;
                        if (t === b) return 33320;
                        if (t === x) return 36248;
                        if (t === _) return 36249;
                        if (t === w || t === S || t === M || t === T) {
                            if (null === (e = i.get("WEBGL_compressed_texture_s3tc"))) return null;
                            if (t === w) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (t === S) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (t === M) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (t === T) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if (t === C || t === A || t === E || t === D) {
                            if (null === (e = i.get("WEBGL_compressed_texture_pvrtc"))) return null;
                            if (t === C) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (t === A) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (t === E) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (t === D) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (t === P) return null !== (e = i.get("WEBGL_compressed_texture_etc1")) ? e.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if ((t === L || t === O) && null !== (e = i.get("WEBGL_compressed_texture_etc"))) {
                            if (t === L) return e.COMPRESSED_RGB8_ETC2;
                            if (t === O) return e.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        return t === F || t === $t || t === Kt || t === Qt || t === te || t === ee || t === ie || t === ne || t === re || t === ae || t === se || t === oe || t === le || t === he || t === ce || t === pe || t === de || t === fe || t === me || t === ge || t === ve || t === ye || t === be || t === xe || t === _e || t === we || t === Se || t === Me ? null !== (e = i.get("WEBGL_compressed_texture_astc")) ? t : null : t === ue ? null !== (e = i.get("EXT_texture_compression_bptc")) ? t : null : t === qt ? n ? 34042 : null !== (e = i.get("WEBGL_depth_texture")) ? e.UNSIGNED_INT_24_8_WEBGL : null : void 0
                    }
                }
            }

            function Us(t) {
                Or.call(this), this.cameras = t || []
            }

            function js() {
                rn.call(this), this.type = "Group"
            }

            function Hs() {
                this._targetRay = null, this._grip = null, this._hand = null
            }

            function Ws(d, r) {
                var e = this,
                    f = null,
                    a = 1,
                    m = null,
                    s = "local-floor",
                    g = null,
                    v = [],
                    h = new Map,
                    o = new Or;
                o.layers.enable(1), o.viewport = new $e;
                var l = new Or;
                l.layers.enable(2), l.viewport = new $e;
                var y = [o, l],
                    b = new Us;
                b.layers.enable(1), b.layers.enable(2);
                var u = null,
                    c = null;

                function p(t) {
                    var e = h.get(t.inputSource);
                    e && e.dispatchEvent({
                        type: t.type
                    })
                }

                function x() {
                    h.forEach(function(t, e) {
                        t.disconnect(e)
                    }), h.clear(), d.setFramebuffer(null), d.setRenderTarget(d.getRenderTarget()), i.stop(), e.isPresenting = !1, e.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function _(t) {
                    m = t, i.setContext(f), i.start(), e.isPresenting = !0, e.dispatchEvent({
                        type: "sessionstart"
                    })
                }

                function w(t) {
                    for (var e = f.inputSources, i = 0; i < v.length; i++) h.set(e[i], v[i]);
                    for (var n = 0; n < t.removed.length; n++) {
                        var r = t.removed[n],
                            a = h.get(r);
                        a && (a.dispatchEvent({
                            type: "disconnected",
                            data: r
                        }), h.delete(r))
                    }
                    for (var s = 0; s < t.added.length; s++) {
                        var o = t.added[s],
                            l = h.get(o);
                        l && l.dispatchEvent({
                            type: "connected",
                            data: o
                        })
                    }
                }
                this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                    var e = v[t];
                    return void 0 === e && (e = new Hs, v[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function(t) {
                    var e = v[t];
                    return void 0 === e && (e = new Hs, v[t] = e), e.getGripSpace()
                }, this.getHand = function(t) {
                    var e = v[t];
                    return void 0 === e && (e = new Hs, v[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function(t) {
                    a = t, e.isPresenting
                }, this.setReferenceSpaceType = function(t) {
                    s = t, e.isPresenting
                }, this.getReferenceSpace = function() {
                    return m
                }, this.getSession = function() {
                    return f
                }, this.setSession = function(t) {
                    var e, i, n;
                    null !== (f = t) && (f.addEventListener("select", p), f.addEventListener("selectstart", p), f.addEventListener("selectend", p), f.addEventListener("squeeze", p), f.addEventListener("squeezestart", p), f.addEventListener("squeezeend", p), f.addEventListener("end", x), !0 !== (e = r.getContextAttributes()).xrCompatible && r.makeXRCompatible(), i = {
                        antialias: e.antialias,
                        alpha: e.alpha,
                        depth: e.depth,
                        stencil: e.stencil,
                        framebufferScaleFactor: a
                    }, n = new XRWebGLLayer(f, r, i), f.updateRenderState({
                        baseLayer: n
                    }), f.requestReferenceSpace(s).then(_), f.addEventListener("inputsourceschange", w))
                };
                var S = new ni,
                    M = new ni;

                function T(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
                }
                this.getCamera = function(t) {
                    b.near = l.near = o.near = t.near, b.far = l.far = o.far = t.far, u === b.near && c === b.far || (f.updateRenderState({
                        depthNear: b.near,
                        depthFar: b.far
                    }), u = b.near, c = b.far);
                    var e = t.parent,
                        i = b.cameras;
                    T(b, e);
                    for (var n = 0; n < i.length; n++) T(i[n], e);
                    t.matrixWorld.copy(b.matrixWorld);
                    for (var r = t.children, a = 0, s = r.length; a < s; a++) r[a].updateMatrixWorld(!0);
                    return 2 === i.length ? function(t, e, i) {
                        S.setFromMatrixPosition(e.matrixWorld), M.setFromMatrixPosition(i.matrixWorld);
                        var n = S.distanceTo(M),
                            r = e.projectionMatrix.elements,
                            a = i.projectionMatrix.elements,
                            s = r[14] / (r[10] - 1),
                            o = r[14] / (r[10] + 1),
                            l = (r[9] + 1) / r[5],
                            h = (r[9] - 1) / r[5],
                            u = (r[8] - 1) / r[0],
                            c = (a[8] + 1) / a[0],
                            p = s * u,
                            d = s * c,
                            f = n / (c - u),
                            m = f * -u;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                        var g = s + f,
                            v = o + f,
                            y = p - m,
                            b = n - m + d,
                            x = l * o / v * g,
                            _ = h * o / v * g;
                        t.projectionMatrix.makePerspective(y, b, x, _, g, v)
                    }(b, o, l) : b.projectionMatrix.copy(o.projectionMatrix), b
                };
                var C = null;
                var i = new Gr;
                i.setAnimationLoop(function(t, e) {
                    if (null !== (g = e.getViewerPose(m))) {
                        var i = g.views,
                            n = f.renderState.baseLayer;
                        d.setFramebuffer(n.framebuffer);
                        var r = !1;
                        i.length !== b.cameras.length && (r = !(b.cameras.length = 0));
                        for (var a = 0; a < i.length; a++) {
                            var s = i[a],
                                o = n.getViewport(s),
                                l = y[a];
                            l.matrix.fromArray(s.transform.matrix), l.projectionMatrix.fromArray(s.projectionMatrix), l.viewport.set(o.x, o.y, o.width, o.height), 0 === a && b.matrix.copy(l.matrix), !0 === r && b.cameras.push(l)
                        }
                    }
                    for (var h = f.inputSources, u = 0; u < v.length; u++) {
                        var c = v[u],
                            p = h[u];
                        c.update(p, e, m)
                    }
                    C && C(t, e)
                }), this.setAnimationLoop = function(t) {
                    C = t
                }, this.dispose = function() {}
            }

            function qs(s) {
                function p(t, e) {
                    t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap);
                    var i, n, r, a = s.get(e).envMap;
                    a && (t.envMap.value = a, t.flipEnvMap.value = a.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, void 0 !== (i = s.get(a).__maxMipLevel) && (t.maxMipLevel.value = i)), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap ? n = e.emissiveMap : e.clearcoatMap ? n = e.clearcoatMap : e.clearcoatNormalMap ? n = e.clearcoatNormalMap : e.clearcoatRoughnessMap && (n = e.clearcoatRoughnessMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)), e.aoMap ? r = e.aoMap : e.lightMap && (r = e.lightMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uv2Transform.value.copy(r.matrix))
                }

                function d(t, e) {
                    t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === q && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === q && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), s.get(e).envMap && (t.envMapIntensity.value = e.envMapIntensity)
                }
                return {
                    refreshFogUniforms: function(t, e) {
                        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    },
                    refreshMaterialUniforms: function(t, e, i, n) {
                        var r, a, s, o, l, h, u, c;
                        e.isMeshBasicMaterial ? p(t, e) : e.isMeshLambertMaterial ? (p(t, e), u = t, (c = e).emissiveMap && (u.emissiveMap.value = c.emissiveMap)) : e.isMeshToonMaterial ? (p(t, e), function(t, e) {
                            e.gradientMap && (t.gradientMap.value = e.gradientMap);
                            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === q && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === q && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, e)) : e.isMeshPhongMaterial ? (p(t, e), function(t, e) {
                            t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === q && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === q && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, e)) : e.isMeshStandardMaterial ? (p(t, e), (e.isMeshPhysicalMaterial ? function(t, e) {
                            d(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                            e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                            e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                            e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === q && t.clearcoatNormalScale.value.negate());
                            t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                        } : d)(t, e)) : e.isMeshMatcapMaterial ? (p(t, e), function(t, e) {
                            e.matcap && (t.matcap.value = e.matcap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === q && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === q && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, e)) : e.isMeshDepthMaterial ? (p(t, e), l = t, (h = e).displacementMap && (l.displacementMap.value = h.displacementMap, l.displacementScale.value = h.displacementScale, l.displacementBias.value = h.displacementBias)) : e.isMeshDistanceMaterial ? (p(t, e), function(t, e) {
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                            t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                        }(t, e)) : e.isMeshNormalMaterial ? (p(t, e), function(t, e) {
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === q && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === q && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, e)) : e.isLineBasicMaterial ? (o = e, (s = t).diffuse.value.copy(o.color), s.opacity.value = o.opacity, e.isLineDashedMaterial && (a = e, (r = t).dashSize.value = a.dashSize, r.totalSize.value = a.dashSize + a.gapSize, r.scale.value = a.scale)) : e.isPointsMaterial ? function(t, e, i, n) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = .5 * n, e.map && (t.map.value = e.map);
                            e.alphaMap && (t.alphaMap.value = e.alphaMap);
                            var r;
                            e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                            void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                        }(t, e, i, n) : e.isSpriteMaterial ? function(t, e) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                            e.alphaMap && (t.alphaMap.value = e.alphaMap);
                            var i;
                            e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
                            void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
                        }(t, e) : e.isShadowMaterial ? (t.color.value.copy(e.color), t.opacity.value = e.opacity) : e.isShaderMaterial && (e.uniformsNeedUpdate = !1)
                    }
                }
            }

            function Xs(t) {
                var a = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    e = void 0 !== t.context ? t.context : null,
                    i = void 0 !== t.alpha && t.alpha,
                    n = void 0 === t.depth || t.depth,
                    r = void 0 === t.stencil || t.stencil,
                    s = void 0 !== t.antialias && t.antialias,
                    o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    h = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat,
                    y = null,
                    T = null;
                this.domElement = a, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Te, this.physicallyCorrectLights = !1, this.toneMapping = Tt, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var C = this,
                    c = !1,
                    p = null,
                    d = 0,
                    f = 0,
                    A = null,
                    m = null,
                    E = -1,
                    D = null,
                    g = null,
                    v = new $e,
                    b = new $e,
                    x = null,
                    _ = a.width,
                    P = a.height,
                    L = 1,
                    w = null,
                    S = null,
                    M = new $e(0, 0, _, P),
                    k = new $e(0, 0, _, P),
                    O = !1,
                    F = new zr,
                    I = !1,
                    N = !1,
                    B = new Li,
                    R = new ni,
                    z = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function G() {
                    return null === A ? L : 1
                }
                var V, U, j, H, W, q, X, Y, J, Z, $, K, Q, tt, et, it, nt, rt, at, st, ot, lt = e;

                function ht(t, e) {
                    for (var i = 0; i < t.length; i++) {
                        var n = t[i],
                            r = a.getContext(n, e);
                        if (null !== r) return r
                    }
                    return null
                }
                try {
                    var ut = {
                        alpha: i,
                        depth: n,
                        stencil: r,
                        antialias: s,
                        premultipliedAlpha: o,
                        preserveDrawingBuffer: l,
                        powerPreference: h,
                        failIfMajorPerformanceCaveat: u
                    };
                    if (a.addEventListener("webglcontextlost", mt, !1), a.addEventListener("webglcontextrestored", gt, !1), null === lt) {
                        var ct = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === C.isWebGL1Renderer && ct.shift(), null === (lt = ht(ct, ut))) throw ht(ct) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    void 0 === lt.getShaderPrecisionFormat && (lt.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    throw t
                }

                function pt() {
                    V = new Qr(lt), !1 === (U = new Zr(lt, V, t)).isWebGL2 && (V.get("WEBGL_depth_texture"), V.get("OES_texture_float"), V.get("OES_texture_half_float"), V.get("OES_texture_half_float_linear"), V.get("OES_standard_derivatives"), V.get("OES_element_index_uint"), V.get("OES_vertex_array_object"), V.get("ANGLE_instanced_arrays")), V.get("OES_texture_float_linear"), st = new Vs(0, V, U), (j = new zs(lt, V, U)).scissor(b.copy(k).multiplyScalar(L).floor()), j.viewport(v.copy(M).multiplyScalar(L).floor()), H = new ia, W = new Ss, q = new Gs(lt, V, j, W, U, st, H), X = new Kr(C), Y = new Vr(lt, U), ot = new Yr(lt, V, Y, U), J = new ta(0, Y, H, ot), Z = new sa(0, J, Y, H), nt = new aa(lt), et = new $r(W), $ = new ws(C, X, V, U, ot, et), K = new qs(W), Q = new As(W), tt = new Os, it = new Xr(C, X, j, Z, o), rt = new Jr(lt, V, H, U), at = new ea(lt, V, H, U), H.programs = $.programs, C.capabilities = U, C.extensions = V, C.properties = W, C.renderLists = Q, C.state = j, C.info = H
                }
                pt();
                var dt = new Ws(C, lt);
                this.xr = dt;
                var ft = new Rs(C, Z, U.maxTextureSize);

                function mt(t) {
                    t.preventDefault(), c = !0
                }

                function gt() {
                    c = !1, pt()
                }

                function vt(t) {
                    var e, i = t.target;
                    i.removeEventListener("dispose", vt), yt(e = i), W.remove(e)
                }

                function yt(t) {
                    var e = W.get(t).program;
                    void 0 !== e && $.releaseProgram(e)
                }
                this.shadowMap = ft, this.getContext = function() {
                    return lt
                }, this.getContextAttributes = function() {
                    return lt.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var t = V.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    var t = V.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return L
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (L = t, this.setSize(_, P, !1))
                }, this.getSize = function(t) {
                    return void 0 === t && (t = new He), t.set(_, P)
                }, this.setSize = function(t, e, i) {
                    dt.isPresenting || (_ = t, P = e, a.width = Math.floor(t * L), a.height = Math.floor(e * L), !1 !== i && (a.style.width = t + "px", a.style.height = e + "px"), this.setViewport(0, 0, t, e))
                }, this.getDrawingBufferSize = function(t) {
                    return void 0 === t && (t = new He), t.set(_ * L, P * L).floor()
                }, this.setDrawingBufferSize = function(t, e, i) {
                    _ = t, P = e, L = i, a.width = Math.floor(t * i), a.height = Math.floor(e * i), this.setViewport(0, 0, t, e)
                }, this.getCurrentViewport = function(t) {
                    return void 0 === t && (t = new $e), t.copy(v)
                }, this.getViewport = function(t) {
                    return t.copy(M)
                }, this.setViewport = function(t, e, i, n) {
                    t.isVector4 ? M.set(t.x, t.y, t.z, t.w) : M.set(t, e, i, n), j.viewport(v.copy(M).multiplyScalar(L).floor())
                }, this.getScissor = function(t) {
                    return t.copy(k)
                }, this.setScissor = function(t, e, i, n) {
                    t.isVector4 ? k.set(t.x, t.y, t.z, t.w) : k.set(t, e, i, n), j.scissor(b.copy(k).multiplyScalar(L).floor())
                }, this.getScissorTest = function() {
                    return O
                }, this.setScissorTest = function(t) {
                    j.setScissorTest(O = t)
                }, this.setOpaqueSort = function(t) {
                    w = t
                }, this.setTransparentSort = function(t) {
                    S = t
                }, this.getClearColor = function() {
                    return it.getClearColor()
                }, this.setClearColor = function() {
                    it.setClearColor.apply(it, arguments)
                }, this.getClearAlpha = function() {
                    return it.getClearAlpha()
                }, this.setClearAlpha = function() {
                    it.setClearAlpha.apply(it, arguments)
                }, this.clear = function(t, e, i) {
                    var n = 0;
                    void 0 !== t && !t || (n |= 16384), void 0 !== e && !e || (n |= 256), void 0 !== i && !i || (n |= 1024), lt.clear(n)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    a.removeEventListener("webglcontextlost", mt, !1), a.removeEventListener("webglcontextrestored", gt, !1), Q.dispose(), tt.dispose(), W.dispose(), X.dispose(), Z.dispose(), ot.dispose(), dt.dispose(), xt.stop()
                }, this.renderBufferImmediate = function(t, e) {
                    ot.initAttributes();
                    var i = W.get(t);
                    t.hasPositions && !i.position && (i.position = lt.createBuffer()), t.hasNormals && !i.normal && (i.normal = lt.createBuffer()), t.hasUvs && !i.uv && (i.uv = lt.createBuffer()), t.hasColors && !i.color && (i.color = lt.createBuffer());
                    var n = e.getAttributes();
                    t.hasPositions && (lt.bindBuffer(34962, i.position), lt.bufferData(34962, t.positionArray, 35048), ot.enableAttribute(n.position), lt.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (lt.bindBuffer(34962, i.normal), lt.bufferData(34962, t.normalArray, 35048), ot.enableAttribute(n.normal), lt.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (lt.bindBuffer(34962, i.uv), lt.bufferData(34962, t.uvArray, 35048), ot.enableAttribute(n.uv), lt.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), t.hasColors && (lt.bindBuffer(34962, i.color), lt.bufferData(34962, t.colorArray, 35048), ot.enableAttribute(n.color), lt.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), ot.disableUnusedAttributes(), lt.drawArrays(4, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, i, n, r, a) {
                    null === e && (e = z);
                    var s = r.isMesh && r.matrixWorld.determinant() < 0,
                        o = Mt(t, e, n, r);
                    j.setMaterial(n, s);
                    var l = i.index,
                        h = i.attributes.position;
                    if (null === l) {
                        if (void 0 === h || 0 === h.count) return
                    } else if (0 === l.count) return;
                    var u, c = 1;
                    !0 === n.wireframe && (l = J.getWireframeAttribute(i), c = 2), (n.morphTargets || n.morphNormals) && nt.update(r, i, n, o), ot.setup(r, n, o, i, l);
                    var p = rt;
                    null !== l && (u = Y.get(l), (p = at).setIndex(u));
                    var d, f, m = null !== l ? l.count : h.count,
                        g = i.drawRange.start * c,
                        v = i.drawRange.count * c,
                        y = null !== a ? a.start * c : 0,
                        b = null !== a ? a.count * c : 1 / 0,
                        x = Math.max(g, y),
                        _ = Math.min(m, g + v, y + b) - 1,
                        w = Math.max(0, _ - x + 1);
                    0 !== w && (r.isMesh ? !0 === n.wireframe ? (j.setLineWidth(n.wireframeLinewidth * G()), p.setMode(1)) : p.setMode(4) : r.isLine ? (void 0 === (d = n.linewidth) && (d = 1), j.setLineWidth(d * G()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)) : r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4), r.isInstancedMesh ? p.renderInstances(x, w, r.count) : i.isInstancedBufferGeometry ? (f = Math.min(i.instanceCount, i._maxInstanceCount), p.renderInstances(x, w, f)) : p.render(x, w))
                }, this.compile = function(r, t) {
                    (T = tt.get(r, t)).init(), r.traverse(function(t) {
                        t.isLight && (T.pushLight(t), t.castShadow && T.pushShadow(t))
                    }), T.setupLights(t);
                    var a = new WeakMap;
                    r.traverse(function(t) {
                        var e = t.material;
                        if (e)
                            if (Array.isArray(e))
                                for (var i = 0; i < e.length; i++) {
                                    var n = e[i];
                                    !1 === a.has(n) && (St(n, r, t), a.set(n))
                                } else !1 === a.has(e) && (St(e, r, t), a.set(e))
                    })
                };
                var bt = null;
                var xt = new Gr;

                function _t(t, e, i) {
                    for (var n = !0 === e.isScene ? e.overrideMaterial : null, r = 0, a = t.length; r < a; r++) {
                        var s = t[r],
                            o = s.object,
                            l = s.geometry,
                            h = null === n ? s.material : n,
                            u = s.group;
                        if (i.isArrayCamera)
                            for (var c = (g = i).cameras, p = 0, d = c.length; p < d; p++) {
                                var f = c[p];
                                o.layers.test(f.layers) && (j.viewport(v.copy(f.viewport)), T.setupLights(f), wt(o, e, f, l, h, u))
                            } else g = null, wt(o, e, i, l, h, u)
                    }
                }

                function wt(t, e, i, n, r, a) {
                    var s, o;
                    t.onBeforeRender(C, e, i, n, r, a), T = tt.get(e, g || i), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject ? (s = Mt(i, e, r, t), j.setMaterial(r), ot.reset(), o = s, t.render(function(t) {
                        C.renderBufferImmediate(t, o)
                    })) : C.renderBufferDirect(i, e, n, r, t, a), t.onAfterRender(C, e, i, n, r, a), T = tt.get(e, g || i)
                }

                function St(t, e, i) {
                    !0 !== e.isScene && (e = z);
                    var n = W.get(t),
                        r = T.state.lights,
                        a = T.state.shadowsArray,
                        s = r.state.version,
                        o = $.getParameters(t, r.state, a, e, i),
                        l = $.getProgramCacheKey(o),
                        h = n.program,
                        u = !0;
                    if (void 0 === h) t.addEventListener("dispose", vt);
                    else if (h.cacheKey !== l) yt(t);
                    else if (n.lightsStateVersion !== s) u = !1;
                    else {
                        if (void 0 !== o.shaderID) {
                            var c = t.isMeshStandardMaterial ? e.environment : null;
                            return void(n.envMap = X.get(t.envMap || c))
                        }
                        u = !1
                    }
                    u && (o.uniforms = $.getUniforms(t), t.onBeforeCompile(o, C), h = $.acquireProgram(o, l), n.program = h, n.uniforms = o.uniforms, n.outputEncoding = o.outputEncoding);
                    var p, d = n.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = et.numPlanes, n.numIntersection = et.numIntersection, d.clippingPlanes = et.uniform), n.environment = t.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = X.get(t.envMap || n.environment), n.needsLights = (p = t).isMeshLambertMaterial || p.isMeshToonMaterial || p.isMeshPhongMaterial || p.isMeshStandardMaterial || p.isShadowMaterial || p.isShaderMaterial && !0 === p.lights, n.lightsStateVersion = s, n.needsLights && (d.ambientLightColor.value = r.state.ambient, d.lightProbe.value = r.state.probe, d.directionalLights.value = r.state.directional, d.directionalLightShadows.value = r.state.directionalShadow, d.spotLights.value = r.state.spot, d.spotLightShadows.value = r.state.spotShadow, d.rectAreaLights.value = r.state.rectArea, d.ltc_1.value = r.state.rectAreaLTC1, d.ltc_2.value = r.state.rectAreaLTC2, d.pointLights.value = r.state.point, d.pointLightShadows.value = r.state.pointShadow, d.hemisphereLights.value = r.state.hemi, d.directionalShadowMap.value = r.state.directionalShadowMap, d.directionalShadowMatrix.value = r.state.directionalShadowMatrix, d.spotShadowMap.value = r.state.spotShadowMap, d.spotShadowMatrix.value = r.state.spotShadowMatrix, d.pointShadowMap.value = r.state.pointShadowMap, d.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    var f = n.program.getUniforms(),
                        m = ns.seqWithValue(f.seq, d);
                    n.uniformsList = m
                }

                function Mt(t, e, i, n) {
                    !0 !== e.isScene && (e = z), q.resetTextureUnits();
                    var r, a = e.fog,
                        s = i.isMeshStandardMaterial ? e.environment : null,
                        o = null === A ? C.outputEncoding : A.texture.encoding,
                        l = X.get(i.envMap || s),
                        h = W.get(i),
                        u = T.state.lights;
                    !0 === I && (!0 !== N && t === D || (r = t === D && i.id === E, et.setState(i, t, r))), i.version === h.__version ? (i.fog && h.fog !== a || h.environment !== s || h.needsLights && h.lightsStateVersion !== u.state.version || void 0 !== h.numClippingPlanes && (h.numClippingPlanes !== et.numPlanes || h.numIntersection !== et.numIntersection) || h.outputEncoding !== o || h.envMap !== l) && St(i, e, n) : (St(i, e, n), h.__version = i.version);
                    var c, p, d, f, m, g, v, y, b = !1,
                        x = !1,
                        _ = !1,
                        w = h.program,
                        S = w.getUniforms(),
                        M = h.uniforms;
                    return j.useProgram(w.program) && (_ = x = b = !0), i.id !== E && (E = i.id, x = !0), !b && D === t || (S.setValue(lt, "projectionMatrix", t.projectionMatrix), U.logarithmicDepthBuffer && S.setValue(lt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), D !== t && (D = t, _ = x = !0), !(i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) || void 0 !== (c = S.map.cameraPosition) && c.setValue(lt, R.setFromMatrixPosition(t.matrixWorld)), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && S.setValue(lt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || i.skinning) && S.setValue(lt, "viewMatrix", t.matrixWorldInverse)), i.skinning && (S.setOptional(lt, n, "bindMatrix"), S.setOptional(lt, n, "bindMatrixInverse"), (p = n.skeleton) && (d = p.bones, U.floatVertexTextures ? (void 0 === p.boneTexture && (f = Math.sqrt(4 * d.length), f = je.ceilPowerOfTwo(f), f = Math.max(f, 4), (m = new Float32Array(f * f * 4)).set(p.boneMatrices), g = new Nr(m, f, f, Yt, Ht), p.boneMatrices = m, p.boneTexture = g, p.boneTextureSize = f), S.setValue(lt, "boneTexture", p.boneTexture, q), S.setValue(lt, "boneTextureSize", p.boneTextureSize)) : S.setOptional(lt, p, "boneMatrices"))), !x && h.receiveShadow === n.receiveShadow || (h.receiveShadow = n.receiveShadow, S.setValue(lt, "receiveShadow", n.receiveShadow)), x && (S.setValue(lt, "toneMappingExposure", C.toneMappingExposure), h.needsLights && (y = _, (v = M).ambientLightColor.needsUpdate = y, v.lightProbe.needsUpdate = y, v.directionalLights.needsUpdate = y, v.directionalLightShadows.needsUpdate = y, v.pointLights.needsUpdate = y, v.pointLightShadows.needsUpdate = y, v.spotLights.needsUpdate = y, v.spotLightShadows.needsUpdate = y, v.rectAreaLights.needsUpdate = y, v.hemisphereLights.needsUpdate = y), a && i.fog && K.refreshFogUniforms(M, a), K.refreshMaterialUniforms(M, i, L, P), ns.upload(lt, h.uniformsList, M, q)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (ns.upload(lt, h.uniformsList, M, q), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && S.setValue(lt, "center", n.center), S.setValue(lt, "modelViewMatrix", n.modelViewMatrix), S.setValue(lt, "normalMatrix", n.normalMatrix), S.setValue(lt, "modelMatrix", n.matrixWorld), w
                }
                xt.setAnimationLoop(function(t) {
                    dt.isPresenting || bt && bt(t)
                }), "undefined" != typeof window && xt.setContext(window), this.setAnimationLoop = function(t) {
                    bt = t, dt.setAnimationLoop(t), null === t ? xt.stop() : xt.start()
                }, this.render = function(t, e) {
                    var i, n, r, a, s;
                    void 0 !== arguments[2] && (i = arguments[2]), void 0 !== arguments[3] && (n = arguments[3]), void 0 !== e && !0 !== e.isCamera || !0 !== c && (ot.resetDefaultState(), E = -1, !(D = null) === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === dt.enabled && !0 === dt.isPresenting && (e = dt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(C, t, e, i || A), (T = tt.get(t, e)).init(), B.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), F.setFromProjectionMatrix(B), N = this.localClippingEnabled, I = et.init(this.clippingPlanes, N, e), (y = Q.get(t, e)).init(), function t(e, i, n, r) {
                        if (!1 === e.visible) return;
                        var a = e.layers.test(i.layers);
                        if (a)
                            if (e.isGroup) n = e.renderOrder;
                            else if (e.isLOD) !0 === e.autoUpdate && e.update(i);
                        else if (e.isLight) T.pushLight(e), e.castShadow && T.pushShadow(e);
                        else if (e.isSprite) {
                            var s, o;
                            e.frustumCulled && !F.intersectsSprite(e) || (r && R.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B), s = Z.update(e), (o = e.material).visible && y.push(e, s, o, n, R.z, null))
                        } else if (e.isImmediateRenderObject) r && R.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B), y.push(e, null, e.material, n, R.z, null);
                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== H.render.frame && (e.skeleton.update(), e.skeleton.frame = H.render.frame), !e.frustumCulled || F.intersectsObject(e))) {
                            r && R.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B);
                            var l = Z.update(e),
                                h = e.material;
                            if (Array.isArray(h))
                                for (var u = l.groups, c = 0, p = u.length; c < p; c++) {
                                    var d = u[c],
                                        f = h[d.materialIndex];
                                    f && f.visible && y.push(e, l, f, n, R.z, d)
                                } else h.visible && y.push(e, l, h, n, R.z, null)
                        }
                        var m = e.children;
                        for (var g = 0, v = m.length; g < v; g++) t(m[g], i, n, r)
                    }(t, e, 0, C.sortObjects), y.finish(), !0 === C.sortObjects && y.sort(w, S), !0 === I && et.beginShadows(), r = T.state.shadowsArray, ft.render(r, t, e), T.setupLights(e), !0 === I && et.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i), it.render(y, t, e, n), a = y.opaque, s = y.transparent, 0 < a.length && _t(a, t, e), 0 < s.length && _t(s, t, e), !0 === t.isScene && t.onAfterRender(C, t, e), null !== A && (q.updateRenderTargetMipmap(A), q.updateMultisampleRenderTarget(A)), j.buffers.depth.setTest(!0), j.buffers.depth.setMask(!0), j.buffers.color.setMask(!0), j.setPolygonOffset(!1), T = y = null)
                }, this.setFramebuffer = function(t) {
                    p !== t && null === A && lt.bindFramebuffer(36160, t), p = t
                }, this.getActiveCubeFace = function() {
                    return d
                }, this.getActiveMipmapLevel = function() {
                    return f
                }, this.getRenderList = function() {
                    return y
                }, this.setRenderList = function(t) {
                    y = t
                }, this.getRenderState = function() {
                    return T
                }, this.setRenderState = function(t) {
                    T = t
                }, this.getRenderTarget = function() {
                    return A
                }, this.setRenderTarget = function(t, e, i) {
                    void 0 === e && (e = 0), void 0 === i && (i = 0), d = e, f = i, (A = t) && void 0 === W.get(t).__webglFramebuffer && q.setupRenderTarget(t);
                    var n, r, a = p,
                        s = !1;
                    x = t ? (n = W.get(t).__webglFramebuffer, t.isWebGLCubeRenderTarget ? (a = n[e], s = !0) : a = t.isWebGLMultisampleRenderTarget ? W.get(t).__webglMultisampledFramebuffer : n, v.copy(t.viewport), b.copy(t.scissor), t.scissorTest) : (v.copy(M).multiplyScalar(L).floor(), b.copy(k).multiplyScalar(L).floor(), O), m !== a && (lt.bindFramebuffer(36160, a), m = a), j.viewport(v), j.scissor(b), j.setScissorTest(x), s && (r = W.get(t.texture), lt.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, i))
                }, this.readRenderTargetPixels = function(t, e, i, n, r, a, s) {
                    if (t && t.isWebGLRenderTarget) {
                        var o = W.get(t).__webglFramebuffer;
                        if (t.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) {
                            var l = !1;
                            o !== m && (lt.bindFramebuffer(36160, o), l = !0);
                            try {
                                var h = t.texture,
                                    u = h.format,
                                    c = h.type;
                                if (u !== Yt && st.convert(u) !== lt.getParameter(35739)) return;
                                if (!(c === Vt || st.convert(c) === lt.getParameter(35738) || c === Ht && (U.isWebGL2 || V.get("OES_texture_float") || V.get("WEBGL_color_buffer_float")) || c === Wt && (U.isWebGL2 ? V.get("EXT_color_buffer_float") : V.get("EXT_color_buffer_half_float")))) return;
                                36053 === lt.checkFramebufferStatus(36160) && 0 <= e && e <= t.width - n && 0 <= i && i <= t.height - r && lt.readPixels(e, i, n, r, st.convert(u), st.convert(c), a)
                            } finally {
                                l && lt.bindFramebuffer(36160, m)
                            }
                        }
                    }
                }, this.copyFramebufferToTexture = function(t, e, i) {
                    void 0 === i && (i = 0);
                    var n = Math.pow(2, -i),
                        r = Math.floor(e.image.width * n),
                        a = Math.floor(e.image.height * n),
                        s = st.convert(e.format);
                    q.setTexture2D(e, 0), lt.copyTexImage2D(3553, i, s, t.x, t.y, r, a, 0), j.unbindTexture()
                }, this.copyTextureToTexture = function(t, e, i, n) {
                    void 0 === n && (n = 0);
                    var r = e.image.width,
                        a = e.image.height,
                        s = st.convert(i.format),
                        o = st.convert(i.type);
                    q.setTexture2D(i, 0), lt.pixelStorei(37440, i.flipY), lt.pixelStorei(37441, i.premultiplyAlpha), lt.pixelStorei(3317, i.unpackAlignment), e.isDataTexture ? lt.texSubImage2D(3553, n, t.x, t.y, r, a, s, o, e.image.data) : e.isCompressedTexture ? lt.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : lt.texSubImage2D(3553, n, t.x, t.y, s, o, e.image), 0 === n && i.generateMipmaps && lt.generateMipmap(3553), j.unbindTexture()
                }, this.initTexture = function(t) {
                    q.setTexture2D(t, 0), j.unbindTexture()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }

            function Ys(t) {
                Xs.call(this, t)
            }
            Us.prototype = Object.assign(Object.create(Or.prototype), {
                constructor: Us,
                isArrayCamera: !0
            }), js.prototype = Object.assign(Object.create(rn.prototype), {
                constructor: js,
                isGroup: !0
            }), Object.assign(Hs.prototype, {
                constructor: Hs,
                getHandSpace: function() {
                    if (null === this._hand && (this._hand = new js, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = {
                            pinching: !1
                        }, window.XRHand))
                        for (var t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
                            var e = new js;
                            e.matrixAutoUpdate = !1, e.visible = !1, this._hand.joints.push(e), this._hand.add(e)
                        }
                    return this._hand
                },
                getTargetRaySpace: function() {
                    return null === this._targetRay && (this._targetRay = new js, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
                },
                getGripSpace: function() {
                    return null === this._grip && (this._grip = new js, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
                },
                dispatchEvent: function(t) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                },
                disconnect: function(t) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                },
                update: function(t, e, i) {
                    var n = null,
                        r = null,
                        a = null,
                        s = this._targetRay,
                        o = this._grip,
                        l = this._hand;
                    if (t)
                        if (l && t.hand) {
                            a = !0;
                            for (var h, u, c, p, d, f = 0; f <= window.XRHand.LITTLE_PHALANX_TIP; f++) {
                                t.hand[f] && (h = e.getJointPose(t.hand[f], i), u = l.joints[f], null !== h && (u.matrix.fromArray(h.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.jointRadius = h.radius), u.visible = null !== h, c = l.joints[window.XRHand.INDEX_PHALANX_TIP], p = l.joints[window.XRHand.THUMB_PHALANX_TIP], d = c.position.distanceTo(p.position), l.inputState.pinching && .025 < d ? (l.inputState.pinching = !1, this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: t.handedness,
                                    target: this
                                })) : !l.inputState.pinching && d <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: t.handedness,
                                    target: this
                                })))
                            }
                        } else null !== s && null !== (n = e.getPose(t.targetRaySpace, i)) && (s.matrix.fromArray(n.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)), null !== o && t.gripSpace && null !== (r = e.getPose(t.gripSpace, i)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale));
                    return null !== s && (s.visible = null !== n), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== a), this
                }
            }), Object.assign(Ws.prototype, ze.prototype), Ys.prototype = Object.assign(Object.create(Xs.prototype), {
                constructor: Ys,
                isWebGL1Renderer: !0
            });

            function Js(t, e) {
                Object.defineProperty(this, "isFogExp2", {
                    value: !0
                }), this.name = "", this.color = new Cn(t), this.density = void 0 !== e ? e : 25e-5
            }
            Js.prototype.clone = function() {
                return new Js(this.color, this.density)
            }, Js.prototype.toJSON = function() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            };

            function Zs(t, e, i) {
                Object.defineProperty(this, "isFog", {
                    value: !0
                }), this.name = "", this.color = new Cn(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
            }

            function $s() {
                rn.call(this), Object.defineProperty(this, "isScene", {
                    value: !0
                }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }

            function Ks(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Ne, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = je.generateUUID()
            }
            Zs.prototype.clone = function() {
                return new Zs(this.color, this.near, this.far)
            }, Zs.prototype.toJSON = function() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }, (($s.prototype = Object.create(rn.prototype)).constructor = $s).prototype.copy = function(t, e) {
                return rn.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            }, $s.prototype.toJSON = function(t) {
                var e = rn.prototype.toJSON.call(this, t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            }, Object.defineProperty(Ks.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Ks.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setUsage: function(t) {
                    return this.usage = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
                },
                copyAt: function(t, e, i) {
                    t *= this.stride, i *= e.stride;
                    for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                clone: function(t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = je.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    var e = new Ks(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride);
                    return e.setUsage(this.usage), e
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                toJSON: function(t) {
                    return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = je.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            });
            var Qs, to = new ni;

            function eo(t, e, i, n) {
                this.name = "", this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
            }

            function io(t) {
                Dn.call(this), this.type = "SpriteMaterial", this.color = new Cn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
            }
            Object.defineProperties(eo.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                },
                needsUpdate: {
                    set: function(t) {
                        this.data.needsUpdate = t
                    }
                }
            }), Object.assign(eo.prototype, {
                isInterleavedBufferAttribute: !0,
                applyMatrix4: function(t) {
                    for (var e = 0, i = this.data.count; e < i; e++) to.x = this.getX(e), to.y = this.getY(e), to.z = this.getZ(e), to.applyMatrix4(t), this.setXYZ(e, to.x, to.y, to.z);
                    return this
                },
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
                },
                setXYZ: function(t, e, i, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
                },
                setXYZW: function(t, e, i, n, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
                },
                clone: function(t) {
                    if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new eo(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
                    for (var e = [], i = 0; i < this.count; i++)
                        for (var n = i * this.data.stride + this.offset, r = 0; r < this.itemSize; r++) e.push(this.data.array[n + r]);
                    return new On(new this.array.constructor(e), this.itemSize, this.normalized)
                },
                toJSON: function(t) {
                    if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    };
                    for (var e = [], i = 0; i < this.count; i++)
                        for (var n = i * this.data.stride + this.offset, r = 0; r < this.itemSize; r++) e.push(this.data.array[n + r]);
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: e,
                        normalized: this.normalized
                    }
                }
            }), ((io.prototype = Object.create(Dn.prototype)).constructor = io).prototype.isSpriteMaterial = !0, io.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            };
            var no = new ni,
                ro = new ni,
                ao = new ni,
                so = new He,
                oo = new He,
                lo = new Li,
                ho = new ni,
                uo = new ni,
                co = new ni,
                po = new He,
                fo = new He,
                mo = new He;

            function go(t) {
                var e;
                rn.call(this), this.type = "Sprite", void 0 === Qs && (Qs = new Kn, e = new Ks(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5), Qs.setIndex([0, 1, 2, 0, 2, 3]), Qs.setAttribute("position", new eo(e, 3, 0, !1)), Qs.setAttribute("uv", new eo(e, 2, 3, !1))), this.geometry = Qs, this.material = void 0 !== t ? t : new io, this.center = new He(.5, .5)
            }

            function vo(t, e, i, n, r, a) {
                so.subVectors(t, i).addScalar(.5).multiply(n), void 0 !== r ? (oo.x = a * so.x - r * so.y, oo.y = r * so.x + a * so.y) : oo.copy(so), t.copy(e), t.x += oo.x, t.y += oo.y, t.applyMatrix4(lo)
            }
            go.prototype = Object.assign(Object.create(rn.prototype), {
                constructor: go,
                isSprite: !0,
                raycast: function(t, e) {
                    t.camera, ro.setFromMatrixScale(this.matrixWorld), lo.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ao.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && ro.multiplyScalar(-ao.z);
                    var i, n, r = this.material.rotation;
                    0 !== r && (n = Math.cos(r), i = Math.sin(r));
                    var a = this.center;
                    vo(ho.set(-.5, -.5, 0), ao, a, ro, i, n), vo(uo.set(.5, -.5, 0), ao, a, ro, i, n), vo(co.set(.5, .5, 0), ao, a, ro, i, n), po.set(0, 0), fo.set(1, 0), mo.set(1, 1);
                    var s, o = t.ray.intersectTriangle(ho, uo, co, !1, no);
                    null === o && (vo(uo.set(-.5, .5, 0), ao, a, ro, i, n), fo.set(0, 1), null === (o = t.ray.intersectTriangle(ho, co, uo, !1, no))) || ((s = t.ray.origin.distanceTo(no)) < t.near || s > t.far || e.push({
                        distance: s,
                        point: no.clone(),
                        uv: bn.getUV(no, ho, uo, co, po, fo, mo, new He),
                        face: null,
                        object: this
                    }))
                },
                copy: function(t) {
                    return rn.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                }
            });
            var yo, bo, xo, _o, wo, So = new ni,
                Mo = new ni;

            function To() {
                rn.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                }), this.autoUpdate = !0
            }

            function Co(t, e) {
                t && t.isGeometry, gr.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Li, this.bindMatrixInverse = new Li
            }
            To.prototype = Object.assign(Object.create(rn.prototype), {
                constructor: To,
                isLOD: !0,
                copy: function(t) {
                    rn.prototype.copy.call(this, t, !1);
                    for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
                        var r = e[i];
                        this.addLevel(r.object.clone(), r.distance)
                    }
                    return this.autoUpdate = t.autoUpdate, this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0), e = Math.abs(e);
                    for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
                    return i.splice(n, 0, {
                        distance: e,
                        object: t
                    }), this.add(t), this
                },
                getCurrentLevel: function() {
                    return this._currentLevel
                },
                getObjectForDistance: function(t) {
                    var e = this.levels;
                    if (0 < e.length) {
                        for (var i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
                        return e[i - 1].object
                    }
                    return null
                },
                raycast: function(t, e) {
                    var i;
                    0 < this.levels.length && (So.setFromMatrixPosition(this.matrixWorld), i = t.ray.origin.distanceTo(So), this.getObjectForDistance(i).raycast(t, e))
                },
                update: function(t) {
                    var e = this.levels;
                    if (1 < e.length) {
                        So.setFromMatrixPosition(t.matrixWorld), Mo.setFromMatrixPosition(this.matrixWorld);
                        var i, n, r = So.distanceTo(Mo) / t.zoom;
                        for (e[0].object.visible = !0, i = 1, n = e.length; i < n && r >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                        for (this._currentLevel = i - 1; i < n; i++) e[i].object.visible = !1
                    }
                },
                toJSON: function(t) {
                    var e = rn.prototype.toJSON.call(this, t);
                    !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                    for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                        var a = i[n];
                        e.object.levels.push({
                            object: a.object.uuid,
                            distance: a.distance
                        })
                    }
                    return e
                }
            }), Co.prototype = Object.assign(Object.create(gr.prototype), {
                constructor: Co,
                isSkinnedMesh: !0,
                copy: function(t) {
                    return gr.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                },
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    for (var t = new $e, e = this.geometry.attributes.skinWeight, i = 0, n = e.count; i < n; i++) {
                        t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
                        var r = 1 / t.manhattanLength();
                        r != 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                    }
                },
                updateMatrixWorld: function(t) {
                    gr.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode && this.bindMatrixInverse.getInverse(this.bindMatrix)
                },
                boneTransform: (yo = new ni, bo = new $e, xo = new $e, _o = new ni, wo = new Li, function(t, e) {
                    var i = this.skeleton,
                        n = this.geometry;
                    bo.fromBufferAttribute(n.attributes.skinIndex, t), xo.fromBufferAttribute(n.attributes.skinWeight, t), yo.fromBufferAttribute(n.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                    for (var r = 0; r < 4; r++) {
                        var a, s = xo.getComponent(r);
                        0 !== s && (a = bo.getComponent(r), wo.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), e.addScaledVector(_o.copy(yo).applyMatrix4(wo), s))
                    }
                    return e.applyMatrix4(this.bindMatrixInverse)
                })
            });
            var Ao = new Li,
                Eo = new Li;

            function Do(t, e) {
                if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();
                else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
                else {
                    this.boneInverses = [];
                    for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new Li)
                }
            }

            function Po() {
                rn.call(this), this.type = "Bone"
            }
            Object.assign(Do.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var t = 0, e = this.bones.length; t < e; t++) {
                        var i = new Li;
                        this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
                    }
                },
                pose: function() {
                    for (var t = 0, e = this.bones.length; t < e; t++) {
                        var i = this.bones[t];
                        i && i.matrixWorld.getInverse(this.boneInverses[t])
                    }
                    for (var n = 0, r = this.bones.length; n < r; n++) {
                        var a = this.bones[n];
                        a && (a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
                    }
                },
                update: function() {
                    for (var t = this.bones, e = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, a = t.length; r < a; r++) {
                        var s = t[r] ? t[r].matrixWorld : Eo;
                        Ao.multiplyMatrices(s, e[r]), Ao.toArray(i, 16 * r)
                    }
                    void 0 !== n && (n.needsUpdate = !0)
                },
                clone: function() {
                    return new Do(this.bones, this.boneInverses)
                },
                getBoneByName: function(t) {
                    for (var e = 0, i = this.bones.length; e < i; e++) {
                        var n = this.bones[e];
                        if (n.name === t) return n
                    }
                },
                dispose: function() {
                    this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0)
                }
            }), Po.prototype = Object.assign(Object.create(rn.prototype), {
                constructor: Po,
                isBone: !0
            });
            var Lo = new Li,
                ko = new Li,
                Oo = [],
                Fo = new gr;

            function Io(t, e, i) {
                gr.call(this, t, e), this.instanceMatrix = new On(new Float32Array(16 * i), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1
            }

            function No(t) {
                Dn.call(this), this.type = "LineBasicMaterial", this.color = new Cn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
            }
            Io.prototype = Object.assign(Object.create(gr.prototype), {
                constructor: Io,
                isInstancedMesh: !0,
                copy: function(t) {
                    return gr.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this
                },
                setColorAt: function(t, e) {
                    null === this.instanceColor && (this.instanceColor = new On(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                },
                getMatrixAt: function(t, e) {
                    e.fromArray(this.instanceMatrix.array, 16 * t)
                },
                raycast: function(t, e) {
                    var i = this.matrixWorld,
                        n = this.count;
                    if (Fo.geometry = this.geometry, Fo.material = this.material, void 0 !== Fo.material)
                        for (var r = 0; r < n; r++) {
                            this.getMatrixAt(r, Lo), ko.multiplyMatrices(i, Lo), Fo.matrixWorld = ko, Fo.raycast(t, Oo);
                            for (var a = 0, s = Oo.length; a < s; a++) {
                                var o = Oo[a];
                                o.instanceId = r, o.object = this, e.push(o)
                            }
                            Oo.length = 0
                        }
                },
                setMatrixAt: function(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t)
                },
                updateMorphTargets: function() {}
            }), ((No.prototype = Object.create(Dn.prototype)).constructor = No).prototype.isLineBasicMaterial = !0, No.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
            };
            var Bo = new ni,
                Ro = new ni,
                zo = new Li,
                Go = new Si,
                Vo = new li;

            function Uo(t, e, i) {
                rn.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Kn, this.material = void 0 !== e ? e : new No, this.updateMorphTargets()
            }
            Uo.prototype = Object.assign(Object.create(rn.prototype), {
                constructor: Uo,
                isLine: !0,
                copy: function(t) {
                    return rn.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
                },
                computeLineDistances: function() {
                    var t = this.geometry;
                    if (t.isBufferGeometry) {
                        if (null === t.index) {
                            for (var e = t.attributes.position, i = [0], n = 1, r = e.count; n < r; n++) Bo.fromBufferAttribute(e, n - 1), Ro.fromBufferAttribute(e, n), i[n] = i[n - 1], i[n] += Bo.distanceTo(Ro);
                            t.setAttribute("lineDistance", new Vn(i, 1))
                        }
                    } else if (t.isGeometry) {
                        var a = t.vertices,
                            s = t.lineDistances;
                        s[0] = 0;
                        for (var o = 1, l = a.length; o < l; o++) s[o] = s[o - 1], s[o] += a[o - 1].distanceTo(a[o])
                    }
                    return this
                },
                raycast: function(t, e) {
                    var i = this.geometry,
                        n = this.matrixWorld,
                        r = t.params.Line.threshold;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), Vo.copy(i.boundingSphere), Vo.applyMatrix4(n), Vo.radius += r, !1 !== t.ray.intersectsSphere(Vo)) {
                        zo.getInverse(n), Go.copy(t.ray).applyMatrix4(zo);
                        var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            s = a * a,
                            o = new ni,
                            l = new ni,
                            h = new ni,
                            u = new ni,
                            c = this && this.isLineSegments ? 2 : 1;
                        if (i.isBufferGeometry) {
                            var p = i.index,
                                d = i.attributes.position.array;
                            if (null !== p)
                                for (var f = p.array, m = 0, g = f.length - 1; m < g; m += c) {
                                    var v, y = f[m],
                                        b = f[m + 1];
                                    o.fromArray(d, 3 * y), l.fromArray(d, 3 * b), s < Go.distanceSqToSegment(o, l, u, h) || (u.applyMatrix4(this.matrixWorld), (v = t.ray.origin.distanceTo(u)) < t.near || v > t.far || e.push({
                                        distance: v,
                                        point: h.clone().applyMatrix4(this.matrixWorld),
                                        index: m,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                                } else
                                    for (var x, _ = 0, w = d.length / 3 - 1; _ < w; _ += c) {
                                        o.fromArray(d, 3 * _), l.fromArray(d, 3 * _ + 3), s < Go.distanceSqToSegment(o, l, u, h) || (u.applyMatrix4(this.matrixWorld), (x = t.ray.origin.distanceTo(u)) < t.near || x > t.far || e.push({
                                            distance: x,
                                            point: h.clone().applyMatrix4(this.matrixWorld),
                                            index: _,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        }))
                                    }
                        } else if (i.isGeometry)
                            for (var S, M = i.vertices, T = M.length, C = 0; C < T - 1; C += c) {
                                s < Go.distanceSqToSegment(M[C], M[C + 1], u, h) || (u.applyMatrix4(this.matrixWorld), (S = t.ray.origin.distanceTo(u)) < t.near || S > t.far || e.push({
                                    distance: S,
                                    point: h.clone().applyMatrix4(this.matrixWorld),
                                    index: C,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                    }
                },
                updateMorphTargets: function() {
                    var t = this.geometry;
                    if (t.isBufferGeometry) {
                        var e = t.morphAttributes,
                            i = Object.keys(e);
                        if (0 < i.length) {
                            var n = e[i[0]];
                            if (void 0 !== n) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (var r = 0, a = n.length; r < a; r++) {
                                    var s = n[r].name || String(r);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = r
                                }
                            }
                        }
                    } else {
                        var o = t.morphTargets;
                        void 0 !== o && o.length
                    }
                }
            });
            var jo = new ni,
                Ho = new ni;

            function Wo(t, e) {
                Uo.call(this, t, e), this.type = "LineSegments"
            }

            function qo(t, e) {
                Uo.call(this, t, e), this.type = "LineLoop"
            }

            function Xo(t) {
                Dn.call(this), this.type = "PointsMaterial", this.color = new Cn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
            }
            Wo.prototype = Object.assign(Object.create(Uo.prototype), {
                constructor: Wo,
                isLineSegments: !0,
                computeLineDistances: function() {
                    var t = this.geometry;
                    if (t.isBufferGeometry) {
                        if (null === t.index) {
                            for (var e = t.attributes.position, i = [], n = 0, r = e.count; n < r; n += 2) jo.fromBufferAttribute(e, n), Ho.fromBufferAttribute(e, n + 1), i[n] = 0 === n ? 0 : i[n - 1], i[n + 1] = i[n] + jo.distanceTo(Ho);
                            t.setAttribute("lineDistance", new Vn(i, 1))
                        }
                    } else if (t.isGeometry)
                        for (var a = t.vertices, s = t.lineDistances, o = 0, l = a.length; o < l; o += 2) jo.copy(a[o]), Ho.copy(a[o + 1]), s[o] = 0 === o ? 0 : s[o - 1], s[o + 1] = s[o] + jo.distanceTo(Ho);
                    return this
                }
            }), qo.prototype = Object.assign(Object.create(Uo.prototype), {
                constructor: qo,
                isLineLoop: !0
            }), ((Xo.prototype = Object.create(Dn.prototype)).constructor = Xo).prototype.isPointsMaterial = !0, Xo.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
            };
            var Yo = new Li,
                Jo = new Si,
                Zo = new li,
                $o = new ni;

            function Ko(t, e) {
                rn.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Kn, this.material = void 0 !== e ? e : new Xo, this.updateMorphTargets()
            }

            function Qo(t, e, i, n, r, a, s) {
                var o = Jo.distanceSqToPoint(t);
                if (o < i) {
                    var l = new ni;
                    Jo.closestPointToPoint(t, l), l.applyMatrix4(n);
                    var h = r.ray.origin.distanceTo(l);
                    if (h < r.near || h > r.far) return;
                    a.push({
                        distance: h,
                        distanceToRay: Math.sqrt(o),
                        point: l,
                        index: e,
                        face: null,
                        object: s
                    })
                }
            }

            function tl(e, t, i, n, r, a, s, o, l) {
                Ze.call(this, e, t, i, n, r, a, s, o, l), this.format = void 0 !== s ? s : Xt, this.minFilter = void 0 !== a ? a : Rt, this.magFilter = void 0 !== r ? r : Rt, this.generateMipmaps = !1;
                var h = this;
                "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() {
                    h.needsUpdate = !0, e.requestVideoFrameCallback(t)
                })
            }

            function el(t, e, i, n, r, a, s, o, l, h, u, c) {
                Ze.call(this, null, a, s, o, l, h, n, r, u, c), this.image = {
                    width: e,
                    height: i
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }

            function il(t, e, i, n, r, a, s, o, l) {
                Ze.call(this, t, e, i, n, r, a, s, o, l), this.needsUpdate = !0
            }

            function nl(t, e, i, n, r, a, s, o, l, h) {
                if ((h = void 0 !== h ? h : Jt) !== Jt && h !== Zt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === i && h === Jt && (i = Ut), void 0 === i && h === Zt && (i = qt), Ze.call(this, null, n, r, a, s, o, h, i, l), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== s ? s : It, this.minFilter = void 0 !== o ? o : It, this.flipY = !1, this.generateMipmaps = !1
            }

            function rl(t) {
                Kn.call(this), this.type = "WireframeGeometry";
                var e = [],
                    i = [0, 0],
                    n = {},
                    r = ["a", "b", "c"];
                if (t && t.isGeometry) {
                    for (var a = t.faces, s = 0, o = a.length; s < o; s++)
                        for (var l = a[s], h = 0; h < 3; h++) {
                            var u = l[r[h]],
                                c = l[r[(h + 1) % 3]];
                            i[0] = Math.min(u, c), i[1] = Math.max(u, c);
                            var p = i[0] + "," + i[1];
                            void 0 === n[p] && (n[p] = {
                                index1: i[0],
                                index2: i[1]
                            })
                        }
                    for (var d in n) {
                        var f = n[d],
                            m = t.vertices[f.index1];
                        e.push(m.x, m.y, m.z), m = t.vertices[f.index2], e.push(m.x, m.y, m.z)
                    }
                } else if (t && t.isBufferGeometry) {
                    var g = new ni;
                    if (null !== t.index) {
                        var v = t.attributes.position,
                            y = t.index,
                            b = t.groups;
                        0 === b.length && (b = [{
                            start: 0,
                            count: y.count,
                            materialIndex: 0
                        }]);
                        for (var x = 0, _ = b.length; x < _; ++x)
                            for (var w = b[x], S = w.start, M = S, T = S + w.count; M < T; M += 3)
                                for (var C = 0; C < 3; C++) {
                                    var A = y.getX(M + C),
                                        E = y.getX(M + (C + 1) % 3);
                                    i[0] = Math.min(A, E), i[1] = Math.max(A, E);
                                    var D = i[0] + "," + i[1];
                                    void 0 === n[D] && (n[D] = {
                                        index1: i[0],
                                        index2: i[1]
                                    })
                                }
                        for (var P in n) {
                            var L = n[P];
                            g.fromBufferAttribute(v, L.index1), e.push(g.x, g.y, g.z), g.fromBufferAttribute(v, L.index2), e.push(g.x, g.y, g.z)
                        }
                    } else
                        for (var k = t.attributes.position, O = 0, F = k.count / 3; O < F; O++)
                            for (var I = 0; I < 3; I++) {
                                var N = 3 * O + I;
                                g.fromBufferAttribute(k, N), e.push(g.x, g.y, g.z);
                                var B = 3 * O + (I + 1) % 3;
                                g.fromBufferAttribute(k, B), e.push(g.x, g.y, g.z)
                            }
                }
                this.setAttribute("position", new Vn(e, 3))
            }

            function al(t, e, i) {
                Sr.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: i
                }, this.fromBufferGeometry(new sl(t, e, i)), this.mergeVertices()
            }

            function sl(t, e, i) {
                Kn.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: i
                };
                var n = [],
                    r = [],
                    a = [],
                    s = [],
                    o = new ni,
                    l = new ni,
                    h = new ni,
                    u = new ni,
                    c = new ni;
                t.length;
                for (var p = e + 1, d = 0; d <= i; d++)
                    for (var f = d / i, m = 0; m <= e; m++) {
                        var g = m / e;
                        t(g, f, l), r.push(l.x, l.y, l.z), 0 <= g - 1e-5 ? (t(g - 1e-5, f, h), u.subVectors(l, h)) : (t(1e-5 + g, f, h), u.subVectors(h, l)), 0 <= f - 1e-5 ? (t(g, f - 1e-5, h), c.subVectors(l, h)) : (t(g, 1e-5 + f, h), c.subVectors(h, l)), o.crossVectors(u, c).normalize(), a.push(o.x, o.y, o.z), s.push(g, f)
                    }
                for (var v = 0; v < i; v++)
                    for (var y = 0; y < e; y++) {
                        var b = v * p + y,
                            x = v * p + y + 1,
                            _ = (v + 1) * p + y + 1,
                            w = (v + 1) * p + y;
                        n.push(b, x, w), n.push(x, _, w)
                    }
                this.setIndex(n), this.setAttribute("position", new Vn(r, 3)), this.setAttribute("normal", new Vn(a, 3)), this.setAttribute("uv", new Vn(s, 2))
            }

            function ol(t, e, i, n) {
                Sr.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: i,
                    detail: n
                }, this.fromBufferGeometry(new ll(t, e, i, n)), this.mergeVertices()
            }

            function ll(n, a, t, e) {
                Kn.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: n,
                    indices: a,
                    radius: t,
                    detail: e
                }, t = t || 1;
                var u = [],
                    c = [];

                function f(t) {
                    u.push(t.x, t.y, t.z)
                }

                function s(t, e) {
                    var i = 3 * t;
                    e.x = n[0 + i], e.y = n[1 + i], e.z = n[2 + i]
                }

                function p(t, e, i, n) {
                    n < 0 && 1 === t.x && (c[e] = t.x - 1), 0 === i.x && 0 === i.z && (c[e] = n / 2 / Math.PI + .5)
                }

                function d(t) {
                    return Math.atan2(t.z, -t.x)
                }! function(t) {
                    for (var e = new ni, i = new ni, n = new ni, r = 0; r < a.length; r += 3) s(a[r + 0], e), s(a[r + 1], i), s(a[r + 2], n),
                        function(t, e, i, n) {
                            for (var r = Math.pow(2, n), a = [], s = 0; s <= r; s++) {
                                a[s] = [];
                                for (var o = t.clone().lerp(i, s / r), l = e.clone().lerp(i, s / r), h = r - s, u = 0; u <= h; u++) a[s][u] = 0 === u && s === r ? o : o.clone().lerp(l, u / h)
                            }
                            for (var c = 0; c < r; c++)
                                for (var p = 0; p < 2 * (r - c) - 1; p++) {
                                    var d = Math.floor(p / 2);
                                    p % 2 == 0 ? (f(a[c][d + 1]), f(a[c + 1][d]), f(a[c][d])) : (f(a[c][d + 1]), f(a[c + 1][d + 1]), f(a[c + 1][d]))
                                }
                        }(e, i, n, t)
                }(e = e || 0),
                function(t) {
                    for (var e = new ni, i = 0; i < u.length; i += 3) e.x = u[i + 0], e.y = u[i + 1], e.z = u[i + 2], e.normalize().multiplyScalar(t), u[i + 0] = e.x, u[i + 1] = e.y, u[i + 2] = e.z
                }(t),
                function() {
                    for (var t = new ni, e = 0; e < u.length; e += 3) {
                        t.x = u[e + 0], t.y = u[e + 1], t.z = u[e + 2];
                        var i = d(t) / 2 / Math.PI + .5,
                            n = function(t) {
                                return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
                            }(t) / Math.PI + .5;
                        c.push(i, 1 - n)
                    }(function() {
                        for (var t = new ni, e = new ni, i = new ni, n = new ni, r = new He, a = new He, s = new He, o = 0, l = 0; o < u.length; o += 9, l += 6) {
                            t.set(u[o + 0], u[o + 1], u[o + 2]), e.set(u[o + 3], u[o + 4], u[o + 5]), i.set(u[o + 6], u[o + 7], u[o + 8]), r.set(c[l + 0], c[l + 1]), a.set(c[l + 2], c[l + 3]), s.set(c[l + 4], c[l + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                            var h = d(n);
                            p(r, l + 0, t, h), p(a, l + 2, e, h), p(s, l + 4, i, h)
                        }
                    })(),
                    function() {
                        for (var t = 0; t < c.length; t += 6) {
                            var e = c[t + 0],
                                i = c[t + 2],
                                n = c[t + 4],
                                r = Math.max(e, i, n),
                                a = Math.min(e, i, n);
                            .9 < r && a < .1 && (e < .2 && (c[t + 0] += 1), i < .2 && (c[t + 2] += 1), n < .2 && (c[t + 4] += 1))
                        }
                    }()
                }(), this.setAttribute("position", new Vn(u, 3)), this.setAttribute("normal", new Vn(u.slice(), 3)), this.setAttribute("uv", new Vn(c, 2)), 0 === e ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function hl(t, e) {
                Sr.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new ul(t, e)), this.mergeVertices()
            }

            function ul(t, e) {
                ll.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function cl(t, e) {
                Sr.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new pl(t, e)), this.mergeVertices()
            }

            function pl(t, e) {
                ll.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function dl(t, e) {
                Sr.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new fl(t, e)), this.mergeVertices()
            }

            function fl(t, e) {
                var i = (1 + Math.sqrt(5)) / 2;
                ll.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function ml(t, e) {
                Sr.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new gl(t, e)), this.mergeVertices()
            }

            function gl(t, e) {
                var i = (1 + Math.sqrt(5)) / 2,
                    n = 1 / i;
                ll.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function vl(t, e, i, n, r, a) {
                Sr.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: i,
                    radialSegments: n,
                    closed: r
                };
                var s = new yl(t, e, i, n, r);
                this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals, this.fromBufferGeometry(s), this.mergeVertices()
            }

            function yl(o, l, h, u, e) {
                Kn.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: o,
                    tubularSegments: l,
                    radius: h,
                    radialSegments: u,
                    closed: e
                }, l = l || 64, h = h || 1, u = u || 8, e = e || !1;
                var c = o.computeFrenetFrames(l, e);
                this.tangents = c.tangents, this.normals = c.normals, this.binormals = c.binormals;
                var p = new ni,
                    d = new ni,
                    i = new He,
                    f = new ni,
                    m = [],
                    g = [],
                    n = [],
                    s = [];

                function r(t) {
                    f = o.getPointAt(t / l, f);
                    for (var e = c.normals[t], i = c.binormals[t], n = 0; n <= u; n++) {
                        var r = n / u * Math.PI * 2,
                            a = Math.sin(r),
                            s = -Math.cos(r);
                        d.x = s * e.x + a * i.x, d.y = s * e.y + a * i.y, d.z = s * e.z + a * i.z, d.normalize(), g.push(d.x, d.y, d.z), p.x = f.x + h * d.x, p.y = f.y + h * d.y, p.z = f.z + h * d.z, m.push(p.x, p.y, p.z)
                    }
                }! function() {
                    for (var t = 0; t < l; t++) r(t);
                    r(!1 === e ? l : 0),
                        function() {
                            for (var t = 0; t <= l; t++)
                                for (var e = 0; e <= u; e++) i.x = t / l, i.y = e / u, n.push(i.x, i.y)
                        }(),
                        function() {
                            for (var t = 1; t <= l; t++)
                                for (var e = 1; e <= u; e++) {
                                    var i = (u + 1) * (t - 1) + (e - 1),
                                        n = (u + 1) * t + (e - 1),
                                        r = (u + 1) * t + e,
                                        a = (u + 1) * (t - 1) + e;
                                    s.push(i, n, a), s.push(n, r, a)
                                }
                        }()
                }(), this.setIndex(s), this.setAttribute("position", new Vn(m, 3)), this.setAttribute("normal", new Vn(g, 3)), this.setAttribute("uv", new Vn(n, 2))
            }

            function bl(t, e, i, n, r, a, s) {
                Sr.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: i,
                    radialSegments: n,
                    p: r,
                    q: a
                }, this.fromBufferGeometry(new xl(t, e, i, n, r, a)), this.mergeVertices()
            }

            function xl(t, e, i, n, r, a) {
                Kn.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: i,
                    radialSegments: n,
                    p: r,
                    q: a
                }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, a = a || 3;
                for (var s = [], o = [], l = [], h = [], u = new ni, c = new ni, p = new ni, d = new ni, f = new ni, m = new ni, g = new ni, v = 0; v <= i; ++v) {
                    var y = v / i * r * Math.PI * 2;
                    D(y, r, a, t, p), D(.01 + y, r, a, t, d), m.subVectors(d, p), g.addVectors(d, p), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize();
                    for (var b = 0; b <= n; ++b) {
                        var x = b / n * Math.PI * 2,
                            _ = -e * Math.cos(x),
                            w = e * Math.sin(x);
                        u.x = p.x + (_ * g.x + w * f.x), u.y = p.y + (_ * g.y + w * f.y), u.z = p.z + (_ * g.z + w * f.z), o.push(u.x, u.y, u.z), c.subVectors(u, p).normalize(), l.push(c.x, c.y, c.z), h.push(v / i), h.push(b / n)
                    }
                }
                for (var S = 1; S <= i; S++)
                    for (var M = 1; M <= n; M++) {
                        var T = (n + 1) * (S - 1) + (M - 1),
                            C = (n + 1) * S + (M - 1),
                            A = (n + 1) * S + M,
                            E = (n + 1) * (S - 1) + M;
                        s.push(T, C, E), s.push(C, A, E)
                    }

                function D(t, e, i, n, r) {
                    var a = Math.cos(t),
                        s = Math.sin(t),
                        o = i / e * t,
                        l = Math.cos(o);
                    r.x = n * (2 + l) * .5 * a, r.y = n * (2 + l) * s * .5, r.z = n * Math.sin(o) * .5
                }
                this.setIndex(s), this.setAttribute("position", new Vn(o, 3)), this.setAttribute("normal", new Vn(l, 3)), this.setAttribute("uv", new Vn(h, 2))
            }

            function _l(t, e, i, n, r) {
                Sr.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: i,
                    tubularSegments: n,
                    arc: r
                }, this.fromBufferGeometry(new wl(t, e, i, n, r)), this.mergeVertices()
            }

            function wl(t, e, i, n, r) {
                Kn.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: i,
                    tubularSegments: n,
                    arc: r
                }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
                for (var a = [], s = [], o = [], l = [], h = new ni, u = new ni, c = new ni, p = 0; p <= i; p++)
                    for (var d = 0; d <= n; d++) {
                        var f = d / n * r,
                            m = p / i * Math.PI * 2;
                        u.x = (t + e * Math.cos(m)) * Math.cos(f), u.y = (t + e * Math.cos(m)) * Math.sin(f), u.z = e * Math.sin(m), s.push(u.x, u.y, u.z), h.x = t * Math.cos(f), h.y = t * Math.sin(f), c.subVectors(u, h).normalize(), o.push(c.x, c.y, c.z), l.push(d / n), l.push(p / i)
                    }
                for (var g = 1; g <= i; g++)
                    for (var v = 1; v <= n; v++) {
                        var y = (n + 1) * g + v - 1,
                            b = (n + 1) * (g - 1) + v - 1,
                            x = (n + 1) * (g - 1) + v,
                            _ = (n + 1) * g + v;
                        a.push(y, b, _), a.push(b, x, _)
                    }
                this.setIndex(a), this.setAttribute("position", new Vn(s, 3)), this.setAttribute("normal", new Vn(o, 3)), this.setAttribute("uv", new Vn(l, 2))
            }
            Ko.prototype = Object.assign(Object.create(rn.prototype), {
                constructor: Ko,
                isPoints: !0,
                copy: function(t) {
                    return rn.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
                },
                raycast: function(t, e) {
                    var i = this.geometry,
                        n = this.matrixWorld,
                        r = t.params.Points.threshold;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), Zo.copy(i.boundingSphere), Zo.applyMatrix4(n), Zo.radius += r, !1 !== t.ray.intersectsSphere(Zo)) {
                        Yo.getInverse(n), Jo.copy(t.ray).applyMatrix4(Yo);
                        var a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            s = a * a;
                        if (i.isBufferGeometry) {
                            var o = i.index,
                                l = i.attributes.position.array;
                            if (null !== o)
                                for (var h = o.array, u = 0, c = h.length; u < c; u++) {
                                    var p = h[u];
                                    $o.fromArray(l, 3 * p), Qo($o, p, s, n, t, e, this)
                                } else
                                    for (var d = 0, f = l.length / 3; d < f; d++) $o.fromArray(l, 3 * d), Qo($o, d, s, n, t, e, this)
                        } else
                            for (var m = i.vertices, g = 0, v = m.length; g < v; g++) Qo(m[g], g, s, n, t, e, this)
                    }
                },
                updateMorphTargets: function() {
                    var t = this.geometry;
                    if (t.isBufferGeometry) {
                        var e = t.morphAttributes,
                            i = Object.keys(e);
                        if (0 < i.length) {
                            var n = e[i[0]];
                            if (void 0 !== n) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (var r = 0, a = n.length; r < a; r++) {
                                    var s = n[r].name || String(r);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = r
                                }
                            }
                        }
                    } else {
                        var o = t.morphTargets;
                        void 0 !== o && o.length
                    }
                }
            }), tl.prototype = Object.assign(Object.create(Ze.prototype), {
                constructor: tl,
                isVideoTexture: !0,
                update: function() {
                    var t = this.image;
                    !1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), ((el.prototype = Object.create(Ze.prototype)).constructor = el).prototype.isCompressedTexture = !0, ((il.prototype = Object.create(Ze.prototype)).constructor = il).prototype.isCanvasTexture = !0, ((nl.prototype = Object.create(Ze.prototype)).constructor = nl).prototype.isDepthTexture = !0, (rl.prototype = Object.create(Kn.prototype)).constructor = rl, (al.prototype = Object.create(Sr.prototype)).constructor = al, (sl.prototype = Object.create(Kn.prototype)).constructor = sl, (ol.prototype = Object.create(Sr.prototype)).constructor = ol, (ll.prototype = Object.create(Kn.prototype)).constructor = ll, (hl.prototype = Object.create(Sr.prototype)).constructor = hl, (ul.prototype = Object.create(ll.prototype)).constructor = ul, (cl.prototype = Object.create(Sr.prototype)).constructor = cl, (pl.prototype = Object.create(ll.prototype)).constructor = pl, (dl.prototype = Object.create(Sr.prototype)).constructor = dl, (fl.prototype = Object.create(ll.prototype)).constructor = fl, (ml.prototype = Object.create(Sr.prototype)).constructor = ml, (gl.prototype = Object.create(ll.prototype)).constructor = gl, (vl.prototype = Object.create(Sr.prototype)).constructor = vl, ((yl.prototype = Object.create(Kn.prototype)).constructor = yl).prototype.toJSON = function() {
                var t = Kn.prototype.toJSON.call(this);
                return t.path = this.parameters.path.toJSON(), t
            }, (bl.prototype = Object.create(Sr.prototype)).constructor = bl, (xl.prototype = Object.create(Kn.prototype)).constructor = xl, (_l.prototype = Object.create(Sr.prototype)).constructor = _l, (wl.prototype = Object.create(Kn.prototype)).constructor = wl;
            var Sl = function(t, e, i) {
                i = i || 2;
                var n, r, a, s, o, l, h, u = e && e.length,
                    c = u ? e[0] * i : t.length,
                    p = Ml(t, 0, c, i, !0),
                    d = [];
                if (!p || p.next === p.prev) return d;
                if (u && (p = function(t, e, i, n) {
                        var r, a, s, o, l, h = [];
                        for (r = 0, a = e.length; r < a; r++) s = e[r] * n, o = r < a - 1 ? e[r + 1] * n : t.length, (l = Ml(t, s, o, n, !1)) === l.next && (l.steiner = !0), h.push(function(t) {
                            var e = t,
                                i = t;
                            for (;
                                (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next, e !== t;);
                            return i
                        }(l));
                        for (h.sort(Al), r = 0; r < h.length; r++) ! function(t, e) {
                            {
                                var i;
                                (e = function(t, e) {
                                    var i, n = e,
                                        r = t.x,
                                        a = t.y,
                                        s = -1 / 0;
                                    do {
                                        if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
                                            var o = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                            if (o <= r && s < o) {
                                                if ((s = o) === r) {
                                                    if (a === n.y) return n;
                                                    if (a === n.next.y) return n.next
                                                }
                                                i = n.x < n.next.x ? n : n.next
                                            }
                                        }
                                        n = n.next
                                    } while (n !== e);
                                    if (!i) return null;
                                    if (r === s) return i;
                                    var l, h = i,
                                        u = i.x,
                                        c = i.y,
                                        p = 1 / 0;
                                    n = i;
                                    for (; r >= n.x && n.x >= u && r !== n.x && Dl(a < c ? r : s, a, u, c, a < c ? s : r, a, n.x, n.y) && (l = Math.abs(a - n.y) / (r - n.x), Il(n, t) && (l < p || l === p && (n.x > i.x || n.x === i.x && function(t, e) {
                                            return Pl(t.prev, t, e.prev) < 0 && Pl(e.next, t, t.next) < 0
                                        }(i, n))) && (i = n, p = l)), n = n.next, n !== h;);
                                    return i
                                }(t, e)) && (i = Nl(e, t), Tl(e, e.next), Tl(i, i.next))
                            }
                        }(h[r], i), i = Tl(i, i.next);
                        return i
                    }(t, e, p, i)), t.length > 80 * i) {
                    n = a = t[0], r = s = t[1];
                    for (var f = i; f < c; f += i)(o = t[f]) < n && (n = o), (l = t[f + 1]) < r && (r = l), a < o && (a = o), s < l && (s = l);
                    h = 0 !== (h = Math.max(a - n, s - r)) ? 1 / h : 0
                }
                return Cl(p, d, i, n, r, h), d
            };

            function Ml(t, e, i, n, r) {
                var a, s;
                if (r === 0 < function(t, e, i, n) {
                        for (var r = 0, a = e, s = i - n; a < i; a += n) r += (t[s] - t[a]) * (t[a + 1] + t[s + 1]), s = a;
                        return r
                    }(t, e, i, n))
                    for (a = e; a < i; a += n) s = Bl(a, t[a], t[a + 1], s);
                else
                    for (a = i - n; e <= a; a -= n) s = Bl(a, t[a], t[a + 1], s);
                return s && Ll(s, s.next) && (Rl(s), s = s.next), s
            }

            function Tl(t, e) {
                if (!t) return t;
                e = e || t;
                var i, n = t;
                do {
                    if (i = !1, n.steiner || !Ll(n, n.next) && 0 !== Pl(n.prev, n, n.next)) n = n.next;
                    else {
                        if (Rl(n), (n = e = n.prev) === n.next) break;
                        i = !0
                    }
                } while (i || n !== e);
                return e
            }

            function Cl(t, e, i, n, r, a, s) {
                if (t) {
                    !s && a && function(t, e, i, n) {
                        var r = t;
                        for (; null === r.z && (r.z = El(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next, r !== t;);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                var e, i, n, r, a, s, o, l, h = 1;
                                do {
                                    for (i = t, a = t = null, s = 0; i;) {
                                        for (s++, n = i, e = o = 0; e < h && (o++, n = n.nextZ); e++);
                                        for (l = h; 0 < o || 0 < l && n;) 0 !== o && (0 === l || !n || i.z <= n.z) ? (i = (r = i).nextZ, o--) : (n = (r = n).nextZ, l--), a ? a.nextZ = r : t = r, r.prevZ = a, a = r;
                                        i = n
                                    }
                                    a.nextZ = null, h *= 2
                                } while (1 < s)
                            }(r)
                    }(t, n, r, a);
                    for (var o, l, h = t; t.prev !== t.next;)
                        if (o = t.prev, l = t.next, a ? function(t, e, i, n) {
                                var r = t.prev,
                                    a = t,
                                    s = t.next;
                                if (0 <= Pl(r, a, s)) return !1;
                                var o = r.x < a.x ? r.x < s.x ? r.x : s.x : a.x < s.x ? a.x : s.x,
                                    l = r.y < a.y ? r.y < s.y ? r.y : s.y : a.y < s.y ? a.y : s.y,
                                    h = r.x > a.x ? r.x > s.x ? r.x : s.x : a.x > s.x ? a.x : s.x,
                                    u = r.y > a.y ? r.y > s.y ? r.y : s.y : a.y > s.y ? a.y : s.y,
                                    c = El(o, l, e, i, n),
                                    p = El(h, u, e, i, n),
                                    d = t.prevZ,
                                    f = t.nextZ;
                                for (; d && d.z >= c && f && f.z <= p;) {
                                    if (d !== t.prev && d !== t.next && Dl(r.x, r.y, a.x, a.y, s.x, s.y, d.x, d.y) && 0 <= Pl(d.prev, d, d.next)) return !1;
                                    if (d = d.prevZ, f !== t.prev && f !== t.next && Dl(r.x, r.y, a.x, a.y, s.x, s.y, f.x, f.y) && 0 <= Pl(f.prev, f, f.next)) return !1;
                                    f = f.nextZ
                                }
                                for (; d && d.z >= c;) {
                                    if (d !== t.prev && d !== t.next && Dl(r.x, r.y, a.x, a.y, s.x, s.y, d.x, d.y) && 0 <= Pl(d.prev, d, d.next)) return !1;
                                    d = d.prevZ
                                }
                                for (; f && f.z <= p;) {
                                    if (f !== t.prev && f !== t.next && Dl(r.x, r.y, a.x, a.y, s.x, s.y, f.x, f.y) && 0 <= Pl(f.prev, f, f.next)) return !1;
                                    f = f.nextZ
                                }
                                return !0
                            }(t, n, r, a) : function(t) {
                                var e = t.prev,
                                    i = t,
                                    n = t.next;
                                if (0 <= Pl(e, i, n)) return !1;
                                var r = t.next.next;
                                for (; r !== t.prev;) {
                                    if (Dl(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && 0 <= Pl(r.prev, r, r.next)) return !1;
                                    r = r.next
                                }
                                return !0
                            }(t)) e.push(o.i / i), e.push(t.i / i), e.push(l.i / i), Rl(t), t = l.next, h = l.next;
                        else if ((t = l) === h) {
                        s ? 1 === s ? Cl(t = function(t, e, i) {
                            var n = t;
                            do {
                                var r = n.prev,
                                    a = n.next.next;
                                !Ll(r, a) && kl(r, n, n.next, a) && Il(r, a) && Il(a, r) && (e.push(r.i / i), e.push(n.i / i), e.push(a.i / i), Rl(n), Rl(n.next), n = t = a), n = n.next
                            } while (n !== t);
                            return Tl(n)
                        }(Tl(t), e, i), e, i, n, r, a, 2) : 2 === s && function(t, e, i, n, r, a) {
                            var s = t;
                            do {
                                for (var o = s.next.next; o !== s.prev;) {
                                    if (s.i !== o.i && function(t, e) {
                                            return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                                                var i = t;
                                                do {
                                                    if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && kl(i, i.next, t, e)) return !0;
                                                    i = i.next
                                                } while (i !== t);
                                                return !1
                                            }(t, e) && (Il(t, e) && Il(e, t) && function(t, e) {
                                                var i = t,
                                                    n = !1,
                                                    r = (t.x + e.x) / 2,
                                                    a = (t.y + e.y) / 2;
                                                for (; i.y > a != i.next.y > a && i.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next, i !== t;);
                                                return n
                                            }(t, e) && (Pl(t.prev, t, e.prev) || Pl(t, e.prev, e)) || Ll(t, e) && 0 < Pl(t.prev, t, t.next) && 0 < Pl(e.prev, e, e.next))
                                        }(s, o)) {
                                        var l = Nl(s, o);
                                        return s = Tl(s, s.next), l = Tl(l, l.next), Cl(s, e, i, n, r, a), Cl(l, e, i, n, r, a)
                                    }
                                    o = o.next
                                }
                                s = s.next
                            } while (s !== t)
                        }(t, e, i, n, r, a) : Cl(Tl(t), e, i, n, r, a, 1);
                        break
                    }
                }
            }

            function Al(t, e) {
                return t.x - e.x
            }

            function El(t, e, i, n, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function Dl(t, e, i, n, r, a, s, o) {
                return 0 <= (r - s) * (e - o) - (t - s) * (a - o) && 0 <= (t - s) * (n - o) - (i - s) * (e - o) && 0 <= (i - s) * (a - o) - (r - s) * (n - o)
            }

            function Pl(t, e, i) {
                return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
            }

            function Ll(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function kl(t, e, i, n) {
                var r = Fl(Pl(t, e, i)),
                    a = Fl(Pl(t, e, n)),
                    s = Fl(Pl(i, n, t)),
                    o = Fl(Pl(i, n, e));
                return r !== a && s !== o || (0 === r && Ol(t, i, e) || (0 === a && Ol(t, n, e) || (0 === s && Ol(i, t, n) || !(0 !== o || !Ol(i, e, n)))))
            }

            function Ol(t, e, i) {
                return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
            }

            function Fl(t) {
                return 0 < t ? 1 : t < 0 ? -1 : 0
            }

            function Il(t, e) {
                return Pl(t.prev, t, t.next) < 0 ? 0 <= Pl(t, e, t.next) && 0 <= Pl(t, t.prev, e) : Pl(t, e, t.prev) < 0 || Pl(t, t.next, e) < 0
            }

            function Nl(t, e) {
                var i = new zl(t.i, t.x, t.y),
                    n = new zl(e.i, e.x, e.y),
                    r = t.next,
                    a = e.prev;
                return (t.next = e).prev = t, (i.next = r).prev = i, (n.next = i).prev = n, (a.next = n).prev = a, n
            }

            function Bl(t, e, i, n) {
                var r = new zl(t, e, i);
                return n ? (r.next = n.next, (r.prev = n).next.prev = r, n.next = r) : (r.prev = r).next = r, r
            }

            function Rl(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function zl(t, e, i) {
                this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var Gl = {
                area: function(t) {
                    for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                    return .5 * i
                },
                isClockWise: function(t) {
                    return Gl.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    var i = [],
                        n = [],
                        r = [];
                    Vl(t), Ul(i, t);
                    var a = t.length;
                    e.forEach(Vl);
                    for (var s = 0; s < e.length; s++) n.push(a), a += e[s].length, Ul(i, e[s]);
                    for (var o = Sl(i, n), l = 0; l < o.length; l += 3) r.push(o.slice(l, l + 3));
                    return r
                }
            };

            function Vl(t) {
                var e = t.length;
                2 < e && t[e - 1].equals(t[0]) && t.pop()
            }

            function Ul(t, e) {
                for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
            }

            function jl(t, e) {
                Sr.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, this.fromBufferGeometry(new Hl(t, e)), this.mergeVertices()
            }

            function Hl(t, Lt) {
                Kn.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: t,
                    options: Lt
                }, t = Array.isArray(t) ? t : [t];
                for (var kt = this, Ot = [], Ft = [], e = 0, i = t.length; e < i; e++) {
                    ! function(t) {
                        var n = [],
                            e = void 0 !== Lt.curveSegments ? Lt.curveSegments : 12,
                            c = void 0 !== Lt.steps ? Lt.steps : 1,
                            i = void 0 !== Lt.depth ? Lt.depth : 100,
                            p = void 0 === Lt.bevelEnabled || Lt.bevelEnabled,
                            r = void 0 !== Lt.bevelThickness ? Lt.bevelThickness : 6,
                            a = void 0 !== Lt.bevelSize ? Lt.bevelSize : r - 2,
                            s = void 0 !== Lt.bevelOffset ? Lt.bevelOffset : 0,
                            d = void 0 !== Lt.bevelSegments ? Lt.bevelSegments : 3,
                            o = Lt.extrudePath,
                            h = void 0 !== Lt.UVGenerator ? Lt.UVGenerator : Wl;
                        void 0 !== Lt.amount && (i = Lt.amount);
                        var l, u, f, m, g, v = !1;
                        o && (l = o.getSpacedPoints(c), p = !(v = !0), u = o.computeFrenetFrames(c, !1), f = new ni, m = new ni, g = new ni);
                        p || (s = a = r = d = 0);
                        var y = t.extractPoints(e),
                            b = y.shape,
                            x = y.holes;
                        if (!Gl.isClockWise(b)) {
                            b = b.reverse();
                            for (var _ = 0, w = x.length; _ < w; _++) {
                                var S = x[_];
                                Gl.isClockWise(S) && (x[_] = S.reverse())
                            }
                        }
                        for (var M = Gl.triangulateShape(b, x), T = b, C = 0, A = x.length; C < A; C++) {
                            var E = x[C];
                            b = b.concat(E)
                        }

                        function D(t, e, i) {
                            return e.clone().multiplyScalar(i).add(t)
                        }
                        var P = b.length,
                            L = M.length;

                        function k(t, e, i) {
                            var n, r = t.x - e.x,
                                a = t.y - e.y,
                                s = i.x - t.x,
                                o = i.y - t.y,
                                l = r * r + a * a,
                                h = r * o - a * s;
                            if (Math.abs(h) > Number.EPSILON) {
                                var u, c, p = Math.sqrt(l),
                                    d = Math.sqrt(s * s + o * o),
                                    f = e.x - a / p,
                                    m = e.y + r / p,
                                    g = ((i.x - o / d - f) * o - (i.y + s / d - m) * s) / (r * o - a * s),
                                    v = (u = f + r * g - t.x) * u + (c = m + a * g - t.y) * c;
                                if (v <= 2) return new He(u, c);
                                n = Math.sqrt(v / 2)
                            } else {
                                var y = !1;
                                r > Number.EPSILON ? s > Number.EPSILON && (y = !0) : r < -Number.EPSILON ? s < -Number.EPSILON && (y = !0) : Math.sign(a) === Math.sign(o) && (y = !0), n = y ? (u = -a, c = r, Math.sqrt(l)) : (u = r, c = a, Math.sqrt(l / 2))
                            }
                            return new He(u / n, c / n)
                        }
                        for (var O = [], F = 0, I = T.length, N = I - 1, B = F + 1; F < I; F++, N++, B++) N === I && (N = 0), B === I && (B = 0), O[F] = k(T[F], T[N], T[B]);
                        for (var R, z = [], G = O.concat(), V = 0, U = x.length; V < U; V++) {
                            var j = x[V];
                            R = [];
                            for (var H = 0, W = j.length, q = W - 1, X = H + 1; H < W; H++, q++, X++) q === W && (q = 0), X === W && (X = 0), R[H] = k(j[H], j[q], j[X]);
                            z.push(R), G = G.concat(R)
                        }
                        for (var Y = 0; Y < d; Y++) {
                            for (var J = Y / d, Z = r * Math.cos(J * Math.PI / 2), $ = a * Math.sin(J * Math.PI / 2) + s, K = 0, Q = T.length; K < Q; K++) {
                                var tt = D(T[K], O[K], $);
                                At(tt.x, tt.y, -Z)
                            }
                            for (var et = 0, it = x.length; et < it; et++) {
                                var nt = x[et];
                                R = z[et];
                                for (var rt = 0, at = nt.length; rt < at; rt++) {
                                    var st = D(nt[rt], R[rt], $);
                                    At(st.x, st.y, -Z)
                                }
                            }
                        }
                        for (var ot = a + s, lt = 0; lt < P; lt++) {
                            var ht = p ? D(b[lt], G[lt], ot) : b[lt];
                            v ? (m.copy(u.normals[0]).multiplyScalar(ht.x), f.copy(u.binormals[0]).multiplyScalar(ht.y), g.copy(l[0]).add(m).add(f), At(g.x, g.y, g.z)) : At(ht.x, ht.y, 0)
                        }
                        for (var ut = 1; ut <= c; ut++)
                            for (var ct = 0; ct < P; ct++) {
                                var pt = p ? D(b[ct], G[ct], ot) : b[ct];
                                v ? (m.copy(u.normals[ut]).multiplyScalar(pt.x), f.copy(u.binormals[ut]).multiplyScalar(pt.y), g.copy(l[ut]).add(m).add(f), At(g.x, g.y, g.z)) : At(pt.x, pt.y, i / c * ut)
                            }
                        for (var dt = d - 1; 0 <= dt; dt--) {
                            for (var ft = dt / d, mt = r * Math.cos(ft * Math.PI / 2), gt = a * Math.sin(ft * Math.PI / 2) + s, vt = 0, yt = T.length; vt < yt; vt++) {
                                var bt = D(T[vt], O[vt], gt);
                                At(bt.x, bt.y, i + mt)
                            }
                            for (var xt = 0, _t = x.length; xt < _t; xt++) {
                                var wt = x[xt];
                                R = z[xt];
                                for (var St = 0, Mt = wt.length; St < Mt; St++) {
                                    var Tt = D(wt[St], R[St], gt);
                                    v ? At(Tt.x, Tt.y + l[c - 1].y, l[c - 1].x + mt) : At(Tt.x, Tt.y, i + mt)
                                }
                            }
                        }

                        function Ct(t, e) {
                            for (var i = t.length; 0 <= --i;) {
                                var n = i,
                                    r = i - 1;
                                r < 0 && (r = t.length - 1);
                                for (var a = 0, s = c + 2 * d; a < s; a++) {
                                    var o = P * a,
                                        l = P * (a + 1);
                                    ! function(t, e, i, n) {
                                        Dt(t), Dt(e), Dt(n), Dt(e), Dt(i), Dt(n);
                                        var r = Ot.length / 3,
                                            a = h.generateSideWallUV(kt, Ot, r - 6, r - 3, r - 2, r - 1);
                                        Pt(a[0]), Pt(a[1]), Pt(a[3]), Pt(a[1]), Pt(a[2]), Pt(a[3])
                                    }(e + n + o, e + r + o, e + r + l, e + n + l)
                                }
                            }
                        }

                        function At(t, e, i) {
                            n.push(t), n.push(e), n.push(i)
                        }

                        function Et(t, e, i) {
                            Dt(t), Dt(e), Dt(i);
                            var n = Ot.length / 3,
                                r = h.generateTopUV(kt, Ot, n - 3, n - 2, n - 1);
                            Pt(r[0]), Pt(r[1]), Pt(r[2])
                        }

                        function Dt(t) {
                            Ot.push(n[3 * t + 0]), Ot.push(n[3 * t + 1]), Ot.push(n[3 * t + 2])
                        }

                        function Pt(t) {
                            Ft.push(t.x), Ft.push(t.y)
                        }(function() {
                            var t = Ot.length / 3;
                            if (p) {
                                for (var e = 0, i = P * e, n = 0; n < L; n++) {
                                    var r = M[n];
                                    Et(r[2] + i, r[1] + i, r[0] + i)
                                }
                                i = P * (e = c + 2 * d);
                                for (var a = 0; a < L; a++) {
                                    var s = M[a];
                                    Et(s[0] + i, s[1] + i, s[2] + i)
                                }
                            } else {
                                for (var o = 0; o < L; o++) {
                                    var l = M[o];
                                    Et(l[2], l[1], l[0])
                                }
                                for (var h = 0; h < L; h++) {
                                    var u = M[h];
                                    Et(u[0] + P * c, u[1] + P * c, u[2] + P * c)
                                }
                            }
                            kt.addGroup(t, Ot.length / 3 - t, 0)
                        })(),
                        function() {
                            var t = Ot.length / 3,
                                e = 0;
                            Ct(T, e), e += T.length;
                            for (var i = 0, n = x.length; i < n; i++) {
                                var r = x[i];
                                Ct(r, e), e += r.length
                            }
                            kt.addGroup(t, Ot.length / 3 - t, 1)
                        }()
                    }(t[e])
                }
                this.setAttribute("position", new Vn(Ot, 3)), this.setAttribute("uv", new Vn(Ft, 2)), this.computeVertexNormals()
            }((jl.prototype = Object.create(Sr.prototype)).constructor = jl).prototype.toJSON = function() {
                var t = Sr.prototype.toJSON.call(this);
                return ql(this.parameters.shapes, this.parameters.options, t)
            }, ((Hl.prototype = Object.create(Kn.prototype)).constructor = Hl).prototype.toJSON = function() {
                var t = Kn.prototype.toJSON.call(this);
                return ql(this.parameters.shapes, this.parameters.options, t)
            };
            var Wl = {
                generateTopUV: function(t, e, i, n, r) {
                    var a = e[3 * i],
                        s = e[3 * i + 1],
                        o = e[3 * n],
                        l = e[3 * n + 1],
                        h = e[3 * r],
                        u = e[3 * r + 1];
                    return [new He(a, s), new He(o, l), new He(h, u)]
                },
                generateSideWallUV: function(t, e, i, n, r, a) {
                    var s = e[3 * i],
                        o = e[3 * i + 1],
                        l = e[3 * i + 2],
                        h = e[3 * n],
                        u = e[3 * n + 1],
                        c = e[3 * n + 2],
                        p = e[3 * r],
                        d = e[3 * r + 1],
                        f = e[3 * r + 2],
                        m = e[3 * a],
                        g = e[3 * a + 1],
                        v = e[3 * a + 2];
                    return Math.abs(o - u) < .01 ? [new He(s, 1 - l), new He(h, 1 - c), new He(p, 1 - f), new He(m, 1 - v)] : [new He(o, 1 - l), new He(u, 1 - c), new He(d, 1 - f), new He(g, 1 - v)]
                }
            };

            function ql(t, e, i) {
                if (i.shapes = [], Array.isArray(t))
                    for (var n = 0, r = t.length; n < r; n++) {
                        var a = t[n];
                        i.shapes.push(a.uuid)
                    } else i.shapes.push(t.uuid);
                return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
            }

            function Xl(t, e) {
                Sr.call(this), this.type = "TextGeometry", this.parameters = {
                    text: t,
                    parameters: e
                }, this.fromBufferGeometry(new Yl(t, e)), this.mergeVertices()
            }

            function Yl(t, e) {
                var i = (e = e || {}).font;
                if (!i || !i.isFont) return new Sr;
                var n = i.generateShapes(t, e.size);
                e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Hl.call(this, n, e), this.type = "TextBufferGeometry"
            }

            function Jl(t, e, i, n, r, a, s) {
                Sr.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: i,
                    phiStart: n,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: s
                }, this.fromBufferGeometry(new Zl(t, e, i, n, r, a, s)), this.mergeVertices()
            }

            function Zl(t, e, i, n, r, a, s) {
                Kn.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: i,
                    phiStart: n,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: s
                }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : Math.PI;
                for (var o = Math.min(a + s, Math.PI), l = 0, h = [], u = new ni, c = new ni, p = [], d = [], f = [], m = [], g = 0; g <= i; g++) {
                    var v = [],
                        y = g / i,
                        b = 0;
                    0 == g && 0 == a ? b = .5 / e : g == i && o == Math.PI && (b = -.5 / e);
                    for (var x = 0; x <= e; x++) {
                        var _ = x / e;
                        u.x = -t * Math.cos(n + _ * r) * Math.sin(a + y * s), u.y = t * Math.cos(a + y * s), u.z = t * Math.sin(n + _ * r) * Math.sin(a + y * s), d.push(u.x, u.y, u.z), c.copy(u).normalize(), f.push(c.x, c.y, c.z), m.push(_ + b, 1 - y), v.push(l++)
                    }
                    h.push(v)
                }
                for (var w = 0; w < i; w++)
                    for (var S = 0; S < e; S++) {
                        var M = h[w][S + 1],
                            T = h[w][S],
                            C = h[w + 1][S],
                            A = h[w + 1][S + 1];
                        (0 !== w || 0 < a) && p.push(M, T, A), (w !== i - 1 || o < Math.PI) && p.push(T, C, A)
                    }
                this.setIndex(p), this.setAttribute("position", new Vn(d, 3)), this.setAttribute("normal", new Vn(f, 3)), this.setAttribute("uv", new Vn(m, 2))
            }

            function $l(t, e, i, n, r, a) {
                Sr.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: r,
                    thetaLength: a
                }, this.fromBufferGeometry(new Kl(t, e, i, n, r, a)), this.mergeVertices()
            }

            function Kl(t, e, i, n, r, a) {
                Kn.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: r,
                    thetaLength: a
                }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
                for (var s = [], o = [], l = [], h = [], u = t, c = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1), p = new ni, d = new He, f = 0; f <= n; f++) {
                    for (var m = 0; m <= i; m++) {
                        var g = r + m / i * a;
                        p.x = u * Math.cos(g), p.y = u * Math.sin(g), o.push(p.x, p.y, p.z), l.push(0, 0, 1), d.x = (p.x / e + 1) / 2, d.y = (p.y / e + 1) / 2, h.push(d.x, d.y)
                    }
                    u += c
                }
                for (var v = 0; v < n; v++)
                    for (var y = v * (i + 1), b = 0; b < i; b++) {
                        var x = b + y,
                            _ = x + i + 1,
                            w = x + i + 2,
                            S = x + 1;
                        s.push(x, _, S), s.push(_, w, S)
                    }
                this.setIndex(s), this.setAttribute("position", new Vn(o, 3)), this.setAttribute("normal", new Vn(l, 3)), this.setAttribute("uv", new Vn(h, 2))
            }

            function Ql(t, e, i, n) {
                Sr.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: i,
                    phiLength: n
                }, this.fromBufferGeometry(new th(t, e, i, n)), this.mergeVertices()
            }

            function th(t, e, i, n) {
                Kn.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: i,
                    phiLength: n
                }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = je.clamp(n, 0, 2 * Math.PI);
                for (var r = [], a = [], s = [], o = 1 / e, l = new ni, h = new He, u = 0; u <= e; u++)
                    for (var c = i + u * o * n, p = Math.sin(c), d = Math.cos(c), f = 0; f <= t.length - 1; f++) l.x = t[f].x * p, l.y = t[f].y, l.z = t[f].x * d, a.push(l.x, l.y, l.z), h.x = u / e, h.y = f / (t.length - 1), s.push(h.x, h.y);
                for (var m = 0; m < e; m++)
                    for (var g = 0; g < t.length - 1; g++) {
                        var v = g + m * t.length,
                            y = v + t.length,
                            b = v + t.length + 1,
                            x = v + 1;
                        r.push(v, y, x), r.push(y, b, x)
                    }
                if (this.setIndex(r), this.setAttribute("position", new Vn(a, 3)), this.setAttribute("uv", new Vn(s, 2)), this.computeVertexNormals(), n === 2 * Math.PI)
                    for (var _ = this.attributes.normal.array, w = new ni, S = new ni, M = new ni, T = e * t.length * 3, C = 0, A = 0; C < t.length; C++, A += 3) w.x = _[A + 0], w.y = _[A + 1], w.z = _[A + 2], S.x = _[T + A + 0], S.y = _[T + A + 1], S.z = _[T + A + 2], M.addVectors(w, S).normalize(), _[A + 0] = _[T + A + 0] = M.x, _[A + 1] = _[T + A + 1] = M.y, _[A + 2] = _[T + A + 2] = M.z
            }

            function eh(t, e) {
                Sr.call(this), this.type = "ShapeGeometry", "object" === Wp(e) && (e = e.curveSegments), this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, this.fromBufferGeometry(new ih(t, e)), this.mergeVertices()
            }

            function ih(t, _) {
                Kn.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: _
                }, _ = _ || 12;
                var w = [],
                    S = [],
                    M = [],
                    T = [],
                    e = 0,
                    C = 0;
                if (!1 === Array.isArray(t)) n(t);
                else
                    for (var i = 0; i < t.length; i++) n(t[i]), this.addGroup(e, C, i), e += C, C = 0;

                function n(t) {
                    var e = S.length / 3,
                        i = t.extractPoints(_),
                        n = i.shape,
                        r = i.holes;
                    !1 === Gl.isClockWise(n) && (n = n.reverse());
                    for (var a = 0, s = r.length; a < s; a++) {
                        var o = r[a];
                        !0 === Gl.isClockWise(o) && (r[a] = o.reverse())
                    }
                    for (var l = Gl.triangulateShape(n, r), h = 0, u = r.length; h < u; h++) var c = r[h],
                        n = n.concat(c);
                    for (var p = 0, d = n.length; p < d; p++) {
                        var f = n[p];
                        S.push(f.x, f.y, 0), M.push(0, 0, 1), T.push(f.x, f.y)
                    }
                    for (var m = 0, g = l.length; m < g; m++) {
                        var v = l[m],
                            y = v[0] + e,
                            b = v[1] + e,
                            x = v[2] + e;
                        w.push(y, b, x), C += 3
                    }
                }
                this.setIndex(w), this.setAttribute("position", new Vn(S, 3)), this.setAttribute("normal", new Vn(M, 3)), this.setAttribute("uv", new Vn(T, 2))
            }

            function nh(t, e) {
                if (e.shapes = [], Array.isArray(t))
                    for (var i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        e.shapes.push(r.uuid)
                    } else e.shapes.push(t.uuid);
                return e
            }

            function rh(t, e) {
                Kn.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: e
                }, e = void 0 !== e ? e : 1;
                var i, n, r, a, s = [],
                    o = Math.cos(je.DEG2RAD * e),
                    l = [0, 0],
                    h = {},
                    u = ["a", "b", "c"];
                t.isBufferGeometry ? (a = new Sr).fromBufferGeometry(t) : a = t.clone(), a.mergeVertices(), a.computeFaceNormals();
                for (var c = a.vertices, p = a.faces, d = 0, f = p.length; d < f; d++)
                    for (var m = p[d], g = 0; g < 3; g++) i = m[u[g]], n = m[u[(g + 1) % 3]], l[0] = Math.min(i, n), l[1] = Math.max(i, n), void 0 === h[r = l[0] + "," + l[1]] ? h[r] = {
                        index1: l[0],
                        index2: l[1],
                        face1: d,
                        face2: void 0
                    } : h[r].face2 = d;
                for (r in h) {
                    var v, y = h[r];
                    (void 0 === y.face2 || p[y.face1].normal.dot(p[y.face2].normal) <= o) && (v = c[y.index1], s.push(v.x, v.y, v.z), v = c[y.index2], s.push(v.x, v.y, v.z))
                }
                this.setAttribute("position", new Vn(s, 3))
            }

            function ah(t, e, i, n, r, a, s, o) {
                Sr.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: i,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: a,
                    thetaStart: s,
                    thetaLength: o
                }, this.fromBufferGeometry(new sh(t, e, i, n, r, a, s, o)), this.mergeVertices()
            }

            function sh(b, x, _, w, S, t, M, T) {
                Kn.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: b,
                    radiusBottom: x,
                    height: _,
                    radialSegments: w,
                    heightSegments: S,
                    openEnded: t,
                    thetaStart: M,
                    thetaLength: T
                };
                var C = this;
                b = void 0 !== b ? b : 1, x = void 0 !== x ? x : 1, _ = _ || 1, w = Math.floor(w) || 8, S = Math.floor(S) || 1, t = void 0 !== t && t, M = void 0 !== M ? M : 0, T = void 0 !== T ? T : 2 * Math.PI;
                var A = [],
                    E = [],
                    D = [],
                    P = [],
                    L = 0,
                    k = [],
                    O = _ / 2,
                    F = 0;

                function e(t) {
                    for (var e = L, i = new He, n = new ni, r = 0, a = !0 === t ? b : x, s = !0 === t ? 1 : -1, o = 1; o <= w; o++) E.push(0, O * s, 0), D.push(0, s, 0), P.push(.5, .5), L++;
                    for (var l = L, h = 0; h <= w; h++) {
                        var u = h / w * T + M,
                            c = Math.cos(u),
                            p = Math.sin(u);
                        n.x = a * p, n.y = O * s, n.z = a * c, E.push(n.x, n.y, n.z), D.push(0, s, 0), i.x = .5 * c + .5, i.y = .5 * p * s + .5, P.push(i.x, i.y), L++
                    }
                    for (var d = 0; d < w; d++) {
                        var f = e + d,
                            m = l + d;
                        !0 === t ? A.push(m, m + 1, f) : A.push(m + 1, m, f), r += 3
                    }
                    C.addGroup(F, r, !0 === t ? 1 : 2), F += r
                }! function() {
                    for (var t = new ni, e = new ni, i = 0, n = (x - b) / _, r = 0; r <= S; r++) {
                        for (var a = [], s = r / S, o = s * (x - b) + b, l = 0; l <= w; l++) {
                            var h = l / w,
                                u = h * T + M,
                                c = Math.sin(u),
                                p = Math.cos(u);
                            e.x = o * c, e.y = -s * _ + O, e.z = o * p, E.push(e.x, e.y, e.z), t.set(c, n, p).normalize(), D.push(t.x, t.y, t.z), P.push(h, 1 - s), a.push(L++)
                        }
                        k.push(a)
                    }
                    for (var d = 0; d < w; d++)
                        for (var f = 0; f < S; f++) {
                            var m = k[f][d],
                                g = k[f + 1][d],
                                v = k[f + 1][d + 1],
                                y = k[f][d + 1];
                            A.push(m, g, y), A.push(g, v, y), i += 6
                        }
                    C.addGroup(F, i, 0), F += i
                }(), !1 === t && (0 < b && e(!0), 0 < x && e(!1)), this.setIndex(A), this.setAttribute("position", new Vn(E, 3)), this.setAttribute("normal", new Vn(D, 3)), this.setAttribute("uv", new Vn(P, 2))
            }

            function oh(t, e, i, n, r, a, s) {
                ah.call(this, 0, t, e, i, n, r, a, s), this.type = "ConeGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: i,
                    heightSegments: n,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: s
                }
            }

            function lh(t, e, i, n, r, a, s) {
                sh.call(this, 0, t, e, i, n, r, a, s), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: i,
                    heightSegments: n,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: s
                }
            }

            function hh(t, e, i, n) {
                Sr.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: i,
                    thetaLength: n
                }, this.fromBufferGeometry(new uh(t, e, i, n)), this.mergeVertices()
            }

            function uh(t, e, i, n) {
                Kn.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: i,
                    thetaLength: n
                }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI;
                var r = [],
                    a = [],
                    s = [],
                    o = [],
                    l = new ni,
                    h = new He;
                a.push(0, 0, 0), s.push(0, 0, 1), o.push(.5, .5);
                for (var u = 0, c = 3; u <= e; u++, c += 3) {
                    var p = i + u / e * n;
                    l.x = t * Math.cos(p), l.y = t * Math.sin(p), a.push(l.x, l.y, l.z), s.push(0, 0, 1), h.x = (a[c] / t + 1) / 2, h.y = (a[c + 1] / t + 1) / 2, o.push(h.x, h.y)
                }
                for (var d = 1; d <= e; d++) r.push(d, d + 1, 0);
                this.setIndex(r), this.setAttribute("position", new Vn(a, 3)), this.setAttribute("normal", new Vn(s, 3)), this.setAttribute("uv", new Vn(o, 2))
            }(Xl.prototype = Object.create(Sr.prototype)).constructor = Xl, (Yl.prototype = Object.create(Hl.prototype)).constructor = Yl, (Jl.prototype = Object.create(Sr.prototype)).constructor = Jl, (Zl.prototype = Object.create(Kn.prototype)).constructor = Zl, ($l.prototype = Object.create(Sr.prototype)).constructor = $l, (Kl.prototype = Object.create(Kn.prototype)).constructor = Kl, (Ql.prototype = Object.create(Sr.prototype)).constructor = Ql, (th.prototype = Object.create(Kn.prototype)).constructor = th, ((eh.prototype = Object.create(Sr.prototype)).constructor = eh).prototype.toJSON = function() {
                var t = Sr.prototype.toJSON.call(this);
                return nh(this.parameters.shapes, t)
            }, ((ih.prototype = Object.create(Kn.prototype)).constructor = ih).prototype.toJSON = function() {
                var t = Kn.prototype.toJSON.call(this);
                return nh(this.parameters.shapes, t)
            }, (rh.prototype = Object.create(Kn.prototype)).constructor = rh, (ah.prototype = Object.create(Sr.prototype)).constructor = ah, (sh.prototype = Object.create(Kn.prototype)).constructor = sh, (oh.prototype = Object.create(ah.prototype)).constructor = oh, (lh.prototype = Object.create(sh.prototype)).constructor = lh, (hh.prototype = Object.create(Sr.prototype)).constructor = hh, (uh.prototype = Object.create(Kn.prototype)).constructor = uh;
            var ch = Object.freeze({
                __proto__: null,
                WireframeGeometry: rl,
                ParametricGeometry: al,
                ParametricBufferGeometry: sl,
                TetrahedronGeometry: hl,
                TetrahedronBufferGeometry: ul,
                OctahedronGeometry: cl,
                OctahedronBufferGeometry: pl,
                IcosahedronGeometry: dl,
                IcosahedronBufferGeometry: fl,
                DodecahedronGeometry: ml,
                DodecahedronBufferGeometry: gl,
                PolyhedronGeometry: ol,
                PolyhedronBufferGeometry: ll,
                TubeGeometry: vl,
                TubeBufferGeometry: yl,
                TorusKnotGeometry: bl,
                TorusKnotBufferGeometry: xl,
                TorusGeometry: _l,
                TorusBufferGeometry: wl,
                TextGeometry: Xl,
                TextBufferGeometry: Yl,
                SphereGeometry: Jl,
                SphereBufferGeometry: Zl,
                RingGeometry: $l,
                RingBufferGeometry: Kl,
                PlaneGeometry: Ur,
                PlaneBufferGeometry: jr,
                LatheGeometry: Ql,
                LatheBufferGeometry: th,
                ShapeGeometry: eh,
                ShapeBufferGeometry: ih,
                ExtrudeGeometry: jl,
                ExtrudeBufferGeometry: Hl,
                EdgesGeometry: rh,
                ConeGeometry: oh,
                ConeBufferGeometry: lh,
                CylinderGeometry: ah,
                CylinderBufferGeometry: sh,
                CircleGeometry: hh,
                CircleBufferGeometry: uh,
                BoxGeometry: Mr,
                BoxBufferGeometry: Tr
            });

            function ph(t) {
                Dn.call(this), this.type = "ShadowMaterial", this.color = new Cn(0), this.transparent = !0, this.setValues(t)
            }

            function dh(t) {
                Lr.call(this, t), this.type = "RawShaderMaterial"
            }

            function fh(t) {
                Dn.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new Cn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Cn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ke, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t)
            }

            function mh(t) {
                fh.call(this), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new He(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t)
            }

            function gh(t) {
                Dn.call(this), this.type = "MeshPhongMaterial", this.color = new Cn(16777215), this.specular = new Cn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Cn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ke, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = R, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function vh(t) {
                Dn.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.color = new Cn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Cn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ke, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function yh(t) {
                Dn.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ke, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function bh(t) {
                Dn.call(this), this.type = "MeshLambertMaterial", this.color = new Cn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Cn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = R, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function xh(t) {
                Dn.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new Cn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ke, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function _h(t) {
                No.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }((ph.prototype = Object.create(Dn.prototype)).constructor = ph).prototype.isShadowMaterial = !0, ph.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.color.copy(t.color), this
            }, ((dh.prototype = Object.create(Lr.prototype)).constructor = dh).prototype.isRawShaderMaterial = !0, ((fh.prototype = Object.create(Dn.prototype)).constructor = fh).prototype.isMeshStandardMaterial = !0, fh.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this
            }, ((mh.prototype = Object.create(fh.prototype)).constructor = mh).prototype.isMeshPhysicalMaterial = !0, mh.prototype.copy = function(t) {
                return fh.prototype.copy.call(this, t), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Cn).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this
            }, ((gh.prototype = Object.create(Dn.prototype)).constructor = gh).prototype.isMeshPhongMaterial = !0, gh.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, ((vh.prototype = Object.create(Dn.prototype)).constructor = vh).prototype.isMeshToonMaterial = !0, vh.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, ((yh.prototype = Object.create(Dn.prototype)).constructor = yh).prototype.isMeshNormalMaterial = !0, yh.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, ((bh.prototype = Object.create(Dn.prototype)).constructor = bh).prototype.isMeshLambertMaterial = !0, bh.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, ((xh.prototype = Object.create(Dn.prototype)).constructor = xh).prototype.isMeshMatcapMaterial = !0, xh.prototype.copy = function(t) {
                return Dn.prototype.copy.call(this, t), this.defines = {
                    MATCAP: ""
                }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, ((_h.prototype = Object.create(No.prototype)).constructor = _h).prototype.isLineDashedMaterial = !0, _h.prototype.copy = function(t) {
                return No.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            };
            var wh = Object.freeze({
                    __proto__: null,
                    ShadowMaterial: ph,
                    SpriteMaterial: io,
                    RawShaderMaterial: dh,
                    ShaderMaterial: Lr,
                    PointsMaterial: Xo,
                    MeshPhysicalMaterial: mh,
                    MeshStandardMaterial: fh,
                    MeshPhongMaterial: gh,
                    MeshToonMaterial: vh,
                    MeshNormalMaterial: yh,
                    MeshLambertMaterial: bh,
                    MeshDepthMaterial: Fs,
                    MeshDistanceMaterial: Is,
                    MeshBasicMaterial: Pn,
                    MeshMatcapMaterial: xh,
                    LineDashedMaterial: _h,
                    LineBasicMaterial: No,
                    Material: Dn
                }),
                Sh = {
                    arraySlice: function(t, e, i) {
                        return Sh.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
                    },
                    convertArray: function(t, e, i) {
                        return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    },
                    isTypedArray: function(t) {
                        return ArrayBuffer.isView(t) && !(t instanceof DataView)
                    },
                    getKeyframeOrder: function(i) {
                        for (var t = i.length, e = new Array(t), n = 0; n !== t; ++n) e[n] = n;
                        return e.sort(function(t, e) {
                            return i[t] - i[e]
                        }), e
                    },
                    sortedArray: function(t, e, i) {
                        for (var n = t.length, r = new t.constructor(n), a = 0, s = 0; s !== n; ++a)
                            for (var o = i[a] * e, l = 0; l !== e; ++l) r[s++] = t[o + l];
                        return r
                    },
                    flattenJSON: function(t, e, i, n) {
                        for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n];) a = t[r++];
                        if (void 0 !== a) {
                            var s = a[n];
                            if (void 0 !== s)
                                if (Array.isArray(s))
                                    for (; void 0 !== (s = a[n]) && (e.push(a.time), i.push.apply(i, s)), void 0 !== (a = t[r++]););
                                else if (void 0 !== s.toArray)
                                for (; void 0 !== (s = a[n]) && (e.push(a.time), s.toArray(i, i.length)), void 0 !== (a = t[r++]););
                            else
                                for (; void 0 !== (s = a[n]) && (e.push(a.time), i.push(s)), void 0 !== (a = t[r++]););
                        }
                    },
                    subclip: function(t, e, i, n, r) {
                        r = r || 30;
                        var a = t.clone();
                        a.name = e;
                        for (var s = [], o = 0; o < a.tracks.length; ++o) {
                            for (var l = a.tracks[o], h = l.getValueSize(), u = [], c = [], p = 0; p < l.times.length; ++p) {
                                var d = l.times[p] * r;
                                if (!(d < i || n <= d)) {
                                    u.push(l.times[p]);
                                    for (var f = 0; f < h; ++f) c.push(l.values[p * h + f])
                                }
                            }
                            0 !== u.length && (l.times = Sh.convertArray(u, l.times.constructor), l.values = Sh.convertArray(c, l.values.constructor), s.push(l))
                        }
                        a.tracks = s;
                        for (var m = 1 / 0, g = 0; g < a.tracks.length; ++g) m > a.tracks[g].times[0] && (m = a.tracks[g].times[0]);
                        for (var v = 0; v < a.tracks.length; ++v) a.tracks[v].shift(-1 * m);
                        return a.resetDuration(), a
                    },
                    makeClipAdditive: function(_, t, w, e) {
                        void 0 === t && (t = 0), void 0 === w && (w = _), (void 0 === e || e <= 0) && (e = 30);
                        for (var i = _.tracks.length, S = t / e, n = 0; n < i; ++n) ! function(t) {
                            var e = w.tracks[t],
                                i = e.ValueTypeName;
                            if ("bool" !== i && "string" !== i) {
                                var n = _.tracks.find(function(t) {
                                    return t.name === e.name && t.ValueTypeName === i
                                });
                                if (void 0 !== n) {
                                    var r = 0,
                                        a = e.getValueSize();
                                    e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (r = a / 3);
                                    var s = 0,
                                        o = n.getValueSize();
                                    n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = o / 3);
                                    var l, h, u, c, p, d, f = e.times.length - 1,
                                        m = void 0;
                                    m = S <= e.times[0] ? (l = a - r, Sh.arraySlice(e.values, r, l)) : S >= e.times[f] ? (u = (h = f * a + r) + a - r, Sh.arraySlice(e.values, h, u)) : (d = a - (p = r), (c = e.createInterpolant()).evaluate(S), Sh.arraySlice(c.resultBuffer, p, d)), "quaternion" === i && (new ei).fromArray(m).normalize().conjugate().toArray(m);
                                    for (var g = n.times.length, v = 0; v < g; ++v) {
                                        var y = v * o + s;
                                        if ("quaternion" === i) ei.multiplyQuaternionsFlat(n.values, y, m, 0, n.values, y);
                                        else
                                            for (var b = o - 2 * s, x = 0; x < b; ++x) n.values[y + x] -= m[x]
                                    }
                                }
                            }
                        }(n);
                        return _.blendMode = 2501, _
                    }
                };

            function Mh(t, e, i, n) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
            }

            function Th(t, e, i, n) {
                Mh.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function Ch(t, e, i, n) {
                Mh.call(this, t, e, i, n)
            }

            function Ah(t, e, i, n) {
                Mh.call(this, t, e, i, n)
            }

            function Eh(t, e, i, n) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = Sh.convertArray(e, this.TimeBufferType), this.values = Sh.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
            }

            function Dh(t, e, i) {
                Eh.call(this, t, e, i)
            }

            function Ph(t, e, i, n) {
                Eh.call(this, t, e, i, n)
            }

            function Lh(t, e, i, n) {
                Eh.call(this, t, e, i, n)
            }

            function kh(t, e, i, n) {
                Mh.call(this, t, e, i, n)
            }

            function Oh(t, e, i, n) {
                Eh.call(this, t, e, i, n)
            }

            function Fh(t, e, i, n) {
                Eh.call(this, t, e, i, n)
            }

            function Ih(t, e, i, n) {
                Eh.call(this, t, e, i, n)
            }

            function Nh(t, e, i, n) {
                this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== n ? n : 2500, this.uuid = je.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function Bh(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var e, i, n = function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Lh;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Ih;
                        case "color":
                            return Ph;
                        case "quaternion":
                            return Oh;
                        case "bool":
                        case "boolean":
                            return Dh;
                        case "string":
                            return Fh
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                return void 0 === t.times && (e = [], i = [], Sh.flattenJSON(t.keys, e, i, "value"), t.times = e, t.values = i), void 0 !== n.parse ? n.parse(t) : new n(t.name, t.times, t.values, t.interpolation)
            }
            Object.assign(Mh.prototype, {
                evaluate: function(t) {
                    var e, i = this.parameterPositions,
                        n = this._cachedIndex,
                        r = i[n],
                        a = i[n - 1];
                    t: {
                        e: {
                            i: {
                                n: if (!(t < r)) {
                                    for (var s = n + 2;;) {
                                        if (void 0 === r) {
                                            if (t < a) break n;
                                            return n = i.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, a)
                                        }
                                        if (n === s) break;
                                        if (a = r, t < (r = i[++n])) break e
                                    }
                                    e = i.length;
                                    break i
                                }if (a <= t) break t;
                                var o = i[1];t < o && (n = 2, a = o);
                                for (var l = n - 2;;) {
                                    if (void 0 === a) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                                    if (n === l) break;
                                    if (r = a, (a = i[--n - 1]) <= t) break e
                                }
                                e = n,
                                n = 0
                            }
                            for (; n < e;) {
                                var h = n + e >>> 1;
                                t < i[h] ? e = h : n = 1 + h
                            }
                            if (r = i[n], void 0 === (a = i[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                            if (void 0 === r) return n = i.length, this._cachedIndex = n, this.afterEnd_(n - 1, a, t)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, a, r)
                    }
                    return this.interpolate_(n, a, t, r)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(t) {
                    for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, a = 0; a !== n; ++a) e[a] = i[r + a];
                    return e
                },
                interpolate_: function() {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function() {}
            }), Object.assign(Mh.prototype, {
                beforeStart_: Mh.prototype.copySampleValue_,
                afterEnd_: Mh.prototype.copySampleValue_
            }), Th.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: Th,
                DefaultSettings_: {
                    endingStart: 2400,
                    endingEnd: 2400
                },
                intervalChanged_: function(t, e, i) {
                    var n = this.parameterPositions,
                        r = t - 2,
                        a = t + 1,
                        s = n[r],
                        o = n[a];
                    if (void 0 === s) switch (this.getSettings_().endingStart) {
                        case 2401:
                            r = t, s = 2 * e - i;
                            break;
                        case 2402:
                            s = e + n[r = n.length - 2] - n[r + 1];
                            break;
                        default:
                            r = t, s = i
                    }
                    if (void 0 === o) switch (this.getSettings_().endingEnd) {
                        case 2401:
                            a = t, o = 2 * i - e;
                            break;
                        case 2402:
                            o = i + n[a = 1] - n[0];
                            break;
                        default:
                            a = t - 1, o = e
                    }
                    var l = .5 * (i - e),
                        h = this.valueSize;
                    this._weightPrev = l / (e - s), this._weightNext = l / (o - i), this._offsetPrev = r * h, this._offsetNext = a * h
                },
                interpolate_: function(t, e, i, n) {
                    for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = t * s, l = o - s, h = this._offsetPrev, u = this._offsetNext, c = this._weightPrev, p = this._weightNext, d = (i - e) / (n - e), f = d * d, m = f * d, g = -c * m + 2 * c * f - c * d, v = (1 + c) * m + (-1.5 - 2 * c) * f + (-.5 + c) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, b = p * m - p * f, x = 0; x !== s; ++x) r[x] = g * a[h + x] + v * a[l + x] + y * a[o + x] + b * a[u + x];
                    return r
                }
            }), Ch.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: Ch,
                interpolate_: function(t, e, i, n) {
                    for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = t * s, l = o - s, h = (i - e) / (n - e), u = 1 - h, c = 0; c !== s; ++c) r[c] = a[l + c] * u + a[o + c] * h;
                    return r
                }
            }), Ah.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: Ah,
                interpolate_: function(t) {
                    return this.copySampleValue_(t - 1)
                }
            }), Object.assign(Eh, {
                toJSON: function(t) {
                    var e, i, n = t.constructor;
                    return void 0 !== n.toJSON ? e = n.toJSON(t) : (e = {
                        name: t.name,
                        times: Sh.convertArray(t.times, Array),
                        values: Sh.convertArray(t.values, Array)
                    }, (i = t.getInterpolation()) !== t.DefaultInterpolation && (e.interpolation = i)), e.type = t.ValueTypeName, e
                }
            }), Object.assign(Eh.prototype, {
                constructor: Eh,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodDiscrete: function(t) {
                    return new Ah(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodLinear: function(t) {
                    return new Ch(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodSmooth: function(t) {
                    return new Th(this.times, this.values, this.getValueSize(), t)
                },
                setInterpolation: function(t) {
                    var e;
                    switch (t) {
                        case 2300:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case 2301:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case 2302:
                            e = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 !== e) return this.createInterpolant = e, this;
                    var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(i);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return this
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return 2300;
                        case this.InterpolantFactoryMethodLinear:
                            return 2301;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(t) {
                    if (0 !== t)
                        for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
                    return this
                },
                scale: function(t) {
                    if (1 !== t)
                        for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
                    return this
                },
                trim: function(t, e) {
                    for (var i, n = this.times, r = n.length, a = 0, s = r - 1; a !== r && n[a] < t;) ++a;
                    for (; - 1 !== s && n[s] > e;) --s;
                    return ++s, 0 === a && s === r || (s <= a && (a = (s = Math.max(s, 1)) - 1), i = this.getValueSize(), this.times = Sh.arraySlice(n, a, s), this.values = Sh.arraySlice(this.values, a * i, s * i)), this
                },
                validate: function() {
                    var t = !0,
                        e = this.getValueSize();
                    e - Math.floor(e) != 0 && (t = !1);
                    var i = this.times,
                        n = this.values,
                        r = i.length;
                    0 === r && (t = !1);
                    for (var a = null, s = 0; s !== r; s++) {
                        var o = i[s];
                        if ("number" == typeof o && isNaN(o)) {
                            t = !1;
                            break
                        }
                        if (null !== a && o < a) {
                            t = !1;
                            break
                        }
                        a = o
                    }
                    if (void 0 !== n && Sh.isTypedArray(n))
                        for (var l = 0, h = n.length; l !== h; ++l) {
                            var u = n[l];
                            if (isNaN(u)) {
                                t = !1;
                                break
                            }
                        }
                    return t
                },
                optimize: function() {
                    for (var t = Sh.arraySlice(this.times), e = Sh.arraySlice(this.values), i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = t.length - 1, a = 1, s = 1; s < r; ++s) {
                        var o = !1,
                            l = t[s];
                        if (l !== t[s + 1] && (1 !== s || l !== l[0]))
                            if (n) o = !0;
                            else
                                for (var h = s * i, u = h - i, c = h + i, p = 0; p !== i; ++p) {
                                    var d = e[h + p];
                                    if (d !== e[u + p] || d !== e[c + p]) {
                                        o = !0;
                                        break
                                    }
                                }
                        if (o) {
                            if (s !== a) {
                                t[a] = t[s];
                                for (var f = s * i, m = a * i, g = 0; g !== i; ++g) e[m + g] = e[f + g]
                            }++a
                        }
                    }
                    if (0 < r) {
                        t[a] = t[r];
                        for (var v = r * i, y = a * i, b = 0; b !== i; ++b) e[y + b] = e[v + b];
                        ++a
                    }
                    return a !== t.length ? (this.times = Sh.arraySlice(t, 0, a), this.values = Sh.arraySlice(e, 0, a * i)) : (this.times = t, this.values = e), this
                },
                clone: function() {
                    var t = Sh.arraySlice(this.times, 0),
                        e = Sh.arraySlice(this.values, 0),
                        i = new this.constructor(this.name, t, e);
                    return i.createInterpolant = this.createInterpolant, i
                }
            }), Dh.prototype = Object.assign(Object.create(Eh.prototype), {
                constructor: Dh,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: 2300,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Ph.prototype = Object.assign(Object.create(Eh.prototype), {
                constructor: Ph,
                ValueTypeName: "color"
            }), Lh.prototype = Object.assign(Object.create(Eh.prototype), {
                constructor: Lh,
                ValueTypeName: "number"
            }), kh.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: kh,
                interpolate_: function(t, e, i, n) {
                    for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = (i - e) / (n - e), l = t * s, h = l + s; l !== h; l += 4) ei.slerpFlat(r, 0, a, l - s, a, l, o);
                    return r
                }
            }), Oh.prototype = Object.assign(Object.create(Eh.prototype), {
                constructor: Oh,
                ValueTypeName: "quaternion",
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodLinear: function(t) {
                    return new kh(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), Fh.prototype = Object.assign(Object.create(Eh.prototype), {
                constructor: Fh,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: 2300,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Ih.prototype = Object.assign(Object.create(Eh.prototype), {
                constructor: Ih,
                ValueTypeName: "vector"
            }), Object.assign(Nh, {
                parse: function(t) {
                    for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i.length; r !== a; ++r) e.push(Bh(i[r]).scale(n));
                    return new Nh(t.name, t.duration, e, t.blendMode)
                },
                toJSON: function(t) {
                    for (var e = [], i = t.tracks, n = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e,
                            uuid: t.uuid,
                            blendMode: t.blendMode
                        }, r = 0, a = i.length; r !== a; ++r) e.push(Eh.toJSON(i[r]));
                    return n
                },
                CreateFromMorphTargetSequence: function(t, e, i, n) {
                    for (var r = e.length, a = [], s = 0; s < r; s++) {
                        var o = [];
                        (h = []).push((s + r - 1) % r, s, (s + 1) % r), o.push(0, 1, 0);
                        var l = Sh.getKeyframeOrder(h),
                            h = Sh.sortedArray(h, 1, l),
                            o = Sh.sortedArray(o, 1, l);
                        n || 0 !== h[0] || (h.push(r), o.push(o[0])), a.push(new Lh(".morphTargetInfluences[" + e[s].name + "]", h, o).scale(1 / i))
                    }
                    return new Nh(t, -1, a)
                },
                findByName: function(t, e) {
                    var i = t;
                    Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations);
                    for (var n = 0; n < i.length; n++)
                        if (i[n].name === e) return i[n];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(t, e, i) {
                    for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, s = t.length; a < s; a++) {
                        var o, l, h = t[a],
                            u = h.name.match(r);
                        u && 1 < u.length && ((l = n[o = u[1]]) || (n[o] = l = []), l.push(h))
                    }
                    var c = [];
                    for (var p in n) c.push(Nh.CreateFromMorphTargetSequence(p, n[p], e, i));
                    return c
                },
                parseAnimation: function(t, e) {
                    if (!t) return null;
                    for (var i = function(t, e, i, n, r) {
                            var a, s;
                            0 !== i.length && (a = [], s = [], Sh.flattenJSON(i, a, s, n), 0 !== a.length && r.push(new t(e, a, s)))
                        }, n = [], r = t.name || "default", a = t.fps || 30, s = t.blendMode, o = t.length || -1, l = t.hierarchy || [], h = 0; h < l.length; h++) {
                        var u = l[h].keys;
                        if (u && 0 !== u.length)
                            if (u[0].morphTargets) {
                                for (var c = {}, p = void 0, p = 0; p < u.length; p++)
                                    if (u[p].morphTargets)
                                        for (var d = 0; d < u[p].morphTargets.length; d++) c[u[p].morphTargets[d]] = -1;
                                for (var f in c) {
                                    for (var m = [], g = [], v = 0; v !== u[p].morphTargets.length; ++v) {
                                        var y = u[p];
                                        m.push(y.time), g.push(y.morphTarget === f ? 1 : 0)
                                    }
                                    n.push(new Lh(".morphTargetInfluence[" + f + "]", m, g))
                                }
                                o = c.length * (a || 1)
                            } else {
                                var b = ".bones[" + e[h].name + "]";
                                i(Ih, b + ".position", u, "pos", n), i(Oh, b + ".quaternion", u, "rot", n), i(Ih, b + ".scale", u, "scl", n)
                            }
                    }
                    return 0 === n.length ? null : new Nh(r, o, n, s)
                }
            }), Object.assign(Nh.prototype, {
                resetDuration: function() {
                    for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) var n = this.tracks[e],
                        t = Math.max(t, n.times[n.times.length - 1]);
                    return this.duration = t, this
                },
                trim: function() {
                    for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                    return this
                },
                validate: function() {
                    for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                    return t
                },
                optimize: function() {
                    for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                    return this
                },
                clone: function() {
                    for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                    return new Nh(this.name, this.duration, t, this.blendMode)
                }
            });
            var Rh = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };

            function zh(t, e, i) {
                var n = this,
                    r = !1,
                    a = 0,
                    s = 0,
                    o = void 0,
                    l = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                    s++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, s), r = !0
                }, this.itemEnd = function(t) {
                    a++, void 0 !== n.onProgress && n.onProgress(t, a, s), a === s && (r = !1, void 0 !== n.onLoad && n.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== n.onError && n.onError(t)
                }, this.resolveURL = function(t) {
                    return o ? o(t) : t
                }, this.setURLModifier = function(t) {
                    return o = t, this
                }, this.addHandler = function(t, e) {
                    return l.push(t, e), this
                }, this.removeHandler = function(t) {
                    var e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2), this
                }, this.getHandler = function(t) {
                    for (var e = 0, i = l.length; e < i; e += 2) {
                        var n = l[e],
                            r = l[e + 1];
                        if (n.global && (n.lastIndex = 0), n.test(t)) return r
                    }
                    return null
                }
            }
            var Gh = new zh;

            function Vh(t) {
                this.manager = void 0 !== t ? t : Gh, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            Object.assign(Vh.prototype, {
                load: function() {},
                loadAsync: function(i, n) {
                    var r = this;
                    return new Promise(function(t, e) {
                        r.load(i, t, n, e)
                    })
                },
                parse: function() {},
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            });
            var Uh = {};

            function jh(t) {
                Vh.call(this, t)
            }

            function Hh(t) {
                Vh.call(this, t)
            }

            function Wh(t) {
                Vh.call(this, t)
            }

            function qh(t) {
                Vh.call(this, t)
            }

            function Xh(t) {
                Vh.call(this, t)
            }

            function Yh(t) {
                Vh.call(this, t)
            }

            function Jh(t) {
                Vh.call(this, t)
            }

            function Zh() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function $h(t, e, i, n, r, a, s, o) {
                Zh.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = o || 0
            }

            function Kh(t, e, i, n, r, a) {
                $h.call(this, t, e, i, i, n, r, a), this.type = "ArcCurve"
            }

            function Qh() {
                var r = 0,
                    a = 0,
                    s = 0,
                    o = 0;

                function h(t, e, i, n) {
                    s = -3 * (r = t) + 3 * e - 2 * (a = i) - n, o = 2 * t - 2 * e + i + n
                }
                return {
                    initCatmullRom: function(t, e, i, n, r) {
                        h(e, i, r * (i - t), r * (n - e))
                    },
                    initNonuniformCatmullRom: function(t, e, i, n, r, a, s) {
                        var o = (e - t) / r - (i - t) / (r + a) + (i - e) / a,
                            l = (i - e) / a - (n - e) / (a + s) + (n - i) / s;
                        h(e, i, o *= a, l *= a)
                    },
                    calc: function(t) {
                        var e = t * t;
                        return r + a * t + s * e + o * (e * t)
                    }
                }
            }
            jh.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: jh,
                load: function(h, t, e, i) {
                    void 0 === h && (h = ""), void 0 !== this.path && (h = this.path + h), h = this.manager.resolveURL(h);
                    var u = this,
                        n = Rh.get(h);
                    if (void 0 !== n) return u.manager.itemStart(h), setTimeout(function() {
                        t && t(n), u.manager.itemEnd(h)
                    }, 0), n;
                    if (void 0 === Uh[h]) {
                        var r, a = h.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (a) {
                            var s = a[1],
                                o = !!a[2],
                                l = a[3],
                                l = decodeURIComponent(l);
                            o && (l = atob(l));
                            try {
                                var c = (this.responseType || "").toLowerCase();
                                switch (c) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var p = new Uint8Array(l.length), d = 0; d < l.length; d++) p[d] = l.charCodeAt(d);
                                        f = "blob" === c ? new Blob([p.buffer], {
                                            type: s
                                        }) : p.buffer;
                                        break;
                                    case "document":
                                        var f = (new DOMParser).parseFromString(l, s);
                                        break;
                                    case "json":
                                        f = JSON.parse(l);
                                        break;
                                    default:
                                        f = l
                                }
                                setTimeout(function() {
                                    t && t(f), u.manager.itemEnd(h)
                                }, 0)
                            } catch (t) {
                                setTimeout(function() {
                                    i && i(t), u.manager.itemError(h), u.manager.itemEnd(h)
                                }, 0)
                            }
                        } else {
                            for (var m in Uh[h] = [], Uh[h].push({
                                    onLoad: t,
                                    onProgress: e,
                                    onError: i
                                }), (r = new XMLHttpRequest).open("GET", h, !0), r.addEventListener("load", function(t) {
                                    var e = this.response,
                                        i = Uh[h];
                                    if (delete Uh[h], 200 === this.status || 0 === this.status) {
                                        this.status, Rh.add(h, e);
                                        for (var n = 0, r = i.length; n < r; n++) {
                                            var a = i[n];
                                            a.onLoad && a.onLoad(e)
                                        }
                                        u.manager.itemEnd(h)
                                    } else {
                                        for (var s = 0, o = i.length; s < o; s++) {
                                            var l = i[s];
                                            l.onError && l.onError(t)
                                        }
                                        u.manager.itemError(h), u.manager.itemEnd(h)
                                    }
                                }, !1), r.addEventListener("progress", function(t) {
                                    for (var e = Uh[h], i = 0, n = e.length; i < n; i++) {
                                        var r = e[i];
                                        r.onProgress && r.onProgress(t)
                                    }
                                }, !1), r.addEventListener("error", function(t) {
                                    var e = Uh[h];
                                    delete Uh[h];
                                    for (var i = 0, n = e.length; i < n; i++) {
                                        var r = e[i];
                                        r.onError && r.onError(t)
                                    }
                                    u.manager.itemError(h), u.manager.itemEnd(h)
                                }, !1), r.addEventListener("abort", function(t) {
                                    var e = Uh[h];
                                    delete Uh[h];
                                    for (var i = 0, n = e.length; i < n; i++) {
                                        var r = e[i];
                                        r.onError && r.onError(t)
                                    }
                                    u.manager.itemError(h), u.manager.itemEnd(h)
                                }, !1), void 0 !== this.responseType && (r.responseType = this.responseType), void 0 !== this.withCredentials && (r.withCredentials = this.withCredentials), r.overrideMimeType && r.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) r.setRequestHeader(m, this.requestHeader[m]);
                            r.send(null)
                        }
                        return u.manager.itemStart(h), r
                    }
                    Uh[h].push({
                        onLoad: t,
                        onProgress: e,
                        onError: i
                    })
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                }
            }), Hh.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: Hh,
                load: function(e, i, t, n) {
                    var r = this,
                        a = new jh(r.manager);
                    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.load(e, function(t) {
                        try {
                            i(r.parse(JSON.parse(t)))
                        } catch (t) {
                            n && n(t), r.manager.itemError(e)
                        }
                    }, t, n)
                },
                parse: function(t) {
                    for (var e = [], i = 0; i < t.length; i++) {
                        var n = Nh.parse(t[i]);
                        e.push(n)
                    }
                    return e
                }
            }), Wh.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: Wh,
                load: function(t, a, e, n) {
                    var s = this,
                        o = [],
                        l = new el;
                    l.image = o;
                    var r = new jh(this.manager);
                    r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader);
                    var h = 0;
                    if (Array.isArray(t))
                        for (var i = 0, u = t.length; i < u; ++i) ! function(i) {
                            r.load(t[i], function(t) {
                                var e = s.parse(t, !0);
                                o[i] = {
                                    width: e.width,
                                    height: e.height,
                                    format: e.format,
                                    mipmaps: e.mipmaps
                                }, 6 === (h += 1) && (1 === e.mipmapCount && (l.minFilter = Rt), l.format = e.format, l.needsUpdate = !0, a && a(l))
                            }, e, n)
                        }(i);
                    else r.load(t, function(t) {
                        var e = s.parse(t, !0);
                        if (e.isCubemap)
                            for (var i = e.mipmaps.length / e.mipmapCount, n = 0; n < i; n++) {
                                o[n] = {
                                    mipmaps: []
                                };
                                for (var r = 0; r < e.mipmapCount; r++) o[n].mipmaps.push(e.mipmaps[n * e.mipmapCount + r]), o[n].format = e.format, o[n].width = e.width, o[n].height = e.height
                            } else l.image.width = e.width, l.image.height = e.height, l.mipmaps = e.mipmaps;
                        1 === e.mipmapCount && (l.minFilter = Rt), l.format = e.format, l.needsUpdate = !0, a && a(l)
                    }, e, n);
                    return l
                }
            }), qh.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: qh,
                load: function(e, t, i, n) {
                    void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var r = this,
                        a = Rh.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function() {
                        t && t(a), r.manager.itemEnd(e)
                    }, 0), a;
                    var s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function o() {
                        s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1), Rh.add(e, this), t && t(this), r.manager.itemEnd(e)
                    }

                    function l(t) {
                        s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1), n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    }
                    return s.addEventListener("load", o, !1), s.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(e), s.src = e, s
                }
            }), Xh.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: Xh,
                load: function(t, i, e, n) {
                    var r = new oa,
                        a = new qh(this.manager);
                    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                    var s = 0;
                    for (var o = 0; o < t.length; ++o) ! function(e) {
                        a.load(t[e], function(t) {
                            r.images[e] = t, 6 === ++s && (r.needsUpdate = !0, i && i(r))
                        }, void 0, n)
                    }(o);
                    return r
                }
            }), Yh.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: Yh,
                load: function(t, i, e, n) {
                    var r = this,
                        a = new Nr,
                        s = new jh(this.manager);
                    return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.load(t, function(t) {
                        var e = r.parse(t);
                        e && (void 0 !== e.image ? a.image = e.image : void 0 !== e.data && (a.image.width = e.width, a.image.height = e.height, a.image.data = e.data), a.wrapS = void 0 !== e.wrapS ? e.wrapS : Ot, a.wrapT = void 0 !== e.wrapT ? e.wrapT : Ot, a.magFilter = void 0 !== e.magFilter ? e.magFilter : Rt, a.minFilter = void 0 !== e.minFilter ? e.minFilter : Rt, a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (a.format = e.format), void 0 !== e.type && (a.type = e.type), void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps, a.minFilter = Gt), 1 === e.mipmapCount && (a.minFilter = Rt), a.needsUpdate = !0, i && i(a, e))
                    }, e, n), a
                }
            }), Jh.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: Jh,
                load: function(i, n, t, e) {
                    var r = new Ze,
                        a = new qh(this.manager);
                    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(i, function(t) {
                        r.image = t;
                        var e = 0 < i.search(/\.jpe?g($|\?)/i) || 0 === i.search(/^data\:image\/jpeg/);
                        r.format = e ? Xt : Yt, r.needsUpdate = !0, void 0 !== n && n(r)
                    }, t, e), r
                }
            }), Object.assign(Zh.prototype, {
                getPoint: function() {
                    return null
                },
                getPointAt: function(t, e) {
                    var i = this.getUtoTmapping(t);
                    return this.getPoint(i, e)
                },
                getPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                    return e
                },
                getLength: function() {
                    var t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var e, i = [],
                        n = this.getPoint(0),
                        r = 0;
                    i.push(0);
                    for (var a = 1; a <= t; a++) r += (e = this.getPoint(a / t)).distanceTo(n), i.push(r), n = e;
                    return this.cacheArcLengths = i
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    for (var i, n = this.getLengths(), r = 0, a = n.length, s = e || t * n[a - 1], o = 0, l = a - 1; o <= l;)
                        if ((i = n[r = Math.floor(o + (l - o) / 2)] - s) < 0) o = r + 1;
                        else {
                            if (!(0 < i)) {
                                l = r;
                                break
                            }
                            l = r - 1
                        }
                    if (n[r = l] === s) return r / (a - 1);
                    var h = n[r];
                    return (r + (s - h) / (n[r + 1] - h)) / (a - 1)
                },
                getTangent: function(t, e) {
                    var i = t - 1e-4,
                        n = t + 1e-4;
                    i < 0 && (i = 0), 1 < n && (n = 1);
                    var r = this.getPoint(i),
                        a = this.getPoint(n),
                        s = e || new(r.isVector2 ? He : ni);
                    return s.copy(a).sub(r).normalize(), s
                },
                getTangentAt: function(t, e) {
                    var i = this.getUtoTmapping(t);
                    return this.getTangent(i, e)
                },
                computeFrenetFrames: function(t, e) {
                    for (var i = new ni, n = [], r = [], a = [], s = new ni, o = new Li, l = 0; l <= t; l++) {
                        var h = l / t;
                        n[l] = this.getTangentAt(h, new ni), n[l].normalize()
                    }
                    r[0] = new ni, a[0] = new ni;
                    var u = Number.MAX_VALUE,
                        c = Math.abs(n[0].x),
                        p = Math.abs(n[0].y),
                        d = Math.abs(n[0].z);
                    c <= u && (u = c, i.set(1, 0, 0)), p <= u && (u = p, i.set(0, 1, 0)), d <= u && i.set(0, 0, 1), s.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], s), a[0].crossVectors(n[0], r[0]);
                    for (var f, m = 1; m <= t; m++) {
                        r[m] = r[m - 1].clone(), a[m] = a[m - 1].clone(), s.crossVectors(n[m - 1], n[m]), s.length() > Number.EPSILON && (s.normalize(), f = Math.acos(je.clamp(n[m - 1].dot(n[m]), -1, 1)), r[m].applyMatrix4(o.makeRotationAxis(s, f))), a[m].crossVectors(n[m], r[m])
                    }
                    if (!0 === e) {
                        var g = Math.acos(je.clamp(r[0].dot(r[t]), -1, 1));
                        g /= t, 0 < n[0].dot(s.crossVectors(r[0], r[t])) && (g = -g);
                        for (var v = 1; v <= t; v++) r[v].applyMatrix4(o.makeRotationAxis(n[v], g * v)), a[v].crossVectors(n[v], r[v])
                    }
                    return {
                        tangents: n,
                        normals: r,
                        binormals: a
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }), (($h.prototype = Object.create(Zh.prototype)).constructor = $h).prototype.isEllipseCurve = !0, $h.prototype.getPoint = function(t, e) {
                for (var i = e || new He, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; r < 0;) r += n;
                for (; n < r;) r -= n;
                r < Number.EPSILON && (r = a ? 0 : n), !0 !== this.aClockwise || a || (r === n ? r = -n : r -= n);
                var s, o, l, h, u = this.aStartAngle + t * r,
                    c = this.aX + this.xRadius * Math.cos(u),
                    p = this.aY + this.yRadius * Math.sin(u);
                return 0 !== this.aRotation && (s = Math.cos(this.aRotation), o = Math.sin(this.aRotation), c = (l = c - this.aX) * s - (h = p - this.aY) * o + this.aX, p = l * o + h * s + this.aY), i.set(c, p)
            }, $h.prototype.copy = function(t) {
                return Zh.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, $h.prototype.toJSON = function() {
                var t = Zh.prototype.toJSON.call(this);
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }, $h.prototype.fromJSON = function(t) {
                return Zh.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, ((Kh.prototype = Object.create($h.prototype)).constructor = Kh).prototype.isArcCurve = !0;
            var tu = new ni,
                eu = new Qh,
                iu = new Qh,
                nu = new Qh;

            function ru(t, e, i, n) {
                Zh.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = void 0 !== n ? n : .5
            }

            function au(t, e, i, n, r) {
                var a = .5 * (n - e),
                    s = .5 * (r - i),
                    o = t * t;
                return (2 * i - 2 * n + a + s) * (t * o) + (-3 * i + 3 * n - 2 * a - s) * o + a * t + i
            }

            function su(t, e, i, n) {
                return (s = 1 - t) * s * e + 2 * (1 - (a = t)) * a * i + (r = t) * r * n;
                var r, a, s
            }

            function ou(t, e, i, n, r) {
                return (h = 1 - t) * h * h * e + 3 * (l = 1 - (o = t)) * l * o * i + 3 * (1 - (s = t)) * s * s * n + (a = t) * a * a * r;
                var a, s, o, l, h
            }

            function lu(t, e, i, n) {
                Zh.call(this), this.type = "CubicBezierCurve", this.v0 = t || new He, this.v1 = e || new He, this.v2 = i || new He, this.v3 = n || new He
            }

            function hu(t, e, i, n) {
                Zh.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new ni, this.v1 = e || new ni, this.v2 = i || new ni, this.v3 = n || new ni
            }

            function uu(t, e) {
                Zh.call(this), this.type = "LineCurve", this.v1 = t || new He, this.v2 = e || new He
            }

            function cu(t, e) {
                Zh.call(this), this.type = "LineCurve3", this.v1 = t || new ni, this.v2 = e || new ni
            }

            function pu(t, e, i) {
                Zh.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new He, this.v1 = e || new He, this.v2 = i || new He
            }

            function du(t, e, i) {
                Zh.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new ni, this.v1 = e || new ni, this.v2 = i || new ni
            }

            function fu(t) {
                Zh.call(this), this.type = "SplineCurve", this.points = t || []
            }((ru.prototype = Object.create(Zh.prototype)).constructor = ru).prototype.isCatmullRomCurve3 = !0, ru.prototype.getPoint = function(t, e) {
                var i, n = e || new ni,
                    r = this.points,
                    a = r.length,
                    s = (a - (this.closed ? 0 : 1)) * t,
                    o = Math.floor(s),
                    l = s - o;
                this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / a) + 1) * a : 0 === l && o === a - 1 && (o = a - 2, l = 1), i = this.closed || 0 < o ? r[(o - 1) % a] : (tu.subVectors(r[0], r[1]).add(r[0]), tu);
                var h, u, c, p, d = r[o % a],
                    f = r[(o + 1) % a],
                    m = this.closed || o + 2 < a ? r[(o + 2) % a] : (tu.subVectors(r[a - 1], r[a - 2]).add(r[a - 1]), tu);
                return "centripetal" === this.curveType || "chordal" === this.curveType ? (h = "chordal" === this.curveType ? .5 : .25, u = Math.pow(i.distanceToSquared(d), h), (c = Math.pow(d.distanceToSquared(f), h)) < 1e-4 && (c = 1), u < 1e-4 && (u = c), (p = Math.pow(f.distanceToSquared(m), h)) < 1e-4 && (p = c), eu.initNonuniformCatmullRom(i.x, d.x, f.x, m.x, u, c, p), iu.initNonuniformCatmullRom(i.y, d.y, f.y, m.y, u, c, p), nu.initNonuniformCatmullRom(i.z, d.z, f.z, m.z, u, c, p)) : "catmullrom" === this.curveType && (eu.initCatmullRom(i.x, d.x, f.x, m.x, this.tension), iu.initCatmullRom(i.y, d.y, f.y, m.y, this.tension), nu.initCatmullRom(i.z, d.z, f.z, m.z, this.tension)), n.set(eu.calc(l), iu.calc(l), nu.calc(l)), n
            }, ru.prototype.copy = function(t) {
                Zh.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, ru.prototype.toJSON = function() {
                var t = Zh.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, i = this.points.length; e < i; e++) {
                    var n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }, ru.prototype.fromJSON = function(t) {
                Zh.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push((new ni).fromArray(n))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, ((lu.prototype = Object.create(Zh.prototype)).constructor = lu).prototype.isCubicBezierCurve = !0, lu.prototype.getPoint = function(t, e) {
                var i = e || new He,
                    n = this.v0,
                    r = this.v1,
                    a = this.v2,
                    s = this.v3;
                return i.set(ou(t, n.x, r.x, a.x, s.x), ou(t, n.y, r.y, a.y, s.y)), i
            }, lu.prototype.copy = function(t) {
                return Zh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, lu.prototype.toJSON = function() {
                var t = Zh.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, lu.prototype.fromJSON = function(t) {
                return Zh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, ((hu.prototype = Object.create(Zh.prototype)).constructor = hu).prototype.isCubicBezierCurve3 = !0, hu.prototype.getPoint = function(t, e) {
                var i = e || new ni,
                    n = this.v0,
                    r = this.v1,
                    a = this.v2,
                    s = this.v3;
                return i.set(ou(t, n.x, r.x, a.x, s.x), ou(t, n.y, r.y, a.y, s.y), ou(t, n.z, r.z, a.z, s.z)), i
            }, hu.prototype.copy = function(t) {
                return Zh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, hu.prototype.toJSON = function() {
                var t = Zh.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, hu.prototype.fromJSON = function(t) {
                return Zh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, ((uu.prototype = Object.create(Zh.prototype)).constructor = uu).prototype.isLineCurve = !0, uu.prototype.getPoint = function(t, e) {
                var i = e || new He;
                return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
            }, uu.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, uu.prototype.getTangent = function(t, e) {
                var i = e || new He;
                return i.copy(this.v2).sub(this.v1).normalize(), i
            }, uu.prototype.copy = function(t) {
                return Zh.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, uu.prototype.toJSON = function() {
                var t = Zh.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, uu.prototype.fromJSON = function(t) {
                return Zh.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, ((cu.prototype = Object.create(Zh.prototype)).constructor = cu).prototype.isLineCurve3 = !0, cu.prototype.getPoint = function(t, e) {
                var i = e || new ni;
                return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
            }, cu.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, cu.prototype.copy = function(t) {
                return Zh.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, cu.prototype.toJSON = function() {
                var t = Zh.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, cu.prototype.fromJSON = function(t) {
                return Zh.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, ((pu.prototype = Object.create(Zh.prototype)).constructor = pu).prototype.isQuadraticBezierCurve = !0, pu.prototype.getPoint = function(t, e) {
                var i = e || new He,
                    n = this.v0,
                    r = this.v1,
                    a = this.v2;
                return i.set(su(t, n.x, r.x, a.x), su(t, n.y, r.y, a.y)), i
            }, pu.prototype.copy = function(t) {
                return Zh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, pu.prototype.toJSON = function() {
                var t = Zh.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, pu.prototype.fromJSON = function(t) {
                return Zh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, ((du.prototype = Object.create(Zh.prototype)).constructor = du).prototype.isQuadraticBezierCurve3 = !0, du.prototype.getPoint = function(t, e) {
                var i = e || new ni,
                    n = this.v0,
                    r = this.v1,
                    a = this.v2;
                return i.set(su(t, n.x, r.x, a.x), su(t, n.y, r.y, a.y), su(t, n.z, r.z, a.z)), i
            }, du.prototype.copy = function(t) {
                return Zh.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, du.prototype.toJSON = function() {
                var t = Zh.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, du.prototype.fromJSON = function(t) {
                return Zh.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, ((fu.prototype = Object.create(Zh.prototype)).constructor = fu).prototype.isSplineCurve = !0, fu.prototype.getPoint = function(t, e) {
                var i = e || new He,
                    n = this.points,
                    r = (n.length - 1) * t,
                    a = Math.floor(r),
                    s = r - a,
                    o = n[0 === a ? a : a - 1],
                    l = n[a],
                    h = n[a > n.length - 2 ? n.length - 1 : a + 1],
                    u = n[a > n.length - 3 ? n.length - 1 : a + 2];
                return i.set(au(s, o.x, l.x, h.x, u.x), au(s, o.y, l.y, h.y, u.y)), i
            }, fu.prototype.copy = function(t) {
                Zh.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }, fu.prototype.toJSON = function() {
                var t = Zh.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, i = this.points.length; e < i; e++) {
                    var n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }, fu.prototype.fromJSON = function(t) {
                Zh.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push((new He).fromArray(n))
                }
                return this
            };
            var mu = Object.freeze({
                __proto__: null,
                ArcCurve: Kh,
                CatmullRomCurve3: ru,
                CubicBezierCurve: lu,
                CubicBezierCurve3: hu,
                EllipseCurve: $h,
                LineCurve: uu,
                LineCurve3: cu,
                QuadraticBezierCurve: pu,
                QuadraticBezierCurve3: du,
                SplineCurve: fu
            });

            function gu() {
                Zh.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function vu(t) {
                gu.call(this), this.type = "Path", this.currentPoint = new He, t && this.setFromPoints(t)
            }

            function yu(t) {
                vu.call(this, t), this.uuid = je.generateUUID(), this.type = "Shape", this.holes = []
            }

            function bu(t, e) {
                rn.call(this), this.type = "Light", this.color = new Cn(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
            }

            function xu(t, e, i) {
                bu.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(rn.DefaultUp), this.updateMatrix(), this.groundColor = new Cn(e)
            }

            function _u(t) {
                this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new He(512, 512), this.map = null, this.mapPass = null, this.matrix = new Li, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new zr, this._frameExtents = new He(1, 1), this._viewportCount = 1, this._viewports = [new $e(0, 0, 1, 1)]
            }

            function wu() {
                _u.call(this, new Or(50, 1, .5, 500))
            }

            function Su(t, e, i, n, r, a) {
                bu.call(this, t, e), this.type = "SpotLight", this.position.copy(rn.DefaultUp), this.updateMatrix(), this.target = new rn, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new wu
            }

            function Mu() {
                _u.call(this, new Or(90, 1, .5, 500)), this._frameExtents = new He(4, 2), this._viewportCount = 6, this._viewports = [new $e(2, 1, 1, 1), new $e(0, 1, 1, 1), new $e(3, 1, 1, 1), new $e(1, 1, 1, 1), new $e(3, 0, 1, 1), new $e(1, 0, 1, 1)], this._cubeDirections = [new ni(1, 0, 0), new ni(-1, 0, 0), new ni(0, 0, 1), new ni(0, 0, -1), new ni(0, 1, 0), new ni(0, -1, 0)], this._cubeUps = [new ni(0, 1, 0), new ni(0, 1, 0), new ni(0, 1, 0), new ni(0, 1, 0), new ni(0, 0, 1), new ni(0, 0, -1)]
            }

            function Tu(t, e, i, n) {
                bu.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new Mu
            }

            function Cu(t, e, i, n, r, a) {
                kr.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
            }

            function Au() {
                _u.call(this, new Cu(-5, 5, 5, -5, .5, 500))
            }

            function Eu(t, e) {
                bu.call(this, t, e), this.type = "DirectionalLight", this.position.copy(rn.DefaultUp), this.updateMatrix(), this.target = new rn, this.shadow = new Au
            }

            function Du(t, e) {
                bu.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
            }

            function Pu(t, e, i, n) {
                bu.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
            }
            gu.prototype = Object.assign(Object.create(Zh.prototype), {
                constructor: gu,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    var t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new uu(e, t))
                },
                getPoint: function(t) {
                    for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) {
                        if (i[n] >= e) {
                            var r = i[n] - e,
                                a = this.curves[n],
                                s = a.getLength(),
                                o = 0 === s ? 0 : 1 - r / s;
                            return a.getPointAt(o)
                        }
                        n++
                    }
                    return null
                },
                getLength: function() {
                    var t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                    return this.cacheLengths = t
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 40);
                    for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return this.autoClose && e.push(e[0]), e
                },
                getPoints: function(t) {
                    t = t || 12;
                    for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
                        for (var a = r[n], s = a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t, o = a.getPoints(s), l = 0; l < o.length; l++) {
                            var h = o[l];
                            e && e.equals(h) || (i.push(h), e = h)
                        }
                    return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
                },
                copy: function(t) {
                    Zh.prototype.copy.call(this, t), this.curves = [];
                    for (var e = 0, i = t.curves.length; e < i; e++) {
                        var n = t.curves[e];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = t.autoClose, this
                },
                toJSON: function() {
                    var t = Zh.prototype.toJSON.call(this);
                    t.autoClose = this.autoClose, t.curves = [];
                    for (var e = 0, i = this.curves.length; e < i; e++) {
                        var n = this.curves[e];
                        t.curves.push(n.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    Zh.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                    for (var e = 0, i = t.curves.length; e < i; e++) {
                        var n = t.curves[e];
                        this.curves.push((new mu[n.type]).fromJSON(n))
                    }
                    return this
                }
            }), vu.prototype = Object.assign(Object.create(gu.prototype), {
                constructor: vu,
                setFromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
                    return this
                },
                moveTo: function(t, e) {
                    return this.currentPoint.set(t, e), this
                },
                lineTo: function(t, e) {
                    var i = new uu(this.currentPoint.clone(), new He(t, e));
                    return this.curves.push(i), this.currentPoint.set(t, e), this
                },
                quadraticCurveTo: function(t, e, i, n) {
                    var r = new pu(this.currentPoint.clone(), new He(t, e), new He(i, n));
                    return this.curves.push(r), this.currentPoint.set(i, n), this
                },
                bezierCurveTo: function(t, e, i, n, r, a) {
                    var s = new lu(this.currentPoint.clone(), new He(t, e), new He(i, n), new He(r, a));
                    return this.curves.push(s), this.currentPoint.set(r, a), this
                },
                splineThru: function(t) {
                    var e = new fu([this.currentPoint.clone()].concat(t));
                    return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
                },
                arc: function(t, e, i, n, r, a) {
                    var s = this.currentPoint.x,
                        o = this.currentPoint.y;
                    return this.absarc(t + s, e + o, i, n, r, a), this
                },
                absarc: function(t, e, i, n, r, a) {
                    return this.absellipse(t, e, i, i, n, r, a), this
                },
                ellipse: function(t, e, i, n, r, a, s, o) {
                    var l = this.currentPoint.x,
                        h = this.currentPoint.y;
                    return this.absellipse(t + l, e + h, i, n, r, a, s, o), this
                },
                absellipse: function(t, e, i, n, r, a, s, o) {
                    var l, h = new $h(t, e, i, n, r, a, s, o);
                    0 < this.curves.length && ((l = h.getPoint(0)).equals(this.currentPoint) || this.lineTo(l.x, l.y)), this.curves.push(h);
                    var u = h.getPoint(1);
                    return this.currentPoint.copy(u), this
                },
                copy: function(t) {
                    return gu.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
                },
                toJSON: function() {
                    var t = gu.prototype.toJSON.call(this);
                    return t.currentPoint = this.currentPoint.toArray(), t
                },
                fromJSON: function(t) {
                    return gu.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }), yu.prototype = Object.assign(Object.create(vu.prototype), {
                constructor: yu,
                getPointsHoles: function(t) {
                    for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                    return e
                },
                extractPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                copy: function(t) {
                    vu.prototype.copy.call(this, t), this.holes = [];
                    for (var e = 0, i = t.holes.length; e < i; e++) {
                        var n = t.holes[e];
                        this.holes.push(n.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var t = vu.prototype.toJSON.call(this);
                    t.uuid = this.uuid, t.holes = [];
                    for (var e = 0, i = this.holes.length; e < i; e++) {
                        var n = this.holes[e];
                        t.holes.push(n.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    vu.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                    for (var e = 0, i = t.holes.length; e < i; e++) {
                        var n = t.holes[e];
                        this.holes.push((new vu).fromJSON(n))
                    }
                    return this
                }
            }), bu.prototype = Object.assign(Object.create(rn.prototype), {
                constructor: bu,
                isLight: !0,
                copy: function(t) {
                    return rn.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    var e = rn.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }), xu.prototype = Object.assign(Object.create(bu.prototype), {
                constructor: xu,
                isHemisphereLight: !0,
                copy: function(t) {
                    return bu.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }), Object.assign(_u.prototype, {
                _projScreenMatrix: new Li,
                _lightPositionWorld: new ni,
                _lookTarget: new ni,
                getViewportCount: function() {
                    return this._viewportCount
                },
                getFrustum: function() {
                    return this._frustum
                },
                updateMatrices: function(t) {
                    var e = this.camera,
                        i = this.matrix,
                        n = this._projScreenMatrix,
                        r = this._lookTarget,
                        a = this._lightPositionWorld;
                    a.setFromMatrixPosition(t.matrixWorld), e.position.copy(a), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), n.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(n), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(e.projectionMatrix), i.multiply(e.matrixWorldInverse)
                },
                getViewport: function(t) {
                    return this._viewports[t]
                },
                getFrameExtents: function() {
                    return this._frameExtents
                },
                copy: function(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }), wu.prototype = Object.assign(Object.create(_u.prototype), {
                constructor: wu,
                isSpotLightShadow: !0,
                updateMatrices: function(t) {
                    var e = this.camera,
                        i = 2 * je.RAD2DEG * t.angle,
                        n = this.mapSize.width / this.mapSize.height,
                        r = t.distance || e.far;
                    i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix()), _u.prototype.updateMatrices.call(this, t)
                }
            }), Su.prototype = Object.assign(Object.create(bu.prototype), {
                constructor: Su,
                isSpotLight: !0,
                copy: function(t) {
                    return bu.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), Mu.prototype = Object.assign(Object.create(_u.prototype), {
                constructor: Mu,
                isPointLightShadow: !0,
                updateMatrices: function(t, e) {
                    void 0 === e && (e = 0);
                    var i = this.camera,
                        n = this.matrix,
                        r = this._lightPositionWorld,
                        a = this._lookTarget,
                        s = this._projScreenMatrix;
                    r.setFromMatrixPosition(t.matrixWorld), i.position.copy(r), a.copy(i.position), a.add(this._cubeDirections[e]), i.up.copy(this._cubeUps[e]), i.lookAt(a), i.updateMatrixWorld(), n.makeTranslation(-r.x, -r.y, -r.z), s.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s)
                }
            }), Tu.prototype = Object.assign(Object.create(bu.prototype), {
                constructor: Tu,
                isPointLight: !0,
                copy: function(t) {
                    return bu.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }), Cu.prototype = Object.assign(Object.create(kr.prototype), {
                constructor: Cu,
                isOrthographicCamera: !0,
                copy: function(t, e) {
                    return kr.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                },
                setViewOffset: function(t, e, i, n, r, a) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t, e, i = (this.right - this.left) / (2 * this.zoom),
                        n = (this.top - this.bottom) / (2 * this.zoom),
                        r = (this.right + this.left) / 2,
                        a = (this.top + this.bottom) / 2,
                        s = r - i,
                        o = r + i,
                        l = a + n,
                        h = a - n;
                    null !== this.view && this.view.enabled && (t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom, o = (s += t * this.view.offsetX) + t * this.view.width, h = (l -= e * this.view.offsetY) - e * this.view.height), this.projectionMatrix.makeOrthographic(s, o, l, h, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = rn.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }), Au.prototype = Object.assign(Object.create(_u.prototype), {
                constructor: Au,
                isDirectionalLightShadow: !0,
                updateMatrices: function(t) {
                    _u.prototype.updateMatrices.call(this, t)
                }
            }), Eu.prototype = Object.assign(Object.create(bu.prototype), {
                constructor: Eu,
                isDirectionalLight: !0,
                copy: function(t) {
                    return bu.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), Du.prototype = Object.assign(Object.create(bu.prototype), {
                constructor: Du,
                isAmbientLight: !0
            }), Pu.prototype = Object.assign(Object.create(bu.prototype), {
                constructor: Pu,
                isRectAreaLight: !0,
                copy: function(t) {
                    return bu.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
                },
                toJSON: function(t) {
                    var e = bu.prototype.toJSON.call(this, t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            });
            var Lu = function() {
                Object.defineProperty(this, "isSphericalHarmonics3", {
                    value: !0
                }), this.coefficients = [];
                for (var t = 0; t < 9; t++) this.coefficients.push(new ni)
            };

            function ku(t, e) {
                bu.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new Lu
            }

            function Ou(t) {
                Vh.call(this, t), this.textures = {}
            }
            Lu.prototype.set = function(t) {
                for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                return this
            }, Lu.prototype.zero = function() {
                for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                return this
            }, Lu.prototype.getAt = function(t, e) {
                var i = t.x,
                    n = t.y,
                    r = t.z,
                    a = this.coefficients;
                return e.copy(a[0]).multiplyScalar(.282095), e.addScaledVector(a[1], .488603 * n), e.addScaledVector(a[2], .488603 * r), e.addScaledVector(a[3], .488603 * i), e.addScaledVector(a[4], i * n * 1.092548), e.addScaledVector(a[5], n * r * 1.092548), e.addScaledVector(a[6], .315392 * (3 * r * r - 1)), e.addScaledVector(a[7], i * r * 1.092548), e.addScaledVector(a[8], .546274 * (i * i - n * n)), e
            }, Lu.prototype.getIrradianceAt = function(t, e) {
                var i = t.x,
                    n = t.y,
                    r = t.z,
                    a = this.coefficients;
                return e.copy(a[0]).multiplyScalar(.886227), e.addScaledVector(a[1], 1.023328 * n), e.addScaledVector(a[2], 1.023328 * r), e.addScaledVector(a[3], 1.023328 * i), e.addScaledVector(a[4], .858086 * i * n), e.addScaledVector(a[5], .858086 * n * r), e.addScaledVector(a[6], .743125 * r * r - .247708), e.addScaledVector(a[7], .858086 * i * r), e.addScaledVector(a[8], .429043 * (i * i - n * n)), e
            }, Lu.prototype.add = function(t) {
                for (var e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                return this
            }, Lu.prototype.addScaledSH = function(t, e) {
                for (var i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], e);
                return this
            }, Lu.prototype.scale = function(t) {
                for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                return this
            }, Lu.prototype.lerp = function(t, e) {
                for (var i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
                return this
            }, Lu.prototype.equals = function(t) {
                for (var e = 0; e < 9; e++)
                    if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                return !0
            }, Lu.prototype.copy = function(t) {
                return this.set(t.coefficients)
            }, Lu.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, Lu.prototype.fromArray = function(t, e) {
                void 0 === e && (e = 0);
                for (var i = this.coefficients, n = 0; n < 9; n++) i[n].fromArray(t, e + 3 * n);
                return this
            }, Lu.prototype.toArray = function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                for (var i = this.coefficients, n = 0; n < 9; n++) i[n].toArray(t, e + 3 * n);
                return t
            }, Lu.getBasisAt = function(t, e) {
                var i = t.x,
                    n = t.y,
                    r = t.z;
                e[0] = .282095, e[1] = .488603 * n, e[2] = .488603 * r, e[3] = .488603 * i, e[4] = 1.092548 * i * n, e[5] = 1.092548 * n * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * i * r, e[8] = .546274 * (i * i - n * n)
            }, ku.prototype = Object.assign(Object.create(bu.prototype), {
                constructor: ku,
                isLightProbe: !0,
                copy: function(t) {
                    return bu.prototype.copy.call(this, t), this.sh.copy(t.sh), this
                },
                fromJSON: function(t) {
                    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                },
                toJSON: function(t) {
                    var e = bu.prototype.toJSON.call(this, t);
                    return e.object.sh = this.sh.toArray(), e
                }
            }), Ou.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: Ou,
                load: function(e, i, t, n) {
                    var r = this,
                        a = new jh(r.manager);
                    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.load(e, function(t) {
                        try {
                            i(r.parse(JSON.parse(t)))
                        } catch (t) {
                            n && n(t), r.manager.itemError(e)
                        }
                    }, t, n)
                },
                parse: function(t) {
                    var e = this.textures;

                    function i(t) {
                        return e[t], e[t]
                    }
                    var n, r = new wh[t.type];
                    if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.sheen && (r.sheen = (new Cn).setHex(t.sheen)), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (r.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (r.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (r.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (r.morphNormals = t.morphNormals), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.vertexTangents && (r.vertexTangents = t.vertexTangents), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? r.vertexColors = 0 < t.vertexColors : r.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                        for (var a in t.uniforms) {
                            var s = t.uniforms[a];
                            switch (r.uniforms[a] = {}, s.type) {
                                case "t":
                                    r.uniforms[a].value = i(s.value);
                                    break;
                                case "c":
                                    r.uniforms[a].value = (new Cn).setHex(s.value);
                                    break;
                                case "v2":
                                    r.uniforms[a].value = (new He).fromArray(s.value);
                                    break;
                                case "v3":
                                    r.uniforms[a].value = (new ni).fromArray(s.value);
                                    break;
                                case "v4":
                                    r.uniforms[a].value = (new $e).fromArray(s.value);
                                    break;
                                case "m3":
                                    r.uniforms[a].value = (new Xe).fromArray(s.value);
                                    break;
                                case "m4":
                                    r.uniforms[a].value = (new Li).fromArray(s.value);
                                    break;
                                default:
                                    r.uniforms[a].value = s.value
                            }
                        }
                    if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                        for (var o in t.extensions) r.extensions[o] = t.extensions[o];
                    return void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = i(t.map)), void 0 !== t.matcap && (r.matcap = i(t.matcap)), void 0 !== t.alphaMap && (r.alphaMap = i(t.alphaMap)), void 0 !== t.bumpMap && (r.bumpMap = i(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = i(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale && (n = t.normalScale, !1 === Array.isArray(n) && (n = [n, n]), r.normalScale = (new He).fromArray(n)), void 0 !== t.displacementMap && (r.displacementMap = i(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = i(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = i(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = i(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = i(t.specularMap)), void 0 !== t.envMap && (r.envMap = i(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (r.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (r.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = i(t.gradientMap)), void 0 !== t.clearcoatMap && (r.clearcoatMap = i(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = i(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (r.clearcoatNormalMap = i(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (r.clearcoatNormalScale = (new He).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (r.transmission = t.transmission), void 0 !== t.transmissionMap && (r.transmissionMap = i(t.transmissionMap)), r
                },
                setTextures: function(t) {
                    return this.textures = t, this
                }
            });
            var Fu = {
                decodeText: function(t) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                    for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
                    try {
                        return decodeURIComponent(escape(e))
                    } catch (t) {
                        return e
                    }
                },
                extractUrlBase: function(t) {
                    var e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.substr(0, e + 1)
                }
            };

            function Iu() {
                Kn.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
            }

            function Nu(t, e, i, n) {
                "number" == typeof i && (n = i, i = !1), On.call(this, t, e, i), this.meshPerAttribute = n || 1
            }

            function Bu(t) {
                Vh.call(this, t)
            }
            Iu.prototype = Object.assign(Object.create(Kn.prototype), {
                constructor: Iu,
                isInstancedBufferGeometry: !0,
                copy: function(t) {
                    return Kn.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = Kn.prototype.toJSON.call(this);
                    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                }
            }), Nu.prototype = Object.assign(Object.create(On.prototype), {
                constructor: Nu,
                isInstancedBufferAttribute: !0,
                copy: function(t) {
                    return On.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                },
                toJSON: function() {
                    var t = On.prototype.toJSON.call(this);
                    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                }
            }), Bu.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: Bu,
                load: function(e, i, t, n) {
                    var r = this,
                        a = new jh(r.manager);
                    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.load(e, function(t) {
                        try {
                            i(r.parse(JSON.parse(t)))
                        } catch (t) {
                            n && n(t), r.manager.itemError(e)
                        }
                    }, t, n)
                },
                parse: function(t) {
                    var a = {},
                        s = {};

                    function e(t, e) {
                        if (void 0 !== a[e]) return a[e];
                        var i = t.interleavedBuffers[e],
                            n = function(t, e) {
                                if (void 0 !== s[e]) return s[e];
                                var i = t.arrayBuffers[e],
                                    n = new Uint32Array(i).buffer;
                                return s[e] = n
                            }(t, i.buffer),
                            r = new Ks(new Ru[i.type](n), i.stride);
                        return r.uuid = i.uuid, a[e] = r
                    }
                    var i, n = new(t.isInstancedBufferGeometry ? Iu : Kn),
                        r = t.data.index;
                    void 0 !== r && (i = new Ru[r.type](r.array), n.setIndex(new On(i, 1)));
                    var o = t.data.attributes;
                    for (var l in o) {
                        var h, u = o[l],
                            c = void 0;
                        c = u.isInterleavedBufferAttribute ? new eo(e(t.data, u.data), u.itemSize, u.offset, u.normalized) : (h = new Ru[u.type](u.array), new(u.isInstancedBufferAttribute ? Nu : On)(h, u.itemSize, u.normalized)), void 0 !== u.name && (c.name = u.name), n.setAttribute(l, c)
                    }
                    var p = t.data.morphAttributes;
                    if (p)
                        for (var d in p) {
                            for (var f = p[d], m = [], g = 0, v = f.length; g < v; g++) {
                                var y = f[g],
                                    b = void 0;
                                b = y.isInterleavedBufferAttribute ? new eo(e(t.data, y.data), y.itemSize, y.offset, y.normalized) : new On(new Ru[y.type](y.array), y.itemSize, y.normalized), void 0 !== y.name && (b.name = y.name), m.push(b)
                            }
                            n.morphAttributes[d] = m
                        }
                    t.data.morphTargetsRelative && (n.morphTargetsRelative = !0);
                    var x = t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== x)
                        for (var _ = 0, w = x.length; _ !== w; ++_) {
                            var S = x[_];
                            n.addGroup(S.start, S.count, S.materialIndex)
                        }
                    var M, T = t.data.boundingSphere;
                    return void 0 !== T && (M = new ni, void 0 !== T.center && M.fromArray(T.center), n.boundingSphere = new li(M, T.radius)), t.name && (n.name = t.name), t.userData && (n.userData = t.userData), n
                }
            });
            var Ru = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function zu(t) {
                Vh.call(this, t)
            }
            zu.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: zu,
                load: function(t, n, e, r) {
                    var a = this,
                        i = "" === this.path ? Fu.extractUrlBase(t) : this.path;
                    this.resourcePath = this.resourcePath || i;
                    var s = new jh(a.manager);
                    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.load(t, function(t) {
                        var e = null;
                        try {
                            e = JSON.parse(t)
                        } catch (t) {
                            return void(void 0 !== r && r(t))
                        }
                        var i = e.metadata;
                        void 0 !== i && void 0 !== i.type && "geometry" !== i.type.toLowerCase() && a.parse(e, n)
                    }, e, r)
                },
                parse: function(t, e) {
                    var i = this.parseShape(t.shapes),
                        n = this.parseGeometries(t.geometries, i),
                        r = this.parseImages(t.images, function() {
                            void 0 !== e && e(o)
                        }),
                        a = this.parseTextures(t.textures, r),
                        s = this.parseMaterials(t.materials, a),
                        o = this.parseObject(t.object, n, s);
                    return t.animations && (o.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(o), o
                },
                parseShape: function(t) {
                    var e = {};
                    if (void 0 !== t)
                        for (var i = 0, n = t.length; i < n; i++) {
                            var r = (new yu).fromJSON(t[i]);
                            e[r.uuid] = r
                        }
                    return e
                },
                parseGeometries: function(t, e) {
                    var i, n = {};
                    if (void 0 !== t)
                        for (var r = new Bu, a = 0, s = t.length; a < s; a++) {
                            var o = void 0,
                                l = t[a];
                            switch (l.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    o = new ch[l.type](l.width, l.height, l.widthSegments, l.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    o = new ch[l.type](l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    o = new ch[l.type](l.radius, l.segments, l.thetaStart, l.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    o = new ch[l.type](l.radiusTop, l.radiusBottom, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    o = new ch[l.type](l.radius, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    o = new ch[l.type](l.radius, l.widthSegments, l.heightSegments, l.phiStart, l.phiLength, l.thetaStart, l.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    o = new ch[l.type](l.radius, l.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    o = new ch[l.type](l.innerRadius, l.outerRadius, l.thetaSegments, l.phiSegments, l.thetaStart, l.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    o = new ch[l.type](l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    o = new ch[l.type](l.radius, l.tube, l.tubularSegments, l.radialSegments, l.p, l.q);
                                    break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    o = new ch[l.type]((new mu[l.path.type]).fromJSON(l.path), l.tubularSegments, l.radius, l.radialSegments, l.closed);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    o = new ch[l.type](l.points, l.segments, l.phiStart, l.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    o = new ch[l.type](l.vertices, l.indices, l.radius, l.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    i = [];
                                    for (var h = 0, u = l.shapes.length; h < u; h++) {
                                        var c = e[l.shapes[h]];
                                        i.push(c)
                                    }
                                    o = new ch[l.type](i, l.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    i = [];
                                    for (var p = 0, d = l.shapes.length; p < d; p++) {
                                        var f = e[l.shapes[p]];
                                        i.push(f)
                                    }
                                    var m = l.options.extrudePath;
                                    void 0 !== m && (l.options.extrudePath = (new mu[m.type]).fromJSON(m)), o = new ch[l.type](i, l.options);
                                    break;
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    o = r.parse(l);
                                    break;
                                case "Geometry":
                                    break;
                                default:
                                    continue
                            }
                            o.uuid = l.uuid, void 0 !== l.name && (o.name = l.name), !0 === o.isBufferGeometry && void 0 !== l.userData && (o.userData = l.userData), n[l.uuid] = o
                        }
                    return n
                },
                parseMaterials: function(t, e) {
                    var i = {},
                        n = {};
                    if (void 0 !== t) {
                        var r = new Ou;
                        r.setTextures(e);
                        for (var a = 0, s = t.length; a < s; a++) {
                            var o = t[a];
                            if ("MultiMaterial" === o.type) {
                                for (var l = [], h = 0; h < o.materials.length; h++) {
                                    var u = o.materials[h];
                                    void 0 === i[u.uuid] && (i[u.uuid] = r.parse(u)), l.push(i[u.uuid])
                                }
                                n[o.uuid] = l
                            } else void 0 === i[o.uuid] && (i[o.uuid] = r.parse(o)), n[o.uuid] = i[o.uuid]
                        }
                    }
                    return n
                },
                parseAnimations: function(t) {
                    for (var e = [], i = 0; i < t.length; i++) {
                        var n = t[i],
                            r = Nh.parse(n);
                        void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r)
                    }
                    return e
                },
                parseImages: function(t, e) {
                    var i = this,
                        n = {};

                    function r(t) {
                        return i.manager.itemStart(t), a.load(t, function() {
                            i.manager.itemEnd(t)
                        }, void 0, function() {
                            i.manager.itemError(t), i.manager.itemEnd(t)
                        })
                    }
                    if (void 0 !== t && 0 < t.length) {
                        var a, s = new zh(e);
                        (a = new qh(s)).setCrossOrigin(this.crossOrigin);
                        for (var o = 0, l = t.length; o < l; o++) {
                            var h = t[o],
                                u = h.url;
                            if (Array.isArray(u)) {
                                n[h.uuid] = [];
                                for (var c = 0, p = u.length; c < p; c++) {
                                    var d = u[c],
                                        f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : i.resourcePath + d;
                                    n[h.uuid].push(r(f))
                                }
                            } else {
                                var m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : i.resourcePath + h.url;
                                n[h.uuid] = r(m)
                            }
                        }
                    }
                    return n
                },
                parseTextures: function(t, e) {
                    function i(t, e) {
                        return "number" == typeof t ? t : e[t]
                    }
                    var n = {};
                    if (void 0 !== t)
                        for (var r = 0, a = t.length; r < a; r++) {
                            var s = t[r];
                            s.image, e[s.image];
                            var o = void 0;
                            (o = new(Array.isArray(e[s.image]) ? oa : Ze)(e[s.image])).needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = i(s.mapping, Vu)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = i(s.wrap[0], Uu), o.wrapT = i(s.wrap[1], Uu)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = i(s.minFilter, ju)), void 0 !== s.magFilter && (o.magFilter = i(s.magFilter, ju)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), n[s.uuid] = o
                        }
                    return n
                },
                parseObject: function(t, e, a) {
                    var i, n;

                    function r(t) {
                        return e[t], e[t]
                    }

                    function s(t) {
                        if (void 0 !== t) {
                            if (Array.isArray(t)) {
                                for (var e = [], i = 0, n = t.length; i < n; i++) {
                                    var r = t[i];
                                    a[r], e.push(a[r])
                                }
                                return e
                            }
                            return a[t], a[t]
                        }
                    }
                    switch (t.type) {
                        case "Scene":
                            o = new $s, void 0 !== t.background && Number.isInteger(t.background) && (o.background = new Cn(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? o.fog = new Zs(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (o.fog = new Js(t.fog.color, t.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            o = new Or(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (o.focus = t.focus), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.filmGauge && (o.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (o.filmOffset = t.filmOffset), void 0 !== t.view && (o.view = Object.assign({}, t.view));
                            break;
                        case "OrthographicCamera":
                            o = new Cu(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.view && (o.view = Object.assign({}, t.view));
                            break;
                        case "AmbientLight":
                            o = new Du(t.color, t.intensity);
                            break;
                        case "DirectionalLight":
                            o = new Eu(t.color, t.intensity);
                            break;
                        case "PointLight":
                            o = new Tu(t.color, t.intensity, t.distance, t.decay);
                            break;
                        case "RectAreaLight":
                            o = new Pu(t.color, t.intensity, t.width, t.height);
                            break;
                        case "SpotLight":
                            o = new Su(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                            break;
                        case "HemisphereLight":
                            o = new xu(t.color, t.groundColor, t.intensity);
                            break;
                        case "LightProbe":
                            o = (new ku).fromJSON(t);
                            break;
                        case "SkinnedMesh":
                        case "Mesh":
                            o = new gr(i = r(t.geometry), n = s(t.material));
                            break;
                        case "InstancedMesh":
                            i = r(t.geometry), n = s(t.material);
                            var o, l = t.count,
                                h = t.instanceMatrix;
                            (o = new Io(i, n, l)).instanceMatrix = new On(new Float32Array(h.array), 16);
                            break;
                        case "LOD":
                            o = new To;
                            break;
                        case "Line":
                            o = new Uo(r(t.geometry), s(t.material), t.mode);
                            break;
                        case "LineLoop":
                            o = new qo(r(t.geometry), s(t.material));
                            break;
                        case "LineSegments":
                            o = new Wo(r(t.geometry), s(t.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            o = new Ko(r(t.geometry), s(t.material));
                            break;
                        case "Sprite":
                            o = new go(s(t.material));
                            break;
                        case "Group":
                            o = new js;
                            break;
                        default:
                            o = new rn
                    }
                    if (o.uuid = t.uuid, void 0 !== t.name && (o.name = t.name), void 0 !== t.matrix ? (o.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (o.matrixAutoUpdate = t.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== t.position && o.position.fromArray(t.position), void 0 !== t.rotation && o.rotation.fromArray(t.rotation), void 0 !== t.quaternion && o.quaternion.fromArray(t.quaternion), void 0 !== t.scale && o.scale.fromArray(t.scale)), void 0 !== t.castShadow && (o.castShadow = t.castShadow), void 0 !== t.receiveShadow && (o.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (o.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (o.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (o.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && o.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (o.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (o.visible = t.visible), void 0 !== t.frustumCulled && (o.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (o.renderOrder = t.renderOrder), void 0 !== t.userData && (o.userData = t.userData), void 0 !== t.layers && (o.layers.mask = t.layers), void 0 !== t.children)
                        for (var u = t.children, c = 0; c < u.length; c++) o.add(this.parseObject(u[c], e, a));
                    if ("LOD" === t.type) {
                        void 0 !== t.autoUpdate && (o.autoUpdate = t.autoUpdate);
                        for (var p = t.levels, d = 0; d < p.length; d++) {
                            var f = p[d],
                                m = o.getObjectByProperty("uuid", f.object);
                            void 0 !== m && o.addLevel(m, f.distance)
                        }
                    }
                    return o
                }
            });
            var Gu, Vu = {
                    UVMapping: 300,
                    CubeReflectionMapping: Et,
                    CubeRefractionMapping: Dt,
                    EquirectangularReflectionMapping: u,
                    EquirectangularRefractionMapping: c,
                    CubeUVReflectionMapping: Pt,
                    CubeUVRefractionMapping: Lt
                },
                Uu = {
                    RepeatWrapping: kt,
                    ClampToEdgeWrapping: Ot,
                    MirroredRepeatWrapping: Ft
                },
                ju = {
                    NearestFilter: It,
                    NearestMipmapNearestFilter: Nt,
                    NearestMipmapLinearFilter: Bt,
                    LinearFilter: Rt,
                    LinearMipmapNearestFilter: zt,
                    LinearMipmapLinearFilter: Gt
                };

            function Hu(t) {
                Vh.call(this, t), this.options = {
                    premultiplyAlpha: "none"
                }
            }

            function Wu() {
                this.type = "ShapePath", this.color = new Cn, this.subPaths = [], this.currentPath = null
            }

            function qu(t) {
                this.type = "Font", this.data = t
            }

            function Xu(t) {
                Vh.call(this, t)
            }
            Hu.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: Hu,
                isImageBitmapLoader: !0,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(e, i, t, n) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var r = this,
                        a = Rh.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function() {
                        i && i(a), r.manager.itemEnd(e)
                    }, 0), a;
                    fetch(e).then(function(t) {
                        return t.blob()
                    }).then(function(t) {
                        return createImageBitmap(t, r.options)
                    }).then(function(t) {
                        Rh.add(e, t), i && i(t), r.manager.itemEnd(e)
                    }).catch(function(t) {
                        n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    }), r.manager.itemStart(e)
                }
            }), Object.assign(Wu.prototype, {
                moveTo: function(t, e) {
                    return this.currentPath = new vu, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
                },
                lineTo: function(t, e) {
                    return this.currentPath.lineTo(t, e), this
                },
                quadraticCurveTo: function(t, e, i, n) {
                    return this.currentPath.quadraticCurveTo(t, e, i, n), this
                },
                bezierCurveTo: function(t, e, i, n, r, a) {
                    return this.currentPath.bezierCurveTo(t, e, i, n, r, a), this
                },
                splineThru: function(t) {
                    return this.currentPath.splineThru(t), this
                },
                toShapes: function(t, e) {
                    function i(t) {
                        for (var e = [], i = 0, n = t.length; i < n; i++) {
                            var r = t[i],
                                a = new yu;
                            a.curves = r.curves, e.push(a)
                        }
                        return e
                    }
                    var n, r, a, s = Gl.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === e) return i(o);
                    var l = [];
                    if (1 === o.length) return r = o[0], (a = new yu).curves = r.curves, l.push(a), l;
                    var h, u = !s(o[0].getPoints()),
                        u = t ? !u : u,
                        c = [],
                        p = [],
                        d = [],
                        f = 0;
                    p[f] = void 0, d[f] = [];
                    for (var m, g = 0, v = o.length; g < v; g++) n = s(h = (r = o[g]).getPoints()), (n = t ? !n : n) ? (!u && p[f] && f++, p[f] = {
                        s: new yu,
                        p: h
                    }, p[f].s.curves = r.curves, u && f++, d[f] = []) : d[f].push({
                        h: r,
                        p: h[0]
                    });
                    if (!p[0]) return i(o);
                    if (1 < p.length) {
                        for (var y = !1, b = [], x = 0, _ = p.length; x < _; x++) c[x] = [];
                        for (var w = 0, S = p.length; w < S; w++)
                            for (var M = d[w], T = 0; T < M.length; T++) {
                                for (var C = M[T], A = !0, E = 0; E < p.length; E++) ! function(t, e) {
                                    for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
                                        var s = e[r],
                                            o = e[a],
                                            l = o.x - s.x,
                                            h = o.y - s.y;
                                        if (Math.abs(h) > Number.EPSILON) {
                                            if (h < 0 && (s = e[a], l = -l, o = e[r], h = -h), t.y < s.y || t.y > o.y) continue;
                                            if (t.y === s.y) {
                                                if (t.x === s.x) return 1
                                            } else {
                                                var u = h * (t.x - s.x) - l * (t.y - s.y);
                                                if (0 == u) return 1;
                                                if (u < 0) continue;
                                                n = !n
                                            }
                                        } else {
                                            if (t.y !== s.y) continue;
                                            if (o.x <= t.x && t.x <= s.x || s.x <= t.x && t.x <= o.x) return 1
                                        }
                                    }
                                    return n
                                }(C.p, p[E].p) || (w !== E && b.push({
                                    froms: w,
                                    tos: E,
                                    hole: T
                                }), A ? (A = !1, c[E].push(C)) : y = !0);
                                A && c[w].push(C)
                            }
                        0 < b.length && (y || (d = c))
                    }
                    for (var D = 0, P = p.length; D < P; D++) {
                        a = p[D].s, l.push(a);
                        for (var L = 0, k = (m = d[D]).length; L < k; L++) a.holes.push(m[L].h)
                    }
                    return l
                }
            }), Object.assign(qu.prototype, {
                isFont: !0,
                generateShapes: function(t, e) {
                    void 0 === e && (e = 100);
                    for (var i = [], n = function(t, e, i) {
                            for (var n = Array.from ? Array.from(t) : String(t).split(""), r = e / i.resolution, a = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, s = [], o = 0, l = 0, h = 0; h < n.length; h++) {
                                var u, c = n[h];
                                "\n" === c ? (o = 0, l -= a) : (u = function(t, e, i, n, r) {
                                    var a = r.glyphs[t] || r.glyphs["?"];
                                    if (!a) return;
                                    var s, o, l, h, u, c, p, d, f = new Wu;
                                    if (a.o)
                                        for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, v = m.length; g < v;) {
                                            switch (m[g++]) {
                                                case "m":
                                                    s = m[g++] * e + i, o = m[g++] * e + n, f.moveTo(s, o);
                                                    break;
                                                case "l":
                                                    s = m[g++] * e + i, o = m[g++] * e + n, f.lineTo(s, o);
                                                    break;
                                                case "q":
                                                    l = m[g++] * e + i, h = m[g++] * e + n, u = m[g++] * e + i, c = m[g++] * e + n, f.quadraticCurveTo(u, c, l, h);
                                                    break;
                                                case "b":
                                                    l = m[g++] * e + i, h = m[g++] * e + n, u = m[g++] * e + i, c = m[g++] * e + n, p = m[g++] * e + i, d = m[g++] * e + n, f.bezierCurveTo(u, c, p, d, l, h)
                                            }
                                        }
                                    return {
                                        offsetX: a.ha * e,
                                        path: f
                                    }
                                }(c, r, o, l, i), o += u.offsetX, s.push(u.path))
                            }
                            return s
                        }(t, e, this.data), r = 0, a = n.length; r < a; r++) Array.prototype.push.apply(i, n[r].toShapes());
                    return i
                }
            }), Xu.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: Xu,
                load: function(t, n, e, i) {
                    var r = this,
                        a = new jh(this.manager);
                    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.load(t, function(e) {
                        var i;
                        try {
                            i = JSON.parse(e)
                        } catch (t) {
                            i = JSON.parse(e.substring(65, e.length - 2))
                        }
                        var t = r.parse(i);
                        n && n(t)
                    }, e, i)
                },
                parse: function(t) {
                    return new qu(t)
                }
            });
            var Yu = {
                getContext: function() {
                    return void 0 === Gu && (Gu = new(window.AudioContext || window.webkitAudioContext)), Gu
                },
                setContext: function(t) {
                    Gu = t
                }
            };

            function Ju(t) {
                Vh.call(this, t)
            }

            function Zu(t, e, i) {
                ku.call(this, void 0, i);
                var n = (new Cn).set(t),
                    r = (new Cn).set(e),
                    a = new ni(n.r, n.g, n.b),
                    s = new ni(r.r, r.g, r.b),
                    o = Math.sqrt(Math.PI),
                    l = o * Math.sqrt(.75);
                this.sh.coefficients[0].copy(a).add(s).multiplyScalar(o), this.sh.coefficients[1].copy(a).sub(s).multiplyScalar(l)
            }

            function $u(t, e) {
                ku.call(this, void 0, e);
                var i = (new Cn).set(t);
                this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
            Ju.prototype = Object.assign(Object.create(Vh.prototype), {
                constructor: Ju,
                load: function(i, n, t, r) {
                    var a = this,
                        e = new jh(a.manager);
                    e.setResponseType("arraybuffer"), e.setPath(a.path), e.setRequestHeader(a.requestHeader), e.load(i, function(t) {
                        try {
                            var e = t.slice(0);
                            Yu.getContext().decodeAudioData(e, function(t) {
                                n(t)
                            })
                        } catch (t) {
                            r && r(t), a.manager.itemError(i)
                        }
                    }, t, r)
                }
            }), Zu.prototype = Object.assign(Object.create(ku.prototype), {
                constructor: Zu,
                isHemisphereLightProbe: !0,
                copy: function(t) {
                    return ku.prototype.copy.call(this, t), this
                },
                toJSON: function(t) {
                    return ku.prototype.toJSON.call(this, t)
                }
            }), $u.prototype = Object.assign(Object.create(ku.prototype), {
                constructor: $u,
                isAmbientLightProbe: !0,
                copy: function(t) {
                    return ku.prototype.copy.call(this, t), this
                },
                toJSON: function(t) {
                    return ku.prototype.toJSON.call(this, t)
                }
            });
            var Ku = new Li,
                Qu = new Li;

            function tc() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Or, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Or, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }
            Object.assign(tc.prototype, {
                update: function(t) {
                    var e, i, n, r, a, s, o = this._cache;
                    o.focus === t.focus && o.fov === t.fov && o.aspect === t.aspect * this.aspect && o.near === t.near && o.far === t.far && o.zoom === t.zoom && o.eyeSep === this.eyeSep || (o.focus = t.focus, o.fov = t.fov, o.aspect = t.aspect * this.aspect, o.near = t.near, o.far = t.far, o.zoom = t.zoom, o.eyeSep = this.eyeSep, e = t.projectionMatrix.clone(), n = (i = o.eyeSep / 2) * o.near / o.focus, r = o.near * Math.tan(je.DEG2RAD * o.fov * .5) / o.zoom, Qu.elements[12] = -i, Ku.elements[12] = i, a = -r * o.aspect + n, s = r * o.aspect + n, e.elements[0] = 2 * o.near / (s - a), e.elements[8] = (s + a) / (s - a), this.cameraL.projectionMatrix.copy(e), a = -r * o.aspect - n, s = r * o.aspect - n, e.elements[0] = 2 * o.near / (s - a), e.elements[8] = (s + a) / (s - a), this.cameraR.projectionMatrix.copy(e)), this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Qu), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Ku)
                }
            });

            function ec(t) {
                this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            ec.prototype.start = function() {
                this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }, ec.prototype.stop = function() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }, ec.prototype.getElapsedTime = function() {
                return this.getDelta(), this.elapsedTime
            }, ec.prototype.getDelta = function() {
                var t, e = 0;
                return this.autoStart && !this.running ? (this.start(), 0) : (this.running && (e = ((t = ("undefined" == typeof performance ? Date : performance).now()) - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e), e)
            };
            var ic = new ni,
                nc = new ei,
                rc = new ni,
                ac = new ni;

            function sc() {
                rn.call(this), this.type = "AudioListener", this.context = Yu.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new ec
            }

            function oc(t) {
                rn.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
            }((sc.prototype = Object.create(rn.prototype)).constructor = sc).prototype.getInput = function() {
                return this.gain
            }, sc.prototype.removeFilter = function() {
                return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
            }, sc.prototype.getFilter = function() {
                return this.filter
            }, sc.prototype.setFilter = function(t) {
                return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
            }, sc.prototype.getMasterVolume = function() {
                return this.gain.gain.value
            }, sc.prototype.setMasterVolume = function(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
            }, sc.prototype.updateMatrixWorld = function(t) {
                rn.prototype.updateMatrixWorld.call(this, t);
                var e, i = this.context.listener,
                    n = this.up;
                this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ic, nc, rc), ac.set(0, 0, -1).applyQuaternion(nc), i.positionX ? (e = this.context.currentTime + this.timeDelta, i.positionX.linearRampToValueAtTime(ic.x, e), i.positionY.linearRampToValueAtTime(ic.y, e), i.positionZ.linearRampToValueAtTime(ic.z, e), i.forwardX.linearRampToValueAtTime(ac.x, e), i.forwardY.linearRampToValueAtTime(ac.y, e), i.forwardZ.linearRampToValueAtTime(ac.z, e), i.upX.linearRampToValueAtTime(n.x, e), i.upY.linearRampToValueAtTime(n.y, e), i.upZ.linearRampToValueAtTime(n.z, e)) : (i.setPosition(ic.x, ic.y, ic.z), i.setOrientation(ac.x, ac.y, ac.z, n.x, n.y, n.z))
            }, ((oc.prototype = Object.create(rn.prototype)).constructor = oc).prototype.getOutput = function() {
                return this.gain
            }, oc.prototype.setNodeSource = function(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            }, oc.prototype.setMediaElementSource = function(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
            }, oc.prototype.setMediaStreamSource = function(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
            }, oc.prototype.setBuffer = function(t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            }, oc.prototype.play = function(t) {
                if (void 0 === t && (t = 0), !0 !== this.isPlaying && !1 !== this.hasPlaybackControl) {
                    this._startedAt = this.context.currentTime + t;
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
            }, oc.prototype.pause = function() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
            }, oc.prototype.stop = function() {
                if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this
            }, oc.prototype.connect = function() {
                if (0 < this.filters.length) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this._connected = !0, this
            }, oc.prototype.disconnect = function() {
                if (0 < this.filters.length) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this._connected = !1, this
            }, oc.prototype.getFilters = function() {
                return this.filters
            }, oc.prototype.setFilters = function(t) {
                return t = t || [], !0 === this._connected ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
            }, oc.prototype.setDetune = function(t) {
                if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            }, oc.prototype.getDetune = function() {
                return this.detune
            }, oc.prototype.getFilter = function() {
                return this.getFilters()[0]
            }, oc.prototype.setFilter = function(t) {
                return this.setFilters(t ? [t] : [])
            }, oc.prototype.setPlaybackRate = function(t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
            }, oc.prototype.getPlaybackRate = function() {
                return this.playbackRate
            }, oc.prototype.onEnded = function() {
                this.isPlaying = !1
            }, oc.prototype.getLoop = function() {
                return !1 !== this.hasPlaybackControl && this.loop
            }, oc.prototype.setLoop = function(t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this
            }, oc.prototype.setLoopStart = function(t) {
                return this.loopStart = t, this
            }, oc.prototype.setLoopEnd = function(t) {
                return this.loopEnd = t, this
            }, oc.prototype.getVolume = function() {
                return this.gain.gain.value
            }, oc.prototype.setVolume = function(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
            };
            var lc = new ni,
                hc = new ei,
                uc = new ni,
                cc = new ni;

            function pc(t) {
                oc.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
            }((pc.prototype = Object.create(oc.prototype)).constructor = pc).prototype.getOutput = function() {
                return this.panner
            }, pc.prototype.getRefDistance = function() {
                return this.panner.refDistance
            }, pc.prototype.setRefDistance = function(t) {
                return this.panner.refDistance = t, this
            }, pc.prototype.getRolloffFactor = function() {
                return this.panner.rolloffFactor
            }, pc.prototype.setRolloffFactor = function(t) {
                return this.panner.rolloffFactor = t, this
            }, pc.prototype.getDistanceModel = function() {
                return this.panner.distanceModel
            }, pc.prototype.setDistanceModel = function(t) {
                return this.panner.distanceModel = t, this
            }, pc.prototype.getMaxDistance = function() {
                return this.panner.maxDistance
            }, pc.prototype.setMaxDistance = function(t) {
                return this.panner.maxDistance = t, this
            }, pc.prototype.setDirectionalCone = function(t, e, i) {
                return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this
            }, pc.prototype.updateMatrixWorld = function(t) {
                var e, i;
                oc.prototype.updateMatrixWorld.call(this, t), !0 === this.hasPlaybackControl && !1 === this.isPlaying || (this.matrixWorld.decompose(lc, hc, uc), cc.set(0, 0, 1).applyQuaternion(hc), (e = this.panner).positionX ? (i = this.context.currentTime + this.listener.timeDelta, e.positionX.linearRampToValueAtTime(lc.x, i), e.positionY.linearRampToValueAtTime(lc.y, i), e.positionZ.linearRampToValueAtTime(lc.z, i), e.orientationX.linearRampToValueAtTime(cc.x, i), e.orientationY.linearRampToValueAtTime(cc.y, i), e.orientationZ.linearRampToValueAtTime(cc.z, i)) : (e.setPosition(lc.x, lc.y, lc.z), e.setOrientation(cc.x, cc.y, cc.z)))
            };

            function dc(t, e) {
                this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
            }

            function fc(t, e, i) {
                var n, r, a;
                switch (this.binding = t, this.valueSize = i, e) {
                    case "quaternion":
                        n = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        n = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i);
                        break;
                    default:
                        n = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i)
                }
                this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }
            dc.prototype.getFrequencyData = function() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            }, dc.prototype.getAverageFrequency = function() {
                for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                return t / e.length
            }, Object.assign(fc.prototype, {
                accumulate: function(t, e) {
                    var i = this.buffer,
                        n = this.valueSize,
                        r = t * n + n,
                        a = this.cumulativeWeight;
                    if (0 === a) {
                        for (var s = 0; s !== n; ++s) i[r + s] = i[s];
                        a = e
                    } else {
                        var o = e / (a += e);
                        this._mixBufferRegion(i, r, 0, o, n)
                    }
                    this.cumulativeWeight = a
                },
                accumulateAdditive: function(t) {
                    var e = this.buffer,
                        i = this.valueSize,
                        n = i * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, i), this.cumulativeWeightAdditive += t
                },
                apply: function(t) {
                    var e, i = this.valueSize,
                        n = this.buffer,
                        r = t * i + i,
                        a = this.cumulativeWeight,
                        s = this.cumulativeWeightAdditive,
                        o = this.binding;
                    this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, a < 1 && (e = i * this._origIndex, this._mixBufferRegion(n, r, e, 1 - a, i)), 0 < s && this._mixBufferRegionAdditive(n, r, this._addIndex * i, 1, i);
                    for (var l = i, h = i + i; l !== h; ++l)
                        if (n[l] !== n[l + i]) {
                            o.setValue(n, r);
                            break
                        }
                },
                saveOriginalState: function() {
                    var t = this.binding,
                        e = this.buffer,
                        i = this.valueSize,
                        n = i * this._origIndex;
                    t.getValue(e, n);
                    for (var r = i, a = n; r !== a; ++r) e[r] = e[n + r % i];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                },
                restoreOriginalState: function() {
                    var t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                },
                _setAdditiveIdentityNumeric: function() {
                    for (var t = this._addIndex * this.valueSize, e = t + this.valueSize, i = t; i < e; i++) this.buffer[i] = 0
                },
                _setAdditiveIdentityQuaternion: function() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                },
                _setAdditiveIdentityOther: function() {
                    for (var t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize, i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i]
                },
                _select: function(t, e, i, n, r) {
                    if (.5 <= n)
                        for (var a = 0; a !== r; ++a) t[e + a] = t[i + a]
                },
                _slerp: function(t, e, i, n) {
                    ei.slerpFlat(t, e, t, e, t, i, n)
                },
                _slerpAdditive: function(t, e, i, n, r) {
                    var a = this._workIndex * r;
                    ei.multiplyQuaternionsFlat(t, a, t, e, t, i), ei.slerpFlat(t, e, t, e, t, a, n)
                },
                _lerp: function(t, e, i, n, r) {
                    for (var a = 1 - n, s = 0; s !== r; ++s) {
                        var o = e + s;
                        t[o] = t[o] * a + t[i + s] * n
                    }
                },
                _lerpAdditive: function(t, e, i, n, r) {
                    for (var a = 0; a !== r; ++a) {
                        var s = e + a;
                        t[s] = t[s] + t[i + a] * n
                    }
                }
            });
            var mc = "\\[\\]\\.:\\/",
                gc = new RegExp("[" + mc + "]", "g"),
                vc = "[^" + mc + "]",
                yc = "[^" + mc.replace("\\.", "") + "]",
                bc = /((?:WC+[\/:])*)/.source.replace("WC", vc),
                xc = /(WCOD+)?/.source.replace("WCOD", yc),
                _c = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", vc),
                wc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", vc),
                Sc = new RegExp("^" + bc + xc + _c + wc + "$"),
                Mc = ["material", "materials", "bones"];

            function Tc(t, e, i) {
                var n = i || Cc.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, n)
            }

            function Cc(t, e, i) {
                this.path = e, this.parsedPath = i || Cc.parseTrackName(e), this.node = Cc.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }

            function Ac() {
                this.uuid = je.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var t = {};
                this._indicesByUUID = t;
                for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var n = this;
                this.stats = {
                    objects: {
                        get total() {
                            return n._objects.length
                        },
                        get inUse() {
                            return this.total - n.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return n._bindings.length
                    }
                }
            }
            Object.assign(Tc.prototype, {
                getValue: function(t, e) {
                    this.bind();
                    var i = this._targetGroup.nCachedObjects_,
                        n = this._bindings[i];
                    void 0 !== n && n.getValue(t, e)
                },
                setValue: function(t, e) {
                    for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
                },
                bind: function() {
                    for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
                },
                unbind: function() {
                    for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
                }
            }), Object.assign(Cc, {
                Composite: Tc,
                create: function(t, e, i) {
                    return t && t.isAnimationObjectGroup ? new Cc.Composite(t, e, i) : new Cc(t, e, i)
                },
                sanitizeNodeName: function(t) {
                    return t.replace(/\s/g, "_").replace(gc, "")
                },
                parseTrackName: function(t) {
                    var e = Sc.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    var i, n = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r && (i = n.nodeName.substring(r + 1), -1 !== Mc.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)), null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return n
                },
                findNode: function(t, a) {
                    if (!a || "" === a || "." === a || -1 === a || a === t.name || a === t.uuid) return t;
                    if (t.skeleton) {
                        var e = t.skeleton.getBoneByName(a);
                        if (void 0 !== e) return e
                    }
                    if (t.children) {
                        var i = function t(e) {
                            for (var i = 0; i < e.length; i++) {
                                var n = e[i];
                                if (n.name === a || n.uuid === a) return n;
                                var r = t(n.children);
                                if (r) return r
                            }
                            return null
                        }(t.children);
                        if (i) return i
                    }
                    return null
                }
            }), Object.assign(Cc.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(t, e) {
                    t[e] = this.node[this.propertyName]
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
                }, function(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex]
                }, function(t, e) {
                    this.resolvedProperty.toArray(t, e)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function(t, e) {
                        this.targetObject[this.propertyName] = t[e]
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                    }, function(t, e) {
                        for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty.fromArray(t, e)
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function(t, e) {
                    this.bind(), this.getValue(t, e)
                },
                setValue: function(t, e) {
                    this.bind(), this.setValue(t, e)
                },
                bind: function() {
                    var t = this.node,
                        e = this.parsedPath,
                        i = e.objectName,
                        n = e.propertyName,
                        r = e.propertyIndex;
                    if (t || (t = Cc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                        if (i) {
                            var a = e.objectIndex;
                            switch (i) {
                                case "materials":
                                    if (!t.material) return;
                                    if (!t.material.materials) return;
                                    t = t.material.materials;
                                    break;
                                case "bones":
                                    if (!t.skeleton) return;
                                    t = t.skeleton.bones;
                                    for (var s = 0; s < t.length; s++)
                                        if (t[s].name === a) {
                                            a = s;
                                            break
                                        }
                                    break;
                                default:
                                    if (void 0 === t[i]) return;
                                    t = t[i]
                            }
                            if (void 0 !== a) {
                                if (void 0 === t[a]) return;
                                t = t[a]
                            }
                        }
                        var o = t[n];
                        if (void 0 !== o) {
                            var l = this.Versioning.None;
                            void 0 !== (this.targetObject = t).needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                            var h = this.BindingType.Direct;
                            if (void 0 !== r) {
                                if ("morphTargetInfluences" === n) {
                                    if (!t.geometry) return;
                                    if (!t.geometry.isBufferGeometry) return;
                                    if (!t.geometry.morphAttributes) return;
                                    void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                                }
                                h = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                            } else void 0 !== o.fromArray && void 0 !== o.toArray ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (h = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
                            this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][l]
                        } else e.nodeName
                    }
                },
                unbind: function() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(Cc.prototype, {
                _getValue_unbound: Cc.prototype.getValue,
                _setValue_unbound: Cc.prototype.setValue
            }), Object.assign(Ac.prototype, {
                isAnimationObjectGroup: !0,
                add: function() {
                    for (var t = this._objects, e = this._indicesByUUID, i = this._paths, n = this._parsedPaths, r = this._bindings, a = r.length, s = t.length, o = this.nCachedObjects_, l = 0, h = arguments.length; l !== h; ++l) {
                        var u = arguments[l],
                            c = u.uuid,
                            p = e[c];
                        if (void 0 === p) {
                            p = s++, e[c] = p, t.push(u);
                            for (var d = 0, f = a; d !== f; ++d) r[d].push(new Cc(u, i[d], n[d]))
                        } else if (p < o) {
                            t[p];
                            var m = --o,
                                g = t[m];
                            t[e[g.uuid] = p] = g, t[e[c] = m] = u;
                            for (var v = 0, y = a; v !== y; ++v) {
                                var b = r[v],
                                    x = b[m],
                                    _ = b[p];
                                b[p] = x, void 0 === _ && (_ = new Cc(u, i[v], n[v])), b[m] = _
                            }
                        } else t[p]
                    }
                    this.nCachedObjects_ = o
                },
                remove: function() {
                    for (var t = this._objects, e = this._indicesByUUID, i = this._bindings, n = i.length, r = this.nCachedObjects_, a = 0, s = arguments.length; a !== s; ++a) {
                        var o = arguments[a],
                            l = o.uuid,
                            h = e[l];
                        if (void 0 !== h && r <= h) {
                            var u = r++,
                                c = t[u];
                            t[e[c.uuid] = h] = c, t[e[l] = u] = o;
                            for (var p = 0, d = n; p !== d; ++p) {
                                var f = i[p],
                                    m = f[u],
                                    g = f[h];
                                f[h] = m, f[u] = g
                            }
                        }
                    }
                    this.nCachedObjects_ = r
                },
                uncache: function() {
                    for (var t = this._objects, e = this._indicesByUUID, i = this._bindings, n = i.length, r = this.nCachedObjects_, a = t.length, s = 0, o = arguments.length; s !== o; ++s) {
                        var l = arguments[s].uuid,
                            h = e[l];
                        if (void 0 !== h)
                            if (delete e[l], h < r) {
                                var u = --r,
                                    c = t[u],
                                    p = --a,
                                    d = t[p];
                                t[e[c.uuid] = h] = c, t[e[d.uuid] = u] = d, t.pop();
                                for (var f = 0, m = n; f !== m; ++f) {
                                    var g = i[f],
                                        v = g[u],
                                        y = g[p];
                                    g[h] = v, g[u] = y, g.pop()
                                }
                            } else {
                                var b = --a,
                                    x = t[b];
                                t[e[x.uuid] = h] = x, t.pop();
                                for (var _ = 0, w = n; _ !== w; ++_) {
                                    var S = i[_];
                                    S[h] = S[b], S.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = r
                },
                subscribe_: function(t, e) {
                    var i = this._bindingsIndicesByPath,
                        n = i[t],
                        r = this._bindings;
                    if (void 0 !== n) return r[n];
                    var a = this._paths,
                        s = this._parsedPaths,
                        o = this._objects,
                        l = o.length,
                        h = this.nCachedObjects_,
                        u = new Array(l),
                        n = r.length;
                    i[t] = n, a.push(t), s.push(e), r.push(u);
                    for (var c = h, p = o.length; c !== p; ++c) {
                        var d = o[c];
                        u[c] = new Cc(d, t, e)
                    }
                    return u
                },
                unsubscribe_: function(t) {
                    var e, i, n, r, a, s = this._bindingsIndicesByPath,
                        o = s[t];
                    void 0 !== o && (e = this._paths, i = this._parsedPaths, a = (n = this._bindings)[r = n.length - 1], n[s[t[r]] = o] = a, n.pop(), i[o] = i[r], i.pop(), e[o] = e[r], e.pop())
                }
            });

            function Ec(t, e, i, n) {
                this._mixer = t, this._clip = e, this._localRoot = i || null, this.blendMode = n || e.blendMode;
                for (var r = e.tracks, a = r.length, s = new Array(a), o = {
                        endingStart: 2400,
                        endingEnd: 2400
                    }, l = 0; l !== a; ++l) {
                    var h = r[l].createInterpolant(null);
                    (s[l] = h).settings = o
                }
                this._interpolantSettings = o, this._interpolants = s, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function Dc(t) {
                this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }
            Ec.prototype.play = function() {
                return this._mixer._activateAction(this), this
            }, Ec.prototype.stop = function() {
                return this._mixer._deactivateAction(this), this.reset()
            }, Ec.prototype.reset = function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }, Ec.prototype.isRunning = function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }, Ec.prototype.isScheduled = function() {
                return this._mixer._isActiveAction(this)
            }, Ec.prototype.startAt = function(t) {
                return this._startTime = t, this
            }, Ec.prototype.setLoop = function(t, e) {
                return this.loop = t, this.repetitions = e, this
            }, Ec.prototype.setEffectiveWeight = function(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            }, Ec.prototype.getEffectiveWeight = function() {
                return this._effectiveWeight
            }, Ec.prototype.fadeIn = function(t) {
                return this._scheduleFading(t, 0, 1)
            }, Ec.prototype.fadeOut = function(t) {
                return this._scheduleFading(t, 1, 0)
            }, Ec.prototype.crossFadeFrom = function(t, e, i) {
                var n, r, a, s;
                return t.fadeOut(e), this.fadeIn(e), i && (n = this._clip.duration, a = (r = t._clip.duration) / n, s = n / r, t.warp(1, a, e), this.warp(s, 1, e)), this
            }, Ec.prototype.crossFadeTo = function(t, e, i) {
                return t.crossFadeFrom(this, e, i)
            }, Ec.prototype.stopFading = function() {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }, Ec.prototype.setEffectiveTimeScale = function(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            }, Ec.prototype.getEffectiveTimeScale = function() {
                return this._effectiveTimeScale
            }, Ec.prototype.setDuration = function(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            }, Ec.prototype.syncWith = function(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            }, Ec.prototype.halt = function(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }, Ec.prototype.warp = function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    a = this.timeScale,
                    s = this._timeScaleInterpolant;
                null === s && (s = n._lendControlInterpolant(), this._timeScaleInterpolant = s);
                var o = s.parameterPositions,
                    l = s.sampleValues;
                return o[0] = r, o[1] = r + i, l[0] = t / a, l[1] = e / a, this
            }, Ec.prototype.stopWarping = function() {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }, Ec.prototype.getMixer = function() {
                return this._mixer
            }, Ec.prototype.getClip = function() {
                return this._clip
            }, Ec.prototype.getRoot = function() {
                return this._localRoot || this._mixer._root
            }, Ec.prototype._update = function(t, e, i, n) {
                if (this.enabled) {
                    var r = this._startTime;
                    if (null !== r) {
                        var a = (t - r) * i;
                        if (a < 0 || 0 === i) return;
                        this._startTime = null, e = i * a
                    }
                    e *= this._updateTimeScale(t);
                    var s = this._updateTime(e),
                        o = this._updateWeight(t);
                    if (0 < o) {
                        var l = this._interpolants,
                            h = this._propertyBindings;
                        switch (this.blendMode) {
                            case 2501:
                                for (var u = 0, c = l.length; u !== c; ++u) l[u].evaluate(s), h[u].accumulateAdditive(o);
                                break;
                            case 2500:
                            default:
                                for (var p = 0, d = l.length; p !== d; ++p) l[p].evaluate(s), h[p].accumulate(n, o)
                        }
                    }
                } else this._updateWeight(t)
            }, Ec.prototype._updateWeight = function(t) {
                var e, i, n = 0;
                return this.enabled && (n = this.weight, null !== (e = this._weightInterpolant) && (n *= i = e.evaluate(t)[0], t > e.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1)))), this._effectiveWeight = n
            }, Ec.prototype._updateTimeScale = function(t) {
                var e, i = 0;
                return this.paused || (i = this.timeScale, null !== (e = this._timeScaleInterpolant) && (i *= e.evaluate(t)[0], t > e.parameterPositions[1] && (this.stopWarping(), 0 === i ? this.paused = !0 : this.timeScale = i))), this._effectiveTimeScale = i
            }, Ec.prototype._updateTime = function(t) {
                var e, i, n, r = this._clip.duration,
                    a = this.loop,
                    s = this.time + t,
                    o = this._loopCount,
                    l = 2202 === a;
                if (0 === t) return -1 !== o && l && 1 == (1 & o) ? r - s : s;
                if (2200 === a) {
                    -1 === o && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t: {
                        if (r <= s) s = r;
                        else {
                            if (!(s < 0)) {
                                this.time = s;
                                break t
                            }
                            s = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = s,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === o && (0 <= t ? (o = 0, this._setEndings(!0, 0 === this.repetitions, l)) : this._setEndings(0 === this.repetitions, !0, l)), r <= s || s < 0 ? (s -= r * (e = Math.floor(s / r)), o += Math.abs(e), (i = this.repetitions - o) <= 0 ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = 0 < t ? r : 0, this.time = s, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: 0 < t ? 1 : -1
                        })) : (1 == i ? (n = t < 0, this._setEndings(n, !n, l)) : this._setEndings(!1, !1, l), this._loopCount = o, this.time = s, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: e
                        }))) : this.time = s, l && 1 == (1 & o)) return r - s
                }
                return s
            }, Ec.prototype._setEndings = function(t, e, i) {
                var n = this._interpolantSettings;
                i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
            }, Ec.prototype._scheduleFading = function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    a = this._weightInterpolant;
                null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
                var s = a.parameterPositions,
                    o = a.sampleValues;
                return s[0] = r, o[0] = e, s[1] = r + t, o[1] = i, this
            }, Dc.prototype = Object.assign(Object.create(ze.prototype), {
                constructor: Dc,
                _bindAction: function(t, e) {
                    var i = t._localRoot || this._root,
                        n = t._clip.tracks,
                        r = n.length,
                        a = t._propertyBindings,
                        s = t._interpolants,
                        o = i.uuid,
                        l = this._bindingsByRootAndName,
                        h = l[o];
                    void 0 === h && (h = {}, l[o] = h);
                    for (var u = 0; u !== r; ++u) {
                        var c = n[u],
                            p = c.name;
                        if (void 0 !== (d = h[p])) a[u] = d;
                        else {
                            if (void 0 !== (d = a[u])) {
                                null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, o, p));
                                continue
                            }
                            var d, f = e && e._propertyBindings[u].binding.parsedPath;
                            ++(d = new fc(Cc.create(i, p, f), c.ValueTypeName, c.getValueSize())).referenceCount, this._addInactiveBinding(d, o, p), a[u] = d
                        }
                        s[u].resultBuffer = d.buffer
                    }
                },
                _activateAction: function(t) {
                    if (!this._isActiveAction(t)) {
                        var e, i, n;
                        null === t._cacheIndex && (e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i], this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e));
                        for (var r = t._propertyBindings, a = 0, s = r.length; a !== s; ++a) {
                            var o = r[a];
                            0 == o.useCount++ && (this._lendBinding(o), o.saveOriginalState())
                        }
                        this._lendAction(t)
                    }
                },
                _deactivateAction: function(t) {
                    if (this._isActiveAction(t)) {
                        for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                            var r = e[i];
                            0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                        }
                        this._takeBackAction(t)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    var t = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return t._actions.length
                            },
                            get inUse() {
                                return t._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return t._bindings.length
                            },
                            get inUse() {
                                return t._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return t._controlInterpolants.length
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(t) {
                    var e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions
                },
                _addInactiveAction: function(t, e, i) {
                    var n, r = this._actions,
                        a = this._actionsByClip,
                        s = a[e];
                    void 0 === s ? (s = {
                        knownActions: [t],
                        actionByRoot: {}
                    }, t._byClipCacheIndex = 0, a[e] = s) : (n = s.knownActions, t._byClipCacheIndex = n.length, n.push(t)), t._cacheIndex = r.length, r.push(t), s.actionByRoot[i] = t
                },
                _removeInactiveAction: function(t) {
                    var e = this._actions,
                        i = e[e.length - 1],
                        n = t._cacheIndex;
                    e[i._cacheIndex = n] = i, e.pop(), t._cacheIndex = null;
                    var r = t._clip.uuid,
                        a = this._actionsByClip,
                        s = a[r],
                        o = s.knownActions,
                        l = o[o.length - 1],
                        h = t._byClipCacheIndex;
                    o[l._byClipCacheIndex = h] = l, o.pop(), t._byClipCacheIndex = null, delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete a[r], this._removeInactiveBindingsForAction(t)
                },
                _removeInactiveBindingsForAction: function(t) {
                    for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                        var r = e[i];
                        0 == --r.referenceCount && this._removeInactiveBinding(r)
                    }
                },
                _lendAction: function(t) {
                    var e = this._actions,
                        i = t._cacheIndex,
                        n = this._nActiveActions++,
                        r = e[n];
                    e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
                },
                _takeBackAction: function(t) {
                    var e = this._actions,
                        i = t._cacheIndex,
                        n = --this._nActiveActions,
                        r = e[n];
                    e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
                },
                _addInactiveBinding: function(t, e, i) {
                    var n = this._bindingsByRootAndName,
                        r = this._bindings,
                        a = n[e];
                    void 0 === a && (a = {}, n[e] = a), (a[i] = t)._cacheIndex = r.length, r.push(t)
                },
                _removeInactiveBinding: function(t) {
                    var e = this._bindings,
                        i = t.binding,
                        n = i.rootNode.uuid,
                        r = i.path,
                        a = this._bindingsByRootAndName,
                        s = a[n],
                        o = e[e.length - 1],
                        l = t._cacheIndex;
                    e[o._cacheIndex = l] = o, e.pop(), delete s[r], 0 === Object.keys(s).length && delete a[n]
                },
                _lendBinding: function(t) {
                    var e = this._bindings,
                        i = t._cacheIndex,
                        n = this._nActiveBindings++,
                        r = e[n];
                    e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
                },
                _takeBackBinding: function(t) {
                    var e = this._bindings,
                        i = t._cacheIndex,
                        n = --this._nActiveBindings,
                        r = e[n];
                    e[t._cacheIndex = n] = t, e[r._cacheIndex = i] = r
                },
                _lendControlInterpolant: function() {
                    var t = this._controlInterpolants,
                        e = this._nActiveControlInterpolants++,
                        i = t[e];
                    return void 0 === i && (t[(i = new Ch(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e] = i), i
                },
                _takeBackControlInterpolant: function(t) {
                    var e = this._controlInterpolants,
                        i = t.__cacheIndex,
                        n = --this._nActiveControlInterpolants,
                        r = e[n];
                    e[t.__cacheIndex = n] = t, e[r.__cacheIndex = i] = r
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function(t, e, i) {
                    var n = e || this._root,
                        r = n.uuid,
                        a = "string" == typeof t ? Nh.findByName(n, t) : t,
                        s = null !== a ? a.uuid : t,
                        o = this._actionsByClip[s],
                        l = null;
                    if (void 0 === i && (i = null !== a ? a.blendMode : 2500), void 0 !== o) {
                        var h = o.actionByRoot[r];
                        if (void 0 !== h && h.blendMode === i) return h;
                        l = o.knownActions[0], null === a && (a = l._clip)
                    }
                    if (null === a) return null;
                    var u = new Ec(this, a, e, i);
                    return this._bindAction(u, l), this._addInactiveAction(u, s, r), u
                },
                existingAction: function(t, e) {
                    var i = e || this._root,
                        n = i.uuid,
                        r = "string" == typeof t ? Nh.findByName(i, t) : t,
                        a = r ? r.uuid : t,
                        s = this._actionsByClip[a];
                    return void 0 !== s && s.actionByRoot[n] || null
                },
                stopAllAction: function() {
                    for (var t = this._actions, e = this._nActiveActions - 1; 0 <= e; --e) t[e].stop();
                    return this
                },
                update: function(t) {
                    t *= this.timeScale;
                    for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, s = 0; s !== i; ++s) {
                        e[s]._update(n, t, r, a)
                    }
                    for (var o = this._bindings, l = this._nActiveBindings, h = 0; h !== l; ++h) o[h].apply(a);
                    return this
                },
                setTime: function(t) {
                    for (var e = this.time = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                    return this.update(t)
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(t) {
                    var e = this._actions,
                        i = t.uuid,
                        n = this._actionsByClip,
                        r = n[i];
                    if (void 0 !== r) {
                        for (var a = r.knownActions, s = 0, o = a.length; s !== o; ++s) {
                            var l = a[s];
                            this._deactivateAction(l);
                            var h = l._cacheIndex,
                                u = e[e.length - 1];
                            l._cacheIndex = null, l._byClipCacheIndex = null, e[u._cacheIndex = h] = u, e.pop(), this._removeInactiveBindingsForAction(l)
                        }
                        delete n[i]
                    }
                },
                uncacheRoot: function(t) {
                    var e = t.uuid,
                        i = this._actionsByClip;
                    for (var n in i) {
                        var r = i[n].actionByRoot[e];
                        void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                    }
                    var a = this._bindingsByRootAndName[e];
                    if (void 0 !== a)
                        for (var s in a) {
                            var o = a[s];
                            o.restoreOriginalState(), this._removeInactiveBinding(o)
                        }
                },
                uncacheAction: function(t, e) {
                    var i = this.existingAction(t, e);
                    null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
            });

            function Pc(t, e) {
                "string" == typeof t && (t = e), this.value = t
            }

            function Lc(t, e, i) {
                Ks.call(this, t, e), this.meshPerAttribute = i || 1
            }

            function kc(t, e, i, n, r) {
                this.buffer = t, this.type = e, this.itemSize = i, this.elementSize = n, this.count = r, this.version = 0
            }

            function Oc(t, e, i, n) {
                this.ray = new Si(t, e), this.near = i || 0, this.far = n || 1 / 0, this.camera = null, this.layers = new ji, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return this.Points
                        }
                    }
                })
            }

            function Fc(t, e) {
                return t.distance - e.distance
            }

            function Ic(t, e, i, n) {
                if (t.layers.test(e.layers) && t.raycast(e, i), !0 === n)
                    for (var r = t.children, a = 0, s = r.length; a < s; a++) Ic(r[a], e, i, !0)
            }
            Pc.prototype.clone = function() {
                return new Pc(void 0 === this.value.clone ? this.value : this.value.clone())
            }, Lc.prototype = Object.assign(Object.create(Ks.prototype), {
                constructor: Lc,
                isInstancedInterleavedBuffer: !0,
                copy: function(t) {
                    return Ks.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                },
                clone: function(t) {
                    var e = Ks.prototype.clone.call(this, t);
                    return e.meshPerAttribute = this.meshPerAttribute, e
                },
                toJSON: function(t) {
                    var e = Ks.prototype.toJSON.call(this, t);
                    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                }
            }), Object.defineProperty(kc.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(kc.prototype, {
                isGLBufferAttribute: !0,
                setBuffer: function(t) {
                    return this.buffer = t, this
                },
                setType: function(t, e) {
                    return this.type = t, this.elementSize = e, this
                },
                setItemSize: function(t) {
                    return this.itemSize = t, this
                },
                setCount: function(t) {
                    return this.count = t, this
                }
            }), Object.assign(Oc.prototype, {
                set: function(t, e) {
                    this.ray.set(t, e)
                },
                setFromCamera: function(t, e) {
                    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera && (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e)
                },
                intersectObject: function(t, e, i) {
                    var n = i || [];
                    return Ic(t, this, n, e), n.sort(Fc), n
                },
                intersectObjects: function(t, e, i) {
                    var n = i || [];
                    if (!1 === Array.isArray(t)) return n;
                    for (var r = 0, a = t.length; r < a; r++) Ic(t[r], this, n, e);
                    return n.sort(Fc), n
                }
            });

            function Nc(t, e, i) {
                return void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0), this.radius = t, this.phi = e, this.theta = i, this
            }
            Nc.prototype.set = function(t, e, i) {
                return this.radius = t, this.phi = e, this.theta = i, this
            }, Nc.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, Nc.prototype.copy = function(t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            }, Nc.prototype.makeSafe = function() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            }, Nc.prototype.setFromVector3 = function(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            }, Nc.prototype.setFromCartesianCoords = function(t, e, i) {
                return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(je.clamp(e / this.radius, -1, 1))), this
            };

            function Bc(t, e, i) {
                return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
            }
            Bc.prototype.set = function(t, e, i) {
                return this.radius = t, this.theta = e, this.y = i, this
            }, Bc.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, Bc.prototype.copy = function(t) {
                return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
            }, Bc.prototype.setFromVector3 = function(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            }, Bc.prototype.setFromCartesianCoords = function(t, e, i) {
                return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this
            };

            function Rc(t, e) {
                Object.defineProperty(this, "isBox2", {
                    value: !0
                }), this.min = void 0 !== t ? t : new He(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new He(-1 / 0, -1 / 0)
            }
            var zc = new He;
            Rc.prototype.set = function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }, Rc.prototype.setFromPoints = function(t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            }, Rc.prototype.setFromCenterAndSize = function(t, e) {
                var i = zc.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
            }, Rc.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, Rc.prototype.copy = function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }, Rc.prototype.makeEmpty = function() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            }, Rc.prototype.isEmpty = function() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }, Rc.prototype.getCenter = function(t) {
                return void 0 === t && (t = new He), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }, Rc.prototype.getSize = function(t) {
                return void 0 === t && (t = new He), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            }, Rc.prototype.expandByPoint = function(t) {
                return this.min.min(t), this.max.max(t), this
            }, Rc.prototype.expandByVector = function(t) {
                return this.min.sub(t), this.max.add(t), this
            }, Rc.prototype.expandByScalar = function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }, Rc.prototype.containsPoint = function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }, Rc.prototype.containsBox = function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }, Rc.prototype.getParameter = function(t, e) {
                return void 0 === e && (e = new He), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }, Rc.prototype.intersectsBox = function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }, Rc.prototype.clampPoint = function(t, e) {
                return void 0 === e && (e = new He), e.copy(t).clamp(this.min, this.max)
            }, Rc.prototype.distanceToPoint = function(t) {
                return zc.copy(t).clamp(this.min, this.max).sub(t).length()
            }, Rc.prototype.intersect = function(t) {
                return this.min.max(t.min), this.max.min(t.max), this
            }, Rc.prototype.union = function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }, Rc.prototype.translate = function(t) {
                return this.min.add(t), this.max.add(t), this
            }, Rc.prototype.equals = function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            };

            function Gc(t, e) {
                this.start = void 0 !== t ? t : new ni, this.end = void 0 !== e ? e : new ni
            }
            var Vc = new ni,
                Uc = new ni;

            function jc(t) {
                rn.call(this), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
            }
            Gc.prototype.set = function(t, e) {
                return this.start.copy(t), this.end.copy(e), this
            }, Gc.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, Gc.prototype.copy = function(t) {
                return this.start.copy(t.start), this.end.copy(t.end), this
            }, Gc.prototype.getCenter = function(t) {
                return void 0 === t && (t = new ni), t.addVectors(this.start, this.end).multiplyScalar(.5)
            }, Gc.prototype.delta = function(t) {
                return void 0 === t && (t = new ni), t.subVectors(this.end, this.start)
            }, Gc.prototype.distanceSq = function() {
                return this.start.distanceToSquared(this.end)
            }, Gc.prototype.distance = function() {
                return this.start.distanceTo(this.end)
            }, Gc.prototype.at = function(t, e) {
                return void 0 === e && (e = new ni), this.delta(e).multiplyScalar(t).add(this.start)
            }, Gc.prototype.closestPointToPointParameter = function(t, e) {
                Vc.subVectors(t, this.start), Uc.subVectors(this.end, this.start);
                var i = Uc.dot(Uc),
                    n = Uc.dot(Vc) / i;
                return e && (n = je.clamp(n, 0, 1)), n
            }, Gc.prototype.closestPointToPoint = function(t, e, i) {
                var n = this.closestPointToPointParameter(t, e);
                return void 0 === i && (i = new ni), this.delta(i).multiplyScalar(n).add(this.start)
            }, Gc.prototype.applyMatrix4 = function(t) {
                return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
            }, Gc.prototype.equals = function(t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }, ((jc.prototype = Object.create(rn.prototype)).constructor = jc).prototype.isImmediateRenderObject = !0;
            var Hc = new ni;

            function Wc(t, e) {
                rn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                for (var i = new Kn, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, a = 1; r < 32; r++, a++) {
                    var s = r / 32 * Math.PI * 2,
                        o = a / 32 * Math.PI * 2;
                    n.push(Math.cos(s), Math.sin(s), 1, Math.cos(o), Math.sin(o), 1)
                }
                i.setAttribute("position", new Vn(n, 3));
                var l = new No({
                    fog: !1,
                    toneMapped: !1
                });
                this.cone = new Wo(i, l), this.add(this.cone), this.update()
            }((Wc.prototype = Object.create(rn.prototype)).constructor = Wc).prototype.dispose = function() {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, Wc.prototype.update = function() {
                this.light.updateMatrixWorld();
                var t = this.light.distance ? this.light.distance : 1e3,
                    e = t * Math.tan(this.light.angle);
                this.cone.scale.set(e, e, t), Hc.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Hc), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            };
            var qc = new ni,
                Xc = new Li,
                Yc = new Li;

            function Jc(t) {
                for (var e = function t(e) {
                        var i = [];
                        e && e.isBone && i.push(e);
                        for (var n = 0; n < e.children.length; n++) i.push.apply(i, t(e.children[n]));
                        return i
                    }(t), i = new Kn, n = [], r = [], a = new Cn(0, 0, 1), s = new Cn(0, 1, 0), o = 0; o < e.length; o++) {
                    var l = e[o];
                    l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(s.r, s.g, s.b))
                }
                i.setAttribute("position", new Vn(n, 3)), i.setAttribute("color", new Vn(r, 3));
                var h = new No({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                });
                Wo.call(this, i, h), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }

            function Zc(t, e, i) {
                var n = new Zl(e, 4, 2),
                    r = new Pn({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    });
                gr.call(this, n, r), this.light = t, this.light.updateMatrixWorld(), this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }((Jc.prototype = Object.create(Wo.prototype)).constructor = Jc).prototype.updateMatrixWorld = function(t) {
                var e = this.bones,
                    i = this.geometry,
                    n = i.getAttribute("position");
                Yc.getInverse(this.root.matrixWorld);
                for (var r = 0, a = 0; r < e.length; r++) {
                    var s = e[r];
                    s.parent && s.parent.isBone && (Xc.multiplyMatrices(Yc, s.matrixWorld), qc.setFromMatrixPosition(Xc), n.setXYZ(a, qc.x, qc.y, qc.z), Xc.multiplyMatrices(Yc, s.parent.matrixWorld), qc.setFromMatrixPosition(Xc), n.setXYZ(a + 1, qc.x, qc.y, qc.z), a += 2)
                }
                i.getAttribute("position").needsUpdate = !0, Wo.prototype.updateMatrixWorld.call(this, t)
            }, ((Zc.prototype = Object.create(gr.prototype)).constructor = Zc).prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose()
            }, Zc.prototype.update = function() {
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            };
            var $c = new ni,
                Kc = new Cn,
                Qc = new Cn;

            function tp(t, e, i) {
                rn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
                var n = new pl(e);
                n.rotateY(.5 * Math.PI), this.material = new Pn({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                }), void 0 === this.color && (this.material.vertexColors = !0);
                var r = n.getAttribute("position"),
                    a = new Float32Array(3 * r.count);
                n.setAttribute("color", new On(a, 3)), this.add(new gr(n, this.material)), this.update()
            }

            function ep(t, e, i, n) {
                t = t || 10, e = e || 10, i = new Cn(void 0 !== i ? i : 4473924), n = new Cn(void 0 !== n ? n : 8947848);
                for (var r = e / 2, a = t / e, s = t / 2, o = [], l = [], h = 0, u = 0, c = -s; h <= e; h++, c += a) {
                    o.push(-s, 0, c, s, 0, c), o.push(c, 0, -s, c, 0, s);
                    var p = h === r ? i : n;
                    p.toArray(l, u), u += 3, p.toArray(l, u), u += 3, p.toArray(l, u), u += 3, p.toArray(l, u), u += 3
                }
                var d = new Kn;
                d.setAttribute("position", new Vn(o, 3)), d.setAttribute("color", new Vn(l, 3));
                var f = new No({
                    vertexColors: !0,
                    toneMapped: !1
                });
                Wo.call(this, d, f), this.type = "GridHelper"
            }

            function ip(t, e, i, n, r, a) {
                t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new Cn(void 0 !== r ? r : 4473924), a = new Cn(void 0 !== a ? a : 8947848);
                for (var s = [], o = [], l = 0; l <= e; l++) {
                    var h = l / e * (2 * Math.PI),
                        u = Math.sin(h) * t,
                        c = Math.cos(h) * t;
                    s.push(0, 0, 0), s.push(u, 0, c);
                    var p = 1 & l ? r : a;
                    o.push(p.r, p.g, p.b), o.push(p.r, p.g, p.b)
                }
                for (var d = 0; d <= i; d++)
                    for (var f = 1 & d ? r : a, m = t - t / i * d, g = 0; g < n; g++) {
                        var v = g / n * (2 * Math.PI),
                            y = Math.sin(v) * m,
                            b = Math.cos(v) * m;
                        s.push(y, 0, b), o.push(f.r, f.g, f.b), v = (g + 1) / n * (2 * Math.PI), y = Math.sin(v) * m, b = Math.cos(v) * m, s.push(y, 0, b), o.push(f.r, f.g, f.b)
                    }
                var x = new Kn;
                x.setAttribute("position", new Vn(s, 3)), x.setAttribute("color", new Vn(o, 3));
                var _ = new No({
                    vertexColors: !0,
                    toneMapped: !1
                });
                Wo.call(this, x, _), this.type = "PolarGridHelper"
            }((tp.prototype = Object.create(rn.prototype)).constructor = tp).prototype.dispose = function() {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, tp.prototype.update = function() {
                var t = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var e = t.geometry.getAttribute("color");
                    Kc.copy(this.light.color), Qc.copy(this.light.groundColor);
                    for (var i = 0, n = e.count; i < n; i++) {
                        var r = i < n / 2 ? Kc : Qc;
                        e.setXYZ(i, r.r, r.g, r.b)
                    }
                    e.needsUpdate = !0
                }
                t.lookAt($c.setFromMatrixPosition(this.light.matrixWorld).negate())
            }, (ep.prototype = Object.create(Wo.prototype)).constructor = ep, (ip.prototype = Object.create(Wo.prototype)).constructor = ip;
            var np = new ni,
                rp = new ni,
                ap = new ni;

            function sp(t, e, i) {
                rn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
                var n = new Kn;
                n.setAttribute("position", new Vn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                var r = new No({
                    fog: !1,
                    toneMapped: !1
                });
                this.lightPlane = new Uo(n, r), this.add(this.lightPlane), (n = new Kn).setAttribute("position", new Vn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Uo(n, r), this.add(this.targetLine), this.update()
            }((sp.prototype = Object.create(rn.prototype)).constructor = sp).prototype.dispose = function() {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }, sp.prototype.update = function() {
                np.setFromMatrixPosition(this.light.matrixWorld), rp.setFromMatrixPosition(this.light.target.matrixWorld), ap.subVectors(rp, np), this.lightPlane.lookAt(rp), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(rp), this.targetLine.scale.z = ap.length()
            };
            var op = new ni,
                lp = new kr;

            function hp(t) {
                var e = new Kn,
                    i = new No({
                        color: 16777215,
                        vertexColors: !0,
                        toneMapped: !1
                    }),
                    n = [],
                    r = [],
                    a = {},
                    s = new Cn(16755200),
                    o = new Cn(16711680),
                    l = new Cn(43775),
                    h = new Cn(16777215),
                    u = new Cn(3355443);

                function c(t, e, i) {
                    p(t, i), p(e, i)
                }

                function p(t, e) {
                    n.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === a[t] && (a[t] = []), a[t].push(n.length / 3 - 1)
                }
                c("n1", "n2", s), c("n2", "n4", s), c("n4", "n3", s), c("n3", "n1", s), c("f1", "f2", s), c("f2", "f4", s), c("f4", "f3", s), c("f3", "f1", s), c("n1", "f1", s), c("n2", "f2", s), c("n3", "f3", s), c("n4", "f4", s), c("p", "n1", o), c("p", "n2", o), c("p", "n3", o), c("p", "n4", o), c("u1", "u2", l), c("u2", "u3", l), c("u3", "u1", l), c("c", "t", h), c("p", "c", u), c("cn1", "cn2", u), c("cn3", "cn4", u), c("cf1", "cf2", u), c("cf3", "cf4", u), e.setAttribute("position", new Vn(n, 3)), e.setAttribute("color", new Vn(r, 3)), Wo.call(this, e, i), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
            }

            function up(t, e, i, n, r, a, s) {
                op.set(r, a, s).unproject(n);
                var o = e[t];
                if (void 0 !== o)
                    for (var l = i.getAttribute("position"), h = 0, u = o.length; h < u; h++) l.setXYZ(o[h], op.x, op.y, op.z)
            }((hp.prototype = Object.create(Wo.prototype)).constructor = hp).prototype.update = function() {
                var t = this.geometry,
                    e = this.pointMap;
                lp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), up("c", e, t, lp, 0, 0, -1), up("t", e, t, lp, 0, 0, 1), up("n1", e, t, lp, -1, -1, -1), up("n2", e, t, lp, 1, -1, -1), up("n3", e, t, lp, -1, 1, -1), up("n4", e, t, lp, 1, 1, -1), up("f1", e, t, lp, -1, -1, 1), up("f2", e, t, lp, 1, -1, 1), up("f3", e, t, lp, -1, 1, 1), up("f4", e, t, lp, 1, 1, 1), up("u1", e, t, lp, .7, 1.1, -1), up("u2", e, t, lp, -.7, 1.1, -1), up("u3", e, t, lp, 0, 2, -1), up("cf1", e, t, lp, -1, 0, 1), up("cf2", e, t, lp, 1, 0, 1), up("cf3", e, t, lp, 0, -1, 1), up("cf4", e, t, lp, 0, 1, 1), up("cn1", e, t, lp, -1, 0, -1), up("cn2", e, t, lp, 1, 0, -1), up("cn3", e, t, lp, 0, -1, -1), up("cn4", e, t, lp, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
            };
            var cp = new ri;

            function pp(t, e) {
                void 0 === e && (e = 16776960);
                var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    n = new Float32Array(24),
                    r = new Kn;
                r.setIndex(new On(i, 1)), r.setAttribute("position", new On(n, 3)), Wo.call(this, r, new No({
                    color: e,
                    toneMapped: !1
                })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
            }

            function dp(t, e) {
                void 0 === e && (e = 16776960);
                var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    n = new Kn;
                n.setIndex(new On(i, 1)), n.setAttribute("position", new Vn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Wo.call(this, n, new No({
                    color: e,
                    toneMapped: !1
                })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
            }

            function fp(t, e, i) {
                var n = void 0 !== i ? i : 16776960,
                    r = new Kn;
                r.setAttribute("position", new Vn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), Uo.call(this, r, new No({
                    color: n,
                    toneMapped: !1
                })), this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
                var a = new Kn;
                a.setAttribute("position", new Vn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new gr(a, new Pn({
                    color: n,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1
                })))
            }((pp.prototype = Object.create(Wo.prototype)).constructor = pp).prototype.update = function() {
                var t, e, i, n;
                void 0 !== this.object && cp.setFromObject(this.object), cp.isEmpty() || (t = cp.min, e = cp.max, (n = (i = this.geometry.attributes.position).array)[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = t.x, n[4] = e.y, n[5] = e.z, n[6] = t.x, n[7] = t.y, n[8] = e.z, n[9] = e.x, n[10] = t.y, n[11] = e.z, n[12] = e.x, n[13] = e.y, n[14] = t.z, n[15] = t.x, n[16] = e.y, n[17] = t.z, n[18] = t.x, n[19] = t.y, n[20] = t.z, n[21] = e.x, n[22] = t.y, n[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere())
            }, pp.prototype.setFromObject = function(t) {
                return this.object = t, this.update(), this
            }, pp.prototype.copy = function(t) {
                return Wo.prototype.copy.call(this, t), this.object = t.object, this
            }, ((dp.prototype = Object.create(Wo.prototype)).constructor = dp).prototype.updateMatrixWorld = function(t) {
                var e = this.box;
                e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), Wo.prototype.updateMatrixWorld.call(this, t))
            }, ((fp.prototype = Object.create(Uo.prototype)).constructor = fp).prototype.updateMatrixWorld = function(t) {
                var e = -this.plane.constant;
                Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? q : k, this.lookAt(this.plane.normal), Uo.prototype.updateMatrixWorld.call(this, t)
            };
            var mp, gp, vp = new ni;

            function yp(t, e, i, n, r, a) {
                rn.call(this), this.type = "ArrowHelper", void 0 === t && (t = new ni(0, 0, 1)), void 0 === e && (e = new ni(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === r && (r = .2 * i), void 0 === a && (a = .2 * r), void 0 === mp && ((mp = new Kn).setAttribute("position", new Vn([0, 0, 0, 0, 1, 0], 3)), (gp = new sh(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new Uo(mp, new No({
                    color: n,
                    toneMapped: !1
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new gr(gp, new Pn({
                    color: n,
                    toneMapped: !1
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, r, a)
            }

            function bp(t) {
                void 0 === t && (t = 1);
                var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    i = new Kn;
                i.setAttribute("position", new Vn(e, 3)), i.setAttribute("color", new Vn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var n = new No({
                    vertexColors: !0,
                    toneMapped: !1
                });
                Wo.call(this, i, n), this.type = "AxesHelper"
            }((yp.prototype = Object.create(rn.prototype)).constructor = yp).prototype.setDirection = function(t) {
                var e;
                .99999 < t.y ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (vp.set(t.z, 0, -t.x).normalize(), e = Math.acos(t.y), this.quaternion.setFromAxisAngle(vp, e))
            }, yp.prototype.setLength = function(t, e, i) {
                void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
            }, yp.prototype.setColor = function(t) {
                this.line.material.color.set(t), this.cone.material.color.set(t)
            }, yp.prototype.copy = function(t) {
                return rn.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
            }, (bp.prototype = Object.create(Wo.prototype)).constructor = bp;
            var xp = Math.pow(2, 8),
                _p = [.125, .215, .35, .446, .526, .582],
                wp = 5 + _p.length,
                Sp = {};
            Sp[Te] = 0, Sp[Ce] = 1, Sp[Ee] = 2, Sp[i] = 3, Sp[n] = 4, Sp[De] = 5, Sp[Ae] = 6;

            function Mp(t) {
                var e, i, n;
                this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = (e = 20, i = new Float32Array(e), n = new ni(0, 1, 0), new dh({
                    name: "SphericalGaussianBlur",
                    defines: {
                        n: e
                    },
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        samples: {
                            value: 1
                        },
                        weights: {
                            value: i
                        },
                        latitudinal: {
                            value: !1
                        },
                        dTheta: {
                            value: 0
                        },
                        mipInt: {
                            value: 0
                        },
                        poleAxis: {
                            value: n
                        },
                        inputEncoding: {
                            value: Sp[Te]
                        },
                        outputEncoding: {
                            value: Sp[Te]
                        }
                    },
                    vertexShader: Rp(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t" + zp() + "\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                    blending: Y,
                    depthTest: !1,
                    depthWrite: !1
                })), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
            }
            var Tp = new Cu,
                Cp = function() {
                    for (var t = [], e = [], i = [], n = 8, r = 0; r < wp; r++) {
                        var a = Math.pow(2, n);
                        e.push(a);
                        var s = 1 / a;
                        4 < r ? s = _p[r - 8 + 4 - 1] : 0 == r && (s = 0), i.push(s);
                        for (var o = 1 / (a - 1), l = -o / 2, h = 1 + o / 2, u = [l, l, h, l, h, h, l, l, h, h, l, h], c = new Float32Array(108), p = new Float32Array(72), d = new Float32Array(36), f = 0; f < 6; f++) {
                            var m = f % 3 * 2 / 3 - 1,
                                g = 2 < f ? 0 : -1,
                                v = [m, g, 0, m + 2 / 3, g, 0, m + 2 / 3, 1 + g, 0, m, g, 0, m + 2 / 3, 1 + g, 0, m, 1 + g, 0];
                            c.set(v, 18 * f), p.set(u, 12 * f);
                            var y = [f, f, f, f, f, f];
                            d.set(y, 6 * f)
                        }
                        var b = new Kn;
                        b.setAttribute("position", new On(c, 3)), b.setAttribute("uv", new On(p, 2)), b.setAttribute("faceIndex", new On(d, 1)), t.push(b), 4 < n && n--
                    }
                    return {
                        _lodPlanes: t,
                        _sizeLods: e,
                        _sigmas: i
                    }
                }(),
                Ap = Cp._lodPlanes,
                Ep = Cp._sizeLods,
                Dp = Cp._sigmas,
                Pp = null,
                Lp = (1 + Math.sqrt(5)) / 2,
                kp = 1 / Lp,
                Op = [new ni(1, 1, 1), new ni(-1, 1, 1), new ni(1, 1, -1), new ni(-1, 1, -1), new ni(0, Lp, kp), new ni(0, Lp, -kp), new ni(kp, 0, Lp), new ni(-kp, 0, Lp), new ni(Lp, kp, 0), new ni(-Lp, kp, 0)];

            function Fp(t) {
                var e = new Qe(3 * xp, 3 * xp, t);
                return e.texture.mapping = Pt, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
            }

            function Ip(t, e, i, n, r) {
                t.viewport.set(e, i, n, r), t.scissor.set(e, i, n, r)
            }

            function Np() {
                return new dh({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        texelSize: {
                            value: new He(1, 1)
                        },
                        inputEncoding: {
                            value: Sp[Te]
                        },
                        outputEncoding: {
                            value: Sp[Te]
                        }
                    },
                    vertexShader: Rp(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t" + zp() + "\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                    blending: Y,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function Bp() {
                return new dh({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        inputEncoding: {
                            value: Sp[Te]
                        },
                        outputEncoding: {
                            value: Sp[Te]
                        }
                    },
                    vertexShader: Rp(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t" + zp() + "\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                    blending: Y,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function Rp() {
                return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
            }

            function zp() {
                return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
            }
            Mp.prototype.fromScene = function(t, e, i, n) {
                void 0 === e && (e = 0), void 0 === i && (i = .1), void 0 === n && (n = 100), Pp = this._renderer.getRenderTarget();
                var r = this._allocateTargets();
                return this._sceneToCubeUV(t, i, n, r), 0 < e && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
            }, Mp.prototype.fromEquirectangular = function(t) {
                return this._fromTexture(t)
            }, Mp.prototype.fromCubemap = function(t) {
                return this._fromTexture(t)
            }, Mp.prototype.compileCubemapShader = function() {
                null === this._cubemapShader && (this._cubemapShader = Bp(), this._compileMaterial(this._cubemapShader))
            }, Mp.prototype.compileEquirectangularShader = function() {
                null === this._equirectShader && (this._equirectShader = Np(), this._compileMaterial(this._equirectShader))
            }, Mp.prototype.dispose = function() {
                this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                for (var t = 0; t < Ap.length; t++) Ap[t].dispose()
            }, Mp.prototype._cleanup = function(t) {
                this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Pp), t.scissorTest = !1, Ip(t, 0, 0, t.width, t.height)
            }, Mp.prototype._fromTexture = function(t) {
                Pp = this._renderer.getRenderTarget();
                var e = this._allocateTargets(t);
                return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
            }, Mp.prototype._allocateTargets = function(t) {
                var e, i = {
                        magFilter: It,
                        minFilter: It,
                        generateMipmaps: !1,
                        type: Vt,
                        format: m,
                        encoding: void 0 === (e = t) || e.type !== Vt || e.encoding !== Te && e.encoding !== Ce && e.encoding !== Ae ? Ee : t.encoding,
                        depthBuffer: !1
                    },
                    n = Fp(i);
                return n.depthBuffer = !t, this._pingPongRenderTarget = Fp(i), n
            }, Mp.prototype._compileMaterial = function(t) {
                var e = new gr(Ap[0], t);
                this._renderer.compile(e, Tp)
            }, Mp.prototype._sceneToCubeUV = function(t, e, i, n) {
                var r = new Or(90, 1, e, i),
                    a = [1, -1, 1, 1, 1, 1],
                    s = [1, 1, 1, -1, -1, -1],
                    o = this._renderer,
                    l = o.outputEncoding,
                    h = o.toneMapping,
                    u = o.getClearColor(),
                    c = o.getClearAlpha();
                o.toneMapping = Tt, o.outputEncoding = Te;
                var p, d, f, m = t.background;
                m && m.isColor && (m.convertSRGBToLinear(), p = Math.max(m.r, m.g, m.b), d = Math.min(Math.max(Math.ceil(Math.log2(p)), -128), 127), m = m.multiplyScalar(Math.pow(2, -d)), f = (d + 128) / 255, o.setClearColor(m, f), t.background = null);
                for (var g = 0; g < 6; g++) {
                    var v = g % 3;
                    0 == v ? (r.up.set(0, a[g], 0), r.lookAt(s[g], 0, 0)) : 1 == v ? (r.up.set(0, 0, a[g]), r.lookAt(0, s[g], 0)) : (r.up.set(0, a[g], 0), r.lookAt(0, 0, s[g])), Ip(n, v * xp, 2 < g ? xp : 0, xp, xp), o.setRenderTarget(n), o.render(t, r)
                }
                o.toneMapping = h, o.outputEncoding = l, o.setClearColor(u, c)
            }, Mp.prototype._textureToCubeUV = function(t, e) {
                var i = this._renderer;
                t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Bp()) : null == this._equirectShader && (this._equirectShader = Np());
                var n = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
                    r = new gr(Ap[0], n),
                    a = n.uniforms;
                (a.envMap.value = t).isCubeTexture || a.texelSize.value.set(1 / t.image.width, 1 / t.image.height), a.inputEncoding.value = Sp[t.encoding], a.outputEncoding.value = Sp[e.texture.encoding], Ip(e, 0, 0, 3 * xp, 2 * xp), i.setRenderTarget(e), i.render(r, Tp)
            }, Mp.prototype._applyPMREM = function(t) {
                var e = this._renderer,
                    i = e.autoClear;
                e.autoClear = !1;
                for (var n = 1; n < wp; n++) {
                    var r = Math.sqrt(Dp[n] * Dp[n] - Dp[n - 1] * Dp[n - 1]),
                        a = Op[(n - 1) % Op.length];
                    this._blur(t, n - 1, n, r, a)
                }
                e.autoClear = i
            }, Mp.prototype._blur = function(t, e, i, n, r) {
                var a = this._pingPongRenderTarget;
                this._halfBlur(t, a, e, i, n, "latitudinal", r), this._halfBlur(a, t, i, i, n, "longitudinal", r)
            }, Mp.prototype._halfBlur = function(t, e, i, n, r, a, s) {
                for (var o = this._renderer, l = this._blurMaterial, h = new gr(Ap[n], l), u = l.uniforms, c = Ep[i] - 1, p = isFinite(r) ? Math.PI / (2 * c) : 2 * Math.PI / 39, d = r / p, f = isFinite(r) ? 1 + Math.floor(3 * d) : 20, m = [], g = 0, v = 0; v < 20; ++v) {
                    var y = v / d,
                        b = Math.exp(-y * y / 2);
                    m.push(b), 0 == v ? g += b : v < f && (g += 2 * b)
                }
                for (var x = 0; x < m.length; x++) m[x] = m[x] / g;
                u.envMap.value = t.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === a, s && (u.poleAxis.value = s), u.dTheta.value = p, u.mipInt.value = 8 - i, u.inputEncoding.value = Sp[t.texture.encoding], u.outputEncoding.value = Sp[t.texture.encoding];
                var _ = Ep[n];
                Ip(e, 3 * Math.max(0, xp - 2 * _), (0 === n ? 0 : 2 * xp) + 2 * _ * (4 < n ? n - 8 + 4 : 0), 3 * _, 2 * _), o.setRenderTarget(e), o.render(h, Tp)
            };

            function Gp(t) {
                ru.call(this, t), this.type = "catmullrom", this.closed = !0
            }

            function Vp(t) {
                ru.call(this, t), this.type = "catmullrom"
            }

            function Up(t) {
                ru.call(this, t), this.type = "catmullrom"
            }
            Zh.create = function(t, e) {
                return t.prototype = Object.create(Zh.prototype), (t.prototype.constructor = t).prototype.getPoint = e, t
            }, Object.assign(gu.prototype, {
                createPointsGeometry: function(t) {
                    var e = this.getPoints(t);
                    return this.createGeometry(e)
                },
                createSpacedPointsGeometry: function(t) {
                    var e = this.getSpacedPoints(t);
                    return this.createGeometry(e)
                },
                createGeometry: function(t) {
                    for (var e = new Sr, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        e.vertices.push(new ni(r.x, r.y, r.z || 0))
                    }
                    return e
                }
            }), Object.assign(vu.prototype, {
                fromPoints: function(t) {
                    return this.setFromPoints(t)
                }
            }), Gp.prototype = Object.create(ru.prototype), Vp.prototype = Object.create(ru.prototype), Up.prototype = Object.create(ru.prototype), Object.assign(Up.prototype, {
                initFromArray: function() {},
                getControlPointsArray: function() {},
                reparametrizeByArcLength: function() {}
            }), ep.prototype.setColors = function() {}, Jc.prototype.update = function() {}, Object.assign(Vh.prototype, {
                extractUrlBase: function(t) {
                    return Fu.extractUrlBase(t)
                }
            }), Vh.Handlers = {
                add: function() {},
                get: function() {}
            }, Object.assign(zu.prototype, {
                setTexturePath: function(t) {
                    return this.setResourcePath(t)
                }
            }), Object.assign(Rc.prototype, {
                center: function(t) {
                    return this.getCenter(t)
                },
                empty: function() {
                    return this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return this.intersectsBox(t)
                },
                size: function(t) {
                    return this.getSize(t)
                }
            }), Object.assign(ri.prototype, {
                center: function(t) {
                    return this.getCenter(t)
                },
                empty: function() {
                    return this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return this.intersectsBox(t)
                },
                isIntersectionSphere: function(t) {
                    return this.intersectsSphere(t)
                },
                size: function(t) {
                    return this.getSize(t)
                }
            }), Object.assign(li.prototype, {
                empty: function() {
                    return this.isEmpty()
                }
            }), zr.prototype.setFromMatrix = function(t) {
                return this.setFromProjectionMatrix(t)
            }, Gc.prototype.center = function(t) {
                return this.getCenter(t)
            }, Object.assign(je, {
                random16: function() {
                    return Math.random()
                },
                nearestPowerOfTwo: function(t) {
                    return je.floorPowerOfTwo(t)
                },
                nextPowerOfTwo: function(t) {
                    return je.ceilPowerOfTwo(t)
                }
            }), Object.assign(Xe.prototype, {
                flattenToArrayOffset: function(t, e) {
                    return this.toArray(t, e)
                },
                multiplyVector3: function(t) {
                    return t.applyMatrix3(this)
                },
                multiplyVector3Array: function() {},
                applyToBufferAttribute: function(t) {
                    return t.applyMatrix3(this)
                },
                applyToVector3Array: function() {}
            }), Object.assign(Li.prototype, {
                extractPosition: function(t) {
                    return this.copyPosition(t)
                },
                flattenToArrayOffset: function(t, e) {
                    return this.toArray(t, e)
                },
                getPosition: function() {
                    return (new ni).setFromMatrixColumn(this, 3)
                },
                setRotationFromQuaternion: function(t) {
                    return this.makeRotationFromQuaternion(t)
                },
                multiplyToArray: function() {},
                multiplyVector3: function(t) {
                    return t.applyMatrix4(this)
                },
                multiplyVector4: function(t) {
                    return t.applyMatrix4(this)
                },
                multiplyVector3Array: function() {},
                rotateAxis: function(t) {
                    t.transformDirection(this)
                },
                crossVector: function(t) {
                    return t.applyMatrix4(this)
                },
                translate: function() {},
                rotateX: function() {},
                rotateY: function() {},
                rotateZ: function() {},
                rotateByAxis: function() {},
                applyToBufferAttribute: function(t) {
                    return t.applyMatrix4(this)
                },
                applyToVector3Array: function() {},
                makeFrustum: function(t, e, i, n, r, a) {
                    return this.makePerspective(t, e, n, i, r, a)
                }
            }), ln.prototype.isIntersectionLine = function(t) {
                return this.intersectsLine(t)
            }, ei.prototype.multiplyVector3 = function(t) {
                return t.applyQuaternion(this)
            }, Object.assign(Si.prototype, {
                isIntersectionBox: function(t) {
                    return this.intersectsBox(t)
                },
                isIntersectionPlane: function(t) {
                    return this.intersectsPlane(t)
                },
                isIntersectionSphere: function(t) {
                    return this.intersectsSphere(t)
                }
            }), Object.assign(bn.prototype, {
                area: function() {
                    return this.getArea()
                },
                barycoordFromPoint: function(t, e) {
                    return this.getBarycoord(t, e)
                },
                midpoint: function(t) {
                    return this.getMidpoint(t)
                },
                normal: function(t) {
                    return this.getNormal(t)
                },
                plane: function(t) {
                    return this.getPlane(t)
                }
            }), Object.assign(bn, {
                barycoordFromPoint: function(t, e, i, n, r) {
                    return bn.getBarycoord(t, e, i, n, r)
                },
                normal: function(t, e, i, n) {
                    return bn.getNormal(t, e, i, n)
                }
            }), Object.assign(yu.prototype, {
                extractAllPoints: function(t) {
                    return this.extractPoints(t)
                },
                extrude: function(t) {
                    return new jl(this, t)
                },
                makeGeometry: function(t) {
                    return new eh(this, t)
                }
            }), Object.assign(He.prototype, {
                fromAttribute: function(t, e, i) {
                    return this.fromBufferAttribute(t, e, i)
                },
                distanceToManhattan: function(t) {
                    return this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return this.manhattanLength()
                }
            }), Object.assign(ni.prototype, {
                setEulerFromRotationMatrix: function() {},
                setEulerFromQuaternion: function() {},
                getPositionFromMatrix: function(t) {
                    return this.setFromMatrixPosition(t)
                },
                getScaleFromMatrix: function(t) {
                    return this.setFromMatrixScale(t)
                },
                getColumnFromMatrix: function(t, e) {
                    return this.setFromMatrixColumn(e, t)
                },
                applyProjection: function(t) {
                    return this.applyMatrix4(t)
                },
                fromAttribute: function(t, e, i) {
                    return this.fromBufferAttribute(t, e, i)
                },
                distanceToManhattan: function(t) {
                    return this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return this.manhattanLength()
                }
            }), Object.assign($e.prototype, {
                fromAttribute: function(t, e, i) {
                    return this.fromBufferAttribute(t, e, i)
                },
                lengthManhattan: function() {
                    return this.manhattanLength()
                }
            }), Object.assign(Sr.prototype, {
                computeTangents: function() {},
                computeLineDistances: function() {},
                applyMatrix: function(t) {
                    return this.applyMatrix4(t)
                }
            }), Object.assign(rn.prototype, {
                getChildByName: function(t) {
                    return this.getObjectByName(t)
                },
                renderDepth: function() {},
                translate: function(t, e) {
                    return this.translateOnAxis(e, t)
                },
                getWorldRotation: function() {},
                applyMatrix: function(t) {
                    return this.applyMatrix4(t)
                }
            }), Object.defineProperties(rn.prototype, {
                eulerOrder: {
                    get: function() {
                        return this.rotation.order
                    },
                    set: function(t) {
                        this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {},
                    set: function() {}
                }
            }), Object.assign(gr.prototype, {
                setDrawMode: function() {}
            }), Object.defineProperties(gr.prototype, {
                drawMode: {
                    get: function() {
                        return 0
                    },
                    set: function() {}
                }
            }), Object.defineProperties(To.prototype, {
                objects: {
                    get: function() {
                        return this.levels
                    }
                }
            }), Object.defineProperty(Do.prototype, "useVertexTexture", {
                get: function() {},
                set: function() {}
            }), Co.prototype.initBones = function() {}, Object.defineProperty(Zh.prototype, "__arcLengthDivisions", {
                get: function() {
                    return this.arcLengthDivisions
                },
                set: function(t) {
                    this.arcLengthDivisions = t
                }
            }), Or.prototype.setLens = function(t, e) {
                void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(bu.prototype, {
                onlyShadow: {
                    set: function() {}
                },
                shadowCameraFov: {
                    set: function(t) {
                        this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {}
                },
                shadowBias: {
                    set: function(t) {
                        this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {}
                },
                shadowMapWidth: {
                    set: function(t) {
                        this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(On.prototype, {
                length: {
                    get: function() {
                        return this.array.length
                    }
                },
                dynamic: {
                    get: function() {
                        return this.usage === Be
                    },
                    set: function() {
                        this.setUsage(Be)
                    }
                }
            }), Object.assign(On.prototype, {
                setDynamic: function(t) {
                    return this.setUsage(!0 === t ? Be : Ne), this
                },
                copyIndicesArray: function() {},
                setArray: function() {}
            }), Object.assign(Kn.prototype, {
                addIndex: function(t) {
                    this.setIndex(t)
                },
                addAttribute: function(t, e, i) {
                    return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (this.setIndex(e), this) : this.setAttribute(t, e) : this.setAttribute(t, new On(e, i))
                },
                addDrawCall: function(t, e) {
                    this.addGroup(t, e)
                },
                clearDrawCalls: function() {
                    this.clearGroups()
                },
                computeTangents: function() {},
                computeOffsets: function() {},
                removeAttribute: function(t) {
                    return this.deleteAttribute(t)
                },
                applyMatrix: function(t) {
                    return this.applyMatrix4(t)
                }
            }), Object.defineProperties(Kn.prototype, {
                drawcalls: {
                    get: function() {
                        return this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return this.groups
                    }
                }
            }), Object.defineProperties(Iu.prototype, {
                maxInstancedCount: {
                    get: function() {
                        return this.instanceCount
                    },
                    set: function(t) {
                        this.instanceCount = t
                    }
                }
            }), Object.defineProperties(Oc.prototype, {
                linePrecision: {
                    get: function() {
                        return this.params.Line.threshold
                    },
                    set: function(t) {
                        this.params.Line.threshold = t
                    }
                }
            }), Object.defineProperties(Ks.prototype, {
                dynamic: {
                    get: function() {
                        return this.usage === Be
                    },
                    set: function(t) {
                        this.setUsage(t)
                    }
                }
            }), Object.assign(Ks.prototype, {
                setDynamic: function(t) {
                    return this.setUsage(!0 === t ? Be : Ne), this
                },
                setArray: function() {}
            }), Object.assign(Hl.prototype, {
                getArrays: function() {},
                addShapeList: function() {},
                addShape: function() {}
            }), Object.assign($s.prototype, {
                dispose: function() {}
            }), Object.defineProperties(Pc.prototype, {
                dynamic: {
                    set: function() {}
                },
                onUpdate: {
                    value: function() {
                        return this
                    }
                }
            }), Object.defineProperties(Dn.prototype, {
                wrapAround: {
                    get: function() {},
                    set: function() {}
                },
                overdraw: {
                    get: function() {},
                    set: function() {}
                },
                wrapRGB: {
                    get: function() {
                        return new Cn
                    }
                },
                shading: {
                    get: function() {},
                    set: function(t) {
                        this.flatShading = 1 === t
                    }
                },
                stencilMask: {
                    get: function() {
                        return this.stencilFuncMask
                    },
                    set: function(t) {
                        this.stencilFuncMask = t
                    }
                }
            }), Object.defineProperties(gh.prototype, {
                metal: {
                    get: function() {
                        return !1
                    },
                    set: function() {}
                }
            }), Object.defineProperties(mh.prototype, {
                transparency: {
                    get: function() {
                        return this.transmission
                    },
                    set: function(t) {
                        this.transmission = t
                    }
                }
            }), Object.defineProperties(Lr.prototype, {
                derivatives: {
                    get: function() {
                        return this.extensions.derivatives
                    },
                    set: function(t) {
                        this.extensions.derivatives = t
                    }
                }
            }), Object.assign(Xs.prototype, {
                clearTarget: function(t, e, i, n) {
                    this.setRenderTarget(t), this.clear(e, i, n)
                },
                animate: function(t) {
                    this.setAnimationLoop(t)
                },
                getCurrentRenderTarget: function() {
                    return this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return this.capabilities.precision
                },
                resetGLState: function() {
                    return this.state.reset()
                },
                supportsFloatTextures: function() {
                    return this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(t) {
                    this.setScissorTest(t)
                },
                initMaterial: function() {},
                addPrePlugin: function() {},
                addPostPlugin: function() {},
                updateShadowMap: function() {},
                setFaceCulling: function() {},
                allocTextureUnit: function() {},
                setTexture: function() {},
                setTexture2D: function() {},
                setTextureCube: function() {},
                getActiveMipMapLevel: function() {
                    return this.getActiveMipmapLevel()
                }
            }), Object.defineProperties(Xs.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {},
                    set: function() {}
                },
                context: {
                    get: function() {
                        return this.getContext()
                    }
                },
                vr: {
                    get: function() {
                        return this.xr
                    }
                },
                gammaInput: {
                    get: function() {
                        return !1
                    },
                    set: function() {}
                },
                gammaOutput: {
                    get: function() {
                        return !1
                    },
                    set: function(t) {
                        this.outputEncoding = !0 === t ? Ce : Te
                    }
                },
                toneMappingWhitePoint: {
                    get: function() {
                        return 1
                    },
                    set: function() {}
                }
            }), Object.defineProperties(Rs.prototype, {
                cullFace: {
                    get: function() {},
                    set: function() {}
                },
                renderReverseSided: {
                    get: function() {},
                    set: function() {}
                },
                renderSingleSided: {
                    get: function() {},
                    set: function() {}
                }
            }), Object.defineProperties(Qe.prototype, {
                wrapS: {
                    get: function() {
                        return this.texture.wrapS
                    },
                    set: function(t) {
                        this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return this.texture.wrapT
                    },
                    set: function(t) {
                        this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return this.texture.magFilter
                    },
                    set: function(t) {
                        this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return this.texture.minFilter
                    },
                    set: function(t) {
                        this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return this.texture.anisotropy
                    },
                    set: function(t) {
                        this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return this.texture.offset
                    },
                    set: function(t) {
                        this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return this.texture.repeat
                    },
                    set: function(t) {
                        this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return this.texture.format
                    },
                    set: function(t) {
                        this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return this.texture.type
                    },
                    set: function(t) {
                        this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return this.texture.generateMipmaps
                    },
                    set: function(t) {
                        this.texture.generateMipmaps = t
                    }
                }
            }), Object.defineProperties(oc.prototype, {
                load: {
                    value: function(t) {
                        var e = this;
                        return (new Ju).load(t, function(t) {
                            e.setBuffer(t)
                        }), this
                    }
                },
                startTime: {
                    set: function() {}
                }
            }), dc.prototype.getData = function() {
                return this.getFrequencyData()
            }, Fr.prototype.updateCubeMap = function(t, e) {
                return this.update(t, e)
            };
            var jp = {
                merge: function(t, e, i) {
                    var n;
                    e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, i)
                },
                center: function(t) {
                    return t.center()
                }
            };
            Ye.crossOrigin = void 0, Ye.loadTexture = function(t, e, i, n) {
                var r = new Jh;
                r.setCrossOrigin(this.crossOrigin);
                var a = r.load(t, i, void 0, n);
                return e && (a.mapping = e), a
            }, Ye.loadTextureCube = function(t, e, i, n) {
                var r = new Xh;
                r.setCrossOrigin(this.crossOrigin);
                var a = r.load(t, i, void 0, n);
                return e && (a.mapping = e), a
            }, Ye.loadCompressedTexture = function() {}, Ye.loadCompressedTextureCube = function() {};
            var Hp = {
                createMultiMaterialObject: function() {},
                detach: function() {},
                attach: function() {}
            };
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: "120"
                }
            })), t.ACESFilmicToneMapping = Ct, t.AddEquation = tt, t.AddOperation = G, t.AdditiveAnimationBlendMode = 2501, t.AdditiveBlending = Z, t.AlphaFormat = p, t.AlwaysDepth = vt, t.AlwaysStencilFunc = Ie, t.AmbientLight = Du, t.AmbientLightProbe = $u, t.AnimationClip = Nh, t.AnimationLoader = Hh, t.AnimationMixer = Dc, t.AnimationObjectGroup = Ac, t.AnimationUtils = Sh, t.ArcCurve = Kh, t.ArrayCamera = Us, t.ArrowHelper = yp, t.Audio = oc, t.AudioAnalyser = dc, t.AudioContext = Yu, t.AudioListener = sc, t.AudioLoader = Ju, t.AxesHelper = bp, t.AxisHelper = function(t) {
                return new bp(t)
            }, t.BackSide = q, t.BasicDepthPacking = Pe, t.BasicShadowMap = 0, t.BinaryTextureLoader = function(t) {
                return new Yh(t)
            }, t.Bone = Po, t.BooleanKeyframeTrack = Dh, t.BoundingBoxHelper = function(t, e) {
                return new pp(t, e)
            }, t.Box2 = Rc, t.Box3 = ri, t.Box3Helper = dp, t.BoxBufferGeometry = Tr, t.BoxGeometry = Mr, t.BoxHelper = pp, t.BufferAttribute = On, t.BufferGeometry = Kn, t.BufferGeometryLoader = Bu, t.ByteType = r, t.Cache = Rh, t.Camera = kr, t.CameraHelper = hp, t.CanvasRenderer = function() {}, t.CanvasTexture = il, t.CatmullRomCurve3 = ru, t.CineonToneMapping = Mt, t.CircleBufferGeometry = uh, t.CircleGeometry = hh, t.ClampToEdgeWrapping = Ot, t.Clock = ec, t.ClosedSplineCurve3 = Gp, t.Color = Cn, t.ColorKeyframeTrack = Ph, t.CompressedTexture = el, t.CompressedTextureLoader = Wh, t.ConeBufferGeometry = lh, t.ConeGeometry = oh, t.CubeCamera = Fr, t.CubeGeometry = Mr, t.CubeReflectionMapping = Et, t.CubeRefractionMapping = Dt, t.CubeTexture = oa, t.CubeTextureLoader = Xh, t.CubeUVReflectionMapping = Pt, t.CubeUVRefractionMapping = Lt, t.CubicBezierCurve = lu, t.CubicBezierCurve3 = hu, t.CubicInterpolant = Th, t.CullFaceBack = H, t.CullFaceFront = W, t.CullFaceFrontBack = 3, t.CullFaceNone = j, t.Curve = Zh, t.CurvePath = gu, t.CustomBlending = Q, t.CustomToneMapping = At, t.CylinderBufferGeometry = sh, t.CylinderGeometry = ah, t.Cylindrical = Bc, t.DataTexture = Nr, t.DataTexture2DArray = la, t.DataTexture3D = ha, t.DataTextureLoader = Yh, t.DecrementStencilOp = 7683, t.DecrementWrapStencilOp = 34056, t.DefaultLoadingManager = Gh, t.DepthFormat = Jt, t.DepthStencilFormat = Zt, t.DepthTexture = nl, t.DirectionalLight = Eu, t.DirectionalLightHelper = sp, t.DiscreteInterpolant = Ah, t.DodecahedronBufferGeometry = gl, t.DodecahedronGeometry = ml, t.DoubleSide = X, t.DstAlphaFactor = ct, t.DstColorFactor = dt, t.DynamicBufferAttribute = function(t, e) {
                return new On(t, e).setUsage(Be)
            }, t.DynamicCopyUsage = 35050, t.DynamicDrawUsage = Be, t.DynamicReadUsage = 35049, t.EdgesGeometry = rh, t.EdgesHelper = function(t, e) {
                return new Wo(new rh(t.geometry), new No({
                    color: void 0 !== e ? e : 16777215
                }))
            }, t.EllipseCurve = $h, t.EqualDepth = xt, t.EqualStencilFunc = 514, t.EquirectangularReflectionMapping = u, t.EquirectangularRefractionMapping = c, t.Euler = zi, t.EventDispatcher = ze, t.ExtrudeBufferGeometry = Hl, t.ExtrudeGeometry = jl, t.Face3 = An, t.Face4 = function(t, e, i, n, r, a, s) {
                return new An(t, e, i, r, a, s)
            }, t.FaceColors = 1, t.FileLoader = jh, t.FlatShading = 1, t.Float32Attribute = function(t, e) {
                return new Vn(t, e)
            }, t.Float32BufferAttribute = Vn, t.Float64Attribute = function(t, e) {
                return new Un(t, e)
            }, t.Float64BufferAttribute = Un, t.FloatType = Ht, t.Fog = Zs, t.FogExp2 = Js, t.Font = qu, t.FontLoader = Xu, t.FrontSide = k, t.Frustum = zr, t.GLBufferAttribute = kc, t.GLSL1 = "100", t.GLSL3 = Re, t.GammaEncoding = Ae, t.Geometry = Sr, t.GeometryUtils = jp, t.GreaterDepth = wt, t.GreaterEqualDepth = _t, t.GreaterEqualStencilFunc = 518, t.GreaterStencilFunc = 516, t.GridHelper = ep, t.Group = js, t.HalfFloatType = Wt, t.HemisphereLight = xu, t.HemisphereLightHelper = tp, t.HemisphereLightProbe = Zu, t.IcosahedronBufferGeometry = fl, t.IcosahedronGeometry = dl, t.ImageBitmapLoader = Hu, t.ImageLoader = qh, t.ImageUtils = Ye, t.ImmediateRenderObject = jc, t.IncrementStencilOp = 7682, t.IncrementWrapStencilOp = 34055, t.InstancedBufferAttribute = Nu, t.InstancedBufferGeometry = Iu, t.InstancedInterleavedBuffer = Lc, t.InstancedMesh = Io, t.Int16Attribute = function(t, e) {
                return new Bn(t, e)
            }, t.Int16BufferAttribute = Bn, t.Int32Attribute = function(t, e) {
                return new zn(t, e)
            }, t.Int32BufferAttribute = zn, t.Int8Attribute = function(t, e) {
                return new Fn(t, e)
            }, t.Int8BufferAttribute = Fn, t.IntType = s, t.InterleavedBuffer = Ks, t.InterleavedBufferAttribute = eo, t.Interpolant = Mh, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.InvertStencilOp = 5386, t.JSONLoader = function() {}, t.KeepStencilOp = Fe, t.KeyframeTrack = Eh, t.LOD = To, t.LatheBufferGeometry = th, t.LatheGeometry = Ql, t.Layers = ji, t.LensFlare = function() {}, t.LessDepth = yt, t.LessEqualDepth = bt, t.LessEqualStencilFunc = 515, t.LessStencilFunc = 513, t.Light = bu, t.LightProbe = ku, t.LightShadow = _u, t.Line = Uo, t.Line3 = Gc, t.LineBasicMaterial = No, t.LineCurve = uu, t.LineCurve3 = cu, t.LineDashedMaterial = _h, t.LineLoop = qo, t.LinePieces = 1, t.LineSegments = Wo, t.LineStrip = 0, t.LinearEncoding = Te, t.LinearFilter = Rt, t.LinearInterpolant = Ch, t.LinearMipMapLinearFilter = 1008, t.LinearMipMapNearestFilter = 1007, t.LinearMipmapLinearFilter = Gt, t.LinearMipmapNearestFilter = zt, t.LinearToneMapping = V, t.Loader = Vh, t.LoaderUtils = Fu, t.LoadingManager = zh, t.LogLuvEncoding = e, t.LoopOnce = 2200, t.LoopPingPong = 2202, t.LoopRepeat = 2201, t.LuminanceAlphaFormat = f, t.LuminanceFormat = d, t.MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2
            }, t.Material = Dn, t.MaterialLoader = Ou, t.Math = je, t.MathUtils = je, t.Matrix3 = Xe, t.Matrix4 = Li, t.MaxEquation = rt, t.Mesh = gr, t.MeshBasicMaterial = Pn, t.MeshDepthMaterial = Fs, t.MeshDistanceMaterial = Is, t.MeshFaceMaterial = function(t) {
                return t
            }, t.MeshLambertMaterial = bh, t.MeshMatcapMaterial = xh, t.MeshNormalMaterial = yh, t.MeshPhongMaterial = gh, t.MeshPhysicalMaterial = mh, t.MeshStandardMaterial = fh, t.MeshToonMaterial = vh, t.MinEquation = nt, t.MirroredRepeatWrapping = Ft, t.MixOperation = z, t.MultiMaterial = function(t) {
                return void 0 === t && (t = []), t.isMultiMaterial = !0, (t.materials = t).clone = function() {
                    return t.slice()
                }, t
            }, t.MultiplyBlending = K, t.MultiplyOperation = R, t.NearestFilter = It, t.NearestMipMapLinearFilter = 1005, t.NearestMipMapNearestFilter = 1004, t.NearestMipmapLinearFilter = Bt, t.NearestMipmapNearestFilter = Nt, t.NeverDepth = gt, t.NeverStencilFunc = 512, t.NoBlending = Y, t.NoColors = 0, t.NoToneMapping = Tt, t.NormalAnimationBlendMode = 2500, t.NormalBlending = J, t.NotEqualDepth = St, t.NotEqualStencilFunc = 517, t.NumberKeyframeTrack = Lh, t.Object3D = rn, t.ObjectLoader = zu, t.ObjectSpaceNormalMap = Oe, t.OctahedronBufferGeometry = pl, t.OctahedronGeometry = cl, t.OneFactor = st, t.OneMinusDstAlphaFactor = pt, t.OneMinusDstColorFactor = ft, t.OneMinusSrcAlphaFactor = ut, t.OneMinusSrcColorFactor = lt, t.OrthographicCamera = Cu, t.PCFShadowMap = I, t.PCFSoftShadowMap = N, t.PMREMGenerator = Mp, t.ParametricBufferGeometry = sl, t.ParametricGeometry = al, t.Particle = function(t) {
                return new go(t)
            }, t.ParticleBasicMaterial = function(t) {
                return new Xo(t)
            }, t.ParticleSystem = function(t, e) {
                return new Ko(t, e)
            }, t.ParticleSystemMaterial = function(t) {
                return new Xo(t)
            }, t.Path = vu, t.PerspectiveCamera = Or, t.Plane = ln, t.PlaneBufferGeometry = jr, t.PlaneGeometry = Ur, t.PlaneHelper = fp, t.PointCloud = function(t, e) {
                return new Ko(t, e)
            }, t.PointCloudMaterial = function(t) {
                return new Xo(t)
            }, t.PointLight = Tu, t.PointLightHelper = Zc, t.Points = Ko, t.PointsMaterial = Xo, t.PolarGridHelper = ip, t.PolyhedronBufferGeometry = ll, t.PolyhedronGeometry = ol, t.PositionalAudio = pc, t.PropertyBinding = Cc, t.PropertyMixer = fc, t.QuadraticBezierCurve = pu, t.QuadraticBezierCurve3 = du, t.Quaternion = ei, t.QuaternionKeyframeTrack = Oh, t.QuaternionLinearInterpolant = kh, t.REVISION = "120", t.RGBADepthPacking = Le, t.RGBAFormat = Yt, t.RGBAIntegerFormat = _, t.RGBA_ASTC_10x10_Format = oe, t.RGBA_ASTC_10x5_Format = re, t.RGBA_ASTC_10x6_Format = ae, t.RGBA_ASTC_10x8_Format = se, t.RGBA_ASTC_12x10_Format = le, t.RGBA_ASTC_12x12_Format = he, t.RGBA_ASTC_4x4_Format = F, t.RGBA_ASTC_5x4_Format = $t, t.RGBA_ASTC_5x5_Format = Kt, t.RGBA_ASTC_6x5_Format = Qt, t.RGBA_ASTC_6x6_Format = te, t.RGBA_ASTC_8x5_Format = ee, t.RGBA_ASTC_8x6_Format = ie, t.RGBA_ASTC_8x8_Format = ne, t.RGBA_BPTC_Format = ue, t.RGBA_ETC2_EAC_Format = O, t.RGBA_PVRTC_2BPPV1_Format = D, t.RGBA_PVRTC_4BPPV1_Format = E, t.RGBA_S3TC_DXT1_Format = S, t.RGBA_S3TC_DXT3_Format = M, t.RGBA_S3TC_DXT5_Format = T, t.RGBDEncoding = De, t.RGBEEncoding = Ee, t.RGBEFormat = m, t.RGBFormat = Xt, t.RGBIntegerFormat = x, t.RGBM16Encoding = n, t.RGBM7Encoding = i, t.RGB_ETC1_Format = P, t.RGB_ETC2_Format = L, t.RGB_PVRTC_2BPPV1_Format = A, t.RGB_PVRTC_4BPPV1_Format = C, t.RGB_S3TC_DXT1_Format = w, t.RGFormat = y, t.RGIntegerFormat = b, t.RawShaderMaterial = dh, t.Ray = Si, t.Raycaster = Oc, t.RectAreaLight = Pu, t.RedFormat = g, t.RedIntegerFormat = v, t.ReinhardToneMapping = U, t.RepeatWrapping = kt, t.ReplaceStencilOp = 7681, t.ReverseSubtractEquation = it, t.RingBufferGeometry = Kl, t.RingGeometry = $l, t.SRGB8_ALPHA8_ASTC_10x10_Format = we, t.SRGB8_ALPHA8_ASTC_10x5_Format = be, t.SRGB8_ALPHA8_ASTC_10x6_Format = xe, t.SRGB8_ALPHA8_ASTC_10x8_Format = _e, t.SRGB8_ALPHA8_ASTC_12x10_Format = Se, t.SRGB8_ALPHA8_ASTC_12x12_Format = Me, t.SRGB8_ALPHA8_ASTC_4x4_Format = ce, t.SRGB8_ALPHA8_ASTC_5x4_Format = pe, t.SRGB8_ALPHA8_ASTC_5x5_Format = de, t.SRGB8_ALPHA8_ASTC_6x5_Format = fe, t.SRGB8_ALPHA8_ASTC_6x6_Format = me, t.SRGB8_ALPHA8_ASTC_8x5_Format = ge, t.SRGB8_ALPHA8_ASTC_8x6_Format = ve, t.SRGB8_ALPHA8_ASTC_8x8_Format = ye, t.Scene = $s, t.SceneUtils = Hp, t.ShaderChunk = Hr, t.ShaderLib = qr, t.ShaderMaterial = Lr, t.ShadowMaterial = ph, t.Shape = yu, t.ShapeBufferGeometry = ih, t.ShapeGeometry = eh, t.ShapePath = Wu, t.ShapeUtils = Gl, t.ShortType = a, t.Skeleton = Do, t.SkeletonHelper = Jc, t.SkinnedMesh = Co, t.SmoothShading = 2, t.Sphere = li, t.SphereBufferGeometry = Zl, t.SphereGeometry = Jl, t.Spherical = Nc, t.SphericalHarmonics3 = Lu, t.Spline = Up, t.SplineCurve = fu, t.SplineCurve3 = Vp, t.SpotLight = Su, t.SpotLightHelper = Wc, t.Sprite = go, t.SpriteMaterial = io, t.SrcAlphaFactor = ht, t.SrcAlphaSaturateFactor = mt, t.SrcColorFactor = ot, t.StaticCopyUsage = 35046, t.StaticDrawUsage = Ne, t.StaticReadUsage = 35045, t.StereoCamera = tc, t.StreamCopyUsage = 35042, t.StreamDrawUsage = 35040, t.StreamReadUsage = 35041, t.StringKeyframeTrack = Fh, t.SubtractEquation = et, t.SubtractiveBlending = $, t.TOUCH = {
                ROTATE: 0,
                PAN: 1,
                DOLLY_PAN: 2,
                DOLLY_ROTATE: 3
            }, t.TangentSpaceNormalMap = ke, t.TetrahedronBufferGeometry = ul, t.TetrahedronGeometry = hl, t.TextBufferGeometry = Yl, t.TextGeometry = Xl, t.Texture = Ze, t.TextureLoader = Jh, t.TorusBufferGeometry = wl, t.TorusGeometry = _l, t.TorusKnotBufferGeometry = xl, t.TorusKnotGeometry = bl, t.Triangle = bn, t.TriangleFanDrawMode = 2, t.TriangleStripDrawMode = 1, t.TrianglesDrawMode = 0, t.TubeBufferGeometry = yl, t.TubeGeometry = vl, t.UVMapping = 300, t.Uint16Attribute = function(t, e) {
                return new Rn(t, e)
            }, t.Uint16BufferAttribute = Rn, t.Uint32Attribute = function(t, e) {
                return new Gn(t, e)
            }, t.Uint32BufferAttribute = Gn, t.Uint8Attribute = function(t, e) {
                return new In(t, e)
            }, t.Uint8BufferAttribute = In, t.Uint8ClampedAttribute = function(t, e) {
                return new Nn(t, e)
            }, t.Uint8ClampedBufferAttribute = Nn, t.Uniform = Pc, t.UniformsLib = Wr, t.UniformsUtils = Er, t.UnsignedByteType = Vt, t.UnsignedInt248Type = qt, t.UnsignedIntType = jt, t.UnsignedShort4444Type = o, t.UnsignedShort5551Type = l, t.UnsignedShort565Type = h, t.UnsignedShortType = Ut, t.VSMShadowMap = B, t.Vector2 = He, t.Vector3 = ni, t.Vector4 = $e, t.VectorKeyframeTrack = Ih, t.Vertex = function(t, e, i) {
                return new ni(t, e, i)
            }, t.VertexColors = 2, t.VideoTexture = tl, t.WebGL1Renderer = Ys, t.WebGLCubeRenderTarget = Ir, t.WebGLMultisampleRenderTarget = ti, t.WebGLRenderTarget = Qe, t.WebGLRenderTargetCube = function(t, e, i) {
                return new Ir(t, i)
            }, t.WebGLRenderer = Xs, t.WebGLUtils = Vs, t.WireframeGeometry = rl, t.WireframeHelper = function(t, e) {
                return new Wo(new rl(t.geometry), new No({
                    color: void 0 !== e ? e : 16777215
                }))
            }, t.WrapAroundEnding = 2402, t.XHRLoader = function(t) {
                return new jh(t)
            }, t.ZeroCurvatureEnding = 2400, t.ZeroFactor = at, t.ZeroSlopeEnding = 2401, t.ZeroStencilOp = 0, t.sRGBEncoding = Ce, Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }, "object" === ((n = void 0) === i ? "undefined" : Wp(i)) && void 0 !== e ? r(i) : "function" == typeof define && define.amd ? define(["exports"], r) : r((n = "undefined" != typeof globalThis ? globalThis : n || self).THREE = {})
    }, {}],
    "vanillajs-datepicker/js/Datepicker.js": [function(t, e, i) {
        "use strict";
        Object.defineProperty(i, "__esModule", {
            value: !0
        }), i.default = void 0;
        var f = t("./lib/utils.js"),
            m = t("./lib/date.js"),
            h = t("./lib/date-format.js"),
            g = t("./lib/event.js"),
            n = t("./i18n/base-locales.js"),
            v = r(t("./options/defaultOptions.js")),
            y = r(t("./options/processOptions.js")),
            b = r(t("./picker/Picker.js")),
            o = t("./events/functions.js"),
            x = t("./events/inputFieldListeners.js"),
            _ = t("./events/otherListeners.js");

        function r(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }

        function s(t) {
            return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function a(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        function w(t, e) {
            return t.map(function(t) {
                return (0, h.formatDate)(t, e.format, e.locale)
            }).join(e.dateDelimiter)
        }

        function S(t, e, i) {
            var n = 2 < arguments.length && void 0 !== i && i,
                r = t.config,
                a = t.dates,
                s = t.rangepicker;
            if (0 === e.length) return n ? [] : void 0;
            var o = s && t === s.datepickers[1],
                l = e.reduce(function(t, e) {
                    var i, n = (0, h.parseDate)(e, r.format, r.locale);
                    return void 0 === n || (0 < r.pickLevel && (i = new Date(n), n = 1 === r.pickLevel ? o ? i.setMonth(i.getMonth() + 1, 0) : i.setDate(1) : o ? i.setFullYear(i.getFullYear() + 1, 0, 0) : i.setMonth(0, 1)), !(0, f.isInRange)(n, r.minDate, r.maxDate) || t.includes(n) || r.datesDisabled.includes(n) || r.daysOfWeekDisabled.includes(new Date(n).getDay()) || t.push(n)), t
                }, []);
            return 0 !== l.length ? (r.multidate && !n && (l = l.reduce(function(t, e) {
                return a.includes(e) || t.push(e), t
            }, a.filter(function(t) {
                return !l.includes(t)
            }))), r.maxNumberOfDates && l.length > r.maxNumberOfDates ? l.slice(-1 * r.maxNumberOfDates) : l) : void 0
        }

        function l(t, e, i) {
            var n, r = 1 < arguments.length && void 0 !== e ? e : 3,
                a = !(2 < arguments.length && void 0 !== i) || i,
                s = t.config,
                o = t.picker,
                l = t.inputField;
            2 & r && (n = o.active ? s.pickLevel : s.startView, o.update().changeView(n).render(a)), 1 & r && l && (l.value = w(t.dates, s))
        }

        function u(t, e, i) {
            var n = i.clear,
                r = i.render,
                a = i.autohide;
            void 0 === r && (r = !0), r ? void 0 === a && (a = t.config.autohide) : a = !1;
            var s = S(t, e, n);
            s && (s.toString() !== t.dates.toString() ? (t.dates = s, l(t, r ? 3 : 1), (0, o.triggerDatepickerEvent)(t, "changeDate")) : l(t, 1), a && t.hide())
        }
        var c = function() {
            function d(t) {
                var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
                    i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : void 0;
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, d), (t.datepicker = this).element = t;
                var n = this.config = Object.assign({
                    buttonClass: e.buttonClass && String(e.buttonClass) || "button",
                    container: document.body,
                    defaultViewDate: (0, m.today)(),
                    maxDate: void 0,
                    minDate: void 0
                }, (0, y.default)(v.default, this));
                this._options = e, Object.assign(n, (0, y.default)(e, this));
                var r, a, s, o = this.inline = "INPUT" !== t.tagName;
                if (o ? (n.container = t, a = (0, f.stringToArray)(t.dataset.date, n.dateDelimiter), delete t.dataset.date) : ((s = e.container ? document.querySelector(e.container) : null) && (n.container = s), (r = this.inputField = t).classList.add("datepicker-input"), a = (0, f.stringToArray)(r.value, n.dateDelimiter)), i) {
                    var l = i.inputs.indexOf(r),
                        h = i.datepickers;
                    if (l < 0 || 1 < l || !Array.isArray(h)) throw Error("Invalid rangepicker object.");
                    h[l] = this, Object.defineProperty(this, "rangepicker", {
                        get: function() {
                            return i
                        }
                    })
                }
                this.dates = S(this, a) || [], r && (r.value = w(this.dates, n));
                var u, c, p = this.picker = new b.default(this);
                o ? this.show() : (u = _.onClickOutside.bind(null, this), c = [
                    [r, "keydown", x.onKeydown.bind(null, this)],
                    [r, "focus", x.onFocus.bind(null, this)],
                    [r, "mousedown", x.onMousedown.bind(null, this)],
                    [r, "click", x.onClickInput.bind(null, this)],
                    [r, "paste", x.onPaste.bind(null, this)],
                    [document, "mousedown", u],
                    [document, "touchstart", u],
                    [window, "resize", p.place.bind(p)]
                ], (0, g.registerListeners)(this, c))
            }
            var t, e, i;
            return t = d, i = [{
                key: "formatDate",
                value: function(t, e, i) {
                    return (0, h.formatDate)(t, e, i && n.locales[i] || n.locales.en)
                }
            }, {
                key: "parseDate",
                value: function(t, e, i) {
                    return (0, h.parseDate)(t, e, i && n.locales[i] || n.locales.en)
                }
            }, {
                key: "locales",
                get: function() {
                    return n.locales
                }
            }], (e = [{
                key: "setOptions",
                value: function(t) {
                    var e = this.picker,
                        i = (0, y.default)(t, this);
                    Object.assign(this._options, t), Object.assign(this.config, i), e.setOptions(i), l(this, 3)
                }
            }, {
                key: "show",
                value: function() {
                    this.inputField && this.inputField.disabled || this.picker.show()
                }
            }, {
                key: "hide",
                value: function() {
                    this.inline || (this.picker.hide(), this.picker.update().changeView(this.config.startView).render())
                }
            }, {
                key: "destroy",
                value: function() {
                    return this.hide(), (0, g.unregisterListeners)(this), this.picker.detach(), this.inline || this.inputField.classList.remove("datepicker-input"), delete this.element.datepicker, this
                }
            }, {
                key: "getDate",
                value: function(t) {
                    var e = this,
                        i = 0 < arguments.length && void 0 !== t ? t : void 0,
                        n = i ? function(t) {
                            return (0, h.formatDate)(t, i, e.config.locale)
                        } : function(t) {
                            return new Date(t)
                        };
                    return this.config.multidate ? this.dates.map(n) : 0 < this.dates.length ? n(this.dates[0]) : void 0
                }
            }, {
                key: "setDate",
                value: function() {
                    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                    var n = [].concat(e),
                        r = {},
                        a = (0, f.lastItemOf)(e);
                    "object" !== s(a) || Array.isArray(a) || a instanceof Date || !a || Object.assign(r, n.pop()), u(this, Array.isArray(n[0]) ? n[0] : n, r)
                }
            }, {
                key: "update",
                value: function(t) {
                    var e, i = 0 < arguments.length && void 0 !== t ? t : void 0;
                    this.inline || (e = {
                        clear: !0,
                        autohide: !(!i || !i.autohide)
                    }, u(this, (0, f.stringToArray)(this.inputField.value, this.config.dateDelimiter), e))
                }
            }, {
                key: "refresh",
                value: function(t, e) {
                    var i = 0 < arguments.length && void 0 !== t ? t : void 0,
                        n = 1 < arguments.length && void 0 !== e && e;
                    i && "string" != typeof i && (n = i, i = void 0), l(this, "picker" === i ? 2 : "input" === i ? 1 : 3, !n)
                }
            }, {
                key: "enterEditMode",
                value: function() {
                    this.inline || !this.picker.active || this.editMode || (this.editMode = !0, this.inputField.classList.add("in-edit"))
                }
            }, {
                key: "exitEditMode",
                value: function(t) {
                    var e, i = 0 < arguments.length && void 0 !== t ? t : void 0;
                    !this.inline && this.editMode && (e = Object.assign({
                        update: !1
                    }, i), delete this.editMode, this.inputField.classList.remove("in-edit"), e.update && this.update(e))
                }
            }, {
                key: "active",
                get: function() {
                    return !(!this.picker || !this.picker.active)
                }
            }, {
                key: "pickerElement",
                get: function() {
                    return this.picker ? this.picker.element : void 0
                }
            }]) && a(t.prototype, e), i && a(t, i), d
        }();
        i.default = c
    }, {
        "./events/functions.js": 7,
        "./events/inputFieldListeners.js": 8,
        "./events/otherListeners.js": 9,
        "./i18n/base-locales.js": 11,
        "./lib/date-format.js": 12,
        "./lib/date.js": 13,
        "./lib/event.js": 15,
        "./lib/utils.js": 16,
        "./options/defaultOptions.js": 17,
        "./options/processOptions.js": 18,
        "./picker/Picker.js": 19
    }]
}, {}, []);